(function () {
    const e = document.createElement("link").relList;
    if (e && e.supports && e.supports("modulepreload"))
        return;
    for (const r of document.querySelectorAll('link[rel="modulepreload"]'))
        s(r);
    new MutationObserver(r => {
        for (const i of r)
            if (i.type === "childList")
                for (const o of i.addedNodes)
                    o.tagName === "LINK" && o.rel === "modulepreload" && s(o)
    }
    ).observe(document, {
        childList: !0,
        subtree: !0
    });
    function n(r) {
        const i = {};
        return r.integrity && (i.integrity = r.integrity),
            r.referrerPolicy && (i.referrerPolicy = r.referrerPolicy),
            r.crossOrigin === "use-credentials" ? i.credentials = "include" : r.crossOrigin === "anonymous" ? i.credentials = "omit" : i.credentials = "same-origin",
            i
    }
    function s(r) {
        if (r.ep)
            return;
        r.ep = !0;
        const i = n(r);
        fetch(r.href, i)
    }
}
)();
var $S = {};
/**
* @vue/shared v3.4.33
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
function hv(t, e) {
    const n = new Set(t.split(","));
    return s => n.has(s)
}
const Kt = {}
    , ou = []
    , Sr = () => { }
    , gO = () => !1
    , Pg = t => t.charCodeAt(0) === 111 && t.charCodeAt(1) === 110 && (t.charCodeAt(2) > 122 || t.charCodeAt(2) < 97)
    , dv = t => t.startsWith("onUpdate:")
    , Kn = Object.assign
    , fv = (t, e) => {
        const n = t.indexOf(e);
        n > -1 && t.splice(n, 1)
    }
    , _O = Object.prototype.hasOwnProperty
    , kt = (t, e) => _O.call(t, e)
    , ze = Array.isArray
    , au = t => Lg(t) === "[object Map]"
    , VA = t => Lg(t) === "[object Set]"
    , it = t => typeof t == "function"
    , hn = t => typeof t == "string"
    , Ka = t => typeof t == "symbol"
    , qt = t => t !== null && typeof t == "object"
    , GA = t => (qt(t) || it(t)) && it(t.then) && it(t.catch)
    , HA = Object.prototype.toString
    , Lg = t => HA.call(t)
    , yO = t => Lg(t).slice(8, -1)
    , WA = t => Lg(t) === "[object Object]"
    , pv = t => hn(t) && t !== "NaN" && t[0] !== "-" && "" + parseInt(t, 10) === t
    , Yh = hv(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted")
    , Og = t => {
        const e = Object.create(null);
        return n => e[n] || (e[n] = t(n))
    }
    , bO = /-(\w)/g
    , oi = Og(t => t.replace(bO, (e, n) => n ? n.toUpperCase() : ""))
    , vO = /\B([A-Z])/g
    , dc = Og(t => t.replace(vO, "-$1").toLowerCase())
    , Ng = Og(t => t.charAt(0).toUpperCase() + t.slice(1))
    , n0 = Og(t => t ? `on${Ng(t)}` : "")
    , Ga = (t, e) => !Object.is(t, e)
    , s0 = (t, ...e) => {
        for (let n = 0; n < t.length; n++)
            t[n](...e)
    }
    , YA = (t, e, n, s = !1) => {
        Object.defineProperty(t, e, {
            configurable: !0,
            enumerable: !1,
            writable: s,
            value: n
        })
    }
    , xO = t => {
        const e = parseFloat(t);
        return isNaN(e) ? t : e
    }
    , wO = t => {
        const e = hn(t) ? Number(t) : NaN;
        return isNaN(e) ? t : e
    }
    ;
let US;
const XA = () => US || (US = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof $S < "u" ? $S : {});
function Wt(t) {
    if (ze(t)) {
        const e = {};
        for (let n = 0; n < t.length; n++) {
            const s = t[n]
                , r = hn(s) ? CO(s) : Wt(s);
            if (r)
                for (const i in r)
                    e[i] = r[i]
        }
        return e
    } else if (hn(t) || qt(t))
        return t
}
const SO = /;(?![^(]*\))/g
    , EO = /:([^]+)/
    , TO = /\/\*[^]*?\*\//g;
function CO(t) {
    const e = {};
    return t.replace(TO, "").split(SO).forEach(n => {
        if (n) {
            const s = n.split(EO);
            s.length > 1 && (e[s[0].trim()] = s[1].trim())
        }
    }
    ),
        e
}
function Te(t) {
    let e = "";
    if (hn(t))
        e = t;
    else if (ze(t))
        for (let n = 0; n < t.length; n++) {
            const s = Te(t[n]);
            s && (e += s + " ")
        }
    else if (qt(t))
        for (const n in t)
            t[n] && (e += n + " ");
    return e.trim()
}
const IO = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly"
    , AO = hv(IO);
function jA(t) {
    return !!t || t === ""
}
const zA = t => !!(t && t.__v_isRef === !0)
    , $ = t => hn(t) ? t : t == null ? "" : ze(t) || qt(t) && (t.toString === HA || !it(t.toString)) ? zA(t) ? $(t.value) : JSON.stringify(t, qA, 2) : String(t)
    , qA = (t, e) => zA(e) ? qA(t, e.value) : au(e) ? {
        [`Map(${e.size})`]: [...e.entries()].reduce((n, [s, r], i) => (n[r0(s, i) + " =>"] = r,
            n), {})
    } : VA(e) ? {
        [`Set(${e.size})`]: [...e.values()].map(n => r0(n))
    } : Ka(e) ? r0(e) : qt(e) && !ze(e) && !WA(e) ? String(e) : e
    , r0 = (t, e = "") => {
        var n;
        return Ka(t) ? `Symbol(${(n = t.description) != null ? n : e})` : t
    }
    ;
/**
* @vue/reactivity v3.4.33
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let sr;
class KA {
    constructor(e = !1) {
        this.detached = e,
            this._active = !0,
            this.effects = [],
            this.cleanups = [],
            this.parent = sr,
            !e && sr && (this.index = (sr.scopes || (sr.scopes = [])).push(this) - 1)
    }
    get active() {
        return this._active
    }
    run(e) {
        if (this._active) {
            const n = sr;
            try {
                return sr = this,
                    e()
            } finally {
                sr = n
            }
        }
    }
    on() {
        sr = this
    }
    off() {
        sr = this.parent
    }
    stop(e) {
        if (this._active) {
            let n, s;
            for (n = 0,
                s = this.effects.length; n < s; n++)
                this.effects[n].stop();
            for (n = 0,
                s = this.cleanups.length; n < s; n++)
                this.cleanups[n]();
            if (this.scopes)
                for (n = 0,
                    s = this.scopes.length; n < s; n++)
                    this.scopes[n].stop(!0);
            if (!this.detached && this.parent && !e) {
                const r = this.parent.scopes.pop();
                r && r !== this && (this.parent.scopes[this.index] = r,
                    r.index = this.index)
            }
            this.parent = void 0,
                this._active = !1
        }
    }
}
function mv(t) {
    return new KA(t)
}
function kO(t, e = sr) {
    e && e.active && e.effects.push(t)
}
function JA() {
    return sr
}
function RO(t) {
    sr && sr.cleanups.push(t)
}
let Fl;
class gv {
    constructor(e, n, s, r) {
        this.fn = e,
            this.trigger = n,
            this.scheduler = s,
            this.active = !0,
            this.deps = [],
            this._dirtyLevel = 4,
            this._trackId = 0,
            this._runnings = 0,
            this._shouldSchedule = !1,
            this._depsLength = 0,
            kO(this, r)
    }
    get dirty() {
        if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {
            this._dirtyLevel = 1,
                Ja();
            for (let e = 0; e < this._depsLength; e++) {
                const n = this.deps[e];
                if (n.computed && (MO(n.computed),
                    this._dirtyLevel >= 4))
                    break
            }
            this._dirtyLevel === 1 && (this._dirtyLevel = 0),
                Za()
        }
        return this._dirtyLevel >= 4
    }
    set dirty(e) {
        this._dirtyLevel = e ? 4 : 0
    }
    run() {
        if (this._dirtyLevel = 0,
            !this.active)
            return this.fn();
        let e = La
            , n = Fl;
        try {
            return La = !0,
                Fl = this,
                this._runnings++,
                VS(this),
                this.fn()
        } finally {
            GS(this),
                this._runnings--,
                Fl = n,
                La = e
        }
    }
    stop() {
        this.active && (VS(this),
            GS(this),
            this.onStop && this.onStop(),
            this.active = !1)
    }
}
function MO(t) {
    return t.value
}
function VS(t) {
    t._trackId++,
        t._depsLength = 0
}
function GS(t) {
    if (t.deps.length > t._depsLength) {
        for (let e = t._depsLength; e < t.deps.length; e++)
            ZA(t.deps[e], t);
        t.deps.length = t._depsLength
    }
}
function ZA(t, e) {
    const n = t.get(e);
    n !== void 0 && e._trackId !== n && (t.delete(e),
        t.size === 0 && t.cleanup())
}
let La = !0
    , B1 = 0;
const QA = [];
function Ja() {
    QA.push(La),
        La = !1
}
function Za() {
    const t = QA.pop();
    La = t === void 0 ? !0 : t
}
function _v() {
    B1++
}
function yv() {
    for (B1--; !B1 && F1.length;)
        F1.shift()()
}
function e3(t, e, n) {
    if (e.get(t) !== t._trackId) {
        e.set(t, t._trackId);
        const s = t.deps[t._depsLength];
        s !== e ? (s && ZA(s, t),
            t.deps[t._depsLength++] = e) : t._depsLength++
    }
}
const F1 = [];
function t3(t, e, n) {
    _v();
    for (const s of t.keys()) {
        let r;
        s._dirtyLevel < e && (r ?? (r = t.get(s) === s._trackId)) && (s._shouldSchedule || (s._shouldSchedule = s._dirtyLevel === 0),
            s._dirtyLevel = e),
            s._shouldSchedule && (r ?? (r = t.get(s) === s._trackId)) && (s.trigger(),
                (!s._runnings || s.allowRecurse) && s._dirtyLevel !== 2 && (s._shouldSchedule = !1,
                    s.scheduler && F1.push(s.scheduler)))
    }
    yv()
}
const n3 = (t, e) => {
    const n = new Map;
    return n.cleanup = t,
        n.computed = e,
        n
}
    , im = new WeakMap
    , $l = Symbol("")
    , $1 = Symbol("");
function qs(t, e, n) {
    if (La && Fl) {
        let s = im.get(t);
        s || im.set(t, s = new Map);
        let r = s.get(n);
        r || s.set(n, r = n3(() => s.delete(n))),
            e3(Fl, r)
    }
}
function Eo(t, e, n, s, r, i) {
    const o = im.get(t);
    if (!o)
        return;
    let l = [];
    if (e === "clear")
        l = [...o.values()];
    else if (n === "length" && ze(t)) {
        const a = Number(s);
        o.forEach((c, u) => {
            (u === "length" || !Ka(u) && u >= a) && l.push(c)
        }
        )
    } else
        switch (n !== void 0 && l.push(o.get(n)),
        e) {
            case "add":
                ze(t) ? pv(n) && l.push(o.get("length")) : (l.push(o.get($l)),
                    au(t) && l.push(o.get($1)));
                break;
            case "delete":
                ze(t) || (l.push(o.get($l)),
                    au(t) && l.push(o.get($1)));
                break;
            case "set":
                au(t) && l.push(o.get($l));
                break
        }
    _v();
    for (const a of l)
        a && t3(a, 4);
    yv()
}
function PO(t, e) {
    const n = im.get(t);
    return n && n.get(e)
}
const LO = hv("__proto__,__v_isRef,__isVue")
    , s3 = new Set(Object.getOwnPropertyNames(Symbol).filter(t => t !== "arguments" && t !== "caller").map(t => Symbol[t]).filter(Ka))
    , HS = OO();
function OO() {
    const t = {};
    return ["includes", "indexOf", "lastIndexOf"].forEach(e => {
        t[e] = function (...n) {
            const s = Rt(this);
            for (let i = 0, o = this.length; i < o; i++)
                qs(s, "get", i + "");
            const r = s[e](...n);
            return r === -1 || r === !1 ? s[e](...n.map(Rt)) : r
        }
    }
    ),
        ["push", "pop", "shift", "unshift", "splice"].forEach(e => {
            t[e] = function (...n) {
                Ja(),
                    _v();
                const s = Rt(this)[e].apply(this, n);
                return yv(),
                    Za(),
                    s
            }
        }
        ),
        t
}
function NO(t) {
    Ka(t) || (t = String(t));
    const e = Rt(this);
    return qs(e, "has", t),
        e.hasOwnProperty(t)
}
class r3 {
    constructor(e = !1, n = !1) {
        this._isReadonly = e,
            this._isShallow = n
    }
    get(e, n, s) {
        const r = this._isReadonly
            , i = this._isShallow;
        if (n === "__v_isReactive")
            return !r;
        if (n === "__v_isReadonly")
            return r;
        if (n === "__v_isShallow")
            return i;
        if (n === "__v_raw")
            return s === (r ? i ? zO : l3 : i ? a3 : o3).get(e) || Object.getPrototypeOf(e) === Object.getPrototypeOf(s) ? e : void 0;
        const o = ze(e);
        if (!r) {
            if (o && kt(HS, n))
                return Reflect.get(HS, n, s);
            if (n === "hasOwnProperty")
                return NO
        }
        const l = Reflect.get(e, n, s);
        return (Ka(n) ? s3.has(n) : LO(n)) || (r || qs(e, "get", n),
            i) ? l : Tn(l) ? o && pv(n) ? l : l.value : qt(l) ? r ? lu(l) : Qu(l) : l
    }
}
class i3 extends r3 {
    constructor(e = !1) {
        super(!1, e)
    }
    set(e, n, s, r) {
        let i = e[n];
        if (!this._isShallow) {
            const a = ql(i);
            if (!Au(s) && !ql(s) && (i = Rt(i),
                s = Rt(s)),
                !ze(e) && Tn(i) && !Tn(s))
                return a ? !1 : (i.value = s,
                    !0)
        }
        const o = ze(e) && pv(n) ? Number(n) < e.length : kt(e, n)
            , l = Reflect.set(e, n, s, r);
        return e === Rt(r) && (o ? Ga(s, i) && Eo(e, "set", n, s) : Eo(e, "add", n, s)),
            l
    }
    deleteProperty(e, n) {
        const s = kt(e, n);
        e[n];
        const r = Reflect.deleteProperty(e, n);
        return r && s && Eo(e, "delete", n, void 0),
            r
    }
    has(e, n) {
        const s = Reflect.has(e, n);
        return (!Ka(n) || !s3.has(n)) && qs(e, "has", n),
            s
    }
    ownKeys(e) {
        return qs(e, "iterate", ze(e) ? "length" : $l),
            Reflect.ownKeys(e)
    }
}
class DO extends r3 {
    constructor(e = !1) {
        super(!0, e)
    }
    set(e, n) {
        return !0
    }
    deleteProperty(e, n) {
        return !0
    }
}
const BO = new i3
    , FO = new DO
    , $O = new i3(!0);
const bv = t => t
    , Dg = t => Reflect.getPrototypeOf(t);
function If(t, e, n = !1, s = !1) {
    t = t.__v_raw;
    const r = Rt(t)
        , i = Rt(e);
    n || (Ga(e, i) && qs(r, "get", e),
        qs(r, "get", i));
    const { has: o } = Dg(r)
        , l = s ? bv : n ? wv : fd;
    if (o.call(r, e))
        return l(t.get(e));
    if (o.call(r, i))
        return l(t.get(i));
    t !== r && t.get(e)
}
function Af(t, e = !1) {
    const n = this.__v_raw
        , s = Rt(n)
        , r = Rt(t);
    return e || (Ga(t, r) && qs(s, "has", t),
        qs(s, "has", r)),
        t === r ? n.has(t) : n.has(t) || n.has(r)
}
function kf(t, e = !1) {
    return t = t.__v_raw,
        !e && qs(Rt(t), "iterate", $l),
        Reflect.get(t, "size", t)
}
function WS(t, e = !1) {
    !e && !Au(t) && !ql(t) && (t = Rt(t));
    const n = Rt(this);
    return Dg(n).has.call(n, t) || (n.add(t),
        Eo(n, "add", t, t)),
        this
}
function YS(t, e, n = !1) {
    !n && !Au(e) && !ql(e) && (e = Rt(e));
    const s = Rt(this)
        , { has: r, get: i } = Dg(s);
    let o = r.call(s, t);
    o || (t = Rt(t),
        o = r.call(s, t));
    const l = i.call(s, t);
    return s.set(t, e),
        o ? Ga(e, l) && Eo(s, "set", t, e) : Eo(s, "add", t, e),
        this
}
function XS(t) {
    const e = Rt(this)
        , { has: n, get: s } = Dg(e);
    let r = n.call(e, t);
    r || (t = Rt(t),
        r = n.call(e, t)),
        s && s.call(e, t);
    const i = e.delete(t);
    return r && Eo(e, "delete", t, void 0),
        i
}
function jS() {
    const t = Rt(this)
        , e = t.size !== 0
        , n = t.clear();
    return e && Eo(t, "clear", void 0, void 0),
        n
}
function Rf(t, e) {
    return function (s, r) {
        const i = this
            , o = i.__v_raw
            , l = Rt(o)
            , a = e ? bv : t ? wv : fd;
        return !t && qs(l, "iterate", $l),
            o.forEach((c, u) => s.call(r, a(c), a(u), i))
    }
}
function Mf(t, e, n) {
    return function (...s) {
        const r = this.__v_raw
            , i = Rt(r)
            , o = au(i)
            , l = t === "entries" || t === Symbol.iterator && o
            , a = t === "keys" && o
            , c = r[t](...s)
            , u = n ? bv : e ? wv : fd;
        return !e && qs(i, "iterate", a ? $1 : $l),
        {
            next() {
                const { value: h, done: d } = c.next();
                return d ? {
                    value: h,
                    done: d
                } : {
                    value: l ? [u(h[0]), u(h[1])] : u(h),
                    done: d
                }
            },
            [Symbol.iterator]() {
                return this
            }
        }
    }
}
function qo(t) {
    return function (...e) {
        return t === "delete" ? !1 : t === "clear" ? void 0 : this
    }
}
function UO() {
    const t = {
        get(i) {
            return If(this, i)
        },
        get size() {
            return kf(this)
        },
        has: Af,
        add: WS,
        set: YS,
        delete: XS,
        clear: jS,
        forEach: Rf(!1, !1)
    }
        , e = {
            get(i) {
                return If(this, i, !1, !0)
            },
            get size() {
                return kf(this)
            },
            has: Af,
            add(i) {
                return WS.call(this, i, !0)
            },
            set(i, o) {
                return YS.call(this, i, o, !0)
            },
            delete: XS,
            clear: jS,
            forEach: Rf(!1, !0)
        }
        , n = {
            get(i) {
                return If(this, i, !0)
            },
            get size() {
                return kf(this, !0)
            },
            has(i) {
                return Af.call(this, i, !0)
            },
            add: qo("add"),
            set: qo("set"),
            delete: qo("delete"),
            clear: qo("clear"),
            forEach: Rf(!0, !1)
        }
        , s = {
            get(i) {
                return If(this, i, !0, !0)
            },
            get size() {
                return kf(this, !0)
            },
            has(i) {
                return Af.call(this, i, !0)
            },
            add: qo("add"),
            set: qo("set"),
            delete: qo("delete"),
            clear: qo("clear"),
            forEach: Rf(!0, !0)
        };
    return ["keys", "values", "entries", Symbol.iterator].forEach(i => {
        t[i] = Mf(i, !1, !1),
            n[i] = Mf(i, !0, !1),
            e[i] = Mf(i, !1, !0),
            s[i] = Mf(i, !0, !0)
    }
    ),
        [t, n, e, s]
}
const [VO, GO, HO, WO] = UO();
function vv(t, e) {
    const n = e ? t ? WO : HO : t ? GO : VO;
    return (s, r, i) => r === "__v_isReactive" ? !t : r === "__v_isReadonly" ? t : r === "__v_raw" ? s : Reflect.get(kt(n, r) && r in s ? n : s, r, i)
}
const YO = {
    get: vv(!1, !1)
}
    , XO = {
        get: vv(!1, !0)
    }
    , jO = {
        get: vv(!0, !1)
    };
const o3 = new WeakMap
    , a3 = new WeakMap
    , l3 = new WeakMap
    , zO = new WeakMap;
function qO(t) {
    switch (t) {
        case "Object":
        case "Array":
            return 1;
        case "Map":
        case "Set":
        case "WeakMap":
        case "WeakSet":
            return 2;
        default:
            return 0
    }
}
function KO(t) {
    return t.__v_skip || !Object.isExtensible(t) ? 0 : qO(yO(t))
}
function Qu(t) {
    return ql(t) ? t : xv(t, !1, BO, YO, o3)
}
function c3(t) {
    return xv(t, !1, $O, XO, a3)
}
function lu(t) {
    return xv(t, !0, FO, jO, l3)
}
function xv(t, e, n, s, r) {
    if (!qt(t) || t.__v_raw && !(e && t.__v_isReactive))
        return t;
    const i = r.get(t);
    if (i)
        return i;
    const o = KO(t);
    if (o === 0)
        return t;
    const l = new Proxy(t, o === 2 ? s : n);
    return r.set(t, l),
        l
}
function Ul(t) {
    return ql(t) ? Ul(t.__v_raw) : !!(t && t.__v_isReactive)
}
function ql(t) {
    return !!(t && t.__v_isReadonly)
}
function Au(t) {
    return !!(t && t.__v_isShallow)
}
function u3(t) {
    return t ? !!t.__v_raw : !1
}
function Rt(t) {
    const e = t && t.__v_raw;
    return e ? Rt(e) : t
}
function Bg(t) {
    return Object.isExtensible(t) && YA(t, "__v_skip", !0),
        t
}
const fd = t => qt(t) ? Qu(t) : t
    , wv = t => qt(t) ? lu(t) : t;
class h3 {
    constructor(e, n, s, r) {
        this.getter = e,
            this._setter = n,
            this.dep = void 0,
            this.__v_isRef = !0,
            this.__v_isReadonly = !1,
            this.effect = new gv(() => e(this._value), () => kp(this, this.effect._dirtyLevel === 2 ? 2 : 3)),
            this.effect.computed = this,
            this.effect.active = this._cacheable = !r,
            this.__v_isReadonly = s
    }
    get value() {
        const e = Rt(this);
        return (!e._cacheable || e.effect.dirty) && Ga(e._value, e._value = e.effect.run()) && kp(e, 4),
            d3(e),
            e.effect._dirtyLevel >= 2 && kp(e, 2),
            e._value
    }
    set value(e) {
        this._setter(e)
    }
    get _dirty() {
        return this.effect.dirty
    }
    set _dirty(e) {
        this.effect.dirty = e
    }
}
function JO(t, e, n = !1) {
    let s, r;
    const i = it(t);
    return i ? (s = t,
        r = Sr) : (s = t.get,
            r = t.set),
        new h3(s, r, i || !r, n)
}
function d3(t) {
    var e;
    La && Fl && (t = Rt(t),
        e3(Fl, (e = t.dep) != null ? e : t.dep = n3(() => t.dep = void 0, t instanceof h3 ? t : void 0)))
}
function kp(t, e = 4, n, s) {
    t = Rt(t);
    const r = t.dep;
    r && t3(r, e)
}
function Tn(t) {
    return !!(t && t.__v_isRef === !0)
}
function ke(t) {
    return f3(t, !1)
}
function Sv(t) {
    return f3(t, !0)
}
function f3(t, e) {
    return Tn(t) ? t : new ZO(t, e)
}
class ZO {
    constructor(e, n) {
        this.__v_isShallow = n,
            this.dep = void 0,
            this.__v_isRef = !0,
            this._rawValue = n ? e : Rt(e),
            this._value = n ? e : fd(e)
    }
    get value() {
        return d3(this),
            this._value
    }
    set value(e) {
        const n = this.__v_isShallow || Au(e) || ql(e);
        e = n ? e : Rt(e),
            Ga(e, this._rawValue) && (this._rawValue,
                this._rawValue = e,
                this._value = n ? e : fd(e),
                kp(this, 4))
    }
}
function de(t) {
    return Tn(t) ? t.value : t
}
const QO = {
    get: (t, e, n) => de(Reflect.get(t, e, n)),
    set: (t, e, n, s) => {
        const r = t[e];
        return Tn(r) && !Tn(n) ? (r.value = n,
            !0) : Reflect.set(t, e, n, s)
    }
};
function p3(t) {
    return Ul(t) ? t : new Proxy(t, QO)
}
function e8(t) {
    const e = ze(t) ? new Array(t.length) : {};
    for (const n in t)
        e[n] = n8(t, n);
    return e
}
class t8 {
    constructor(e, n, s) {
        this._object = e,
            this._key = n,
            this._defaultValue = s,
            this.__v_isRef = !0
    }
    get value() {
        const e = this._object[this._key];
        return e === void 0 ? this._defaultValue : e
    }
    set value(e) {
        this._object[this._key] = e
    }
    get dep() {
        return PO(Rt(this._object), this._key)
    }
}
function n8(t, e, n) {
    const s = t[e];
    return Tn(s) ? s : new t8(t, e, n)
}
/**
* @vue/runtime-core v3.4.33
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function Oa(t, e, n, s) {
    try {
        return s ? t(...s) : t()
    } catch (r) {
        Fg(r, e, n)
    }
}
function Ir(t, e, n, s) {
    if (it(t)) {
        const r = Oa(t, e, n, s);
        return r && GA(r) && r.catch(i => {
            Fg(i, e, n)
        }
        ),
            r
    }
    if (ze(t)) {
        const r = [];
        for (let i = 0; i < t.length; i++)
            r.push(Ir(t[i], e, n, s));
        return r
    }
}
function Fg(t, e, n, s = !0) {
    const r = e ? e.vnode : null;
    if (e) {
        let i = e.parent;
        const o = e.proxy
            , l = `https://vuejs.org/error-reference/#runtime-${n}`;
        for (; i;) {
            const c = i.ec;
            if (c) {
                for (let u = 0; u < c.length; u++)
                    if (c[u](t, o, l) === !1)
                        return
            }
            i = i.parent
        }
        const a = e.appContext.config.errorHandler;
        if (a) {
            Ja(),
                Oa(a, null, 10, [t, o, l]),
                Za();
            return
        }
    }
    s8(t, n, r, s)
}
function s8(t, e, n, s = !0) {
    console.error(t)
}
let pd = !1
    , U1 = !1;
const fs = [];
let Di = 0;
const cu = [];
let da = null
    , Al = 0;
const m3 = Promise.resolve();
let Ev = null;
function Zd(t) {
    const e = Ev || m3;
    return t ? e.then(this ? t.bind(this) : t) : e
}
function r8(t) {
    let e = Di + 1
        , n = fs.length;
    for (; e < n;) {
        const s = e + n >>> 1
            , r = fs[s]
            , i = md(r);
        i < t || i === t && r.pre ? e = s + 1 : n = s
    }
    return e
}
function Tv(t) {
    (!fs.length || !fs.includes(t, pd && t.allowRecurse ? Di + 1 : Di)) && (t.id == null ? fs.push(t) : fs.splice(r8(t.id), 0, t),
        g3())
}
function g3() {
    !pd && !U1 && (U1 = !0,
        Ev = m3.then(y3))
}
function i8(t) {
    const e = fs.indexOf(t);
    e > Di && fs.splice(e, 1)
}
function o8(t) {
    ze(t) ? cu.push(...t) : (!da || !da.includes(t, t.allowRecurse ? Al + 1 : Al)) && cu.push(t),
        g3()
}
function zS(t, e, n = pd ? Di + 1 : 0) {
    for (; n < fs.length; n++) {
        const s = fs[n];
        if (s && s.pre) {
            if (t && s.id !== t.uid)
                continue;
            fs.splice(n, 1),
                n--,
                s()
        }
    }
}
function _3(t) {
    if (cu.length) {
        const e = [...new Set(cu)].sort((n, s) => md(n) - md(s));
        if (cu.length = 0,
            da) {
            da.push(...e);
            return
        }
        for (da = e,
            Al = 0; Al < da.length; Al++) {
            const n = da[Al];
            n.active !== !1 && n()
        }
        da = null,
            Al = 0
    }
}
const md = t => t.id == null ? 1 / 0 : t.id
    , a8 = (t, e) => {
        const n = md(t) - md(e);
        if (n === 0) {
            if (t.pre && !e.pre)
                return -1;
            if (e.pre && !t.pre)
                return 1
        }
        return n
    }
    ;
function y3(t) {
    U1 = !1,
        pd = !0,
        fs.sort(a8);
    try {
        for (Di = 0; Di < fs.length; Di++) {
            const e = fs[Di];
            e && e.active !== !1 && Oa(e, e.i, e.i ? 15 : 14)
        }
    } finally {
        Di = 0,
            fs.length = 0,
            _3(),
            pd = !1,
            Ev = null,
            (fs.length || cu.length) && y3()
    }
}
let Pn = null
    , $g = null;
function om(t) {
    const e = Pn;
    return Pn = t,
        $g = t && t.type.__scopeId || null,
        e
}
function Wo(t) {
    $g = t
}
function Yo() {
    $g = null
}
function Ce(t, e = Pn, n) {
    if (!e || t._n)
        return t;
    const s = (...r) => {
        s._d && cE(-1);
        const i = om(e);
        let o;
        try {
            o = t(...r)
        } finally {
            om(i),
                s._d && cE(1)
        }
        return o
    }
        ;
    return s._n = !0,
        s._c = !0,
        s._d = !0,
        s
}
function vn(t, e) {
    if (Pn === null)
        return t;
    const n = Xg(Pn)
        , s = t.dirs || (t.dirs = []);
    for (let r = 0; r < e.length; r++) {
        let [i, o, l, a = Kt] = e[r];
        i && (it(i) && (i = {
            mounted: i,
            updated: i
        }),
            i.deep && Sa(o),
            s.push({
                dir: i,
                instance: n,
                value: o,
                oldValue: void 0,
                arg: l,
                modifiers: a
            }))
    }
    return t
}
function hl(t, e, n, s) {
    const r = t.dirs
        , i = e && e.dirs;
    for (let o = 0; o < r.length; o++) {
        const l = r[o];
        i && (l.oldValue = i[o].value);
        let a = l.dir[s];
        a && (Ja(),
            Ir(a, n, 8, [t.el, l, t, e]),
            Za())
    }
}
const fa = Symbol("_leaveCb")
    , Pf = Symbol("_enterCb");
function l8() {
    const t = {
        isMounted: !1,
        isLeaving: !1,
        isUnmounting: !1,
        leavingVNodes: new Map
    };
    return Or(() => {
        t.isMounted = !0
    }
    ),
        Gg(() => {
            t.isUnmounting = !0
        }
        ),
        t
}
const br = [Function, Array]
    , b3 = {
        mode: String,
        appear: Boolean,
        persisted: Boolean,
        onBeforeEnter: br,
        onEnter: br,
        onAfterEnter: br,
        onEnterCancelled: br,
        onBeforeLeave: br,
        onLeave: br,
        onAfterLeave: br,
        onLeaveCancelled: br,
        onBeforeAppear: br,
        onAppear: br,
        onAfterAppear: br,
        onAppearCancelled: br
    }
    , v3 = t => {
        const e = t.subTree;
        return e.component ? v3(e.component) : e
    }
    , c8 = {
        name: "BaseTransition",
        props: b3,
        setup(t, { slots: e }) {
            const n = ku()
                , s = l8();
            return () => {
                const r = e.default && w3(e.default(), !0);
                if (!r || !r.length)
                    return;
                let i = r[0];
                if (r.length > 1) {
                    for (const d of r)
                        if (d.type !== Ws) {
                            i = d;
                            break
                        }
                }
                const o = Rt(t)
                    , { mode: l } = o;
                if (s.isLeaving)
                    return i0(i);
                const a = qS(i);
                if (!a)
                    return i0(i);
                let c = V1(a, o, s, n, d => c = d);
                am(a, c);
                const u = n.subTree
                    , h = u && qS(u);
                if (h && h.type !== Ws && !kl(a, h) && v3(n).type !== Ws) {
                    const d = V1(h, o, s, n);
                    if (am(h, d),
                        l === "out-in" && a.type !== Ws)
                        return s.isLeaving = !0,
                            d.afterLeave = () => {
                                s.isLeaving = !1,
                                    n.update.active !== !1 && (n.effect.dirty = !0,
                                        n.update())
                            }
                            ,
                            i0(i);
                    l === "in-out" && a.type !== Ws && (d.delayLeave = (f, p, m) => {
                        const g = x3(s, h);
                        g[String(h.key)] = h,
                            f[fa] = () => {
                                p(),
                                    f[fa] = void 0,
                                    delete c.delayedLeave
                            }
                            ,
                            c.delayedLeave = m
                    }
                    )
                }
                return i
            }
        }
    }
    , u8 = c8;
function x3(t, e) {
    const { leavingVNodes: n } = t;
    let s = n.get(e.type);
    return s || (s = Object.create(null),
        n.set(e.type, s)),
        s
}
function V1(t, e, n, s, r) {
    const { appear: i, mode: o, persisted: l = !1, onBeforeEnter: a, onEnter: c, onAfterEnter: u, onEnterCancelled: h, onBeforeLeave: d, onLeave: f, onAfterLeave: p, onLeaveCancelled: m, onBeforeAppear: g, onAppear: b, onAfterAppear: v, onAppearCancelled: _ } = e
        , y = String(t.key)
        , x = x3(n, t)
        , w = (C, I) => {
            C && Ir(C, s, 9, I)
        }
        , S = (C, I) => {
            const L = I[1];
            w(C, I),
                ze(C) ? C.every(k => k.length <= 1) && L() : C.length <= 1 && L()
        }
        , E = {
            mode: o,
            persisted: l,
            beforeEnter(C) {
                let I = a;
                if (!n.isMounted)
                    if (i)
                        I = g || a;
                    else
                        return;
                C[fa] && C[fa](!0);
                const L = x[y];
                L && kl(t, L) && L.el[fa] && L.el[fa](),
                    w(I, [C])
            },
            enter(C) {
                let I = c
                    , L = u
                    , k = h;
                if (!n.isMounted)
                    if (i)
                        I = b || c,
                            L = v || u,
                            k = _ || h;
                    else
                        return;
                let R = !1;
                const U = C[Pf] = W => {
                    R || (R = !0,
                        W ? w(k, [C]) : w(L, [C]),
                        E.delayedLeave && E.delayedLeave(),
                        C[Pf] = void 0)
                }
                    ;
                I ? S(I, [C, U]) : U()
            },
            leave(C, I) {
                const L = String(t.key);
                if (C[Pf] && C[Pf](!0),
                    n.isUnmounting)
                    return I();
                w(d, [C]);
                let k = !1;
                const R = C[fa] = U => {
                    k || (k = !0,
                        I(),
                        U ? w(m, [C]) : w(p, [C]),
                        C[fa] = void 0,
                        x[L] === t && delete x[L])
                }
                    ;
                x[L] = t,
                    f ? S(f, [C, R]) : R()
            },
            clone(C) {
                const I = V1(C, e, n, s, r);
                return r && r(I),
                    I
            }
        };
    return E
}
function i0(t) {
    if (Ug(t))
        return t = Ha(t),
            t.children = null,
            t
}
function qS(t) {
    if (!Ug(t))
        return t;
    const { shapeFlag: e, children: n } = t;
    if (n) {
        if (e & 16)
            return n[0];
        if (e & 32 && it(n.default))
            return n.default()
    }
}
function am(t, e) {
    t.shapeFlag & 6 && t.component ? am(t.component.subTree, e) : t.shapeFlag & 128 ? (t.ssContent.transition = e.clone(t.ssContent),
        t.ssFallback.transition = e.clone(t.ssFallback)) : t.transition = e
}
function w3(t, e = !1, n) {
    let s = []
        , r = 0;
    for (let i = 0; i < t.length; i++) {
        let o = t[i];
        const l = n == null ? o.key : String(n) + String(o.key != null ? o.key : i);
        o.type === Ie ? (o.patchFlag & 128 && r++,
            s = s.concat(w3(o.children, e, l))) : (e || o.type !== Ws) && s.push(l != null ? Ha(o, {
                key: l
            }) : o)
    }
    if (r > 1)
        for (let i = 0; i < s.length; i++)
            s[i].patchFlag = -2;
    return s
}
/*! #__NO_SIDE_EFFECTS__ */
function Qa(t, e) {
    return it(t) ? Kn({
        name: t.name
    }, e, {
        setup: t
    }) : t
}
const Xh = t => !!t.type.__asyncLoader
    , Ug = t => t.type.__isKeepAlive;
function h8(t, e) {
    S3(t, "a", e)
}
function d8(t, e) {
    S3(t, "da", e)
}
function S3(t, e, n = jn) {
    const s = t.__wdc || (t.__wdc = () => {
        let r = n;
        for (; r;) {
            if (r.isDeactivated)
                return;
            r = r.parent
        }
        return t()
    }
    );
    if (Vg(e, s, n),
        n) {
        let r = n.parent;
        for (; r && r.parent;)
            Ug(r.parent.vnode) && f8(s, e, n, r),
                r = r.parent
    }
}
function f8(t, e, n, s) {
    const r = Vg(e, t, s, !0);
    Qd(() => {
        fv(s[e], r)
    }
        , n)
}
function Vg(t, e, n = jn, s = !1) {
    if (n) {
        const r = n[t] || (n[t] = [])
            , i = e.__weh || (e.__weh = (...o) => {
                Ja();
                const l = tf(n)
                    , a = Ir(e, n, t, o);
                return l(),
                    Za(),
                    a
            }
            );
        return s ? r.unshift(i) : r.push(i),
            i
    }
}
const Xo = t => (e, n = jn) => {
    (!Yg || t === "sp") && Vg(t, (...s) => e(...s), n)
}
    , E3 = Xo("bm")
    , Or = Xo("m")
    , p8 = Xo("bu")
    , m8 = Xo("u")
    , Gg = Xo("bum")
    , Qd = Xo("um")
    , g8 = Xo("sp")
    , _8 = Xo("rtg")
    , y8 = Xo("rtc");
function b8(t, e = jn) {
    Vg("ec", t, e)
}
const Cv = "components"
    , v8 = "directives";
function q(t, e) {
    return Iv(Cv, t, !0, e) || t
}
const T3 = Symbol.for("v-ndc");
function Kl(t) {
    return hn(t) ? Iv(Cv, t, !1) || t : t || T3
}
function mr(t) {
    return Iv(v8, t)
}
function Iv(t, e, n = !0, s = !1) {
    const r = Pn || jn;
    if (r) {
        const i = r.type;
        if (t === Cv) {
            const l = uN(i, !1);
            if (l && (l === e || l === oi(e) || l === Ng(oi(e))))
                return i
        }
        const o = KS(r[t] || i[t], e) || KS(r.appContext[t], e);
        return !o && s ? i : o
    }
}
function KS(t, e) {
    return t && (t[e] || t[oi(e)] || t[Ng(oi(e))])
}
function mt(t, e, n, s) {
    let r;
    const i = n;
    if (ze(t) || hn(t)) {
        r = new Array(t.length);
        for (let o = 0, l = t.length; o < l; o++)
            r[o] = e(t[o], o, void 0, i)
    } else if (typeof t == "number") {
        r = new Array(t);
        for (let o = 0; o < t; o++)
            r[o] = e(o + 1, o, void 0, i)
    } else if (qt(t))
        if (t[Symbol.iterator])
            r = Array.from(t, (o, l) => e(o, l, void 0, i));
        else {
            const o = Object.keys(t);
            r = new Array(o.length);
            for (let l = 0, a = o.length; l < a; l++) {
                const c = o[l];
                r[l] = e(t[c], c, l, i)
            }
        }
    else
        r = [];
    return r
}
function C3(t, e) {
    for (let n = 0; n < e.length; n++) {
        const s = e[n];
        if (ze(s))
            for (let r = 0; r < s.length; r++)
                t[s[r].name] = s[r].fn;
        else
            s && (t[s.name] = s.key ? (...r) => {
                const i = s.fn(...r);
                return i && (i.key = s.key),
                    i
            }
                : s.fn)
    }
    return t
}
function rs(t, e, n = {}, s, r) {
    if (Pn.isCE || Pn.parent && Xh(Pn.parent) && Pn.parent.isCE)
        return e !== "default" && (n.name = e),
            G("slot", n, s && s());
    let i = t[e];
    i && i._c && (i._d = !1),
        A();
    const o = i && I3(i(n))
        , l = fe(Ie, {
            key: (n.key || o && o.key || `_${e}`) + (!o && s ? "_fb" : "")
        }, o || (s ? s() : []), o && t._ === 1 ? 64 : -2);
    return !r && l.scopeId && (l.slotScopeIds = [l.scopeId + "-s"]),
        i && i._c && (i._d = !0),
        l
}
function I3(t) {
    return t.some(e => cm(e) ? !(e.type === Ws || e.type === Ie && !I3(e.children)) : !0) ? t : null
}
const G1 = t => t ? j3(t) ? Xg(t) : G1(t.parent) : null
    , jh = Kn(Object.create(null), {
        $: t => t,
        $el: t => t.vnode.el,
        $data: t => t.data,
        $props: t => t.props,
        $attrs: t => t.attrs,
        $slots: t => t.slots,
        $refs: t => t.refs,
        $parent: t => G1(t.parent),
        $root: t => G1(t.root),
        $emit: t => t.emit,
        $options: t => Av(t),
        $forceUpdate: t => t.f || (t.f = () => {
            t.effect.dirty = !0,
                Tv(t.update)
        }
        ),
        $nextTick: t => t.n || (t.n = Zd.bind(t.proxy)),
        $watch: t => Y8.bind(t)
    })
    , o0 = (t, e) => t !== Kt && !t.__isScriptSetup && kt(t, e)
    , x8 = {
        get({ _: t }, e) {
            if (e === "__v_skip")
                return !0;
            const { ctx: n, setupState: s, data: r, props: i, accessCache: o, type: l, appContext: a } = t;
            let c;
            if (e[0] !== "$") {
                const f = o[e];
                if (f !== void 0)
                    switch (f) {
                        case 1:
                            return s[e];
                        case 2:
                            return r[e];
                        case 4:
                            return n[e];
                        case 3:
                            return i[e]
                    }
                else {
                    if (o0(s, e))
                        return o[e] = 1,
                            s[e];
                    if (r !== Kt && kt(r, e))
                        return o[e] = 2,
                            r[e];
                    if ((c = t.propsOptions[0]) && kt(c, e))
                        return o[e] = 3,
                            i[e];
                    if (n !== Kt && kt(n, e))
                        return o[e] = 4,
                            n[e];
                    H1 && (o[e] = 0)
                }
            }
            const u = jh[e];
            let h, d;
            if (u)
                return e === "$attrs" && qs(t.attrs, "get", ""),
                    u(t);
            if ((h = l.__cssModules) && (h = h[e]))
                return h;
            if (n !== Kt && kt(n, e))
                return o[e] = 4,
                    n[e];
            if (d = a.config.globalProperties,
                kt(d, e))
                return d[e]
        },
        set({ _: t }, e, n) {
            const { data: s, setupState: r, ctx: i } = t;
            return o0(r, e) ? (r[e] = n,
                !0) : s !== Kt && kt(s, e) ? (s[e] = n,
                    !0) : kt(t.props, e) || e[0] === "$" && e.slice(1) in t ? !1 : (i[e] = n,
                        !0)
        },
        has({ _: { data: t, setupState: e, accessCache: n, ctx: s, appContext: r, propsOptions: i } }, o) {
            let l;
            return !!n[o] || t !== Kt && kt(t, o) || o0(e, o) || (l = i[0]) && kt(l, o) || kt(s, o) || kt(jh, o) || kt(r.config.globalProperties, o)
        },
        defineProperty(t, e, n) {
            return n.get != null ? t._.accessCache[e] = 0 : kt(n, "value") && this.set(t, e, n.value, null),
                Reflect.defineProperty(t, e, n)
        }
    };
function JS(t) {
    return ze(t) ? t.reduce((e, n) => (e[n] = null,
        e), {}) : t
}
let H1 = !0;
function w8(t) {
    const e = Av(t)
        , n = t.proxy
        , s = t.ctx;
    H1 = !1,
        e.beforeCreate && ZS(e.beforeCreate, t, "bc");
    const { data: r, computed: i, methods: o, watch: l, provide: a, inject: c, created: u, beforeMount: h, mounted: d, beforeUpdate: f, updated: p, activated: m, deactivated: g, beforeDestroy: b, beforeUnmount: v, destroyed: _, unmounted: y, render: x, renderTracked: w, renderTriggered: S, errorCaptured: E, serverPrefetch: C, expose: I, inheritAttrs: L, components: k, directives: R, filters: U } = e;
    if (c && S8(c, s, null),
        o)
        for (const j in o) {
            const z = o[j];
            it(z) && (s[j] = z.bind(n))
        }
    if (r) {
        const j = r.call(n, n);
        qt(j) && (t.data = Qu(j))
    }
    if (H1 = !0,
        i)
        for (const j in i) {
            const z = i[j]
                , ee = it(z) ? z.bind(n, n) : it(z.get) ? z.get.bind(n, n) : Sr
                , J = !it(z) && it(z.set) ? z.set.bind(n) : Sr
                , Y = ve({
                    get: ee,
                    set: J
                });
            Object.defineProperty(s, j, {
                enumerable: !0,
                configurable: !0,
                get: () => Y.value,
                set: ne => Y.value = ne
            })
        }
    if (l)
        for (const j in l)
            A3(l[j], s, n, j);
    if (a) {
        const j = it(a) ? a.call(n) : a;
        Reflect.ownKeys(j).forEach(z => {
            Rp(z, j[z])
        }
        )
    }
    u && ZS(u, t, "c");
    function H(j, z) {
        ze(z) ? z.forEach(ee => j(ee.bind(n))) : z && j(z.bind(n))
    }
    if (H(E3, h),
        H(Or, d),
        H(p8, f),
        H(m8, p),
        H(h8, m),
        H(d8, g),
        H(b8, E),
        H(y8, w),
        H(_8, S),
        H(Gg, v),
        H(Qd, y),
        H(g8, C),
        ze(I))
        if (I.length) {
            const j = t.exposed || (t.exposed = {});
            I.forEach(z => {
                Object.defineProperty(j, z, {
                    get: () => n[z],
                    set: ee => n[z] = ee
                })
            }
            )
        } else
            t.exposed || (t.exposed = {});
    x && t.render === Sr && (t.render = x),
        L != null && (t.inheritAttrs = L),
        k && (t.components = k),
        R && (t.directives = R)
}
function S8(t, e, n = Sr) {
    ze(t) && (t = W1(t));
    for (const s in t) {
        const r = t[s];
        let i;
        qt(r) ? "default" in r ? i = Ar(r.from || s, r.default, !0) : i = Ar(r.from || s) : i = Ar(r),
            Tn(i) ? Object.defineProperty(e, s, {
                enumerable: !0,
                configurable: !0,
                get: () => i.value,
                set: o => i.value = o
            }) : e[s] = i
    }
}
function ZS(t, e, n) {
    Ir(ze(t) ? t.map(s => s.bind(e.proxy)) : t.bind(e.proxy), e, n)
}
function A3(t, e, n, s) {
    const r = s.includes(".") ? H3(n, s) : () => n[s];
    if (hn(t)) {
        const i = e[t];
        it(i) && Ln(r, i)
    } else if (it(t))
        Ln(r, t.bind(n));
    else if (qt(t))
        if (ze(t))
            t.forEach(i => A3(i, e, n, s));
        else {
            const i = it(t.handler) ? t.handler.bind(n) : e[t.handler];
            it(i) && Ln(r, i, t)
        }
}
function Av(t) {
    const e = t.type
        , { mixins: n, extends: s } = e
        , { mixins: r, optionsCache: i, config: { optionMergeStrategies: o } } = t.appContext
        , l = i.get(e);
    let a;
    return l ? a = l : !r.length && !n && !s ? a = e : (a = {},
        r.length && r.forEach(c => lm(a, c, o, !0)),
        lm(a, e, o)),
        qt(e) && i.set(e, a),
        a
}
function lm(t, e, n, s = !1) {
    const { mixins: r, extends: i } = e;
    i && lm(t, i, n, !0),
        r && r.forEach(o => lm(t, o, n, !0));
    for (const o in e)
        if (!(s && o === "expose")) {
            const l = E8[o] || n && n[o];
            t[o] = l ? l(t[o], e[o]) : e[o]
        }
    return t
}
const E8 = {
    data: QS,
    props: eE,
    emits: eE,
    methods: Lh,
    computed: Lh,
    beforeCreate: ys,
    created: ys,
    beforeMount: ys,
    mounted: ys,
    beforeUpdate: ys,
    updated: ys,
    beforeDestroy: ys,
    beforeUnmount: ys,
    destroyed: ys,
    unmounted: ys,
    activated: ys,
    deactivated: ys,
    errorCaptured: ys,
    serverPrefetch: ys,
    components: Lh,
    directives: Lh,
    watch: C8,
    provide: QS,
    inject: T8
};
function QS(t, e) {
    return e ? t ? function () {
        return Kn(it(t) ? t.call(this, this) : t, it(e) ? e.call(this, this) : e)
    }
        : e : t
}
function T8(t, e) {
    return Lh(W1(t), W1(e))
}
function W1(t) {
    if (ze(t)) {
        const e = {};
        for (let n = 0; n < t.length; n++)
            e[t[n]] = t[n];
        return e
    }
    return t
}
function ys(t, e) {
    return t ? [...new Set([].concat(t, e))] : e
}
function Lh(t, e) {
    return t ? Kn(Object.create(null), t, e) : e
}
function eE(t, e) {
    return t ? ze(t) && ze(e) ? [...new Set([...t, ...e])] : Kn(Object.create(null), JS(t), JS(e ?? {})) : e
}
function C8(t, e) {
    if (!t)
        return e;
    if (!e)
        return t;
    const n = Kn(Object.create(null), t);
    for (const s in e)
        n[s] = ys(t[s], e[s]);
    return n
}
function k3() {
    return {
        app: null,
        config: {
            isNativeTag: gO,
            performance: !1,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: Object.create(null),
        optionsCache: new WeakMap,
        propsCache: new WeakMap,
        emitsCache: new WeakMap
    }
}
let I8 = 0;
function A8(t, e) {
    return function (s, r = null) {
        it(s) || (s = Kn({}, s)),
            r != null && !qt(r) && (r = null);
        const i = k3()
            , o = new WeakSet;
        let l = !1;
        const a = i.app = {
            _uid: I8++,
            _component: s,
            _props: r,
            _container: null,
            _context: i,
            _instance: null,
            version: dN,
            get config() {
                return i.config
            },
            set config(c) { },
            use(c, ...u) {
                return o.has(c) || (c && it(c.install) ? (o.add(c),
                    c.install(a, ...u)) : it(c) && (o.add(c),
                        c(a, ...u))),
                    a
            },
            mixin(c) {
                return i.mixins.includes(c) || i.mixins.push(c),
                    a
            },
            component(c, u) {
                return u ? (i.components[c] = u,
                    a) : i.components[c]
            },
            directive(c, u) {
                return u ? (i.directives[c] = u,
                    a) : i.directives[c]
            },
            mount(c, u, h) {
                if (!l) {
                    const d = G(s, r);
                    return d.appContext = i,
                        h === !0 ? h = "svg" : h === !1 && (h = void 0),
                        u && e ? e(d, c) : t(d, c, h),
                        l = !0,
                        a._container = c,
                        c.__vue_app__ = a,
                        Xg(d.component)
                }
            },
            unmount() {
                l && (t(null, a._container),
                    delete a._container.__vue_app__)
            },
            provide(c, u) {
                return i.provides[c] = u,
                    a
            },
            runWithContext(c) {
                const u = uu;
                uu = a;
                try {
                    return c()
                } finally {
                    uu = u
                }
            }
        };
        return a
    }
}
let uu = null;
function Rp(t, e) {
    if (jn) {
        let n = jn.provides;
        const s = jn.parent && jn.parent.provides;
        s === n && (n = jn.provides = Object.create(s)),
            n[t] = e
    }
}
function Ar(t, e, n = !1) {
    const s = jn || Pn;
    if (s || uu) {
        const r = s ? s.parent == null ? s.vnode.appContext && s.vnode.appContext.provides : s.parent.provides : uu._context.provides;
        if (r && t in r)
            return r[t];
        if (arguments.length > 1)
            return n && it(e) ? e.call(s && s.proxy) : e
    }
}
function k8() {
    return !!(jn || Pn || uu)
}
const R3 = {}
    , M3 = () => Object.create(R3)
    , P3 = t => Object.getPrototypeOf(t) === R3;
function R8(t, e, n, s = !1) {
    const r = {}
        , i = M3();
    t.propsDefaults = Object.create(null),
        L3(t, e, r, i);
    for (const o in t.propsOptions[0])
        o in r || (r[o] = void 0);
    n ? t.props = s ? r : c3(r) : t.type.props ? t.props = r : t.props = i,
        t.attrs = i
}
function M8(t, e, n, s) {
    const { props: r, attrs: i, vnode: { patchFlag: o } } = t
        , l = Rt(r)
        , [a] = t.propsOptions;
    let c = !1;
    if ((s || o > 0) && !(o & 16)) {
        if (o & 8) {
            const u = t.vnode.dynamicProps;
            for (let h = 0; h < u.length; h++) {
                let d = u[h];
                if (Wg(t.emitsOptions, d))
                    continue;
                const f = e[d];
                if (a)
                    if (kt(i, d))
                        f !== i[d] && (i[d] = f,
                            c = !0);
                    else {
                        const p = oi(d);
                        r[p] = Y1(a, l, p, f, t, !1)
                    }
                else
                    f !== i[d] && (i[d] = f,
                        c = !0)
            }
        }
    } else {
        L3(t, e, r, i) && (c = !0);
        let u;
        for (const h in l)
            (!e || !kt(e, h) && ((u = dc(h)) === h || !kt(e, u))) && (a ? n && (n[h] !== void 0 || n[u] !== void 0) && (r[h] = Y1(a, l, h, void 0, t, !0)) : delete r[h]);
        if (i !== l)
            for (const h in i)
                (!e || !kt(e, h)) && (delete i[h],
                    c = !0)
    }
    c && Eo(t.attrs, "set", "")
}
function L3(t, e, n, s) {
    const [r, i] = t.propsOptions;
    let o = !1, l;
    if (e)
        for (let a in e) {
            if (Yh(a))
                continue;
            const c = e[a];
            let u;
            r && kt(r, u = oi(a)) ? !i || !i.includes(u) ? n[u] = c : (l || (l = {}))[u] = c : Wg(t.emitsOptions, a) || (!(a in s) || c !== s[a]) && (s[a] = c,
                o = !0)
        }
    if (i) {
        const a = Rt(n)
            , c = l || Kt;
        for (let u = 0; u < i.length; u++) {
            const h = i[u];
            n[h] = Y1(r, a, h, c[h], t, !kt(c, h))
        }
    }
    return o
}
function Y1(t, e, n, s, r, i) {
    const o = t[n];
    if (o != null) {
        const l = kt(o, "default");
        if (l && s === void 0) {
            const a = o.default;
            if (o.type !== Function && !o.skipFactory && it(a)) {
                const { propsDefaults: c } = r;
                if (n in c)
                    s = c[n];
                else {
                    const u = tf(r);
                    s = c[n] = a.call(null, e),
                        u()
                }
            } else
                s = a
        }
        o[0] && (i && !l ? s = !1 : o[1] && (s === "" || s === dc(n)) && (s = !0))
    }
    return s
}
const P8 = new WeakMap;
function O3(t, e, n = !1) {
    const s = n ? P8 : e.propsCache
        , r = s.get(t);
    if (r)
        return r;
    const i = t.props
        , o = {}
        , l = [];
    let a = !1;
    if (!it(t)) {
        const u = h => {
            a = !0;
            const [d, f] = O3(h, e, !0);
            Kn(o, d),
                f && l.push(...f)
        }
            ;
        !n && e.mixins.length && e.mixins.forEach(u),
            t.extends && u(t.extends),
            t.mixins && t.mixins.forEach(u)
    }
    if (!i && !a)
        return qt(t) && s.set(t, ou),
            ou;
    if (ze(i))
        for (let u = 0; u < i.length; u++) {
            const h = oi(i[u]);
            tE(h) && (o[h] = Kt)
        }
    else if (i)
        for (const u in i) {
            const h = oi(u);
            if (tE(h)) {
                const d = i[u]
                    , f = o[h] = ze(d) || it(d) ? {
                        type: d
                    } : Kn({}, d);
                if (f) {
                    const p = rE(Boolean, f.type)
                        , m = rE(String, f.type);
                    f[0] = p > -1,
                        f[1] = m < 0 || p < m,
                        (p > -1 || kt(f, "default")) && l.push(h)
                }
            }
        }
    const c = [o, l];
    return qt(t) && s.set(t, c),
        c
}
function tE(t) {
    return t[0] !== "$" && !Yh(t)
}
function nE(t) {
    return t === null ? "null" : typeof t == "function" ? t.name || "" : typeof t == "object" && t.constructor && t.constructor.name || ""
}
function sE(t, e) {
    return nE(t) === nE(e)
}
function rE(t, e) {
    return ze(e) ? e.findIndex(n => sE(n, t)) : it(e) && sE(e, t) ? 0 : -1
}
const N3 = t => t[0] === "_" || t === "$stable"
    , kv = t => ze(t) ? t.map(Pi) : [Pi(t)]
    , L8 = (t, e, n) => {
        if (e._n)
            return e;
        const s = Ce((...r) => kv(e(...r)), n);
        return s._c = !1,
            s
    }
    , D3 = (t, e, n) => {
        const s = t._ctx;
        for (const r in t) {
            if (N3(r))
                continue;
            const i = t[r];
            if (it(i))
                e[r] = L8(r, i, s);
            else if (i != null) {
                const o = kv(i);
                e[r] = () => o
            }
        }
    }
    , B3 = (t, e) => {
        const n = kv(e);
        t.slots.default = () => n
    }
    , F3 = (t, e, n) => {
        for (const s in e)
            (n || s !== "_") && (t[s] = e[s])
    }
    , O8 = (t, e, n) => {
        const s = t.slots = M3();
        if (t.vnode.shapeFlag & 32) {
            const r = e._;
            r ? (F3(s, e, n),
                n && YA(s, "_", r, !0)) : D3(e, s)
        } else
            e && B3(t, e)
    }
    , N8 = (t, e, n) => {
        const { vnode: s, slots: r } = t;
        let i = !0
            , o = Kt;
        if (s.shapeFlag & 32) {
            const l = e._;
            l ? n && l === 1 ? i = !1 : F3(r, e, n) : (i = !e.$stable,
                D3(e, r)),
                o = e
        } else
            e && (B3(t, e),
                o = {
                    default: 1
                });
        if (i)
            for (const l in r)
                !N3(l) && o[l] == null && delete r[l]
    }
    ;
function X1(t, e, n, s, r = !1) {
    if (ze(t)) {
        t.forEach((d, f) => X1(d, e && (ze(e) ? e[f] : e), n, s, r));
        return
    }
    if (Xh(s) && !r)
        return;
    const i = s.shapeFlag & 4 ? Xg(s.component) : s.el
        , o = r ? null : i
        , { i: l, r: a } = t
        , c = e && e.r
        , u = l.refs === Kt ? l.refs = {} : l.refs
        , h = l.setupState;
    if (c != null && c !== a && (hn(c) ? (u[c] = null,
        kt(h, c) && (h[c] = null)) : Tn(c) && (c.value = null)),
        it(a))
        Oa(a, l, 12, [o, u]);
    else {
        const d = hn(a)
            , f = Tn(a);
        if (d || f) {
            const p = () => {
                if (t.f) {
                    const m = d ? kt(h, a) ? h[a] : u[a] : a.value;
                    r ? ze(m) && fv(m, i) : ze(m) ? m.includes(i) || m.push(i) : d ? (u[a] = [i],
                        kt(h, a) && (h[a] = u[a])) : (a.value = [i],
                            t.k && (u[t.k] = a.value))
                } else
                    d ? (u[a] = o,
                        kt(h, a) && (h[a] = o)) : f && (a.value = o,
                            t.k && (u[t.k] = o))
            }
                ;
            o ? (p.id = -1,
                Gs(p, n)) : p()
        }
    }
}
const $3 = Symbol("_vte")
    , D8 = t => t.__isTeleport
    , zh = t => t && (t.disabled || t.disabled === "")
    , iE = t => typeof SVGElement < "u" && t instanceof SVGElement
    , oE = t => typeof MathMLElement == "function" && t instanceof MathMLElement
    , j1 = (t, e) => {
        const n = t && t.to;
        return hn(n) ? e ? e(n) : null : n
    }
    , B8 = {
        name: "Teleport",
        __isTeleport: !0,
        process(t, e, n, s, r, i, o, l, a, c) {
            const { mc: u, pc: h, pbc: d, o: { insert: f, querySelector: p, createText: m, createComment: g } } = c
                , b = zh(e.props);
            let { shapeFlag: v, children: _, dynamicChildren: y } = e;
            if (t == null) {
                const x = e.el = m("")
                    , w = e.anchor = m("")
                    , S = e.target = j1(e.props, p)
                    , E = e.targetStart = m("")
                    , C = e.targetAnchor = m("");
                f(x, n, s),
                    f(w, n, s),
                    E[$3] = C,
                    S && (f(E, S),
                        f(C, S),
                        o === "svg" || iE(S) ? o = "svg" : (o === "mathml" || oE(S)) && (o = "mathml"));
                const I = (L, k) => {
                    v & 16 && u(_, L, k, r, i, o, l, a)
                }
                    ;
                b ? I(n, w) : S && I(S, C)
            } else {
                e.el = t.el,
                    e.targetStart = t.targetStart;
                const x = e.anchor = t.anchor
                    , w = e.target = t.target
                    , S = e.targetAnchor = t.targetAnchor
                    , E = zh(t.props)
                    , C = E ? n : w
                    , I = E ? x : S;
                if (o === "svg" || iE(w) ? o = "svg" : (o === "mathml" || oE(w)) && (o = "mathml"),
                    y ? (d(t.dynamicChildren, y, C, r, i, o, l),
                        Rv(t, e, !0)) : a || h(t, e, C, I, r, i, o, l, !1),
                    b)
                    E ? e.props && t.props && e.props.to !== t.props.to && (e.props.to = t.props.to) : Lf(e, n, x, c, 1);
                else if ((e.props && e.props.to) !== (t.props && t.props.to)) {
                    const L = e.target = j1(e.props, p);
                    L && Lf(e, L, null, c, 0)
                } else
                    E && Lf(e, w, S, c, 1)
            }
            U3(e)
        },
        remove(t, e, n, { um: s, o: { remove: r } }, i) {
            const { shapeFlag: o, children: l, anchor: a, targetStart: c, targetAnchor: u, target: h, props: d } = t;
            if (h && (r(c),
                r(u)),
                i && r(a),
                o & 16) {
                const f = i || !zh(d);
                for (let p = 0; p < l.length; p++) {
                    const m = l[p];
                    s(m, e, n, f, !!m.dynamicChildren)
                }
            }
        },
        move: Lf,
        hydrate: F8
    };
function Lf(t, e, n, { o: { insert: s }, m: r }, i = 2) {
    i === 0 && s(t.targetAnchor, e, n);
    const { el: o, anchor: l, shapeFlag: a, children: c, props: u } = t
        , h = i === 2;
    if (h && s(o, e, n),
        (!h || zh(u)) && a & 16)
        for (let d = 0; d < c.length; d++)
            r(c[d], e, n, 2);
    h && s(l, e, n)
}
function F8(t, e, n, s, r, i, { o: { nextSibling: o, parentNode: l, querySelector: a } }, c) {
    const u = e.target = j1(e.props, a);
    if (u) {
        const h = u._lpa || u.firstChild;
        if (e.shapeFlag & 16)
            if (zh(e.props))
                e.anchor = c(o(t), e, l(t), n, s, r, i),
                    e.targetAnchor = h;
            else {
                e.anchor = o(t);
                let d = h;
                for (; d;)
                    if (d = o(d),
                        d && d.nodeType === 8 && d.data === "teleport anchor") {
                        e.targetAnchor = d,
                            u._lpa = e.targetAnchor && o(e.targetAnchor);
                        break
                    }
                c(h, e, u, n, s, r, i)
            }
        U3(e)
    }
    return e.anchor && o(e.anchor)
}
const Hg = B8;
function U3(t) {
    const e = t.ctx;
    if (e && e.ut) {
        let n = t.children[0].el;
        for (; n && n !== t.targetAnchor;)
            n.nodeType === 1 && n.setAttribute("data-v-owner", e.uid),
                n = n.nextSibling;
        e.ut()
    }
}
const Gs = Q8;
function $8(t) {
    return U8(t)
}
function U8(t, e) {
    const n = XA();
    n.__VUE__ = !0;
    const { insert: s, remove: r, patchProp: i, createElement: o, createText: l, createComment: a, setText: c, setElementText: u, parentNode: h, nextSibling: d, setScopeId: f = Sr, insertStaticContent: p } = t
        , m = (D, M, X, ae = null, ie = null, pe = null, xe = void 0, P = null, B = !!M.dynamicChildren) => {
            if (D === M)
                return;
            D && !kl(D, M) && (ae = K(D),
                ne(D, ie, pe, !0),
                D = null),
                M.patchFlag === -2 && (B = !1,
                    M.dynamicChildren = null);
            const { type: V, ref: re, shapeFlag: ye } = M;
            switch (V) {
                case ef:
                    g(D, M, X, ae);
                    break;
                case Ws:
                    b(D, M, X, ae);
                    break;
                case Mp:
                    D == null && v(M, X, ae, xe);
                    break;
                case Ie:
                    k(D, M, X, ae, ie, pe, xe, P, B);
                    break;
                default:
                    ye & 1 ? x(D, M, X, ae, ie, pe, xe, P, B) : ye & 6 ? R(D, M, X, ae, ie, pe, xe, P, B) : (ye & 64 || ye & 128) && V.process(D, M, X, ae, ie, pe, xe, P, B, be)
            }
            re != null && ie && X1(re, D && D.ref, pe, M || D, !M)
        }
        , g = (D, M, X, ae) => {
            if (D == null)
                s(M.el = l(M.children), X, ae);
            else {
                const ie = M.el = D.el;
                M.children !== D.children && c(ie, M.children)
            }
        }
        , b = (D, M, X, ae) => {
            D == null ? s(M.el = a(M.children || ""), X, ae) : M.el = D.el
        }
        , v = (D, M, X, ae) => {
            [D.el, D.anchor] = p(D.children, M, X, ae, D.el, D.anchor)
        }
        , _ = ({ el: D, anchor: M }, X, ae) => {
            let ie;
            for (; D && D !== M;)
                ie = d(D),
                    s(D, X, ae),
                    D = ie;
            s(M, X, ae)
        }
        , y = ({ el: D, anchor: M }) => {
            let X;
            for (; D && D !== M;)
                X = d(D),
                    r(D),
                    D = X;
            r(M)
        }
        , x = (D, M, X, ae, ie, pe, xe, P, B) => {
            M.type === "svg" ? xe = "svg" : M.type === "math" && (xe = "mathml"),
                D == null ? w(M, X, ae, ie, pe, xe, P, B) : C(D, M, ie, pe, xe, P, B)
        }
        , w = (D, M, X, ae, ie, pe, xe, P) => {
            let B, V;
            const { props: re, shapeFlag: ye, transition: me, dirs: Z } = D;
            if (B = D.el = o(D.type, pe, re && re.is, re),
                ye & 8 ? u(B, D.children) : ye & 16 && E(D.children, B, null, ae, ie, a0(D, pe), xe, P),
                Z && hl(D, null, ae, "created"),
                S(B, D, D.scopeId, xe, ae),
                re) {
                for (const We in re)
                    We !== "value" && !Yh(We) && i(B, We, null, re[We], pe, ae);
                "value" in re && i(B, "value", null, re.value, pe),
                    (V = re.onVnodeBeforeMount) && bi(V, ae, D)
            }
            Z && hl(D, null, ae, "beforeMount");
            const le = V8(ie, me);
            le && me.beforeEnter(B),
                s(B, M, X),
                ((V = re && re.onVnodeMounted) || le || Z) && Gs(() => {
                    V && bi(V, ae, D),
                        le && me.enter(B),
                        Z && hl(D, null, ae, "mounted")
                }
                    , ie)
        }
        , S = (D, M, X, ae, ie) => {
            if (X && f(D, X),
                ae)
                for (let pe = 0; pe < ae.length; pe++)
                    f(D, ae[pe]);
            if (ie) {
                let pe = ie.subTree;
                if (M === pe) {
                    const xe = ie.vnode;
                    S(D, xe, xe.scopeId, xe.slotScopeIds, ie.parent)
                }
            }
        }
        , E = (D, M, X, ae, ie, pe, xe, P, B = 0) => {
            for (let V = B; V < D.length; V++) {
                const re = D[V] = P ? pa(D[V]) : Pi(D[V]);
                m(null, re, M, X, ae, ie, pe, xe, P)
            }
        }
        , C = (D, M, X, ae, ie, pe, xe) => {
            const P = M.el = D.el;
            let { patchFlag: B, dynamicChildren: V, dirs: re } = M;
            B |= D.patchFlag & 16;
            const ye = D.props || Kt
                , me = M.props || Kt;
            let Z;
            if (X && dl(X, !1),
                (Z = me.onVnodeBeforeUpdate) && bi(Z, X, M, D),
                re && hl(M, D, X, "beforeUpdate"),
                X && dl(X, !0),
                (ye.innerHTML && me.innerHTML == null || ye.textContent && me.textContent == null) && u(P, ""),
                V ? I(D.dynamicChildren, V, P, X, ae, a0(M, ie), pe) : xe || z(D, M, P, null, X, ae, a0(M, ie), pe, !1),
                B > 0) {
                if (B & 16)
                    L(P, ye, me, X, ie);
                else if (B & 2 && ye.class !== me.class && i(P, "class", null, me.class, ie),
                    B & 4 && i(P, "style", ye.style, me.style, ie),
                    B & 8) {
                    const le = M.dynamicProps;
                    for (let We = 0; We < le.length; We++) {
                        const Xe = le[We]
                            , Ft = ye[Xe]
                            , cs = me[Xe];
                        (cs !== Ft || Xe === "value") && i(P, Xe, Ft, cs, ie, X)
                    }
                }
                B & 1 && D.children !== M.children && u(P, M.children)
            } else
                !xe && V == null && L(P, ye, me, X, ie);
            ((Z = me.onVnodeUpdated) || re) && Gs(() => {
                Z && bi(Z, X, M, D),
                    re && hl(M, D, X, "updated")
            }
                , ae)
        }
        , I = (D, M, X, ae, ie, pe, xe) => {
            for (let P = 0; P < M.length; P++) {
                const B = D[P]
                    , V = M[P]
                    , re = B.el && (B.type === Ie || !kl(B, V) || B.shapeFlag & 70) ? h(B.el) : X;
                m(B, V, re, null, ae, ie, pe, xe, !0)
            }
        }
        , L = (D, M, X, ae, ie) => {
            if (M !== X) {
                if (M !== Kt)
                    for (const pe in M)
                        !Yh(pe) && !(pe in X) && i(D, pe, M[pe], null, ie, ae);
                for (const pe in X) {
                    if (Yh(pe))
                        continue;
                    const xe = X[pe]
                        , P = M[pe];
                    xe !== P && pe !== "value" && i(D, pe, P, xe, ie, ae)
                }
                "value" in X && i(D, "value", M.value, X.value, ie)
            }
        }
        , k = (D, M, X, ae, ie, pe, xe, P, B) => {
            const V = M.el = D ? D.el : l("")
                , re = M.anchor = D ? D.anchor : l("");
            let { patchFlag: ye, dynamicChildren: me, slotScopeIds: Z } = M;
            Z && (P = P ? P.concat(Z) : Z),
                D == null ? (s(V, X, ae),
                    s(re, X, ae),
                    E(M.children || [], X, re, ie, pe, xe, P, B)) : ye > 0 && ye & 64 && me && D.dynamicChildren ? (I(D.dynamicChildren, me, X, ie, pe, xe, P),
                        (M.key != null || ie && M === ie.subTree) && Rv(D, M, !0)) : z(D, M, X, re, ie, pe, xe, P, B)
        }
        , R = (D, M, X, ae, ie, pe, xe, P, B) => {
            M.slotScopeIds = P,
                D == null ? M.shapeFlag & 512 ? ie.ctx.activate(M, X, ae, xe, B) : U(M, X, ae, ie, pe, xe, B) : W(D, M, B)
        }
        , U = (D, M, X, ae, ie, pe, xe) => {
            const P = D.component = iN(D, ae, ie);
            if (Ug(D) && (P.ctx.renderer = be),
                oN(P, !1, xe),
                P.asyncDep) {
                if (ie && ie.registerDep(P, H, xe),
                    !D.el) {
                    const B = P.subTree = G(Ws);
                    b(null, B, M, X)
                }
            } else
                H(P, D, M, X, ie, pe, xe)
        }
        , W = (D, M, X) => {
            const ae = M.component = D.component;
            if (K8(D, M, X))
                if (ae.asyncDep && !ae.asyncResolved) {
                    j(ae, M, X);
                    return
                } else
                    ae.next = M,
                        i8(ae.update),
                        ae.effect.dirty = !0,
                        ae.update();
            else
                M.el = D.el,
                    ae.vnode = M
        }
        , H = (D, M, X, ae, ie, pe, xe) => {
            const P = () => {
                if (D.isMounted) {
                    let { next: re, bu: ye, u: me, parent: Z, vnode: le } = D;
                    {
                        const Zs = V3(D);
                        if (Zs) {
                            re && (re.el = le.el,
                                j(D, re, xe)),
                                Zs.asyncDep.then(() => {
                                    D.isUnmounted || P()
                                }
                                );
                            return
                        }
                    }
                    let We = re, Xe;
                    dl(D, !1),
                        re ? (re.el = le.el,
                            j(D, re, xe)) : re = le,
                        ye && s0(ye),
                        (Xe = re.props && re.props.onVnodeBeforeUpdate) && bi(Xe, Z, re, le),
                        dl(D, !0);
                    const Ft = l0(D)
                        , cs = D.subTree;
                    D.subTree = Ft,
                        m(cs, Ft, h(cs.el), K(cs), D, ie, pe),
                        re.el = Ft.el,
                        We === null && J8(D, Ft.el),
                        me && Gs(me, ie),
                        (Xe = re.props && re.props.onVnodeUpdated) && Gs(() => bi(Xe, Z, re, le), ie)
                } else {
                    let re;
                    const { el: ye, props: me } = M
                        , { bm: Z, m: le, parent: We } = D
                        , Xe = Xh(M);
                    if (dl(D, !1),
                        Z && s0(Z),
                        !Xe && (re = me && me.onVnodeBeforeMount) && bi(re, We, M),
                        dl(D, !0),
                        ye && De) {
                        const Ft = () => {
                            D.subTree = l0(D),
                                De(ye, D.subTree, D, ie, null)
                        }
                            ;
                        Xe ? M.type.__asyncLoader().then(() => !D.isUnmounted && Ft()) : Ft()
                    } else {
                        const Ft = D.subTree = l0(D);
                        m(null, Ft, X, ae, D, ie, pe),
                            M.el = Ft.el
                    }
                    if (le && Gs(le, ie),
                        !Xe && (re = me && me.onVnodeMounted)) {
                        const Ft = M;
                        Gs(() => bi(re, We, Ft), ie)
                    }
                    (M.shapeFlag & 256 || We && Xh(We.vnode) && We.vnode.shapeFlag & 256) && D.a && Gs(D.a, ie),
                        D.isMounted = !0,
                        M = X = ae = null
                }
            }
                , B = D.effect = new gv(P, Sr, () => Tv(V), D.scope)
                , V = D.update = () => {
                    B.dirty && B.run()
                }
                ;
            V.i = D,
                V.id = D.uid,
                dl(D, !0),
                V()
        }
        , j = (D, M, X) => {
            M.component = D;
            const ae = D.vnode.props;
            D.vnode = M,
                D.next = null,
                M8(D, M.props, ae, X),
                N8(D, M.children, X),
                Ja(),
                zS(D),
                Za()
        }
        , z = (D, M, X, ae, ie, pe, xe, P, B = !1) => {
            const V = D && D.children
                , re = D ? D.shapeFlag : 0
                , ye = M.children
                , { patchFlag: me, shapeFlag: Z } = M;
            if (me > 0) {
                if (me & 128) {
                    J(V, ye, X, ae, ie, pe, xe, P, B);
                    return
                } else if (me & 256) {
                    ee(V, ye, X, ae, ie, pe, xe, P, B);
                    return
                }
            }
            Z & 8 ? (re & 16 && we(V, ie, pe),
                ye !== V && u(X, ye)) : re & 16 ? Z & 16 ? J(V, ye, X, ae, ie, pe, xe, P, B) : we(V, ie, pe, !0) : (re & 8 && u(X, ""),
                    Z & 16 && E(ye, X, ae, ie, pe, xe, P, B))
        }
        , ee = (D, M, X, ae, ie, pe, xe, P, B) => {
            D = D || ou,
                M = M || ou;
            const V = D.length
                , re = M.length
                , ye = Math.min(V, re);
            let me;
            for (me = 0; me < ye; me++) {
                const Z = M[me] = B ? pa(M[me]) : Pi(M[me]);
                m(D[me], Z, X, null, ie, pe, xe, P, B)
            }
            V > re ? we(D, ie, pe, !0, !1, ye) : E(M, X, ae, ie, pe, xe, P, B, ye)
        }
        , J = (D, M, X, ae, ie, pe, xe, P, B) => {
            let V = 0;
            const re = M.length;
            let ye = D.length - 1
                , me = re - 1;
            for (; V <= ye && V <= me;) {
                const Z = D[V]
                    , le = M[V] = B ? pa(M[V]) : Pi(M[V]);
                if (kl(Z, le))
                    m(Z, le, X, null, ie, pe, xe, P, B);
                else
                    break;
                V++
            }
            for (; V <= ye && V <= me;) {
                const Z = D[ye]
                    , le = M[me] = B ? pa(M[me]) : Pi(M[me]);
                if (kl(Z, le))
                    m(Z, le, X, null, ie, pe, xe, P, B);
                else
                    break;
                ye--,
                    me--
            }
            if (V > ye) {
                if (V <= me) {
                    const Z = me + 1
                        , le = Z < re ? M[Z].el : ae;
                    for (; V <= me;)
                        m(null, M[V] = B ? pa(M[V]) : Pi(M[V]), X, le, ie, pe, xe, P, B),
                            V++
                }
            } else if (V > me)
                for (; V <= ye;)
                    ne(D[V], ie, pe, !0),
                        V++;
            else {
                const Z = V
                    , le = V
                    , We = new Map;
                for (V = le; V <= me; V++) {
                    const Qs = M[V] = B ? pa(M[V]) : Pi(M[V]);
                    Qs.key != null && We.set(Qs.key, V)
                }
                let Xe, Ft = 0;
                const cs = me - le + 1;
                let Zs = !1
                    , Cf = 0;
                const Cc = new Array(cs);
                for (V = 0; V < cs; V++)
                    Cc[V] = 0;
                for (V = Z; V <= ye; V++) {
                    const Qs = D[V];
                    if (Ft >= cs) {
                        ne(Qs, ie, pe, !0);
                        continue
                    }
                    let yi;
                    if (Qs.key != null)
                        yi = We.get(Qs.key);
                    else
                        for (Xe = le; Xe <= me; Xe++)
                            if (Cc[Xe - le] === 0 && kl(Qs, M[Xe])) {
                                yi = Xe;
                                break
                            }
                    yi === void 0 ? ne(Qs, ie, pe, !0) : (Cc[yi - le] = V + 1,
                        yi >= Cf ? Cf = yi : Zs = !0,
                        m(Qs, M[yi], X, null, ie, pe, xe, P, B),
                        Ft++)
                }
                const BS = Zs ? G8(Cc) : ou;
                for (Xe = BS.length - 1,
                    V = cs - 1; V >= 0; V--) {
                    const Qs = le + V
                        , yi = M[Qs]
                        , FS = Qs + 1 < re ? M[Qs + 1].el : ae;
                    Cc[V] === 0 ? m(null, yi, X, FS, ie, pe, xe, P, B) : Zs && (Xe < 0 || V !== BS[Xe] ? Y(yi, X, FS, 2) : Xe--)
                }
            }
        }
        , Y = (D, M, X, ae, ie = null) => {
            const { el: pe, type: xe, transition: P, children: B, shapeFlag: V } = D;
            if (V & 6) {
                Y(D.component.subTree, M, X, ae);
                return
            }
            if (V & 128) {
                D.suspense.move(M, X, ae);
                return
            }
            if (V & 64) {
                xe.move(D, M, X, be);
                return
            }
            if (xe === Ie) {
                s(pe, M, X);
                for (let ye = 0; ye < B.length; ye++)
                    Y(B[ye], M, X, ae);
                s(D.anchor, M, X);
                return
            }
            if (xe === Mp) {
                _(D, M, X);
                return
            }
            if (ae !== 2 && V & 1 && P)
                if (ae === 0)
                    P.beforeEnter(pe),
                        s(pe, M, X),
                        Gs(() => P.enter(pe), ie);
                else {
                    const { leave: ye, delayLeave: me, afterLeave: Z } = P
                        , le = () => s(pe, M, X)
                        , We = () => {
                            ye(pe, () => {
                                le(),
                                    Z && Z()
                            }
                            )
                        }
                        ;
                    me ? me(pe, le, We) : We()
                }
            else
                s(pe, M, X)
        }
        , ne = (D, M, X, ae = !1, ie = !1) => {
            const { type: pe, props: xe, ref: P, children: B, dynamicChildren: V, shapeFlag: re, patchFlag: ye, dirs: me, cacheIndex: Z } = D;
            if (ye === -2 && (ie = !1),
                P != null && X1(P, null, X, D, !0),
                Z != null && (M.renderCache[Z] = void 0),
                re & 256) {
                M.ctx.deactivate(D);
                return
            }
            const le = re & 1 && me
                , We = !Xh(D);
            let Xe;
            if (We && (Xe = xe && xe.onVnodeBeforeUnmount) && bi(Xe, M, D),
                re & 6)
                ue(D.component, X, ae);
            else {
                if (re & 128) {
                    D.suspense.unmount(X, ae);
                    return
                }
                le && hl(D, null, M, "beforeUnmount"),
                    re & 64 ? D.type.remove(D, M, X, be, ae) : V && !V.hasOnce && (pe !== Ie || ye > 0 && ye & 64) ? we(V, M, X, !1, !0) : (pe === Ie && ye & 384 || !ie && re & 16) && we(B, M, X),
                    ae && oe(D)
            }
            (We && (Xe = xe && xe.onVnodeUnmounted) || le) && Gs(() => {
                Xe && bi(Xe, M, D),
                    le && hl(D, null, M, "unmounted")
            }
                , X)
        }
        , oe = D => {
            const { type: M, el: X, anchor: ae, transition: ie } = D;
            if (M === Ie) {
                ce(X, ae);
                return
            }
            if (M === Mp) {
                y(D);
                return
            }
            const pe = () => {
                r(X),
                    ie && !ie.persisted && ie.afterLeave && ie.afterLeave()
            }
                ;
            if (D.shapeFlag & 1 && ie && !ie.persisted) {
                const { leave: xe, delayLeave: P } = ie
                    , B = () => xe(X, pe);
                P ? P(D.el, pe, B) : B()
            } else
                pe()
        }
        , ce = (D, M) => {
            let X;
            for (; D !== M;)
                X = d(D),
                    r(D),
                    D = X;
            r(M)
        }
        , ue = (D, M, X) => {
            const { bum: ae, scope: ie, update: pe, subTree: xe, um: P, m: B, a: V } = D;
            aE(B),
                aE(V),
                ae && s0(ae),
                ie.stop(),
                pe && (pe.active = !1,
                    ne(xe, D, M, X)),
                P && Gs(P, M),
                Gs(() => {
                    D.isUnmounted = !0
                }
                    , M),
                M && M.pendingBranch && !M.isUnmounted && D.asyncDep && !D.asyncResolved && D.suspenseId === M.pendingId && (M.deps--,
                    M.deps === 0 && M.resolve())
        }
        , we = (D, M, X, ae = !1, ie = !1, pe = 0) => {
            for (let xe = pe; xe < D.length; xe++)
                ne(D[xe], M, X, ae, ie)
        }
        , K = D => {
            if (D.shapeFlag & 6)
                return K(D.component.subTree);
            if (D.shapeFlag & 128)
                return D.suspense.next();
            const M = d(D.anchor || D.el)
                , X = M && M[$3];
            return X ? d(X) : M
        }
        ;
    let ge = !1;
    const he = (D, M, X) => {
        D == null ? M._vnode && ne(M._vnode, null, null, !0) : m(M._vnode || null, D, M, null, null, null, X),
            ge || (ge = !0,
                zS(),
                _3(),
                ge = !1),
            M._vnode = D
    }
        , be = {
            p: m,
            um: ne,
            m: Y,
            r: oe,
            mt: U,
            mc: E,
            pc: z,
            pbc: I,
            n: K,
            o: t
        };
    let Pe, De;
    return {
        render: he,
        hydrate: Pe,
        createApp: A8(he, Pe)
    }
}
function a0({ type: t, props: e }, n) {
    return n === "svg" && t === "foreignObject" || n === "mathml" && t === "annotation-xml" && e && e.encoding && e.encoding.includes("html") ? void 0 : n
}
function dl({ effect: t, update: e }, n) {
    t.allowRecurse = e.allowRecurse = n
}
function V8(t, e) {
    return (!t || t && !t.pendingBranch) && e && !e.persisted
}
function Rv(t, e, n = !1) {
    const s = t.children
        , r = e.children;
    if (ze(s) && ze(r))
        for (let i = 0; i < s.length; i++) {
            const o = s[i];
            let l = r[i];
            l.shapeFlag & 1 && !l.dynamicChildren && ((l.patchFlag <= 0 || l.patchFlag === 32) && (l = r[i] = pa(r[i]),
                l.el = o.el),
                !n && l.patchFlag !== -2 && Rv(o, l)),
                l.type === ef && (l.el = o.el)
        }
}
function G8(t) {
    const e = t.slice()
        , n = [0];
    let s, r, i, o, l;
    const a = t.length;
    for (s = 0; s < a; s++) {
        const c = t[s];
        if (c !== 0) {
            if (r = n[n.length - 1],
                t[r] < c) {
                e[s] = r,
                    n.push(s);
                continue
            }
            for (i = 0,
                o = n.length - 1; i < o;)
                l = i + o >> 1,
                    t[n[l]] < c ? i = l + 1 : o = l;
            c < t[n[i]] && (i > 0 && (e[s] = n[i - 1]),
                n[i] = s)
        }
    }
    for (i = n.length,
        o = n[i - 1]; i-- > 0;)
        n[i] = o,
            o = e[o];
    return n
}
function V3(t) {
    const e = t.subTree.component;
    if (e)
        return e.asyncDep && !e.asyncResolved ? e : V3(e)
}
function aE(t) {
    if (t)
        for (let e = 0; e < t.length; e++)
            t[e].active = !1
}
const H8 = Symbol.for("v-scx")
    , W8 = () => Ar(H8)
    , Of = {};
function Ln(t, e, n) {
    return G3(t, e, n)
}
function G3(t, e, { immediate: n, deep: s, flush: r, once: i, onTrack: o, onTrigger: l } = Kt) {
    if (e && i) {
        const w = e;
        e = (...S) => {
            w(...S),
                x()
        }
    }
    const a = jn
        , c = w => s === !0 ? w : Sa(w, s === !1 ? 1 : void 0);
    let u, h = !1, d = !1;
    if (Tn(t) ? (u = () => t.value,
        h = Au(t)) : Ul(t) ? (u = () => c(t),
            h = !0) : ze(t) ? (d = !0,
                h = t.some(w => Ul(w) || Au(w)),
                u = () => t.map(w => {
                    if (Tn(w))
                        return w.value;
                    if (Ul(w))
                        return c(w);
                    if (it(w))
                        return Oa(w, a, 2)
                }
                )) : it(t) ? e ? u = () => Oa(t, a, 2) : u = () => (f && f(),
                    Ir(t, a, 3, [p])) : u = Sr,
        e && s) {
        const w = u;
        u = () => Sa(w())
    }
    let f, p = w => {
        f = _.onStop = () => {
            Oa(w, a, 4),
                f = _.onStop = void 0
        }
    }
        , m;
    if (Yg)
        if (p = Sr,
            e ? n && Ir(e, a, 3, [u(), d ? [] : void 0, p]) : u(),
            r === "sync") {
            const w = W8();
            m = w.__watcherHandles || (w.__watcherHandles = [])
        } else
            return Sr;
    let g = d ? new Array(t.length).fill(Of) : Of;
    const b = () => {
        if (!(!_.active || !_.dirty))
            if (e) {
                const w = _.run();
                (s || h || (d ? w.some((S, E) => Ga(S, g[E])) : Ga(w, g))) && (f && f(),
                    Ir(e, a, 3, [w, g === Of ? void 0 : d && g[0] === Of ? [] : g, p]),
                    g = w)
            } else
                _.run()
    }
        ;
    b.allowRecurse = !!e;
    let v;
    r === "sync" ? v = b : r === "post" ? v = () => Gs(b, a && a.suspense) : (b.pre = !0,
        a && (b.id = a.uid),
        v = () => Tv(b));
    const _ = new gv(u, Sr, v)
        , y = JA()
        , x = () => {
            _.stop(),
                y && fv(y.effects, _)
        }
        ;
    return e ? n ? b() : g = _.run() : r === "post" ? Gs(_.run.bind(_), a && a.suspense) : _.run(),
        m && m.push(x),
        x
}
function Y8(t, e, n) {
    const s = this.proxy
        , r = hn(t) ? t.includes(".") ? H3(s, t) : () => s[t] : t.bind(s, s);
    let i;
    it(e) ? i = e : (i = e.handler,
        n = e);
    const o = tf(this)
        , l = G3(r, i.bind(s), n);
    return o(),
        l
}
function H3(t, e) {
    const n = e.split(".");
    return () => {
        let s = t;
        for (let r = 0; r < n.length && s; r++)
            s = s[n[r]];
        return s
    }
}
function Sa(t, e = 1 / 0, n) {
    if (e <= 0 || !qt(t) || t.__v_skip || (n = n || new Set,
        n.has(t)))
        return t;
    if (n.add(t),
        e--,
        Tn(t))
        Sa(t.value, e, n);
    else if (ze(t))
        for (let s = 0; s < t.length; s++)
            Sa(t[s], e, n);
    else if (VA(t) || au(t))
        t.forEach(s => {
            Sa(s, e, n)
        }
        );
    else if (WA(t)) {
        for (const s in t)
            Sa(t[s], e, n);
        for (const s of Object.getOwnPropertySymbols(t))
            Object.prototype.propertyIsEnumerable.call(t, s) && Sa(t[s], e, n)
    }
    return t
}
const X8 = (t, e) => e === "modelValue" || e === "model-value" ? t.modelModifiers : t[`${e}Modifiers`] || t[`${oi(e)}Modifiers`] || t[`${dc(e)}Modifiers`];
function j8(t, e, ...n) {
    if (t.isUnmounted)
        return;
    const s = t.vnode.props || Kt;
    let r = n;
    const i = e.startsWith("update:")
        , o = i && X8(s, e.slice(7));
    o && (o.trim && (r = n.map(u => hn(u) ? u.trim() : u)),
        o.number && (r = n.map(xO)));
    let l, a = s[l = n0(e)] || s[l = n0(oi(e))];
    !a && i && (a = s[l = n0(dc(e))]),
        a && Ir(a, t, 6, r);
    const c = s[l + "Once"];
    if (c) {
        if (!t.emitted)
            t.emitted = {};
        else if (t.emitted[l])
            return;
        t.emitted[l] = !0,
            Ir(c, t, 6, r)
    }
}
function W3(t, e, n = !1) {
    const s = e.emitsCache
        , r = s.get(t);
    if (r !== void 0)
        return r;
    const i = t.emits;
    let o = {}
        , l = !1;
    if (!it(t)) {
        const a = c => {
            const u = W3(c, e, !0);
            u && (l = !0,
                Kn(o, u))
        }
            ;
        !n && e.mixins.length && e.mixins.forEach(a),
            t.extends && a(t.extends),
            t.mixins && t.mixins.forEach(a)
    }
    return !i && !l ? (qt(t) && s.set(t, null),
        null) : (ze(i) ? i.forEach(a => o[a] = null) : Kn(o, i),
            qt(t) && s.set(t, o),
            o)
}
function Wg(t, e) {
    return !t || !Pg(e) ? !1 : (e = e.slice(2).replace(/Once$/, ""),
        kt(t, e[0].toLowerCase() + e.slice(1)) || kt(t, dc(e)) || kt(t, e))
}
function l0(t) {
    const { type: e, vnode: n, proxy: s, withProxy: r, propsOptions: [i], slots: o, attrs: l, emit: a, render: c, renderCache: u, props: h, data: d, setupState: f, ctx: p, inheritAttrs: m } = t
        , g = om(t);
    let b, v;
    try {
        if (n.shapeFlag & 4) {
            const y = r || s
                , x = y;
            b = Pi(c.call(x, y, u, h, f, d, p)),
                v = l
        } else {
            const y = e;
            b = Pi(y.length > 1 ? y(h, {
                attrs: l,
                slots: o,
                emit: a
            }) : y(h, null)),
                v = e.props ? l : z8(l)
        }
    } catch (y) {
        qh.length = 0,
            Fg(y, t, 1),
            b = G(Ws)
    }
    let _ = b;
    if (v && m !== !1) {
        const y = Object.keys(v)
            , { shapeFlag: x } = _;
        y.length && x & 7 && (i && y.some(dv) && (v = q8(v, i)),
            _ = Ha(_, v, !1, !0))
    }
    return n.dirs && (_ = Ha(_, null, !1, !0),
        _.dirs = _.dirs ? _.dirs.concat(n.dirs) : n.dirs),
        n.transition && (_.transition = n.transition),
        b = _,
        om(g),
        b
}
const z8 = t => {
    let e;
    for (const n in t)
        (n === "class" || n === "style" || Pg(n)) && ((e || (e = {}))[n] = t[n]);
    return e
}
    , q8 = (t, e) => {
        const n = {};
        for (const s in t)
            (!dv(s) || !(s.slice(9) in e)) && (n[s] = t[s]);
        return n
    }
    ;
function K8(t, e, n) {
    const { props: s, children: r, component: i } = t
        , { props: o, children: l, patchFlag: a } = e
        , c = i.emitsOptions;
    if (e.dirs || e.transition)
        return !0;
    if (n && a >= 0) {
        if (a & 1024)
            return !0;
        if (a & 16)
            return s ? lE(s, o, c) : !!o;
        if (a & 8) {
            const u = e.dynamicProps;
            for (let h = 0; h < u.length; h++) {
                const d = u[h];
                if (o[d] !== s[d] && !Wg(c, d))
                    return !0
            }
        }
    } else
        return (r || l) && (!l || !l.$stable) ? !0 : s === o ? !1 : s ? o ? lE(s, o, c) : !0 : !!o;
    return !1
}
function lE(t, e, n) {
    const s = Object.keys(e);
    if (s.length !== Object.keys(t).length)
        return !0;
    for (let r = 0; r < s.length; r++) {
        const i = s[r];
        if (e[i] !== t[i] && !Wg(n, i))
            return !0
    }
    return !1
}
function J8({ vnode: t, parent: e }, n) {
    for (; e;) {
        const s = e.subTree;
        if (s.suspense && s.suspense.activeBranch === t && (s.el = t.el),
            s === t)
            (t = e.vnode).el = n,
                e = e.parent;
        else
            break
    }
}
const Z8 = t => t.__isSuspense;
function Q8(t, e) {
    e && e.pendingBranch ? ze(t) ? e.effects.push(...t) : e.effects.push(t) : o8(t)
}
const Ie = Symbol.for("v-fgt")
    , ef = Symbol.for("v-txt")
    , Ws = Symbol.for("v-cmt")
    , Mp = Symbol.for("v-stc")
    , qh = [];
let ir = null;
function A(t = !1) {
    qh.push(ir = t ? null : [])
}
function eN() {
    qh.pop(),
        ir = qh[qh.length - 1] || null
}
let gd = 1;
function cE(t) {
    gd += t,
        t < 0 && ir && (ir.hasOnce = !0)
}
function Y3(t) {
    return t.dynamicChildren = gd > 0 ? ir || ou : null,
        eN(),
        gd > 0 && ir && ir.push(t),
        t
}
function N(t, e, n, s, r, i) {
    return Y3(T(t, e, n, s, r, i, !0))
}
function fe(t, e, n, s, r) {
    return Y3(G(t, e, n, s, r, !0))
}
function cm(t) {
    return t ? t.__v_isVNode === !0 : !1
}
function kl(t, e) {
    return t.type === e.type && t.key === e.key
}
const X3 = ({ key: t }) => t ?? null
    , Pp = ({ ref: t, ref_key: e, ref_for: n }) => (typeof t == "number" && (t = "" + t),
        t != null ? hn(t) || Tn(t) || it(t) ? {
            i: Pn,
            r: t,
            k: e,
            f: !!n
        } : t : null);
function T(t, e = null, n = null, s = 0, r = null, i = t === Ie ? 0 : 1, o = !1, l = !1) {
    const a = {
        __v_isVNode: !0,
        __v_skip: !0,
        type: t,
        props: e,
        key: e && X3(e),
        ref: e && Pp(e),
        scopeId: $g,
        slotScopeIds: null,
        children: n,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetStart: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag: i,
        patchFlag: s,
        dynamicProps: r,
        dynamicChildren: null,
        appContext: null,
        ctx: Pn
    };
    return l ? (Mv(a, n),
        i & 128 && t.normalize(a)) : n && (a.shapeFlag |= hn(n) ? 8 : 16),
        gd > 0 && !o && ir && (a.patchFlag > 0 || i & 6) && a.patchFlag !== 32 && ir.push(a),
        a
}
const G = tN;
function tN(t, e = null, n = null, s = 0, r = null, i = !1) {
    if ((!t || t === T3) && (t = Ws),
        cm(t)) {
        const l = Ha(t, e, !0);
        return n && Mv(l, n),
            gd > 0 && !i && ir && (l.shapeFlag & 6 ? ir[ir.indexOf(t)] = l : ir.push(l)),
            l.patchFlag = -2,
            l
    }
    if (hN(t) && (t = t.__vccOpts),
        e) {
        e = nN(e);
        let { class: l, style: a } = e;
        l && !hn(l) && (e.class = Te(l)),
            qt(a) && (u3(a) && !ze(a) && (a = Kn({}, a)),
                e.style = Wt(a))
    }
    const o = hn(t) ? 1 : Z8(t) ? 128 : D8(t) ? 64 : qt(t) ? 4 : it(t) ? 2 : 0;
    return T(t, e, n, s, r, o, i, !0)
}
function nN(t) {
    return t ? u3(t) || P3(t) ? Kn({}, t) : t : null
}
function Ha(t, e, n = !1, s = !1) {
    const { props: r, ref: i, patchFlag: o, children: l, transition: a } = t
        , c = e ? Ms(r || {}, e) : r
        , u = {
            __v_isVNode: !0,
            __v_skip: !0,
            type: t.type,
            props: c,
            key: c && X3(c),
            ref: e && e.ref ? n && i ? ze(i) ? i.concat(Pp(e)) : [i, Pp(e)] : Pp(e) : i,
            scopeId: t.scopeId,
            slotScopeIds: t.slotScopeIds,
            children: l,
            target: t.target,
            targetStart: t.targetStart,
            targetAnchor: t.targetAnchor,
            staticCount: t.staticCount,
            shapeFlag: t.shapeFlag,
            patchFlag: e && t.type !== Ie ? o === -1 ? 16 : o | 16 : o,
            dynamicProps: t.dynamicProps,
            dynamicChildren: t.dynamicChildren,
            appContext: t.appContext,
            dirs: t.dirs,
            transition: a,
            component: t.component,
            suspense: t.suspense,
            ssContent: t.ssContent && Ha(t.ssContent),
            ssFallback: t.ssFallback && Ha(t.ssFallback),
            el: t.el,
            anchor: t.anchor,
            ctx: t.ctx,
            ce: t.ce
        };
    return a && s && am(u, a.clone(u)),
        u
}
function Fe(t = " ", e = 0) {
    return G(ef, null, t, e)
}
function Nr(t, e) {
    const n = G(Mp, null, t);
    return n.staticCount = e,
        n
}
function te(t = "", e = !1) {
    return e ? (A(),
        fe(Ws, null, t)) : G(Ws, null, t)
}
function Pi(t) {
    return t == null || typeof t == "boolean" ? G(Ws) : ze(t) ? G(Ie, null, t.slice()) : typeof t == "object" ? pa(t) : G(ef, null, String(t))
}
function pa(t) {
    return t.el === null && t.patchFlag !== -1 || t.memo ? t : Ha(t)
}
function Mv(t, e) {
    let n = 0;
    const { shapeFlag: s } = t;
    if (e == null)
        e = null;
    else if (ze(e))
        n = 16;
    else if (typeof e == "object")
        if (s & 65) {
            const r = e.default;
            r && (r._c && (r._d = !1),
                Mv(t, r()),
                r._c && (r._d = !0));
            return
        } else {
            n = 32;
            const r = e._;
            !r && !P3(e) ? e._ctx = Pn : r === 3 && Pn && (Pn.slots._ === 1 ? e._ = 1 : (e._ = 2,
                t.patchFlag |= 1024))
        }
    else
        it(e) ? (e = {
            default: e,
            _ctx: Pn
        },
            n = 32) : (e = String(e),
                s & 64 ? (n = 16,
                    e = [Fe(e)]) : n = 8);
    t.children = e,
        t.shapeFlag |= n
}
function Ms(...t) {
    const e = {};
    for (let n = 0; n < t.length; n++) {
        const s = t[n];
        for (const r in s)
            if (r === "class")
                e.class !== s.class && (e.class = Te([e.class, s.class]));
            else if (r === "style")
                e.style = Wt([e.style, s.style]);
            else if (Pg(r)) {
                const i = e[r]
                    , o = s[r];
                o && i !== o && !(ze(i) && i.includes(o)) && (e[r] = i ? [].concat(i, o) : o)
            } else
                r !== "" && (e[r] = s[r])
    }
    return e
}
function bi(t, e, n, s = null) {
    Ir(t, e, 7, [n, s])
}
const sN = k3();
let rN = 0;
function iN(t, e, n) {
    const s = t.type
        , r = (e ? e.appContext : t.appContext) || sN
        , i = {
            uid: rN++,
            vnode: t,
            type: s,
            parent: e,
            appContext: r,
            root: null,
            next: null,
            subTree: null,
            effect: null,
            update: null,
            scope: new KA(!0),
            render: null,
            proxy: null,
            exposed: null,
            exposeProxy: null,
            withProxy: null,
            provides: e ? e.provides : Object.create(r.provides),
            accessCache: null,
            renderCache: [],
            components: null,
            directives: null,
            propsOptions: O3(s, r),
            emitsOptions: W3(s, r),
            emit: null,
            emitted: null,
            propsDefaults: Kt,
            inheritAttrs: s.inheritAttrs,
            ctx: Kt,
            data: Kt,
            props: Kt,
            attrs: Kt,
            slots: Kt,
            refs: Kt,
            setupState: Kt,
            setupContext: null,
            suspense: n,
            suspenseId: n ? n.pendingId : 0,
            asyncDep: null,
            asyncResolved: !1,
            isMounted: !1,
            isUnmounted: !1,
            isDeactivated: !1,
            bc: null,
            c: null,
            bm: null,
            m: null,
            bu: null,
            u: null,
            um: null,
            bum: null,
            da: null,
            a: null,
            rtg: null,
            rtc: null,
            ec: null,
            sp: null
        };
    return i.ctx = {
        _: i
    },
        i.root = e ? e.root : i,
        i.emit = j8.bind(null, i),
        t.ce && t.ce(i),
        i
}
let jn = null;
const ku = () => jn || Pn;
let um, z1;
{
    const t = XA()
        , e = (n, s) => {
            let r;
            return (r = t[n]) || (r = t[n] = []),
                r.push(s),
                i => {
                    r.length > 1 ? r.forEach(o => o(i)) : r[0](i)
                }
        }
        ;
    um = e("__VUE_INSTANCE_SETTERS__", n => jn = n),
        z1 = e("__VUE_SSR_SETTERS__", n => Yg = n)
}
const tf = t => {
    const e = jn;
    return um(t),
        t.scope.on(),
        () => {
            t.scope.off(),
                um(e)
        }
}
    , uE = () => {
        jn && jn.scope.off(),
            um(null)
    }
    ;
function j3(t) {
    return t.vnode.shapeFlag & 4
}
let Yg = !1;
function oN(t, e = !1, n = !1) {
    e && z1(e);
    const { props: s, children: r } = t.vnode
        , i = j3(t);
    R8(t, s, i, e),
        O8(t, r, n);
    const o = i ? aN(t, e) : void 0;
    return e && z1(!1),
        o
}
function aN(t, e) {
    const n = t.type;
    t.accessCache = Object.create(null),
        t.proxy = new Proxy(t.ctx, x8);
    const { setup: s } = n;
    if (s) {
        const r = t.setupContext = s.length > 1 ? cN(t) : null
            , i = tf(t);
        Ja();
        const o = Oa(s, t, 0, [t.props, r]);
        if (Za(),
            i(),
            GA(o)) {
            if (o.then(uE, uE),
                e)
                return o.then(l => {
                    hE(t, l, e)
                }
                ).catch(l => {
                    Fg(l, t, 0)
                }
                );
            t.asyncDep = o
        } else
            hE(t, o, e)
    } else
        z3(t, e)
}
function hE(t, e, n) {
    it(e) ? t.type.__ssrInlineRender ? t.ssrRender = e : t.render = e : qt(e) && (t.setupState = p3(e)),
        z3(t, n)
}
let dE;
function z3(t, e, n) {
    const s = t.type;
    if (!t.render) {
        if (!e && dE && !s.render) {
            const r = s.template || Av(t).template;
            if (r) {
                const { isCustomElement: i, compilerOptions: o } = t.appContext.config
                    , { delimiters: l, compilerOptions: a } = s
                    , c = Kn(Kn({
                        isCustomElement: i,
                        delimiters: l
                    }, o), a);
                s.render = dE(r, c)
            }
        }
        t.render = s.render || Sr
    }
    {
        const r = tf(t);
        Ja();
        try {
            w8(t)
        } finally {
            Za(),
                r()
        }
    }
}
const lN = {
    get(t, e) {
        return qs(t, "get", ""),
            t[e]
    }
};
function cN(t) {
    const e = n => {
        t.exposed = n || {}
    }
        ;
    return {
        attrs: new Proxy(t.attrs, lN),
        slots: t.slots,
        emit: t.emit,
        expose: e
    }
}
function Xg(t) {
    return t.exposed ? t.exposeProxy || (t.exposeProxy = new Proxy(p3(Bg(t.exposed)), {
        get(e, n) {
            if (n in e)
                return e[n];
            if (n in jh)
                return jh[n](t)
        },
        has(e, n) {
            return n in e || n in jh
        }
    })) : t.proxy
}
function uN(t, e = !0) {
    return it(t) ? t.displayName || t.name : t.name || e && t.__name
}
function hN(t) {
    return it(t) && "__vccOpts" in t
}
const ve = (t, e) => JO(t, e, Yg);
function Wi(t, e, n) {
    const s = arguments.length;
    return s === 2 ? qt(e) && !ze(e) ? cm(e) ? G(t, null, [e]) : G(t, e) : G(t, null, e) : (s > 3 ? n = Array.prototype.slice.call(arguments, 2) : s === 3 && cm(n) && (n = [n]),
        G(t, e, n))
}
const dN = "3.4.33";
/**
* @vue/runtime-dom v3.4.33
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const fN = "http://www.w3.org/2000/svg"
    , pN = "http://www.w3.org/1998/Math/MathML"
    , uo = typeof document < "u" ? document : null
    , fE = uo && uo.createElement("template")
    , mN = {
        insert: (t, e, n) => {
            e.insertBefore(t, n || null)
        }
        ,
        remove: t => {
            const e = t.parentNode;
            e && e.removeChild(t)
        }
        ,
        createElement: (t, e, n, s) => {
            const r = e === "svg" ? uo.createElementNS(fN, t) : e === "mathml" ? uo.createElementNS(pN, t) : n ? uo.createElement(t, {
                is: n
            }) : uo.createElement(t);
            return t === "select" && s && s.multiple != null && r.setAttribute("multiple", s.multiple),
                r
        }
        ,
        createText: t => uo.createTextNode(t),
        createComment: t => uo.createComment(t),
        setText: (t, e) => {
            t.nodeValue = e
        }
        ,
        setElementText: (t, e) => {
            t.textContent = e
        }
        ,
        parentNode: t => t.parentNode,
        nextSibling: t => t.nextSibling,
        querySelector: t => uo.querySelector(t),
        setScopeId(t, e) {
            t.setAttribute(e, "")
        },
        insertStaticContent(t, e, n, s, r, i) {
            const o = n ? n.previousSibling : e.lastChild;
            if (r && (r === i || r.nextSibling))
                for (; e.insertBefore(r.cloneNode(!0), n),
                    !(r === i || !(r = r.nextSibling));)
                    ;
            else {
                fE.innerHTML = s === "svg" ? `<svg>${t}</svg>` : s === "mathml" ? `<math>${t}</math>` : t;
                const l = fE.content;
                if (s === "svg" || s === "mathml") {
                    const a = l.firstChild;
                    for (; a.firstChild;)
                        l.appendChild(a.firstChild);
                    l.removeChild(a)
                }
                e.insertBefore(l, n)
            }
            return [o ? o.nextSibling : e.firstChild, n ? n.previousSibling : e.lastChild]
        }
    }
    , Ko = "transition"
    , Sh = "animation"
    , _d = Symbol("_vtc")
    , is = (t, { slots: e }) => Wi(u8, gN(t), e);
is.displayName = "Transition";
const q3 = {
    name: String,
    type: String,
    css: {
        type: Boolean,
        default: !0
    },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
};
is.props = Kn({}, b3, q3);
const fl = (t, e = []) => {
    ze(t) ? t.forEach(n => n(...e)) : t && t(...e)
}
    , pE = t => t ? ze(t) ? t.some(e => e.length > 1) : t.length > 1 : !1;
function gN(t) {
    const e = {};
    for (const k in t)
        k in q3 || (e[k] = t[k]);
    if (t.css === !1)
        return e;
    const { name: n = "v", type: s, duration: r, enterFromClass: i = `${n}-enter-from`, enterActiveClass: o = `${n}-enter-active`, enterToClass: l = `${n}-enter-to`, appearFromClass: a = i, appearActiveClass: c = o, appearToClass: u = l, leaveFromClass: h = `${n}-leave-from`, leaveActiveClass: d = `${n}-leave-active`, leaveToClass: f = `${n}-leave-to` } = t
        , p = _N(r)
        , m = p && p[0]
        , g = p && p[1]
        , { onBeforeEnter: b, onEnter: v, onEnterCancelled: _, onLeave: y, onLeaveCancelled: x, onBeforeAppear: w = b, onAppear: S = v, onAppearCancelled: E = _ } = e
        , C = (k, R, U) => {
            pl(k, R ? u : l),
                pl(k, R ? c : o),
                U && U()
        }
        , I = (k, R) => {
            k._isLeaving = !1,
                pl(k, h),
                pl(k, f),
                pl(k, d),
                R && R()
        }
        , L = k => (R, U) => {
            const W = k ? S : v
                , H = () => C(R, k, U);
            fl(W, [R, H]),
                mE(() => {
                    pl(R, k ? a : i),
                        Jo(R, k ? u : l),
                        pE(W) || gE(R, s, m, H)
                }
                )
        }
        ;
    return Kn(e, {
        onBeforeEnter(k) {
            fl(b, [k]),
                Jo(k, i),
                Jo(k, o)
        },
        onBeforeAppear(k) {
            fl(w, [k]),
                Jo(k, a),
                Jo(k, c)
        },
        onEnter: L(!1),
        onAppear: L(!0),
        onLeave(k, R) {
            k._isLeaving = !0;
            const U = () => I(k, R);
            Jo(k, h),
                Jo(k, d),
                vN(),
                mE(() => {
                    k._isLeaving && (pl(k, h),
                        Jo(k, f),
                        pE(y) || gE(k, s, g, U))
                }
                ),
                fl(y, [k, U])
        },
        onEnterCancelled(k) {
            C(k, !1),
                fl(_, [k])
        },
        onAppearCancelled(k) {
            C(k, !0),
                fl(E, [k])
        },
        onLeaveCancelled(k) {
            I(k),
                fl(x, [k])
        }
    })
}
function _N(t) {
    if (t == null)
        return null;
    if (qt(t))
        return [c0(t.enter), c0(t.leave)];
    {
        const e = c0(t);
        return [e, e]
    }
}
function c0(t) {
    return wO(t)
}
function Jo(t, e) {
    e.split(/\s+/).forEach(n => n && t.classList.add(n)),
        (t[_d] || (t[_d] = new Set)).add(e)
}
function pl(t, e) {
    e.split(/\s+/).forEach(s => s && t.classList.remove(s));
    const n = t[_d];
    n && (n.delete(e),
        n.size || (t[_d] = void 0))
}
function mE(t) {
    requestAnimationFrame(() => {
        requestAnimationFrame(t)
    }
    )
}
let yN = 0;
function gE(t, e, n, s) {
    const r = t._endId = ++yN
        , i = () => {
            r === t._endId && s()
        }
        ;
    if (n)
        return setTimeout(i, n);
    const { type: o, timeout: l, propCount: a } = bN(t, e);
    if (!o)
        return s();
    const c = o + "end";
    let u = 0;
    const h = () => {
        t.removeEventListener(c, d),
            i()
    }
        , d = f => {
            f.target === t && ++u >= a && h()
        }
        ;
    setTimeout(() => {
        u < a && h()
    }
        , l + 1),
        t.addEventListener(c, d)
}
function bN(t, e) {
    const n = window.getComputedStyle(t)
        , s = p => (n[p] || "").split(", ")
        , r = s(`${Ko}Delay`)
        , i = s(`${Ko}Duration`)
        , o = _E(r, i)
        , l = s(`${Sh}Delay`)
        , a = s(`${Sh}Duration`)
        , c = _E(l, a);
    let u = null
        , h = 0
        , d = 0;
    e === Ko ? o > 0 && (u = Ko,
        h = o,
        d = i.length) : e === Sh ? c > 0 && (u = Sh,
            h = c,
            d = a.length) : (h = Math.max(o, c),
                u = h > 0 ? o > c ? Ko : Sh : null,
                d = u ? u === Ko ? i.length : a.length : 0);
    const f = u === Ko && /\b(transform|all)(,|$)/.test(s(`${Ko}Property`).toString());
    return {
        type: u,
        timeout: h,
        propCount: d,
        hasTransform: f
    }
}
function _E(t, e) {
    for (; t.length < e.length;)
        t = t.concat(t);
    return Math.max(...e.map((n, s) => yE(n) + yE(t[s])))
}
function yE(t) {
    return t === "auto" ? 0 : Number(t.slice(0, -1).replace(",", ".")) * 1e3
}
function vN() {
    return document.body.offsetHeight
}
function xN(t, e, n) {
    const s = t[_d];
    s && (e = (e ? [e, ...s] : [...s]).join(" ")),
        e == null ? t.removeAttribute("class") : n ? t.setAttribute("class", e) : t.className = e
}
const hm = Symbol("_vod")
    , K3 = Symbol("_vsh")
    , Ru = {
        beforeMount(t, { value: e }, { transition: n }) {
            t[hm] = t.style.display === "none" ? "" : t.style.display,
                n && e ? n.beforeEnter(t) : Eh(t, e)
        },
        mounted(t, { value: e }, { transition: n }) {
            n && e && n.enter(t)
        },
        updated(t, { value: e, oldValue: n }, { transition: s }) {
            !e != !n && (s ? e ? (s.beforeEnter(t),
                Eh(t, !0),
                s.enter(t)) : s.leave(t, () => {
                    Eh(t, !1)
                }
                ) : Eh(t, e))
        },
        beforeUnmount(t, { value: e }) {
            Eh(t, e)
        }
    };
function Eh(t, e) {
    t.style.display = e ? t[hm] : "none",
        t[K3] = !e
}
const wN = Symbol("")
    , SN = /(^|;)\s*display\s*:/;
function EN(t, e, n) {
    const s = t.style
        , r = hn(n);
    let i = !1;
    if (n && !r) {
        if (e)
            if (hn(e))
                for (const o of e.split(";")) {
                    const l = o.slice(0, o.indexOf(":")).trim();
                    n[l] == null && Lp(s, l, "")
                }
            else
                for (const o in e)
                    n[o] == null && Lp(s, o, "");
        for (const o in n)
            o === "display" && (i = !0),
                Lp(s, o, n[o])
    } else if (r) {
        if (e !== n) {
            const o = s[wN];
            o && (n += ";" + o),
                s.cssText = n,
                i = SN.test(n)
        }
    } else
        e && t.removeAttribute("style");
    hm in t && (t[hm] = i ? s.display : "",
        t[K3] && (s.display = "none"))
}
const bE = /\s*!important$/;
function Lp(t, e, n) {
    if (ze(n))
        n.forEach(s => Lp(t, e, s));
    else if (n == null && (n = ""),
        e.startsWith("--"))
        t.setProperty(e, n);
    else {
        const s = TN(t, e);
        bE.test(n) ? t.setProperty(dc(s), n.replace(bE, ""), "important") : t[s] = n
    }
}
const vE = ["Webkit", "Moz", "ms"]
    , u0 = {};
function TN(t, e) {
    const n = u0[e];
    if (n)
        return n;
    let s = oi(e);
    if (s !== "filter" && s in t)
        return u0[e] = s;
    s = Ng(s);
    for (let r = 0; r < vE.length; r++) {
        const i = vE[r] + s;
        if (i in t)
            return u0[e] = i
    }
    return e
}
const xE = "http://www.w3.org/1999/xlink";
function wE(t, e, n, s, r, i = AO(e)) {
    s && e.startsWith("xlink:") ? n == null ? t.removeAttributeNS(xE, e.slice(6, e.length)) : t.setAttributeNS(xE, e, n) : n == null || i && !jA(n) ? t.removeAttribute(e) : t.setAttribute(e, i ? "" : Ka(n) ? String(n) : n)
}
function CN(t, e, n, s) {
    if (e === "innerHTML" || e === "textContent") {
        if (n == null)
            return;
        t[e] = n;
        return
    }
    const r = t.tagName;
    if (e === "value" && r !== "PROGRESS" && !r.includes("-")) {
        const o = r === "OPTION" ? t.getAttribute("value") || "" : t.value
            , l = n == null ? "" : String(n);
        (o !== l || !("_value" in t)) && (t.value = l),
            n == null && t.removeAttribute(e),
            t._value = n;
        return
    }
    let i = !1;
    if (n === "" || n == null) {
        const o = typeof t[e];
        o === "boolean" ? n = jA(n) : n == null && o === "string" ? (n = "",
            i = !0) : o === "number" && (n = 0,
                i = !0)
    }
    try {
        t[e] = n
    } catch { }
    i && t.removeAttribute(e)
}
function IN(t, e, n, s) {
    t.addEventListener(e, n, s)
}
function AN(t, e, n, s) {
    t.removeEventListener(e, n, s)
}
const SE = Symbol("_vei");
function kN(t, e, n, s, r = null) {
    const i = t[SE] || (t[SE] = {})
        , o = i[e];
    if (s && o)
        o.value = s;
    else {
        const [l, a] = RN(e);
        if (s) {
            const c = i[e] = LN(s, r);
            IN(t, l, c, a)
        } else
            o && (AN(t, l, o, a),
                i[e] = void 0)
    }
}
const EE = /(?:Once|Passive|Capture)$/;
function RN(t) {
    let e;
    if (EE.test(t)) {
        e = {};
        let s;
        for (; s = t.match(EE);)
            t = t.slice(0, t.length - s[0].length),
                e[s[0].toLowerCase()] = !0
    }
    return [t[2] === ":" ? t.slice(3) : dc(t.slice(2)), e]
}
let h0 = 0;
const MN = Promise.resolve()
    , PN = () => h0 || (MN.then(() => h0 = 0),
        h0 = Date.now());
function LN(t, e) {
    const n = s => {
        if (!s._vts)
            s._vts = Date.now();
        else if (s._vts <= n.attached)
            return;
        Ir(ON(s, n.value), e, 5, [s])
    }
        ;
    return n.value = t,
        n.attached = PN(),
        n
}
function ON(t, e) {
    if (ze(e)) {
        const n = t.stopImmediatePropagation;
        return t.stopImmediatePropagation = () => {
            n.call(t),
                t._stopped = !0
        }
            ,
            e.map(s => r => !r._stopped && s && s(r))
    } else
        return e
}
const TE = t => t.charCodeAt(0) === 111 && t.charCodeAt(1) === 110 && t.charCodeAt(2) > 96 && t.charCodeAt(2) < 123
    , NN = (t, e, n, s, r, i) => {
        const o = r === "svg";
        e === "class" ? xN(t, s, o) : e === "style" ? EN(t, n, s) : Pg(e) ? dv(e) || kN(t, e, n, s, i) : (e[0] === "." ? (e = e.slice(1),
            !0) : e[0] === "^" ? (e = e.slice(1),
                !1) : DN(t, e, s, o)) ? (CN(t, e, s),
                    !t.tagName.includes("-") && (e === "value" || e === "checked" || e === "selected") && wE(t, e, s, o, i, e !== "value")) : (e === "true-value" ? t._trueValue = s : e === "false-value" && (t._falseValue = s),
                        wE(t, e, s, o))
    }
    ;
function DN(t, e, n, s) {
    if (s)
        return !!(e === "innerHTML" || e === "textContent" || e in t && TE(e) && it(n));
    if (e === "spellcheck" || e === "draggable" || e === "translate" || e === "form" || e === "list" && t.tagName === "INPUT" || e === "type" && t.tagName === "TEXTAREA")
        return !1;
    if (e === "width" || e === "height") {
        const r = t.tagName;
        if (r === "IMG" || r === "VIDEO" || r === "CANVAS" || r === "SOURCE")
            return !1
    }
    return TE(e) && hn(n) ? !1 : e in t
}
const BN = ["ctrl", "shift", "alt", "meta"]
    , FN = {
        stop: t => t.stopPropagation(),
        prevent: t => t.preventDefault(),
        self: t => t.target !== t.currentTarget,
        ctrl: t => !t.ctrlKey,
        shift: t => !t.shiftKey,
        alt: t => !t.altKey,
        meta: t => !t.metaKey,
        left: t => "button" in t && t.button !== 0,
        middle: t => "button" in t && t.button !== 1,
        right: t => "button" in t && t.button !== 2,
        exact: (t, e) => BN.some(n => t[`${n}Key`] && !e.includes(n))
    }
    , ni = (t, e) => {
        const n = t._withMods || (t._withMods = {})
            , s = e.join(".");
        return n[s] || (n[s] = (r, ...i) => {
            for (let o = 0; o < e.length; o++) {
                const l = FN[e[o]];
                if (l && l(r, e))
                    return
            }
            return t(r, ...i)
        }
        )
    }
    , $N = Kn({
        patchProp: NN
    }, mN);
let CE;
function UN() {
    return CE || (CE = $8($N))
}
const VN = (...t) => {
    const e = UN().createApp(...t)
        , { mount: n } = e;
    return e.mount = s => {
        const r = HN(s);
        if (!r)
            return;
        const i = e._component;
        !it(i) && !i.render && !i.template && (i.template = r.innerHTML),
            r.innerHTML = "";
        const o = n(r, !1, GN(r));
        return r instanceof Element && (r.removeAttribute("v-cloak"),
            r.setAttribute("data-v-app", "")),
            o
    }
        ,
        e
}
    ;
function GN(t) {
    if (t instanceof SVGElement)
        return "svg";
    if (typeof MathMLElement == "function" && t instanceof MathMLElement)
        return "mathml"
}
function HN(t) {
    return hn(t) ? document.querySelector(t) : t
}
const WN = "modulepreload"
    , YN = function (t) {
        return "/" + t
    }
    , IE = {}
    , er = function (e, n, s) {
        let r = Promise.resolve();
        if (n && n.length > 0) {
            document.getElementsByTagName("link");
            const i = document.querySelector("meta[property=csp-nonce]")
                , o = (i == null ? void 0 : i.nonce) || (i == null ? void 0 : i.getAttribute("nonce"));
            r = Promise.all(n.map(l => {
                if (l = YN(l),
                    l in IE)
                    return;
                IE[l] = !0;
                const a = l.endsWith(".css")
                    , c = a ? '[rel="stylesheet"]' : "";
                if (document.querySelector(`link[href="${l}"]${c}`))
                    return;
                const u = document.createElement("link");
                if (u.rel = a ? "stylesheet" : WN,
                    a || (u.as = "script",
                        u.crossOrigin = ""),
                    u.href = l,
                    o && u.setAttribute("nonce", o),
                    document.head.appendChild(u),
                    a)
                    return new Promise((h, d) => {
                        u.addEventListener("load", h),
                            u.addEventListener("error", () => d(new Error(`Unable to preload CSS for ${l}`)))
                    }
                    )
            }
            ))
        }
        return r.then(() => e()).catch(i => {
            const o = new Event("vite:preloadError", {
                cancelable: !0
            });
            if (o.payload = i,
                window.dispatchEvent(o),
                !o.defaultPrevented)
                throw i
        }
        )
    };
var XN = !1;
let J3;
const jg = t => J3 = t
    , Z3 = Symbol();
function q1(t) {
    return t && typeof t == "object" && Object.prototype.toString.call(t) === "[object Object]" && typeof t.toJSON != "function"
}
var Kh;
(function (t) {
    t.direct = "direct",
        t.patchObject = "patch object",
        t.patchFunction = "patch function"
}
)(Kh || (Kh = {}));
function jN() {
    const t = mv(!0)
        , e = t.run(() => ke({}));
    let n = []
        , s = [];
    const r = Bg({
        install(i) {
            jg(r),
                r._a = i,
                i.provide(Z3, r),
                i.config.globalProperties.$pinia = r,
                s.forEach(o => n.push(o)),
                s = []
        },
        use(i) {
            return !this._a && !XN ? s.push(i) : n.push(i),
                this
        },
        _p: n,
        _a: null,
        _e: t,
        _s: new Map,
        state: e
    });
    return r
}
const Q3 = () => { }
    ;
function AE(t, e, n, s = Q3) {
    t.push(e);
    const r = () => {
        const i = t.indexOf(e);
        i > -1 && (t.splice(i, 1),
            s())
    }
        ;
    return !n && JA() && RO(r),
        r
}
function Ic(t, ...e) {
    t.slice().forEach(n => {
        n(...e)
    }
    )
}
const zN = t => t()
    , kE = Symbol()
    , d0 = Symbol();
function K1(t, e) {
    t instanceof Map && e instanceof Map ? e.forEach((n, s) => t.set(s, n)) : t instanceof Set && e instanceof Set && e.forEach(t.add, t);
    for (const n in e) {
        if (!e.hasOwnProperty(n))
            continue;
        const s = e[n]
            , r = t[n];
        q1(r) && q1(s) && t.hasOwnProperty(n) && !Tn(s) && !Ul(s) ? t[n] = K1(r, s) : t[n] = s
    }
    return t
}
const qN = Symbol();
function KN(t) {
    return !q1(t) || !t.hasOwnProperty(qN)
}
const { assign: sa } = Object;
function JN(t) {
    return !!(Tn(t) && t.effect)
}
function ZN(t, e, n, s) {
    const { state: r, actions: i, getters: o } = e
        , l = n.state.value[t];
    let a;
    function c() {
        l || (n.state.value[t] = r ? r() : {});
        const u = e8(n.state.value[t]);
        return sa(u, i, Object.keys(o || {}).reduce((h, d) => (h[d] = Bg(ve(() => {
            jg(n);
            const f = n._s.get(t);
            return o[d].call(f, f)
        }
        )),
            h), {}))
    }
    return a = ek(t, c, e, n, s, !0),
        a
}
function ek(t, e, n = {}, s, r, i) {
    let o;
    const l = sa({
        actions: {}
    }, n)
        , a = {
            deep: !0
        };
    let c, u, h = [], d = [], f;
    const p = s.state.value[t];
    !i && !p && (s.state.value[t] = {}),
        ke({});
    let m;
    function g(E) {
        let C;
        c = u = !1,
            typeof E == "function" ? (E(s.state.value[t]),
                C = {
                    type: Kh.patchFunction,
                    storeId: t,
                    events: f
                }) : (K1(s.state.value[t], E),
                    C = {
                        type: Kh.patchObject,
                        payload: E,
                        storeId: t,
                        events: f
                    });
        const I = m = Symbol();
        Zd().then(() => {
            m === I && (c = !0)
        }
        ),
            u = !0,
            Ic(h, C, s.state.value[t])
    }
    const b = i ? function () {
        const { state: C } = n
            , I = C ? C() : {};
        this.$patch(L => {
            sa(L, I)
        }
        )
    }
        : Q3;
    function v() {
        o.stop(),
            h = [],
            d = [],
            s._s.delete(t)
    }
    const _ = (E, C = "") => {
        if (kE in E)
            return E[d0] = C,
                E;
        const I = function () {
            jg(s);
            const L = Array.from(arguments)
                , k = []
                , R = [];
            function U(j) {
                k.push(j)
            }
            function W(j) {
                R.push(j)
            }
            Ic(d, {
                args: L,
                name: I[d0],
                store: x,
                after: U,
                onError: W
            });
            let H;
            try {
                H = E.apply(this && this.$id === t ? this : x, L)
            } catch (j) {
                throw Ic(R, j),
                j
            }
            return H instanceof Promise ? H.then(j => (Ic(k, j),
                j)).catch(j => (Ic(R, j),
                    Promise.reject(j))) : (Ic(k, H),
                        H)
        };
        return I[kE] = !0,
            I[d0] = C,
            I
    }
        , y = {
            _p: s,
            $id: t,
            $onAction: AE.bind(null, d),
            $patch: g,
            $reset: b,
            $subscribe(E, C = {}) {
                const I = AE(h, E, C.detached, () => L())
                    , L = o.run(() => Ln(() => s.state.value[t], k => {
                        (C.flush === "sync" ? u : c) && E({
                            storeId: t,
                            type: Kh.direct,
                            events: f
                        }, k)
                    }
                        , sa({}, a, C)));
                return I
            },
            $dispose: v
        }
        , x = Qu(y);
    s._s.set(t, x);
    const S = (s._a && s._a.runWithContext || zN)(() => s._e.run(() => (o = mv()).run(() => e({
        action: _
    }))));
    for (const E in S) {
        const C = S[E];
        if (Tn(C) && !JN(C) || Ul(C))
            i || (p && KN(C) && (Tn(C) ? C.value = p[E] : K1(C, p[E])),
                s.state.value[t][E] = C);
        else if (typeof C == "function") {
            const I = _(C, E);
            S[E] = I,
                l.actions[E] = C
        }
    }
    return sa(x, S),
        sa(Rt(x), S),
        Object.defineProperty(x, "$state", {
            get: () => s.state.value[t],
            set: E => {
                g(C => {
                    sa(C, E)
                }
                )
            }
        }),
        s._p.forEach(E => {
            sa(x, o.run(() => E({
                store: x,
                app: s._a,
                pinia: s,
                options: l
            })))
        }
        ),
        p && i && n.hydrate && n.hydrate(x.$state, p),
        c = !0,
        u = !0,
        x
}
function Ds(t, e, n) {
    let s, r;
    const i = typeof e == "function";
    typeof t == "string" ? (s = t,
        r = i ? n : e) : (r = t,
            s = t.id);
    function o(l, a) {
        const c = k8();
        return l = l || (c ? Ar(Z3, null) : null),
            l && jg(l),
            l = J3,
            l._s.has(s) || (i ? ek(s, e, r, l) : ZN(s, r, l)),
            l._s.get(s)
    }
    return o.$id = s,
        o
}
function Pv(t, e) {
    return Array.isArray(e) ? e.reduce((n, s) => (n[s] = function () {
        return t(this.$pinia)[s]
    }
        ,
        n), {}) : Object.keys(e).reduce((n, s) => (n[s] = function () {
            const r = t(this.$pinia)
                , i = e[s];
            return typeof i == "function" ? i.call(this, r) : r[i]
        }
            ,
            n), {})
}
var RE = {}
    , ME = {};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const tk = function (t) {
    const e = [];
    let n = 0;
    for (let s = 0; s < t.length; s++) {
        let r = t.charCodeAt(s);
        r < 128 ? e[n++] = r : r < 2048 ? (e[n++] = r >> 6 | 192,
            e[n++] = r & 63 | 128) : (r & 64512) === 55296 && s + 1 < t.length && (t.charCodeAt(s + 1) & 64512) === 56320 ? (r = 65536 + ((r & 1023) << 10) + (t.charCodeAt(++s) & 1023),
                e[n++] = r >> 18 | 240,
                e[n++] = r >> 12 & 63 | 128,
                e[n++] = r >> 6 & 63 | 128,
                e[n++] = r & 63 | 128) : (e[n++] = r >> 12 | 224,
                    e[n++] = r >> 6 & 63 | 128,
                    e[n++] = r & 63 | 128)
    }
    return e
}
    , QN = function (t) {
        const e = [];
        let n = 0
            , s = 0;
        for (; n < t.length;) {
            const r = t[n++];
            if (r < 128)
                e[s++] = String.fromCharCode(r);
            else if (r > 191 && r < 224) {
                const i = t[n++];
                e[s++] = String.fromCharCode((r & 31) << 6 | i & 63)
            } else if (r > 239 && r < 365) {
                const i = t[n++]
                    , o = t[n++]
                    , l = t[n++]
                    , a = ((r & 7) << 18 | (i & 63) << 12 | (o & 63) << 6 | l & 63) - 65536;
                e[s++] = String.fromCharCode(55296 + (a >> 10)),
                    e[s++] = String.fromCharCode(56320 + (a & 1023))
            } else {
                const i = t[n++]
                    , o = t[n++];
                e[s++] = String.fromCharCode((r & 15) << 12 | (i & 63) << 6 | o & 63)
            }
        }
        return e.join("")
    }
    , nk = {
        byteToCharMap_: null,
        charToByteMap_: null,
        byteToCharMapWebSafe_: null,
        charToByteMapWebSafe_: null,
        ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
        get ENCODED_VALS() {
            return this.ENCODED_VALS_BASE + "+/="
        },
        get ENCODED_VALS_WEBSAFE() {
            return this.ENCODED_VALS_BASE + "-_."
        },
        HAS_NATIVE_SUPPORT: typeof atob == "function",
        encodeByteArray(t, e) {
            if (!Array.isArray(t))
                throw Error("encodeByteArray takes an array as a parameter");
            this.init_();
            const n = e ? this.byteToCharMapWebSafe_ : this.byteToCharMap_
                , s = [];
            for (let r = 0; r < t.length; r += 3) {
                const i = t[r]
                    , o = r + 1 < t.length
                    , l = o ? t[r + 1] : 0
                    , a = r + 2 < t.length
                    , c = a ? t[r + 2] : 0
                    , u = i >> 2
                    , h = (i & 3) << 4 | l >> 4;
                let d = (l & 15) << 2 | c >> 6
                    , f = c & 63;
                a || (f = 64,
                    o || (d = 64)),
                    s.push(n[u], n[h], n[d], n[f])
            }
            return s.join("")
        },
        encodeString(t, e) {
            return this.HAS_NATIVE_SUPPORT && !e ? btoa(t) : this.encodeByteArray(tk(t), e)
        },
        decodeString(t, e) {
            return this.HAS_NATIVE_SUPPORT && !e ? atob(t) : QN(this.decodeStringToByteArray(t, e))
        },
        decodeStringToByteArray(t, e) {
            this.init_();
            const n = e ? this.charToByteMapWebSafe_ : this.charToByteMap_
                , s = [];
            for (let r = 0; r < t.length;) {
                const i = n[t.charAt(r++)]
                    , l = r < t.length ? n[t.charAt(r)] : 0;
                ++r;
                const c = r < t.length ? n[t.charAt(r)] : 64;
                ++r;
                const h = r < t.length ? n[t.charAt(r)] : 64;
                if (++r,
                    i == null || l == null || c == null || h == null)
                    throw new eD;
                const d = i << 2 | l >> 4;
                if (s.push(d),
                    c !== 64) {
                    const f = l << 4 & 240 | c >> 2;
                    if (s.push(f),
                        h !== 64) {
                        const p = c << 6 & 192 | h;
                        s.push(p)
                    }
                }
            }
            return s
        },
        init_() {
            if (!this.byteToCharMap_) {
                this.byteToCharMap_ = {},
                    this.charToByteMap_ = {},
                    this.byteToCharMapWebSafe_ = {},
                    this.charToByteMapWebSafe_ = {};
                for (let t = 0; t < this.ENCODED_VALS.length; t++)
                    this.byteToCharMap_[t] = this.ENCODED_VALS.charAt(t),
                        this.charToByteMap_[this.byteToCharMap_[t]] = t,
                        this.byteToCharMapWebSafe_[t] = this.ENCODED_VALS_WEBSAFE.charAt(t),
                        this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[t]] = t,
                        t >= this.ENCODED_VALS_BASE.length && (this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(t)] = t,
                            this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(t)] = t)
            }
        }
    };
class eD extends Error {
    constructor() {
        super(...arguments),
            this.name = "DecodeBase64StringError"
    }
}
const tD = function (t) {
    const e = tk(t);
    return nk.encodeByteArray(e, !0)
}
    , sk = function (t) {
        return tD(t).replace(/\./g, "")
    }
    , rk = function (t) {
        try {
            return nk.decodeString(t, !0)
        } catch (e) {
            console.error("base64Decode failed: ", e)
        }
        return null
    };
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function nD() {
    if (typeof self < "u")
        return self;
    if (typeof window < "u")
        return window;
    if (typeof RE < "u")
        return RE;
    throw new Error("Unable to locate global object.")
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const sD = () => nD().__FIREBASE_DEFAULTS__
    , rD = () => {
        if (typeof process > "u" || typeof ME > "u")
            return;
        const t = ME.__FIREBASE_DEFAULTS__;
        if (t)
            return JSON.parse(t)
    }
    , iD = () => {
        if (typeof document > "u")
            return;
        let t;
        try {
            t = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/)
        } catch {
            return
        }
        const e = t && rk(t[1]);
        return e && JSON.parse(e)
    }
    , Lv = () => {
        try {
            return sD() || rD() || iD()
        } catch (t) {
            console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${t}`);
            return
        }
    }
    , ik = t => {
        var e, n;
        return (n = (e = Lv()) === null || e === void 0 ? void 0 : e.emulatorHosts) === null || n === void 0 ? void 0 : n[t]
    }
    , oD = t => {
        const e = ik(t);
        if (!e)
            return;
        const n = e.lastIndexOf(":");
        if (n <= 0 || n + 1 === e.length)
            throw new Error(`Invalid host ${e} with no separate hostname and port!`);
        const s = parseInt(e.substring(n + 1), 10);
        return e[0] === "[" ? [e.substring(1, n - 1), s] : [e.substring(0, n), s]
    }
    , ok = () => {
        var t;
        return (t = Lv()) === null || t === void 0 ? void 0 : t.config
    }
    , ak = t => {
        var e;
        return (e = Lv()) === null || e === void 0 ? void 0 : e[`_${t}`]
    }
    ;
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class aD {
    constructor() {
        this.reject = () => { }
            ,
            this.resolve = () => { }
            ,
            this.promise = new Promise((e, n) => {
                this.resolve = e,
                    this.reject = n
            }
            )
    }
    wrapCallback(e) {
        return (n, s) => {
            n ? this.reject(n) : this.resolve(s),
                typeof e == "function" && (this.promise.catch(() => { }
                ),
                    e.length === 1 ? e(n) : e(n, s))
        }
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function ms() {
    return typeof navigator < "u" && typeof navigator.userAgent == "string" ? navigator.userAgent : ""
}
function lD() {
    return typeof window < "u" && !!(window.cordova || window.phonegap || window.PhoneGap) && /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(ms())
}
function lk() {
    const t = typeof chrome == "object" ? chrome.runtime : typeof browser == "object" ? browser.runtime : void 0;
    return typeof t == "object" && t.id !== void 0
}
function cD() {
    return typeof navigator == "object" && navigator.product === "ReactNative"
}
function uD() {
    const t = ms();
    return t.indexOf("MSIE ") >= 0 || t.indexOf("Trident/") >= 0
}
function ck() {
    try {
        return typeof indexedDB == "object"
    } catch {
        return !1
    }
}
function uk() {
    return new Promise((t, e) => {
        try {
            let n = !0;
            const s = "validate-browser-context-for-indexeddb-analytics-module"
                , r = self.indexedDB.open(s);
            r.onsuccess = () => {
                r.result.close(),
                    n || self.indexedDB.deleteDatabase(s),
                    t(!0)
            }
                ,
                r.onupgradeneeded = () => {
                    n = !1
                }
                ,
                r.onerror = () => {
                    var i;
                    e(((i = r.error) === null || i === void 0 ? void 0 : i.message) || "")
                }
        } catch (n) {
            e(n)
        }
    }
    )
}
function hD() {
    return !(typeof navigator > "u" || !navigator.cookieEnabled)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const dD = "FirebaseError";
class fi extends Error {
    constructor(e, n, s) {
        super(n),
            this.code = e,
            this.customData = s,
            this.name = dD,
            Object.setPrototypeOf(this, fi.prototype),
            Error.captureStackTrace && Error.captureStackTrace(this, fc.prototype.create)
    }
}
class fc {
    constructor(e, n, s) {
        this.service = e,
            this.serviceName = n,
            this.errors = s
    }
    create(e, ...n) {
        const s = n[0] || {}
            , r = `${this.service}/${e}`
            , i = this.errors[e]
            , o = i ? fD(i, s) : "Error"
            , l = `${this.serviceName}: ${o} (${r}).`;
        return new fi(r, l, s)
    }
}
function fD(t, e) {
    return t.replace(pD, (n, s) => {
        const r = e[s];
        return r != null ? String(r) : `<${s}?>`
    }
    )
}
const pD = /\{\$([^}]+)}/g;
function mD(t) {
    for (const e in t)
        if (Object.prototype.hasOwnProperty.call(t, e))
            return !1;
    return !0
}
function yd(t, e) {
    if (t === e)
        return !0;
    const n = Object.keys(t)
        , s = Object.keys(e);
    for (const r of n) {
        if (!s.includes(r))
            return !1;
        const i = t[r]
            , o = e[r];
        if (PE(i) && PE(o)) {
            if (!yd(i, o))
                return !1
        } else if (i !== o)
            return !1
    }
    for (const r of s)
        if (!n.includes(r))
            return !1;
    return !0
}
function PE(t) {
    return t !== null && typeof t == "object"
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function nf(t) {
    const e = [];
    for (const [n, s] of Object.entries(t))
        Array.isArray(s) ? s.forEach(r => {
            e.push(encodeURIComponent(n) + "=" + encodeURIComponent(r))
        }
        ) : e.push(encodeURIComponent(n) + "=" + encodeURIComponent(s));
    return e.length ? "&" + e.join("&") : ""
}
function gD(t, e) {
    const n = new _D(t, e);
    return n.subscribe.bind(n)
}
class _D {
    constructor(e, n) {
        this.observers = [],
            this.unsubscribes = [],
            this.observerCount = 0,
            this.task = Promise.resolve(),
            this.finalized = !1,
            this.onNoObservers = n,
            this.task.then(() => {
                e(this)
            }
            ).catch(s => {
                this.error(s)
            }
            )
    }
    next(e) {
        this.forEachObserver(n => {
            n.next(e)
        }
        )
    }
    error(e) {
        this.forEachObserver(n => {
            n.error(e)
        }
        ),
            this.close(e)
    }
    complete() {
        this.forEachObserver(e => {
            e.complete()
        }
        ),
            this.close()
    }
    subscribe(e, n, s) {
        let r;
        if (e === void 0 && n === void 0 && s === void 0)
            throw new Error("Missing Observer.");
        yD(e, ["next", "error", "complete"]) ? r = e : r = {
            next: e,
            error: n,
            complete: s
        },
            r.next === void 0 && (r.next = f0),
            r.error === void 0 && (r.error = f0),
            r.complete === void 0 && (r.complete = f0);
        const i = this.unsubscribeOne.bind(this, this.observers.length);
        return this.finalized && this.task.then(() => {
            try {
                this.finalError ? r.error(this.finalError) : r.complete()
            } catch { }
        }
        ),
            this.observers.push(r),
            i
    }
    unsubscribeOne(e) {
        this.observers === void 0 || this.observers[e] === void 0 || (delete this.observers[e],
            this.observerCount -= 1,
            this.observerCount === 0 && this.onNoObservers !== void 0 && this.onNoObservers(this))
    }
    forEachObserver(e) {
        if (!this.finalized)
            for (let n = 0; n < this.observers.length; n++)
                this.sendOne(n, e)
    }
    sendOne(e, n) {
        this.task.then(() => {
            if (this.observers !== void 0 && this.observers[e] !== void 0)
                try {
                    n(this.observers[e])
                } catch (s) {
                    typeof console < "u" && console.error && console.error(s)
                }
        }
        )
    }
    close(e) {
        this.finalized || (this.finalized = !0,
            e !== void 0 && (this.finalError = e),
            this.task.then(() => {
                this.observers = void 0,
                    this.onNoObservers = void 0
            }
            ))
    }
}
function yD(t, e) {
    if (typeof t != "object" || t === null)
        return !1;
    for (const n of e)
        if (n in t && typeof t[n] == "function")
            return !0;
    return !1
}
function f0() { }
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const bD = 1e3
    , vD = 2
    , xD = 4 * 60 * 60 * 1e3
    , wD = .5;
function LE(t, e = bD, n = vD) {
    const s = e * Math.pow(n, t)
        , r = Math.round(wD * s * (Math.random() - .5) * 2);
    return Math.min(xD, s + r)
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Dr(t) {
    return t && t._delegate ? t._delegate : t
}
class ai {
    constructor(e, n, s) {
        this.name = e,
            this.instanceFactory = n,
            this.type = s,
            this.multipleInstances = !1,
            this.serviceProps = {},
            this.instantiationMode = "LAZY",
            this.onInstanceCreated = null
    }
    setInstantiationMode(e) {
        return this.instantiationMode = e,
            this
    }
    setMultipleInstances(e) {
        return this.multipleInstances = e,
            this
    }
    setServiceProps(e) {
        return this.serviceProps = e,
            this
    }
    setInstanceCreatedCallback(e) {
        return this.onInstanceCreated = e,
            this
    }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const bl = "[DEFAULT]";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class SD {
    constructor(e, n) {
        this.name = e,
            this.container = n,
            this.component = null,
            this.instances = new Map,
            this.instancesDeferred = new Map,
            this.instancesOptions = new Map,
            this.onInitCallbacks = new Map
    }
    get(e) {
        const n = this.normalizeInstanceIdentifier(e);
        if (!this.instancesDeferred.has(n)) {
            const s = new aD;
            if (this.instancesDeferred.set(n, s),
                this.isInitialized(n) || this.shouldAutoInitialize())
                try {
                    const r = this.getOrInitializeService({
                        instanceIdentifier: n
                    });
                    r && s.resolve(r)
                } catch { }
        }
        return this.instancesDeferred.get(n).promise
    }
    getImmediate(e) {
        var n;
        const s = this.normalizeInstanceIdentifier(e == null ? void 0 : e.identifier)
            , r = (n = e == null ? void 0 : e.optional) !== null && n !== void 0 ? n : !1;
        if (this.isInitialized(s) || this.shouldAutoInitialize())
            try {
                return this.getOrInitializeService({
                    instanceIdentifier: s
                })
            } catch (i) {
                if (r)
                    return null;
                throw i
            }
        else {
            if (r)
                return null;
            throw Error(`Service ${this.name} is not available`)
        }
    }
    getComponent() {
        return this.component
    }
    setComponent(e) {
        if (e.name !== this.name)
            throw Error(`Mismatching Component ${e.name} for Provider ${this.name}.`);
        if (this.component)
            throw Error(`Component for ${this.name} has already been provided`);
        if (this.component = e,
            !!this.shouldAutoInitialize()) {
            if (TD(e))
                try {
                    this.getOrInitializeService({
                        instanceIdentifier: bl
                    })
                } catch { }
            for (const [n, s] of this.instancesDeferred.entries()) {
                const r = this.normalizeInstanceIdentifier(n);
                try {
                    const i = this.getOrInitializeService({
                        instanceIdentifier: r
                    });
                    s.resolve(i)
                } catch { }
            }
        }
    }
    clearInstance(e = bl) {
        this.instancesDeferred.delete(e),
            this.instancesOptions.delete(e),
            this.instances.delete(e)
    }
    async delete() {
        const e = Array.from(this.instances.values());
        await Promise.all([...e.filter(n => "INTERNAL" in n).map(n => n.INTERNAL.delete()), ...e.filter(n => "_delete" in n).map(n => n._delete())])
    }
    isComponentSet() {
        return this.component != null
    }
    isInitialized(e = bl) {
        return this.instances.has(e)
    }
    getOptions(e = bl) {
        return this.instancesOptions.get(e) || {}
    }
    initialize(e = {}) {
        const { options: n = {} } = e
            , s = this.normalizeInstanceIdentifier(e.instanceIdentifier);
        if (this.isInitialized(s))
            throw Error(`${this.name}(${s}) has already been initialized`);
        if (!this.isComponentSet())
            throw Error(`Component ${this.name} has not been registered yet`);
        const r = this.getOrInitializeService({
            instanceIdentifier: s,
            options: n
        });
        for (const [i, o] of this.instancesDeferred.entries()) {
            const l = this.normalizeInstanceIdentifier(i);
            s === l && o.resolve(r)
        }
        return r
    }
    onInit(e, n) {
        var s;
        const r = this.normalizeInstanceIdentifier(n)
            , i = (s = this.onInitCallbacks.get(r)) !== null && s !== void 0 ? s : new Set;
        i.add(e),
            this.onInitCallbacks.set(r, i);
        const o = this.instances.get(r);
        return o && e(o, r),
            () => {
                i.delete(e)
            }
    }
    invokeOnInitCallbacks(e, n) {
        const s = this.onInitCallbacks.get(n);
        if (s)
            for (const r of s)
                try {
                    r(e, n)
                } catch { }
    }
    getOrInitializeService({ instanceIdentifier: e, options: n = {} }) {
        let s = this.instances.get(e);
        if (!s && this.component && (s = this.component.instanceFactory(this.container, {
            instanceIdentifier: ED(e),
            options: n
        }),
            this.instances.set(e, s),
            this.instancesOptions.set(e, n),
            this.invokeOnInitCallbacks(s, e),
            this.component.onInstanceCreated))
            try {
                this.component.onInstanceCreated(this.container, e, s)
            } catch { }
        return s || null
    }
    normalizeInstanceIdentifier(e = bl) {
        return this.component ? this.component.multipleInstances ? e : bl : e
    }
    shouldAutoInitialize() {
        return !!this.component && this.component.instantiationMode !== "EXPLICIT"
    }
}
function ED(t) {
    return t === bl ? void 0 : t
}
function TD(t) {
    return t.instantiationMode === "EAGER"
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CD {
    constructor(e) {
        this.name = e,
            this.providers = new Map
    }
    addComponent(e) {
        const n = this.getProvider(e.name);
        if (n.isComponentSet())
            throw new Error(`Component ${e.name} has already been registered with ${this.name}`);
        n.setComponent(e)
    }
    addOrOverwriteComponent(e) {
        this.getProvider(e.name).isComponentSet() && this.providers.delete(e.name),
            this.addComponent(e)
    }
    getProvider(e) {
        if (this.providers.has(e))
            return this.providers.get(e);
        const n = new SD(e, this);
        return this.providers.set(e, n),
            n
    }
    getProviders() {
        return Array.from(this.providers.values())
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var $t;
(function (t) {
    t[t.DEBUG = 0] = "DEBUG",
        t[t.VERBOSE = 1] = "VERBOSE",
        t[t.INFO = 2] = "INFO",
        t[t.WARN = 3] = "WARN",
        t[t.ERROR = 4] = "ERROR",
        t[t.SILENT = 5] = "SILENT"
}
)($t || ($t = {}));
const ID = {
    debug: $t.DEBUG,
    verbose: $t.VERBOSE,
    info: $t.INFO,
    warn: $t.WARN,
    error: $t.ERROR,
    silent: $t.SILENT
}
    , AD = $t.INFO
    , kD = {
        [$t.DEBUG]: "log",
        [$t.VERBOSE]: "log",
        [$t.INFO]: "info",
        [$t.WARN]: "warn",
        [$t.ERROR]: "error"
    }
    , RD = (t, e, ...n) => {
        if (e < t.logLevel)
            return;
        const s = new Date().toISOString()
            , r = kD[e];
        if (r)
            console[r](`[${s}]  ${t.name}:`, ...n);
        else
            throw new Error(`Attempted to log a message with an invalid logType (value: ${e})`)
    }
    ;
class Ov {
    constructor(e) {
        this.name = e,
            this._logLevel = AD,
            this._logHandler = RD,
            this._userLogHandler = null
    }
    get logLevel() {
        return this._logLevel
    }
    set logLevel(e) {
        if (!(e in $t))
            throw new TypeError(`Invalid value "${e}" assigned to \`logLevel\``);
        this._logLevel = e
    }
    setLogLevel(e) {
        this._logLevel = typeof e == "string" ? ID[e] : e
    }
    get logHandler() {
        return this._logHandler
    }
    set logHandler(e) {
        if (typeof e != "function")
            throw new TypeError("Value assigned to `logHandler` must be a function");
        this._logHandler = e
    }
    get userLogHandler() {
        return this._userLogHandler
    }
    set userLogHandler(e) {
        this._userLogHandler = e
    }
    debug(...e) {
        this._userLogHandler && this._userLogHandler(this, $t.DEBUG, ...e),
            this._logHandler(this, $t.DEBUG, ...e)
    }
    log(...e) {
        this._userLogHandler && this._userLogHandler(this, $t.VERBOSE, ...e),
            this._logHandler(this, $t.VERBOSE, ...e)
    }
    info(...e) {
        this._userLogHandler && this._userLogHandler(this, $t.INFO, ...e),
            this._logHandler(this, $t.INFO, ...e)
    }
    warn(...e) {
        this._userLogHandler && this._userLogHandler(this, $t.WARN, ...e),
            this._logHandler(this, $t.WARN, ...e)
    }
    error(...e) {
        this._userLogHandler && this._userLogHandler(this, $t.ERROR, ...e),
            this._logHandler(this, $t.ERROR, ...e)
    }
}
const MD = (t, e) => e.some(n => t instanceof n);
let OE, NE;
function PD() {
    return OE || (OE = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction])
}
function LD() {
    return NE || (NE = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey])
}
const hk = new WeakMap
    , J1 = new WeakMap
    , dk = new WeakMap
    , p0 = new WeakMap
    , Nv = new WeakMap;
function OD(t) {
    const e = new Promise((n, s) => {
        const r = () => {
            t.removeEventListener("success", i),
                t.removeEventListener("error", o)
        }
            , i = () => {
                n(Na(t.result)),
                    r()
            }
            , o = () => {
                s(t.error),
                    r()
            }
            ;
        t.addEventListener("success", i),
            t.addEventListener("error", o)
    }
    );
    return e.then(n => {
        n instanceof IDBCursor && hk.set(n, t)
    }
    ).catch(() => { }
    ),
        Nv.set(e, t),
        e
}
function ND(t) {
    if (J1.has(t))
        return;
    const e = new Promise((n, s) => {
        const r = () => {
            t.removeEventListener("complete", i),
                t.removeEventListener("error", o),
                t.removeEventListener("abort", o)
        }
            , i = () => {
                n(),
                    r()
            }
            , o = () => {
                s(t.error || new DOMException("AbortError", "AbortError")),
                    r()
            }
            ;
        t.addEventListener("complete", i),
            t.addEventListener("error", o),
            t.addEventListener("abort", o)
    }
    );
    J1.set(t, e)
}
let Z1 = {
    get(t, e, n) {
        if (t instanceof IDBTransaction) {
            if (e === "done")
                return J1.get(t);
            if (e === "objectStoreNames")
                return t.objectStoreNames || dk.get(t);
            if (e === "store")
                return n.objectStoreNames[1] ? void 0 : n.objectStore(n.objectStoreNames[0])
        }
        return Na(t[e])
    },
    set(t, e, n) {
        return t[e] = n,
            !0
    },
    has(t, e) {
        return t instanceof IDBTransaction && (e === "done" || e === "store") ? !0 : e in t
    }
};
function DD(t) {
    Z1 = t(Z1)
}
function BD(t) {
    return t === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype) ? function (e, ...n) {
        const s = t.call(m0(this), e, ...n);
        return dk.set(s, e.sort ? e.sort() : [e]),
            Na(s)
    }
        : LD().includes(t) ? function (...e) {
            return t.apply(m0(this), e),
                Na(hk.get(this))
        }
            : function (...e) {
                return Na(t.apply(m0(this), e))
            }
}
function FD(t) {
    return typeof t == "function" ? BD(t) : (t instanceof IDBTransaction && ND(t),
        MD(t, PD()) ? new Proxy(t, Z1) : t)
}
function Na(t) {
    if (t instanceof IDBRequest)
        return OD(t);
    if (p0.has(t))
        return p0.get(t);
    const e = FD(t);
    return e !== t && (p0.set(t, e),
        Nv.set(e, t)),
        e
}
const m0 = t => Nv.get(t);
function fk(t, e, { blocked: n, upgrade: s, blocking: r, terminated: i } = {}) {
    const o = indexedDB.open(t, e)
        , l = Na(o);
    return s && o.addEventListener("upgradeneeded", a => {
        s(Na(o.result), a.oldVersion, a.newVersion, Na(o.transaction), a)
    }
    ),
        n && o.addEventListener("blocked", a => n(a.oldVersion, a.newVersion, a)),
        l.then(a => {
            i && a.addEventListener("close", () => i()),
                r && a.addEventListener("versionchange", c => r(c.oldVersion, c.newVersion, c))
        }
        ).catch(() => { }
        ),
        l
}
const $D = ["get", "getKey", "getAll", "getAllKeys", "count"]
    , UD = ["put", "add", "delete", "clear"]
    , g0 = new Map;
function DE(t, e) {
    if (!(t instanceof IDBDatabase && !(e in t) && typeof e == "string"))
        return;
    if (g0.get(e))
        return g0.get(e);
    const n = e.replace(/FromIndex$/, "")
        , s = e !== n
        , r = UD.includes(n);
    if (!(n in (s ? IDBIndex : IDBObjectStore).prototype) || !(r || $D.includes(n)))
        return;
    const i = async function (o, ...l) {
        const a = this.transaction(o, r ? "readwrite" : "readonly");
        let c = a.store;
        return s && (c = c.index(l.shift())),
            (await Promise.all([c[n](...l), r && a.done]))[0]
    };
    return g0.set(e, i),
        i
}
DD(t => ({
    ...t,
    get: (e, n, s) => DE(e, n) || t.get(e, n, s),
    has: (e, n) => !!DE(e, n) || t.has(e, n)
}));
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class VD {
    constructor(e) {
        this.container = e
    }
    getPlatformInfoString() {
        return this.container.getProviders().map(n => {
            if (GD(n)) {
                const s = n.getImmediate();
                return `${s.library}/${s.version}`
            } else
                return null
        }
        ).filter(n => n).join(" ")
    }
}
function GD(t) {
    const e = t.getComponent();
    return (e == null ? void 0 : e.type) === "VERSION"
}
const Q1 = "@firebase/app"
    , BE = "0.10.8";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Jl = new Ov("@firebase/app")
    , HD = "@firebase/app-compat"
    , WD = "@firebase/analytics-compat"
    , YD = "@firebase/analytics"
    , XD = "@firebase/app-check-compat"
    , jD = "@firebase/app-check"
    , zD = "@firebase/auth"
    , qD = "@firebase/auth-compat"
    , KD = "@firebase/database"
    , JD = "@firebase/database-compat"
    , ZD = "@firebase/functions"
    , QD = "@firebase/functions-compat"
    , e9 = "@firebase/installations"
    , t9 = "@firebase/installations-compat"
    , n9 = "@firebase/messaging"
    , s9 = "@firebase/messaging-compat"
    , r9 = "@firebase/performance"
    , i9 = "@firebase/performance-compat"
    , o9 = "@firebase/remote-config"
    , a9 = "@firebase/remote-config-compat"
    , l9 = "@firebase/storage"
    , c9 = "@firebase/storage-compat"
    , u9 = "@firebase/firestore"
    , h9 = "@firebase/vertexai-preview"
    , d9 = "@firebase/firestore-compat"
    , f9 = "firebase"
    , p9 = "10.12.5";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ey = "[DEFAULT]"
    , m9 = {
        [Q1]: "fire-core",
        [HD]: "fire-core-compat",
        [YD]: "fire-analytics",
        [WD]: "fire-analytics-compat",
        [jD]: "fire-app-check",
        [XD]: "fire-app-check-compat",
        [zD]: "fire-auth",
        [qD]: "fire-auth-compat",
        [KD]: "fire-rtdb",
        [JD]: "fire-rtdb-compat",
        [ZD]: "fire-fn",
        [QD]: "fire-fn-compat",
        [e9]: "fire-iid",
        [t9]: "fire-iid-compat",
        [n9]: "fire-fcm",
        [s9]: "fire-fcm-compat",
        [r9]: "fire-perf",
        [i9]: "fire-perf-compat",
        [o9]: "fire-rc",
        [a9]: "fire-rc-compat",
        [l9]: "fire-gcs",
        [c9]: "fire-gcs-compat",
        [u9]: "fire-fst",
        [d9]: "fire-fst-compat",
        [h9]: "fire-vertex",
        "fire-js": "fire-js",
        [f9]: "fire-js-all"
    };
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const dm = new Map
    , g9 = new Map
    , ty = new Map;
function FE(t, e) {
    try {
        t.container.addComponent(e)
    } catch (n) {
        Jl.debug(`Component ${e.name} failed to register with FirebaseApp ${t.name}`, n)
    }
}
function Yi(t) {
    const e = t.name;
    if (ty.has(e))
        return Jl.debug(`There were multiple attempts to register component ${e}.`),
            !1;
    ty.set(e, t);
    for (const n of dm.values())
        FE(n, t);
    for (const n of g9.values())
        FE(n, t);
    return !0
}
function pc(t, e) {
    const n = t.container.getProvider("heartbeat").getImmediate({
        optional: !0
    });
    return n && n.triggerHeartbeat(),
        t.container.getProvider(e)
}
function go(t) {
    return t.settings !== void 0
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const _9 = {
    "no-app": "No Firebase App '{$appName}' has been created - call initializeApp() first",
    "bad-app-name": "Illegal App name: '{$appName}'",
    "duplicate-app": "Firebase App named '{$appName}' already exists with different options or config",
    "app-deleted": "Firebase App named '{$appName}' already deleted",
    "server-app-deleted": "Firebase Server App has been deleted",
    "no-options": "Need to provide options, when not being deployed to hosting via source.",
    "invalid-app-argument": "firebase.{$appName}() takes either no argument or a Firebase App instance.",
    "invalid-log-argument": "First argument to `onLog` must be null or a function.",
    "idb-open": "Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.",
    "idb-get": "Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.",
    "idb-set": "Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.",
    "idb-delete": "Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.",
    "finalization-registry-not-supported": "FirebaseServerApp deleteOnDeref field defined but the JS runtime does not support FinalizationRegistry.",
    "invalid-server-app-environment": "FirebaseServerApp is not for use in browser environments."
}
    , Da = new fc("app", "Firebase", _9);
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class y9 {
    constructor(e, n, s) {
        this._isDeleted = !1,
            this._options = Object.assign({}, e),
            this._config = Object.assign({}, n),
            this._name = n.name,
            this._automaticDataCollectionEnabled = n.automaticDataCollectionEnabled,
            this._container = s,
            this.container.addComponent(new ai("app", () => this, "PUBLIC"))
    }
    get automaticDataCollectionEnabled() {
        return this.checkDestroyed(),
            this._automaticDataCollectionEnabled
    }
    set automaticDataCollectionEnabled(e) {
        this.checkDestroyed(),
            this._automaticDataCollectionEnabled = e
    }
    get name() {
        return this.checkDestroyed(),
            this._name
    }
    get options() {
        return this.checkDestroyed(),
            this._options
    }
    get config() {
        return this.checkDestroyed(),
            this._config
    }
    get container() {
        return this._container
    }
    get isDeleted() {
        return this._isDeleted
    }
    set isDeleted(e) {
        this._isDeleted = e
    }
    checkDestroyed() {
        if (this.isDeleted)
            throw Da.create("app-deleted", {
                appName: this._name
            })
    }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const sf = p9;
function pk(t, e = {}) {
    let n = t;
    typeof e != "object" && (e = {
        name: e
    });
    const s = Object.assign({
        name: ey,
        automaticDataCollectionEnabled: !1
    }, e)
        , r = s.name;
    if (typeof r != "string" || !r)
        throw Da.create("bad-app-name", {
            appName: String(r)
        });
    if (n || (n = ok()),
        !n)
        throw Da.create("no-options");
    const i = dm.get(r);
    if (i) {
        if (yd(n, i.options) && yd(s, i.config))
            return i;
        throw Da.create("duplicate-app", {
            appName: r
        })
    }
    const o = new CD(r);
    for (const a of ty.values())
        o.addComponent(a);
    const l = new y9(n, s, o);
    return dm.set(r, l),
        l
}
function Dv(t = ey) {
    const e = dm.get(t);
    if (!e && t === ey && ok())
        return pk();
    if (!e)
        throw Da.create("no-app", {
            appName: t
        });
    return e
}
function kr(t, e, n) {
    var s;
    let r = (s = m9[t]) !== null && s !== void 0 ? s : t;
    n && (r += `-${n}`);
    const i = r.match(/\s|\//)
        , o = e.match(/\s|\//);
    if (i || o) {
        const l = [`Unable to register library "${r}" with version "${e}":`];
        i && l.push(`library name "${r}" contains illegal characters (whitespace or "/")`),
            i && o && l.push("and"),
            o && l.push(`version name "${e}" contains illegal characters (whitespace or "/")`),
            Jl.warn(l.join(" "));
        return
    }
    Yi(new ai(`${r}-version`, () => ({
        library: r,
        version: e
    }), "VERSION"))
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const b9 = "firebase-heartbeat-database"
    , v9 = 1
    , bd = "firebase-heartbeat-store";
let _0 = null;
function mk() {
    return _0 || (_0 = fk(b9, v9, {
        upgrade: (t, e) => {
            switch (e) {
                case 0:
                    try {
                        t.createObjectStore(bd)
                    } catch (n) {
                        console.warn(n)
                    }
            }
        }
    }).catch(t => {
        throw Da.create("idb-open", {
            originalErrorMessage: t.message
        })
    }
    )),
        _0
}
async function x9(t) {
    try {
        const n = (await mk()).transaction(bd)
            , s = await n.objectStore(bd).get(gk(t));
        return await n.done,
            s
    } catch (e) {
        if (e instanceof fi)
            Jl.warn(e.message);
        else {
            const n = Da.create("idb-get", {
                originalErrorMessage: e == null ? void 0 : e.message
            });
            Jl.warn(n.message)
        }
    }
}
async function $E(t, e) {
    try {
        const s = (await mk()).transaction(bd, "readwrite");
        await s.objectStore(bd).put(e, gk(t)),
            await s.done
    } catch (n) {
        if (n instanceof fi)
            Jl.warn(n.message);
        else {
            const s = Da.create("idb-set", {
                originalErrorMessage: n == null ? void 0 : n.message
            });
            Jl.warn(s.message)
        }
    }
}
function gk(t) {
    return `${t.name}!${t.options.appId}`
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const w9 = 1024
    , S9 = 30 * 24 * 60 * 60 * 1e3;
class E9 {
    constructor(e) {
        this.container = e,
            this._heartbeatsCache = null;
        const n = this.container.getProvider("app").getImmediate();
        this._storage = new C9(n),
            this._heartbeatsCachePromise = this._storage.read().then(s => (this._heartbeatsCache = s,
                s))
    }
    async triggerHeartbeat() {
        var e, n;
        const r = this.container.getProvider("platform-logger").getImmediate().getPlatformInfoString()
            , i = UE();
        if (!(((e = this._heartbeatsCache) === null || e === void 0 ? void 0 : e.heartbeats) == null && (this._heartbeatsCache = await this._heartbeatsCachePromise,
            ((n = this._heartbeatsCache) === null || n === void 0 ? void 0 : n.heartbeats) == null)) && !(this._heartbeatsCache.lastSentHeartbeatDate === i || this._heartbeatsCache.heartbeats.some(o => o.date === i)))
            return this._heartbeatsCache.heartbeats.push({
                date: i,
                agent: r
            }),
                this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter(o => {
                    const l = new Date(o.date).valueOf();
                    return Date.now() - l <= S9
                }
                ),
                this._storage.overwrite(this._heartbeatsCache)
    }
    async getHeartbeatsHeader() {
        var e;
        if (this._heartbeatsCache === null && await this._heartbeatsCachePromise,
            ((e = this._heartbeatsCache) === null || e === void 0 ? void 0 : e.heartbeats) == null || this._heartbeatsCache.heartbeats.length === 0)
            return "";
        const n = UE()
            , { heartbeatsToSend: s, unsentEntries: r } = T9(this._heartbeatsCache.heartbeats)
            , i = sk(JSON.stringify({
                version: 2,
                heartbeats: s
            }));
        return this._heartbeatsCache.lastSentHeartbeatDate = n,
            r.length > 0 ? (this._heartbeatsCache.heartbeats = r,
                await this._storage.overwrite(this._heartbeatsCache)) : (this._heartbeatsCache.heartbeats = [],
                    this._storage.overwrite(this._heartbeatsCache)),
            i
    }
}
function UE() {
    return new Date().toISOString().substring(0, 10)
}
function T9(t, e = w9) {
    const n = [];
    let s = t.slice();
    for (const r of t) {
        const i = n.find(o => o.agent === r.agent);
        if (i) {
            if (i.dates.push(r.date),
                VE(n) > e) {
                i.dates.pop();
                break
            }
        } else if (n.push({
            agent: r.agent,
            dates: [r.date]
        }),
            VE(n) > e) {
            n.pop();
            break
        }
        s = s.slice(1)
    }
    return {
        heartbeatsToSend: n,
        unsentEntries: s
    }
}
class C9 {
    constructor(e) {
        this.app = e,
            this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck()
    }
    async runIndexedDBEnvironmentCheck() {
        return ck() ? uk().then(() => !0).catch(() => !1) : !1
    }
    async read() {
        if (await this._canUseIndexedDBPromise) {
            const n = await x9(this.app);
            return n != null && n.heartbeats ? n : {
                heartbeats: []
            }
        } else
            return {
                heartbeats: []
            }
    }
    async overwrite(e) {
        var n;
        if (await this._canUseIndexedDBPromise) {
            const r = await this.read();
            return $E(this.app, {
                lastSentHeartbeatDate: (n = e.lastSentHeartbeatDate) !== null && n !== void 0 ? n : r.lastSentHeartbeatDate,
                heartbeats: e.heartbeats
            })
        } else
            return
    }
    async add(e) {
        var n;
        if (await this._canUseIndexedDBPromise) {
            const r = await this.read();
            return $E(this.app, {
                lastSentHeartbeatDate: (n = e.lastSentHeartbeatDate) !== null && n !== void 0 ? n : r.lastSentHeartbeatDate,
                heartbeats: [...r.heartbeats, ...e.heartbeats]
            })
        } else
            return
    }
}
function VE(t) {
    return sk(JSON.stringify({
        version: 2,
        heartbeats: t
    })).length
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function I9(t) {
    Yi(new ai("platform-logger", e => new VD(e), "PRIVATE")),
        Yi(new ai("heartbeat", e => new E9(e), "PRIVATE")),
        kr(Q1, BE, t),
        kr(Q1, BE, "esm2017"),
        kr("fire-js", "")
}
I9("");
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const A9 = "type.googleapis.com/google.protobuf.Int64Value"
    , k9 = "type.googleapis.com/google.protobuf.UInt64Value";
function _k(t, e) {
    const n = {};
    for (const s in t)
        t.hasOwnProperty(s) && (n[s] = e(t[s]));
    return n
}
function ny(t) {
    if (t == null)
        return null;
    if (t instanceof Number && (t = t.valueOf()),
        typeof t == "number" && isFinite(t) || t === !0 || t === !1 || Object.prototype.toString.call(t) === "[object String]")
        return t;
    if (t instanceof Date)
        return t.toISOString();
    if (Array.isArray(t))
        return t.map(e => ny(e));
    if (typeof t == "function" || typeof t == "object")
        return _k(t, e => ny(e));
    throw new Error("Data cannot be encoded in JSON: " + t)
}
function fm(t) {
    if (t == null)
        return t;
    if (t["@type"])
        switch (t["@type"]) {
            case A9:
            case k9:
                {
                    const e = Number(t.value);
                    if (isNaN(e))
                        throw new Error("Data cannot be decoded from JSON: " + t);
                    return e
                }
            default:
                throw new Error("Data cannot be decoded from JSON: " + t)
        }
    return Array.isArray(t) ? t.map(e => fm(e)) : typeof t == "function" || typeof t == "object" ? _k(t, e => fm(e)) : t
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Bv = "functions";
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const GE = {
    OK: "ok",
    CANCELLED: "cancelled",
    UNKNOWN: "unknown",
    INVALID_ARGUMENT: "invalid-argument",
    DEADLINE_EXCEEDED: "deadline-exceeded",
    NOT_FOUND: "not-found",
    ALREADY_EXISTS: "already-exists",
    PERMISSION_DENIED: "permission-denied",
    UNAUTHENTICATED: "unauthenticated",
    RESOURCE_EXHAUSTED: "resource-exhausted",
    FAILED_PRECONDITION: "failed-precondition",
    ABORTED: "aborted",
    OUT_OF_RANGE: "out-of-range",
    UNIMPLEMENTED: "unimplemented",
    INTERNAL: "internal",
    UNAVAILABLE: "unavailable",
    DATA_LOSS: "data-loss"
};
class hu extends fi {
    constructor(e, n, s) {
        super(`${Bv}/${e}`, n || ""),
            this.details = s
    }
}
function R9(t) {
    if (t >= 200 && t < 300)
        return "ok";
    switch (t) {
        case 0:
            return "internal";
        case 400:
            return "invalid-argument";
        case 401:
            return "unauthenticated";
        case 403:
            return "permission-denied";
        case 404:
            return "not-found";
        case 409:
            return "aborted";
        case 429:
            return "resource-exhausted";
        case 499:
            return "cancelled";
        case 500:
            return "internal";
        case 501:
            return "unimplemented";
        case 503:
            return "unavailable";
        case 504:
            return "deadline-exceeded"
    }
    return "unknown"
}
function M9(t, e) {
    let n = R9(t), s = n, r;
    try {
        const i = e && e.error;
        if (i) {
            const o = i.status;
            if (typeof o == "string") {
                if (!GE[o])
                    return new hu("internal", "internal");
                n = GE[o],
                    s = o
            }
            const l = i.message;
            typeof l == "string" && (s = l),
                r = i.details,
                r !== void 0 && (r = fm(r))
        }
    } catch { }
    return n === "ok" ? null : new hu(n, s, r)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class P9 {
    constructor(e, n, s) {
        this.auth = null,
            this.messaging = null,
            this.appCheck = null,
            this.auth = e.getImmediate({
                optional: !0
            }),
            this.messaging = n.getImmediate({
                optional: !0
            }),
            this.auth || e.get().then(r => this.auth = r, () => { }
            ),
            this.messaging || n.get().then(r => this.messaging = r, () => { }
            ),
            this.appCheck || s.get().then(r => this.appCheck = r, () => { }
            )
    }
    async getAuthToken() {
        if (this.auth)
            try {
                const e = await this.auth.getToken();
                return e == null ? void 0 : e.accessToken
            } catch {
                return
            }
    }
    async getMessagingToken() {
        if (!(!this.messaging || !("Notification" in self) || Notification.permission !== "granted"))
            try {
                return await this.messaging.getToken()
            } catch {
                return
            }
    }
    async getAppCheckToken(e) {
        if (this.appCheck) {
            const n = e ? await this.appCheck.getLimitedUseToken() : await this.appCheck.getToken();
            return n.error ? null : n.token
        }
        return null
    }
    async getContext(e) {
        const n = await this.getAuthToken()
            , s = await this.getMessagingToken()
            , r = await this.getAppCheckToken(e);
        return {
            authToken: n,
            messagingToken: s,
            appCheckToken: r
        }
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const sy = "us-central1";
function L9(t) {
    let e = null;
    return {
        promise: new Promise((n, s) => {
            e = setTimeout(() => {
                s(new hu("deadline-exceeded", "deadline-exceeded"))
            }
                , t)
        }
        ),
        cancel: () => {
            e && clearTimeout(e)
        }
    }
}
class O9 {
    constructor(e, n, s, r, i = sy, o) {
        this.app = e,
            this.fetchImpl = o,
            this.emulatorOrigin = null,
            this.contextProvider = new P9(n, s, r),
            this.cancelAllRequests = new Promise(l => {
                this.deleteService = () => Promise.resolve(l())
            }
            );
        try {
            const l = new URL(i);
            this.customDomain = l.origin,
                this.region = sy
        } catch {
            this.customDomain = null,
                this.region = i
        }
    }
    _delete() {
        return this.deleteService()
    }
    _url(e) {
        const n = this.app.options.projectId;
        return this.emulatorOrigin !== null ? `${this.emulatorOrigin}/${n}/${this.region}/${e}` : this.customDomain !== null ? `${this.customDomain}/${e}` : `https://${this.region}-${n}.cloudfunctions.net/${e}`
    }
}
function N9(t, e, n) {
    t.emulatorOrigin = `http://${e}:${n}`
}
function D9(t, e, n) {
    return s => F9(t, e, s, {})
}
async function B9(t, e, n, s) {
    n["Content-Type"] = "application/json";
    let r;
    try {
        r = await s(t, {
            method: "POST",
            body: JSON.stringify(e),
            headers: n
        })
    } catch {
        return {
            status: 0,
            json: null
        }
    }
    let i = null;
    try {
        i = await r.json()
    } catch { }
    return {
        status: r.status,
        json: i
    }
}
function F9(t, e, n, s) {
    const r = t._url(e);
    return $9(t, r, n, s)
}
async function $9(t, e, n, s) {
    n = ny(n);
    const r = {
        data: n
    }
        , i = {}
        , o = await t.contextProvider.getContext(s.limitedUseAppCheckTokens);
    o.authToken && (i.Authorization = "Bearer " + o.authToken),
        o.messagingToken && (i["Firebase-Instance-ID-Token"] = o.messagingToken),
        o.appCheckToken !== null && (i["X-Firebase-AppCheck"] = o.appCheckToken);
    const l = s.timeout || 7e4
        , a = L9(l)
        , c = await Promise.race([B9(e, r, i, t.fetchImpl), a.promise, t.cancelAllRequests]);
    if (a.cancel(),
        !c)
        throw new hu("cancelled", "Firebase Functions instance was deleted.");
    const u = M9(c.status, c.json);
    if (u)
        throw u;
    if (!c.json)
        throw new hu("internal", "Response is not valid JSON object.");
    let h = c.json.data;
    if (typeof h > "u" && (h = c.json.result),
        typeof h > "u")
        throw new hu("internal", "Response is missing data field.");
    return {
        data: fm(h)
    }
}
const HE = "@firebase/functions"
    , WE = "0.11.6";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const U9 = "auth-internal"
    , V9 = "app-check-internal"
    , G9 = "messaging-internal";
function H9(t, e) {
    const n = (s, { instanceIdentifier: r }) => {
        const i = s.getProvider("app").getImmediate()
            , o = s.getProvider(U9)
            , l = s.getProvider(G9)
            , a = s.getProvider(V9);
        return new O9(i, o, l, a, r, t)
    }
        ;
    Yi(new ai(Bv, n, "PUBLIC").setMultipleInstances(!0)),
        kr(HE, WE, e),
        kr(HE, WE, "esm2017")
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function W9(t = Dv(), e = sy) {
    const s = pc(Dr(t), Bv).getImmediate({
        identifier: e
    })
        , r = oD("functions");
    return r && Y9(s, ...r),
        s
}
function Y9(t, e, n) {
    N9(Dr(t), e, n)
}
function Bn(t, e, n) {
    return D9(Dr(t), e)
}
H9(fetch.bind(self));
var YE = {}
    , X9 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof YE < "u" ? YE : typeof self < "u" ? self : {};
function Fv(t) {
    return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t
}
function j9(t) {
    if (t.__esModule)
        return t;
    var e = t.default;
    if (typeof e == "function") {
        var n = function s() {
            return this instanceof s ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments)
        };
        n.prototype = e.prototype
    } else
        n = {};
    return Object.defineProperty(n, "__esModule", {
        value: !0
    }),
        Object.keys(t).forEach(function (s) {
            var r = Object.getOwnPropertyDescriptor(t, s);
            Object.defineProperty(n, s, r.get ? r : {
                enumerable: !0,
                get: function () {
                    return t[s]
                }
            })
        }),
        n
}
var yk = {};
function Mr(t, e) {
    typeof e == "boolean" && (e = {
        forever: e
    }),
        this._originalTimeouts = JSON.parse(JSON.stringify(t)),
        this._timeouts = t,
        this._options = e || {},
        this._maxRetryTime = e && e.maxRetryTime || 1 / 0,
        this._fn = null,
        this._errors = [],
        this._attempts = 1,
        this._operationTimeout = null,
        this._operationTimeoutCb = null,
        this._timeout = null,
        this._operationStart = null,
        this._timer = null,
        this._options.forever && (this._cachedTimeouts = this._timeouts.slice(0))
}
var z9 = Mr;
Mr.prototype.reset = function () {
    this._attempts = 1,
        this._timeouts = this._originalTimeouts.slice(0)
}
    ;
Mr.prototype.stop = function () {
    this._timeout && clearTimeout(this._timeout),
        this._timer && clearTimeout(this._timer),
        this._timeouts = [],
        this._cachedTimeouts = null
}
    ;
Mr.prototype.retry = function (t) {
    if (this._timeout && clearTimeout(this._timeout),
        !t)
        return !1;
    var e = new Date().getTime();
    if (t && e - this._operationStart >= this._maxRetryTime)
        return this._errors.push(t),
            this._errors.unshift(new Error("RetryOperation timeout occurred")),
            !1;
    this._errors.push(t);
    var n = this._timeouts.shift();
    if (n === void 0)
        if (this._cachedTimeouts)
            this._errors.splice(0, this._errors.length - 1),
                n = this._cachedTimeouts.slice(-1);
        else
            return !1;
    var s = this;
    return this._timer = setTimeout(function () {
        s._attempts++,
            s._operationTimeoutCb && (s._timeout = setTimeout(function () {
                s._operationTimeoutCb(s._attempts)
            }, s._operationTimeout),
                s._options.unref && s._timeout.unref()),
            s._fn(s._attempts)
    }, n),
        this._options.unref && this._timer.unref(),
        !0
}
    ;
Mr.prototype.attempt = function (t, e) {
    this._fn = t,
        e && (e.timeout && (this._operationTimeout = e.timeout),
            e.cb && (this._operationTimeoutCb = e.cb));
    var n = this;
    this._operationTimeoutCb && (this._timeout = setTimeout(function () {
        n._operationTimeoutCb()
    }, n._operationTimeout)),
        this._operationStart = new Date().getTime(),
        this._fn(this._attempts)
}
    ;
Mr.prototype.try = function (t) {
    console.log("Using RetryOperation.try() is deprecated"),
        this.attempt(t)
}
    ;
Mr.prototype.start = function (t) {
    console.log("Using RetryOperation.start() is deprecated"),
        this.attempt(t)
}
    ;
Mr.prototype.start = Mr.prototype.try;
Mr.prototype.errors = function () {
    return this._errors
}
    ;
Mr.prototype.attempts = function () {
    return this._attempts
}
    ;
Mr.prototype.mainError = function () {
    if (this._errors.length === 0)
        return null;
    for (var t = {}, e = null, n = 0, s = 0; s < this._errors.length; s++) {
        var r = this._errors[s]
            , i = r.message
            , o = (t[i] || 0) + 1;
        t[i] = o,
            o >= n && (e = r,
                n = o)
    }
    return e
}
    ;
(function (t) {
    var e = z9;
    t.operation = function (n) {
        var s = t.timeouts(n);
        return new e(s, {
            forever: n && (n.forever || n.retries === 1 / 0),
            unref: n && n.unref,
            maxRetryTime: n && n.maxRetryTime
        })
    }
        ,
        t.timeouts = function (n) {
            if (n instanceof Array)
                return [].concat(n);
            var s = {
                retries: 10,
                factor: 2,
                minTimeout: 1 * 1e3,
                maxTimeout: 1 / 0,
                randomize: !1
            };
            for (var r in n)
                s[r] = n[r];
            if (s.minTimeout > s.maxTimeout)
                throw new Error("minTimeout is greater than maxTimeout");
            for (var i = [], o = 0; o < s.retries; o++)
                i.push(this.createTimeout(o, s));
            return n && n.forever && !i.length && i.push(this.createTimeout(o, s)),
                i.sort(function (l, a) {
                    return l - a
                }),
                i
        }
        ,
        t.createTimeout = function (n, s) {
            var r = s.randomize ? Math.random() + 1 : 1
                , i = Math.round(r * Math.max(s.minTimeout, 1) * Math.pow(s.factor, n));
            return i = Math.min(i, s.maxTimeout),
                i
        }
        ,
        t.wrap = function (n, s, r) {
            if (s instanceof Array && (r = s,
                s = null),
                !r) {
                r = [];
                for (var i in n)
                    typeof n[i] == "function" && r.push(i)
            }
            for (var o = 0; o < r.length; o++) {
                var l = r[o]
                    , a = n[l];
                n[l] = (function (u) {
                    var h = t.operation(s)
                        , d = Array.prototype.slice.call(arguments, 1)
                        , f = d.pop();
                    d.push(function (p) {
                        h.retry(p) || (p && (arguments[0] = h.mainError()),
                            f.apply(this, arguments))
                    }),
                        h.attempt(function () {
                            u.apply(n, d)
                        })
                }
                ).bind(n, a),
                    n[l].options = s
            }
        }
}
)(yk);
var q9 = yk;
const K9 = Fv(q9)
    , J9 = Object.prototype.toString
    , Z9 = t => J9.call(t) === "[object Error]"
    , Q9 = new Set(["network error", "Failed to fetch", "NetworkError when attempting to fetch resource.", "The Internet connection appears to be offline.", "Load failed", "Network request failed", "fetch failed", "terminated"]);
function eB(t) {
    return t && Z9(t) && t.name === "TypeError" && typeof t.message == "string" ? t.message === "Load failed" ? t.stack === void 0 : Q9.has(t.message) : !1
}
class tB extends Error {
    constructor(e) {
        super(),
            e instanceof Error ? (this.originalError = e,
                { message: e } = e) : (this.originalError = new Error(e),
                    this.originalError.stack = this.stack),
            this.name = "AbortError",
            this.message = e
    }
}
const XE = (t, e, n) => {
    const s = n.retries - (e - 1);
    return t.attemptNumber = e,
        t.retriesLeft = s,
        t
}
    ;
async function bk(t, e) {
    return new Promise((n, s) => {
        e = {
            ...e
        },
            e.onFailedAttempt ?? (e.onFailedAttempt = () => { }
            ),
            e.shouldRetry ?? (e.shouldRetry = () => !0),
            e.retries ?? (e.retries = 10);
        const r = K9.operation(e)
            , i = () => {
                var l;
                r.stop(),
                    s((l = e.signal) == null ? void 0 : l.reason)
            }
            ;
        e.signal && !e.signal.aborted && e.signal.addEventListener("abort", i, {
            once: !0
        });
        const o = () => {
            var l;
            (l = e.signal) == null || l.removeEventListener("abort", i),
                r.stop()
        }
            ;
        r.attempt(async l => {
            try {
                const a = await t(l);
                o(),
                    n(a)
            } catch (a) {
                try {
                    if (!(a instanceof Error))
                        throw new TypeError(`Non-error was thrown: "${a}". You should only throw errors.`);
                    if (a instanceof tB)
                        throw a.originalError;
                    if (a instanceof TypeError && !eB(a))
                        throw a;
                    if (XE(a, l, e),
                        await e.shouldRetry(a) || (r.stop(),
                            s(a)),
                        await e.onFailedAttempt(a),
                        !r.retry(a))
                        throw r.mainError()
                } catch (c) {
                    XE(c, l, e),
                        o(),
                        s(c)
                }
            }
        }
        )
    }
    )
}
const lt = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__
    , To = "8.42.0"
    , St = globalThis;
function zg(t, e, n) {
    const s = St
        , r = s.__SENTRY__ = s.__SENTRY__ || {}
        , i = r[To] = r[To] || {};
    return i[t] || (i[t] = e())
}
const el = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__
    , nB = "Sentry Logger "
    , ry = ["debug", "info", "warn", "error", "log", "assert", "trace"]
    , pm = {};
function pi(t) {
    if (!("console" in St))
        return t();
    const e = St.console
        , n = {}
        , s = Object.keys(pm);
    s.forEach(r => {
        const i = pm[r];
        n[r] = e[r],
            e[r] = i
    }
    );
    try {
        return t()
    } finally {
        s.forEach(r => {
            e[r] = n[r]
        }
        )
    }
}
function sB() {
    let t = !1;
    const e = {
        enable: () => {
            t = !0
        }
        ,
        disable: () => {
            t = !1
        }
        ,
        isEnabled: () => t
    };
    return el ? ry.forEach(n => {
        e[n] = (...s) => {
            t && pi(() => {
                St.console[n](`${nB}[${n}]:`, ...s)
            }
            )
        }
    }
    ) : ry.forEach(n => {
        e[n] = () => { }
    }
    ),
        e
}
const Re = zg("logger", sB)
    , vk = 50
    , Zl = "?"
    , jE = /\(error: (.*)\)/
    , zE = /captureMessage|captureException/;
function xk(...t) {
    const e = t.sort((n, s) => n[0] - s[0]).map(n => n[1]);
    return (n, s = 0, r = 0) => {
        const i = []
            , o = n.split(`
`);
        for (let l = s; l < o.length; l++) {
            const a = o[l];
            if (a.length > 1024)
                continue;
            const c = jE.test(a) ? a.replace(jE, "$1") : a;
            if (!c.match(/\S*Error: /)) {
                for (const u of e) {
                    const h = u(c);
                    if (h) {
                        i.push(h);
                        break
                    }
                }
                if (i.length >= vk + r)
                    break
            }
        }
        return iB(i.slice(r))
    }
}
function rB(t) {
    return Array.isArray(t) ? xk(...t) : t
}
function iB(t) {
    if (!t.length)
        return [];
    const e = Array.from(t);
    return /sentryWrapped/.test(Nf(e).function || "") && e.pop(),
        e.reverse(),
        zE.test(Nf(e).function || "") && (e.pop(),
            zE.test(Nf(e).function || "") && e.pop()),
        e.slice(0, vk).map(n => ({
            ...n,
            filename: n.filename || Nf(e).filename,
            function: n.function || Zl
        }))
}
function Nf(t) {
    return t[t.length - 1] || {}
}
const y0 = "<anonymous>";
function Ro(t) {
    try {
        return !t || typeof t != "function" ? y0 : t.name || y0
    } catch {
        return y0
    }
}
function qE(t) {
    const e = t.exception;
    if (e) {
        const n = [];
        try {
            return e.values.forEach(s => {
                s.stacktrace.frames && n.push(...s.stacktrace.frames)
            }
            ),
                n
        } catch {
            return
        }
    }
}
const Op = {}
    , KE = {};
function tl(t, e) {
    Op[t] = Op[t] || [],
        Op[t].push(e)
}
function nl(t, e) {
    if (!KE[t]) {
        KE[t] = !0;
        try {
            e()
        } catch (n) {
            el && Re.error(`Error while instrumenting ${t}`, n)
        }
    }
}
function Rr(t, e) {
    const n = t && Op[t];
    if (n)
        for (const s of n)
            try {
                s(e)
            } catch (r) {
                el && Re.error(`Error while triggering instrumentation handler.
Type: ${t}
Name: ${Ro(s)}
Error:`, r)
            }
}
let Df = null;
function wk(t) {
    const e = "error";
    tl(e, t),
        nl(e, oB)
}
function oB() {
    Df = St.onerror,
        St.onerror = function (t, e, n, s, r) {
            return Rr("error", {
                column: s,
                error: r,
                line: n,
                msg: t,
                url: e
            }),
                Df && !Df.__SENTRY_LOADER__ ? Df.apply(this, arguments) : !1
        }
        ,
        St.onerror.__SENTRY_INSTRUMENTED__ = !0
}
let Bf = null;
function Sk(t) {
    const e = "unhandledrejection";
    tl(e, t),
        nl(e, aB)
}
function aB() {
    Bf = St.onunhandledrejection,
        St.onunhandledrejection = function (t) {
            return Rr("unhandledrejection", t),
                Bf && !Bf.__SENTRY_LOADER__ ? Bf.apply(this, arguments) : !0
        }
        ,
        St.onunhandledrejection.__SENTRY_INSTRUMENTED__ = !0
}
function mc() {
    return $v(St),
        St
}
function $v(t) {
    const e = t.__SENTRY__ = t.__SENTRY__ || {};
    return e.version = e.version || To,
        e[To] = e[To] || {}
}
const Ek = Object.prototype.toString;
function Uv(t) {
    switch (Ek.call(t)) {
        case "[object Error]":
        case "[object Exception]":
        case "[object DOMException]":
        case "[object WebAssembly.Exception]":
            return !0;
        default:
            return Mo(t, Error)
    }
}
function eh(t, e) {
    return Ek.call(t) === `[object ${e}]`
}
function Tk(t) {
    return eh(t, "ErrorEvent")
}
function JE(t) {
    return eh(t, "DOMError")
}
function lB(t) {
    return eh(t, "DOMException")
}
function Co(t) {
    return eh(t, "String")
}
function Vv(t) {
    return typeof t == "object" && t !== null && "__sentry_template_string__" in t && "__sentry_template_values__" in t
}
function Gv(t) {
    return t === null || Vv(t) || typeof t != "object" && typeof t != "function"
}
function Mu(t) {
    return eh(t, "Object")
}
function qg(t) {
    return typeof Event < "u" && Mo(t, Event)
}
function cB(t) {
    return typeof Element < "u" && Mo(t, Element)
}
function uB(t) {
    return eh(t, "RegExp")
}
function Kg(t) {
    return !!(t && t.then && typeof t.then == "function")
}
function hB(t) {
    return Mu(t) && "nativeEvent" in t && "preventDefault" in t && "stopPropagation" in t
}
function Mo(t, e) {
    try {
        return t instanceof e
    } catch {
        return !1
    }
}
function Ck(t) {
    return !!(typeof t == "object" && t !== null && (t.__isVue || t._isVue))
}
const du = St
    , dB = 80;
function Po(t, e = {}) {
    if (!t)
        return "<unknown>";
    try {
        let n = t;
        const s = 5
            , r = [];
        let i = 0
            , o = 0;
        const l = " > "
            , a = l.length;
        let c;
        const u = Array.isArray(e) ? e : e.keyAttrs
            , h = !Array.isArray(e) && e.maxStringLength || dB;
        for (; n && i++ < s && (c = fB(n, u),
            !(c === "html" || i > 1 && o + r.length * a + c.length >= h));)
            r.push(c),
                o += c.length,
                n = n.parentNode;
        return r.reverse().join(l)
    } catch {
        return "<unknown>"
    }
}
function fB(t, e) {
    const n = t
        , s = [];
    if (!n || !n.tagName)
        return "";
    if (du.HTMLElement && n instanceof HTMLElement && n.dataset) {
        if (n.dataset.sentryComponent)
            return n.dataset.sentryComponent;
        if (n.dataset.sentryElement)
            return n.dataset.sentryElement
    }
    s.push(n.tagName.toLowerCase());
    const r = e && e.length ? e.filter(o => n.getAttribute(o)).map(o => [o, n.getAttribute(o)]) : null;
    if (r && r.length)
        r.forEach(o => {
            s.push(`[${o[0]}="${o[1]}"]`)
        }
        );
    else {
        n.id && s.push(`#${n.id}`);
        const o = n.className;
        if (o && Co(o)) {
            const l = o.split(/\s+/);
            for (const a of l)
                s.push(`.${a}`)
        }
    }
    const i = ["aria-label", "type", "name", "title", "alt"];
    for (const o of i) {
        const l = n.getAttribute(o);
        l && s.push(`[${o}="${l}"]`)
    }
    return s.join("")
}
function Ik() {
    try {
        return du.document.location.href
    } catch {
        return ""
    }
}
function pB(t) {
    return du.document && du.document.querySelector ? du.document.querySelector(t) : null
}
function Ak(t) {
    if (!du.HTMLElement)
        return null;
    let e = t;
    const n = 5;
    for (let s = 0; s < n; s++) {
        if (!e)
            return null;
        if (e instanceof HTMLElement) {
            if (e.dataset.sentryComponent)
                return e.dataset.sentryComponent;
            if (e.dataset.sentryElement)
                return e.dataset.sentryElement
        }
        e = e.parentNode
    }
    return null
}
function fu(t, e = 0) {
    return typeof t != "string" || e === 0 || t.length <= e ? t : `${t.slice(0, e)}...`
}
function ZE(t, e) {
    if (!Array.isArray(t))
        return "";
    const n = [];
    for (let s = 0; s < t.length; s++) {
        const r = t[s];
        try {
            Ck(r) ? n.push("[VueViewModel]") : n.push(String(r))
        } catch {
            n.push("[value cannot be serialized]")
        }
    }
    return n.join(e)
}
function mB(t, e, n = !1) {
    return Co(t) ? uB(e) ? e.test(t) : Co(e) ? n ? t === e : t.includes(e) : !1 : !1
}
function Ba(t, e = [], n = !1) {
    return e.some(s => mB(t, s, n))
}
function Ys(t, e, n) {
    if (!(e in t))
        return;
    const s = t[e]
        , r = n(s);
    typeof r == "function" && kk(r, s);
    try {
        t[e] = r
    } catch {
        el && Re.log(`Failed to replace method "${e}" in object`, t)
    }
}
function Pr(t, e, n) {
    try {
        Object.defineProperty(t, e, {
            value: n,
            writable: !0,
            configurable: !0
        })
    } catch {
        el && Re.log(`Failed to add non-enumerable property "${e}" to object`, t)
    }
}
function kk(t, e) {
    try {
        const n = e.prototype || {};
        t.prototype = e.prototype = n,
            Pr(t, "__sentry_original__", e)
    } catch { }
}
function Hv(t) {
    return t.__sentry_original__
}
function Rk(t) {
    if (Uv(t))
        return {
            message: t.message,
            name: t.name,
            stack: t.stack,
            ...eT(t)
        };
    if (qg(t)) {
        const e = {
            type: t.type,
            target: QE(t.target),
            currentTarget: QE(t.currentTarget),
            ...eT(t)
        };
        return typeof CustomEvent < "u" && Mo(t, CustomEvent) && (e.detail = t.detail),
            e
    } else
        return t
}
function QE(t) {
    try {
        return cB(t) ? Po(t) : Object.prototype.toString.call(t)
    } catch {
        return "<unknown>"
    }
}
function eT(t) {
    if (typeof t == "object" && t !== null) {
        const e = {};
        for (const n in t)
            Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
        return e
    } else
        return {}
}
function gB(t, e = 40) {
    const n = Object.keys(Rk(t));
    n.sort();
    const s = n[0];
    if (!s)
        return "[object has no keys]";
    if (s.length >= e)
        return fu(s, e);
    for (let r = n.length; r > 0; r--) {
        const i = n.slice(0, r).join(", ");
        if (!(i.length > e))
            return r === n.length ? i : fu(i, e)
    }
    return ""
}
function On(t) {
    return iy(t, new Map)
}
function iy(t, e) {
    if (_B(t)) {
        const n = e.get(t);
        if (n !== void 0)
            return n;
        const s = {};
        e.set(t, s);
        for (const r of Object.getOwnPropertyNames(t))
            typeof t[r] < "u" && (s[r] = iy(t[r], e));
        return s
    }
    if (Array.isArray(t)) {
        const n = e.get(t);
        if (n !== void 0)
            return n;
        const s = [];
        return e.set(t, s),
            t.forEach(r => {
                s.push(iy(r, e))
            }
            ),
            s
    }
    return t
}
function _B(t) {
    if (!Mu(t))
        return !1;
    try {
        const e = Object.getPrototypeOf(t).constructor.name;
        return !e || e === "Object"
    } catch {
        return !0
    }
}
const Mk = 1e3;
function rf() {
    return Date.now() / Mk
}
function yB() {
    const { performance: t } = St;
    if (!t || !t.now)
        return rf;
    const e = Date.now() - t.now()
        , n = t.timeOrigin == null ? e : t.timeOrigin;
    return () => (n + t.now()) / Mk
}
const ps = yB()
    , Ps = (() => {
        const { performance: t } = St;
        if (!t || !t.now)
            return;
        const e = 3600 * 1e3
            , n = t.now()
            , s = Date.now()
            , r = t.timeOrigin ? Math.abs(t.timeOrigin + n - s) : e
            , i = r < e
            , o = t.timing && t.timing.navigationStart
            , a = typeof o == "number" ? Math.abs(o + n - s) : e
            , c = a < e;
        return i || c ? r <= a ? t.timeOrigin : o : s
    }
    )();
function Nn() {
    const t = St
        , e = t.crypto || t.msCrypto;
    let n = () => Math.random() * 16;
    try {
        if (e && e.randomUUID)
            return e.randomUUID().replace(/-/g, "");
        e && e.getRandomValues && (n = () => {
            const s = new Uint8Array(1);
            return e.getRandomValues(s),
                s[0]
        }
        )
    } catch { }
    return ("10000000100040008000" + 1e11).replace(/[018]/g, s => (s ^ (n() & 15) >> s / 4).toString(16))
}
function Pk(t) {
    return t.exception && t.exception.values ? t.exception.values[0] : void 0
}
function ma(t) {
    const { message: e, event_id: n } = t;
    if (e)
        return e;
    const s = Pk(t);
    return s ? s.type && s.value ? `${s.type}: ${s.value}` : s.type || s.value || n || "<unknown>" : n || "<unknown>"
}
function oy(t, e, n) {
    const s = t.exception = t.exception || {}
        , r = s.values = s.values || []
        , i = r[0] = r[0] || {};
    i.value || (i.value = e || ""),
        i.type || (i.type = "Error")
}
function vd(t, e) {
    const n = Pk(t);
    if (!n)
        return;
    const s = {
        type: "generic",
        handled: !0
    }
        , r = n.mechanism;
    if (n.mechanism = {
        ...s,
        ...r,
        ...e
    },
        e && "data" in e) {
        const i = {
            ...r && r.data,
            ...e.data
        };
        n.mechanism.data = i
    }
}
function tT(t) {
    if (bB(t))
        return !0;
    try {
        Pr(t, "__sentry_captured__", !0)
    } catch { }
    return !1
}
function bB(t) {
    try {
        return t.__sentry_captured__
    } catch { }
}
var ho;
(function (t) {
    t[t.PENDING = 0] = "PENDING";
    const n = 1;
    t[t.RESOLVED = n] = "RESOLVED";
    const s = 2;
    t[t.REJECTED = s] = "REJECTED"
}
)(ho || (ho = {}));
function Lo(t) {
    return new xr(e => {
        e(t)
    }
    )
}
function mm(t) {
    return new xr((e, n) => {
        n(t)
    }
    )
}
class xr {
    constructor(e) {
        xr.prototype.__init.call(this),
            xr.prototype.__init2.call(this),
            xr.prototype.__init3.call(this),
            xr.prototype.__init4.call(this),
            this._state = ho.PENDING,
            this._handlers = [];
        try {
            e(this._resolve, this._reject)
        } catch (n) {
            this._reject(n)
        }
    }
    then(e, n) {
        return new xr((s, r) => {
            this._handlers.push([!1, i => {
                if (!e)
                    s(i);
                else
                    try {
                        s(e(i))
                    } catch (o) {
                        r(o)
                    }
            }
                , i => {
                    if (!n)
                        r(i);
                    else
                        try {
                            s(n(i))
                        } catch (o) {
                            r(o)
                        }
                }
            ]),
                this._executeHandlers()
        }
        )
    }
    catch(e) {
        return this.then(n => n, e)
    }
    finally(e) {
        return new xr((n, s) => {
            let r, i;
            return this.then(o => {
                i = !1,
                    r = o,
                    e && e()
            }
                , o => {
                    i = !0,
                        r = o,
                        e && e()
                }
            ).then(() => {
                if (i) {
                    s(r);
                    return
                }
                n(r)
            }
            )
        }
        )
    }
    __init() {
        this._resolve = e => {
            this._setResult(ho.RESOLVED, e)
        }
    }
    __init2() {
        this._reject = e => {
            this._setResult(ho.REJECTED, e)
        }
    }
    __init3() {
        this._setResult = (e, n) => {
            if (this._state === ho.PENDING) {
                if (Kg(n)) {
                    n.then(this._resolve, this._reject);
                    return
                }
                this._state = e,
                    this._value = n,
                    this._executeHandlers()
            }
        }
    }
    __init4() {
        this._executeHandlers = () => {
            if (this._state === ho.PENDING)
                return;
            const e = this._handlers.slice();
            this._handlers = [],
                e.forEach(n => {
                    n[0] || (this._state === ho.RESOLVED && n[1](this._value),
                        this._state === ho.REJECTED && n[2](this._value),
                        n[0] = !0)
                }
                )
        }
    }
}
function vB(t) {
    const e = ps()
        , n = {
            sid: Nn(),
            init: !0,
            timestamp: e,
            started: e,
            duration: 0,
            status: "ok",
            errors: 0,
            ignoreDuration: !1,
            toJSON: () => wB(n)
        };
    return t && Pu(n, t),
        n
}
function Pu(t, e = {}) {
    if (e.user && (!t.ipAddress && e.user.ip_address && (t.ipAddress = e.user.ip_address),
        !t.did && !e.did && (t.did = e.user.id || e.user.email || e.user.username)),
        t.timestamp = e.timestamp || ps(),
        e.abnormal_mechanism && (t.abnormal_mechanism = e.abnormal_mechanism),
        e.ignoreDuration && (t.ignoreDuration = e.ignoreDuration),
        e.sid && (t.sid = e.sid.length === 32 ? e.sid : Nn()),
        e.init !== void 0 && (t.init = e.init),
        !t.did && e.did && (t.did = `${e.did}`),
        typeof e.started == "number" && (t.started = e.started),
        t.ignoreDuration)
        t.duration = void 0;
    else if (typeof e.duration == "number")
        t.duration = e.duration;
    else {
        const n = t.timestamp - t.started;
        t.duration = n >= 0 ? n : 0
    }
    e.release && (t.release = e.release),
        e.environment && (t.environment = e.environment),
        !t.ipAddress && e.ipAddress && (t.ipAddress = e.ipAddress),
        !t.userAgent && e.userAgent && (t.userAgent = e.userAgent),
        typeof e.errors == "number" && (t.errors = e.errors),
        e.status && (t.status = e.status)
}
function xB(t, e) {
    let n = {};
    t.status === "ok" && (n = {
        status: "exited"
    }),
        Pu(t, n)
}
function wB(t) {
    return On({
        sid: `${t.sid}`,
        init: t.init,
        started: new Date(t.started * 1e3).toISOString(),
        timestamp: new Date(t.timestamp * 1e3).toISOString(),
        status: t.status,
        errors: t.errors,
        did: typeof t.did == "number" || typeof t.did == "string" ? `${t.did}` : void 0,
        duration: t.duration,
        abnormal_mechanism: t.abnormal_mechanism,
        attrs: {
            release: t.release,
            environment: t.environment,
            ip_address: t.ipAddress,
            user_agent: t.userAgent
        }
    })
}
function xd() {
    return Nn()
}
function gm() {
    return Nn().substring(16)
}
function Jg(t, e, n = 2) {
    if (!e || typeof e != "object" || n <= 0)
        return e;
    if (t && e && Object.keys(e).length === 0)
        return t;
    const s = {
        ...t
    };
    for (const r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (s[r] = Jg(s[r], e[r], n - 1));
    return s
}
const ay = "_sentrySpan";
function wd(t, e) {
    e ? Pr(t, ay, e) : delete t[ay]
}
function _m(t) {
    return t[ay]
}
const SB = 100;
class Wv {
    constructor() {
        this._notifyingListeners = !1,
            this._scopeListeners = [],
            this._eventProcessors = [],
            this._breadcrumbs = [],
            this._attachments = [],
            this._user = {},
            this._tags = {},
            this._extra = {},
            this._contexts = {},
            this._sdkProcessingMetadata = {},
            this._propagationContext = {
                traceId: xd(),
                spanId: gm()
            }
    }
    clone() {
        const e = new Wv;
        return e._breadcrumbs = [...this._breadcrumbs],
            e._tags = {
                ...this._tags
            },
            e._extra = {
                ...this._extra
            },
            e._contexts = {
                ...this._contexts
            },
            e._user = this._user,
            e._level = this._level,
            e._session = this._session,
            e._transactionName = this._transactionName,
            e._fingerprint = this._fingerprint,
            e._eventProcessors = [...this._eventProcessors],
            e._requestSession = this._requestSession,
            e._attachments = [...this._attachments],
            e._sdkProcessingMetadata = {
                ...this._sdkProcessingMetadata
            },
            e._propagationContext = {
                ...this._propagationContext
            },
            e._client = this._client,
            e._lastEventId = this._lastEventId,
            wd(e, _m(this)),
            e
    }
    setClient(e) {
        this._client = e
    }
    setLastEventId(e) {
        this._lastEventId = e
    }
    getClient() {
        return this._client
    }
    lastEventId() {
        return this._lastEventId
    }
    addScopeListener(e) {
        this._scopeListeners.push(e)
    }
    addEventProcessor(e) {
        return this._eventProcessors.push(e),
            this
    }
    setUser(e) {
        return this._user = e || {
            email: void 0,
            id: void 0,
            ip_address: void 0,
            username: void 0
        },
            this._session && Pu(this._session, {
                user: e
            }),
            this._notifyScopeListeners(),
            this
    }
    getUser() {
        return this._user
    }
    getRequestSession() {
        return this._requestSession
    }
    setRequestSession(e) {
        return this._requestSession = e,
            this
    }
    setTags(e) {
        return this._tags = {
            ...this._tags,
            ...e
        },
            this._notifyScopeListeners(),
            this
    }
    setTag(e, n) {
        return this._tags = {
            ...this._tags,
            [e]: n
        },
            this._notifyScopeListeners(),
            this
    }
    setExtras(e) {
        return this._extra = {
            ...this._extra,
            ...e
        },
            this._notifyScopeListeners(),
            this
    }
    setExtra(e, n) {
        return this._extra = {
            ...this._extra,
            [e]: n
        },
            this._notifyScopeListeners(),
            this
    }
    setFingerprint(e) {
        return this._fingerprint = e,
            this._notifyScopeListeners(),
            this
    }
    setLevel(e) {
        return this._level = e,
            this._notifyScopeListeners(),
            this
    }
    setTransactionName(e) {
        return this._transactionName = e,
            this._notifyScopeListeners(),
            this
    }
    setContext(e, n) {
        return n === null ? delete this._contexts[e] : this._contexts[e] = n,
            this._notifyScopeListeners(),
            this
    }
    setSession(e) {
        return e ? this._session = e : delete this._session,
            this._notifyScopeListeners(),
            this
    }
    getSession() {
        return this._session
    }
    update(e) {
        if (!e)
            return this;
        const n = typeof e == "function" ? e(this) : e
            , [s, r] = n instanceof Wa ? [n.getScopeData(), n.getRequestSession()] : Mu(n) ? [e, e.requestSession] : []
            , { tags: i, extra: o, user: l, contexts: a, level: c, fingerprint: u = [], propagationContext: h } = s || {};
        return this._tags = {
            ...this._tags,
            ...i
        },
            this._extra = {
                ...this._extra,
                ...o
            },
            this._contexts = {
                ...this._contexts,
                ...a
            },
            l && Object.keys(l).length && (this._user = l),
            c && (this._level = c),
            u.length && (this._fingerprint = u),
            h && (this._propagationContext = h),
            r && (this._requestSession = r),
            this
    }
    clear() {
        return this._breadcrumbs = [],
            this._tags = {},
            this._extra = {},
            this._user = {},
            this._contexts = {},
            this._level = void 0,
            this._transactionName = void 0,
            this._fingerprint = void 0,
            this._requestSession = void 0,
            this._session = void 0,
            wd(this, void 0),
            this._attachments = [],
            this.setPropagationContext({
                traceId: xd()
            }),
            this._notifyScopeListeners(),
            this
    }
    addBreadcrumb(e, n) {
        const s = typeof n == "number" ? n : SB;
        if (s <= 0)
            return this;
        const r = {
            timestamp: rf(),
            ...e
        }
            , i = this._breadcrumbs;
        return i.push(r),
            this._breadcrumbs = i.length > s ? i.slice(-s) : i,
            this._notifyScopeListeners(),
            this
    }
    getLastBreadcrumb() {
        return this._breadcrumbs[this._breadcrumbs.length - 1]
    }
    clearBreadcrumbs() {
        return this._breadcrumbs = [],
            this._notifyScopeListeners(),
            this
    }
    addAttachment(e) {
        return this._attachments.push(e),
            this
    }
    clearAttachments() {
        return this._attachments = [],
            this
    }
    getScopeData() {
        return {
            breadcrumbs: this._breadcrumbs,
            attachments: this._attachments,
            contexts: this._contexts,
            tags: this._tags,
            extra: this._extra,
            user: this._user,
            level: this._level,
            fingerprint: this._fingerprint || [],
            eventProcessors: this._eventProcessors,
            propagationContext: this._propagationContext,
            sdkProcessingMetadata: this._sdkProcessingMetadata,
            transactionName: this._transactionName,
            span: _m(this)
        }
    }
    setSDKProcessingMetadata(e) {
        return this._sdkProcessingMetadata = Jg(this._sdkProcessingMetadata, e, 2),
            this
    }
    setPropagationContext(e) {
        return this._propagationContext = {
            spanId: gm(),
            ...e
        },
            this
    }
    getPropagationContext() {
        return this._propagationContext
    }
    captureException(e, n) {
        const s = n && n.event_id ? n.event_id : Nn();
        if (!this._client)
            return Re.warn("No client configured on scope - will not capture exception!"),
                s;
        const r = new Error("Sentry syntheticException");
        return this._client.captureException(e, {
            originalException: e,
            syntheticException: r,
            ...n,
            event_id: s
        }, this),
            s
    }
    captureMessage(e, n, s) {
        const r = s && s.event_id ? s.event_id : Nn();
        if (!this._client)
            return Re.warn("No client configured on scope - will not capture message!"),
                r;
        const i = new Error(e);
        return this._client.captureMessage(e, n, {
            originalException: e,
            syntheticException: i,
            ...s,
            event_id: r
        }, this),
            r
    }
    captureEvent(e, n) {
        const s = n && n.event_id ? n.event_id : Nn();
        return this._client ? (this._client.captureEvent(e, {
            ...n,
            event_id: s
        }, this),
            s) : (Re.warn("No client configured on scope - will not capture event!"),
                s)
    }
    _notifyScopeListeners() {
        this._notifyingListeners || (this._notifyingListeners = !0,
            this._scopeListeners.forEach(e => {
                e(this)
            }
            ),
            this._notifyingListeners = !1)
    }
}
const Wa = Wv;
function EB() {
    return zg("defaultCurrentScope", () => new Wa)
}
function TB() {
    return zg("defaultIsolationScope", () => new Wa)
}
class CB {
    constructor(e, n) {
        let s;
        e ? s = e : s = new Wa;
        let r;
        n ? r = n : r = new Wa,
            this._stack = [{
                scope: s
            }],
            this._isolationScope = r
    }
    withScope(e) {
        const n = this._pushScope();
        let s;
        try {
            s = e(n)
        } catch (r) {
            throw this._popScope(),
            r
        }
        return Kg(s) ? s.then(r => (this._popScope(),
            r), r => {
                throw this._popScope(),
                r
            }
        ) : (this._popScope(),
            s)
    }
    getClient() {
        return this.getStackTop().client
    }
    getScope() {
        return this.getStackTop().scope
    }
    getIsolationScope() {
        return this._isolationScope
    }
    getStackTop() {
        return this._stack[this._stack.length - 1]
    }
    _pushScope() {
        const e = this.getScope().clone();
        return this._stack.push({
            client: this.getClient(),
            scope: e
        }),
            e
    }
    _popScope() {
        return this._stack.length <= 1 ? !1 : !!this._stack.pop()
    }
}
function Lu() {
    const t = mc()
        , e = $v(t);
    return e.stack = e.stack || new CB(EB(), TB())
}
function IB(t) {
    return Lu().withScope(t)
}
function AB(t, e) {
    const n = Lu();
    return n.withScope(() => (n.getStackTop().scope = t,
        e(t)))
}
function nT(t) {
    return Lu().withScope(() => t(Lu().getIsolationScope()))
}
function kB() {
    return {
        withIsolationScope: nT,
        withScope: IB,
        withSetScope: AB,
        withSetIsolationScope: (t, e) => nT(e),
        getCurrentScope: () => Lu().getScope(),
        getIsolationScope: () => Lu().getIsolationScope()
    }
}
function th(t) {
    const e = $v(t);
    return e.acs ? e.acs : kB()
}
function Ut() {
    const t = mc();
    return th(t).getCurrentScope()
}
function qi() {
    const t = mc();
    return th(t).getIsolationScope()
}
function RB() {
    return zg("globalScope", () => new Wa)
}
function Yv(...t) {
    const e = mc()
        , n = th(e);
    if (t.length === 2) {
        const [s, r] = t;
        return s ? n.withSetScope(s, r) : n.withScope(r)
    }
    return n.withScope(t[0])
}
function bt() {
    return Ut().getClient()
}
function MB(t) {
    const e = t.getPropagationContext()
        , { traceId: n, spanId: s, parentSpanId: r } = e;
    return On({
        trace_id: n,
        span_id: s,
        parent_span_id: r
    })
}
const PB = "_sentryMetrics";
function ly(t) {
    const e = t[PB];
    if (!e)
        return;
    const n = {};
    for (const [, [s, r]] of e)
        (n[s] || (n[s] = [])).push(On(r));
    return n
}
const or = "sentry.source"
    , Lk = "sentry.sample_rate"
    , Ql = "sentry.op"
    , an = "sentry.origin"
    , cy = "sentry.idle_span_finish_reason"
    , Zg = "sentry.measurement_unit"
    , Qg = "sentry.measurement_value"
    , LB = "sentry.profile_id"
    , Xv = "sentry.exclusive_time"
    , OB = 0
    , Ok = 1
    , Hn = 2;
function NB(t) {
    if (t < 400 && t >= 100)
        return {
            code: Ok
        };
    if (t >= 400 && t < 500)
        switch (t) {
            case 401:
                return {
                    code: Hn,
                    message: "unauthenticated"
                };
            case 403:
                return {
                    code: Hn,
                    message: "permission_denied"
                };
            case 404:
                return {
                    code: Hn,
                    message: "not_found"
                };
            case 409:
                return {
                    code: Hn,
                    message: "already_exists"
                };
            case 413:
                return {
                    code: Hn,
                    message: "failed_precondition"
                };
            case 429:
                return {
                    code: Hn,
                    message: "resource_exhausted"
                };
            case 499:
                return {
                    code: Hn,
                    message: "cancelled"
                };
            default:
                return {
                    code: Hn,
                    message: "invalid_argument"
                }
        }
    if (t >= 500 && t < 600)
        switch (t) {
            case 501:
                return {
                    code: Hn,
                    message: "unimplemented"
                };
            case 503:
                return {
                    code: Hn,
                    message: "unavailable"
                };
            case 504:
                return {
                    code: Hn,
                    message: "deadline_exceeded"
                };
            default:
                return {
                    code: Hn,
                    message: "internal_error"
                }
        }
    return {
        code: Hn,
        message: "unknown_error"
    }
}
function Nk(t, e) {
    t.setAttribute("http.response.status_code", e);
    const n = NB(e);
    n.message !== "unknown_error" && t.setStatus(n)
}
const jv = "sentry-"
    , DB = /^sentry-/
    , BB = 8192;
function Dk(t) {
    const e = $B(t);
    if (!e)
        return;
    const n = Object.entries(e).reduce((s, [r, i]) => {
        if (r.match(DB)) {
            const o = r.slice(jv.length);
            s[o] = i
        }
        return s
    }
        , {});
    if (Object.keys(n).length > 0)
        return n
}
function FB(t) {
    if (!t)
        return;
    const e = Object.entries(t).reduce((n, [s, r]) => (r && (n[`${jv}${s}`] = r),
        n), {});
    return UB(e)
}
function $B(t) {
    if (!(!t || !Co(t) && !Array.isArray(t)))
        return Array.isArray(t) ? t.reduce((e, n) => {
            const s = sT(n);
            return Object.entries(s).forEach(([r, i]) => {
                e[r] = i
            }
            ),
                e
        }
            , {}) : sT(t)
}
function sT(t) {
    return t.split(",").map(e => e.split("=").map(n => decodeURIComponent(n.trim()))).reduce((e, [n, s]) => (n && s && (e[n] = s),
        e), {})
}
function UB(t) {
    if (Object.keys(t).length !== 0)
        return Object.entries(t).reduce((e, [n, s], r) => {
            const i = `${encodeURIComponent(n)}=${encodeURIComponent(s)}`
                , o = r === 0 ? i : `${e},${i}`;
            return o.length > BB ? (el && Re.warn(`Not adding key: ${n} with val: ${s} to baggage header due to exceeding baggage size limits.`),
                e) : o
        }
            , "")
}
const Bk = new RegExp("^[ \\t]*([0-9a-f]{32})?-?([0-9a-f]{16})?-?([01])?[ \\t]*$");
function VB(t) {
    if (!t)
        return;
    const e = t.match(Bk);
    if (!e)
        return;
    let n;
    return e[3] === "1" ? n = !0 : e[3] === "0" && (n = !1),
    {
        traceId: e[1],
        parentSampled: n,
        parentSpanId: e[2]
    }
}
function GB(t, e) {
    const n = VB(t)
        , s = Dk(e);
    if (!n || !n.traceId)
        return {
            traceId: xd(),
            spanId: gm()
        };
    const { traceId: r, parentSpanId: i, parentSampled: o } = n
        , l = gm();
    return {
        traceId: r,
        parentSpanId: i,
        spanId: l,
        sampled: o,
        dsc: s || {}
    }
}
function Fk(t = Nn(), e = Nn().substring(16), n) {
    let s = "";
    return n !== void 0 && (s = n ? "-1" : "-0"),
        `${t}-${e}${s}`
}
const $k = 0
    , Uk = 1;
let rT = !1;
function HB(t) {
    const { spanId: e, traceId: n } = t.spanContext()
        , { data: s, op: r, parent_span_id: i, status: o, origin: l } = It(t);
    return On({
        parent_span_id: i,
        span_id: e,
        trace_id: n,
        data: s,
        op: r,
        status: o,
        origin: l
    })
}
function WB(t) {
    const { spanId: e, traceId: n } = t.spanContext()
        , { parent_span_id: s } = It(t);
    return On({
        parent_span_id: s,
        span_id: e,
        trace_id: n
    })
}
function YB(t) {
    const { traceId: e, spanId: n } = t.spanContext()
        , s = gc(t);
    return Fk(e, n, s)
}
function Vl(t) {
    return typeof t == "number" ? iT(t) : Array.isArray(t) ? t[0] + t[1] / 1e9 : t instanceof Date ? iT(t.getTime()) : ps()
}
function iT(t) {
    return t > 9999999999 ? t / 1e3 : t
}
function It(t) {
    if (jB(t))
        return t.getSpanJSON();
    try {
        const { spanId: e, traceId: n } = t.spanContext();
        if (XB(t)) {
            const { attributes: s, startTime: r, name: i, endTime: o, parentSpanId: l, status: a } = t;
            return On({
                span_id: e,
                trace_id: n,
                data: s,
                description: i,
                parent_span_id: l,
                start_timestamp: Vl(r),
                timestamp: Vl(o) || void 0,
                status: Vk(a),
                op: s[Ql],
                origin: s[an],
                _metrics_summary: ly(t)
            })
        }
        return {
            span_id: e,
            trace_id: n
        }
    } catch {
        return {}
    }
}
function XB(t) {
    const e = t;
    return !!e.attributes && !!e.startTime && !!e.name && !!e.endTime && !!e.status
}
function jB(t) {
    return typeof t.getSpanJSON == "function"
}
function gc(t) {
    const { traceFlags: e } = t.spanContext();
    return e === Uk
}
function Vk(t) {
    if (!(!t || t.code === OB))
        return t.code === Ok ? "ok" : t.message || "unknown_error"
}
const Gl = "_sentryChildSpans"
    , uy = "_sentryRootSpan";
function Gk(t, e) {
    const n = t[uy] || t;
    Pr(e, uy, n),
        t[Gl] ? t[Gl].add(e) : Pr(t, Gl, new Set([e]))
}
function zB(t, e) {
    t[Gl] && t[Gl].delete(e)
}
function Np(t) {
    const e = new Set;
    function n(s) {
        if (!e.has(s) && gc(s)) {
            e.add(s);
            const r = s[Gl] ? Array.from(s[Gl]) : [];
            for (const i of r)
                n(i)
        }
    }
    return n(t),
        Array.from(e)
}
function zn(t) {
    return t[uy] || t
}
function Cn() {
    const t = mc()
        , e = th(t);
    return e.getActiveSpan ? e.getActiveSpan() : _m(Ut())
}
function Hk() {
    rT || (pi(() => {
        console.warn("[Sentry] Deprecation warning: Returning null from `beforeSendSpan` will be disallowed from SDK version 9.0.0 onwards. The callback will only support mutating spans. To drop certain spans, configure the respective integrations directly.")
    }
    ),
        rT = !0)
}
let oT = !1;
function qB() {
    oT || (oT = !0,
        wk(hy),
        Sk(hy))
}
function hy() {
    const t = Cn()
        , e = t && zn(t);
    if (e) {
        const n = "internal_error";
        lt && Re.log(`[Tracing] Root span: ${n} -> Global error occurred`),
            e.setStatus({
                code: Hn,
                message: n
            })
    }
}
hy.tag = "sentry_tracingErrorCallback";
const Wk = "_sentryScope"
    , Yk = "_sentryIsolationScope";
function KB(t, e, n) {
    t && (Pr(t, Yk, n),
        Pr(t, Wk, e))
}
function aT(t) {
    return {
        scope: t[Wk],
        isolationScope: t[Yk]
    }
}
function Oo(t) {
    if (typeof __SENTRY_TRACING__ == "boolean" && !__SENTRY_TRACING__)
        return !1;
    const e = bt()
        , n = t || e && e.getOptions();
    return !!n && (n.enableTracing || "tracesSampleRate" in n || "tracesSampler" in n)
}
class nh {
    constructor(e = {}) {
        this._traceId = e.traceId || Nn(),
            this._spanId = e.spanId || Nn().substring(16)
    }
    spanContext() {
        return {
            spanId: this._spanId,
            traceId: this._traceId,
            traceFlags: $k
        }
    }
    end(e) { }
    setAttribute(e, n) {
        return this
    }
    setAttributes(e) {
        return this
    }
    setStatus(e) {
        return this
    }
    updateName(e) {
        return this
    }
    isRecording() {
        return !1
    }
    addEvent(e, n, s) {
        return this
    }
    addLink(e) {
        return this
    }
    addLinks(e) {
        return this
    }
    recordException(e, n) { }
}
const zv = "production"
    , Xk = "_frozenDsc";
function lT(t, e) {
    Pr(t, Xk, e)
}
function jk(t, e) {
    const n = e.getOptions()
        , { publicKey: s } = e.getDsn() || {}
        , r = On({
            environment: n.environment || zv,
            release: n.release,
            public_key: s,
            trace_id: t
        });
    return e.emit("createDsc", r),
        r
}
function zk(t, e) {
    const n = e.getPropagationContext();
    return n.dsc || jk(n.traceId, t)
}
function _c(t) {
    const e = bt();
    if (!e)
        return {};
    const n = zn(t)
        , s = n[Xk];
    if (s)
        return s;
    const r = n.spanContext().traceState
        , i = r && r.get("sentry.dsc")
        , o = i && Dk(i);
    if (o)
        return o;
    const l = jk(t.spanContext().traceId, e)
        , a = It(n)
        , c = a.data || {}
        , u = c[Lk];
    u != null && (l.sample_rate = `${u}`);
    const h = c[or]
        , d = a.description;
    return h !== "url" && d && (l.transaction = d),
        Oo() && (l.sampled = String(gc(n))),
        e.emit("createDsc", l, n),
        l
}
function JB(t) {
    if (!lt)
        return;
    const { description: e = "< unknown name >", op: n = "< unknown op >", parent_span_id: s } = It(t)
        , { spanId: r } = t.spanContext()
        , i = gc(t)
        , o = zn(t)
        , l = o === t
        , a = `[Tracing] Starting ${i ? "sampled" : "unsampled"} ${l ? "root " : ""}span`
        , c = [`op: ${n}`, `name: ${e}`, `ID: ${r}`];
    if (s && c.push(`parent ID: ${s}`),
        !l) {
        const { op: u, description: h } = It(o);
        c.push(`root ID: ${o.spanContext().spanId}`),
            u && c.push(`root op: ${u}`),
            h && c.push(`root description: ${h}`)
    }
    Re.log(`${a}
  ${c.join(`
  `)}`)
}
function ZB(t) {
    if (!lt)
        return;
    const { description: e = "< unknown name >", op: n = "< unknown op >" } = It(t)
        , { spanId: s } = t.spanContext()
        , i = zn(t) === t
        , o = `[Tracing] Finishing "${n}" ${i ? "root " : ""}span "${e}" with ID ${s}`;
    Re.log(o)
}
function ym(t) {
    if (typeof t == "boolean")
        return Number(t);
    const e = typeof t == "string" ? parseFloat(t) : t;
    if (typeof e != "number" || isNaN(e) || e < 0 || e > 1) {
        lt && Re.warn(`[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(t)} of type ${JSON.stringify(typeof t)}.`);
        return
    }
    return e
}
function QB(t, e) {
    if (!Oo(t))
        return [!1];
    let n;
    typeof t.tracesSampler == "function" ? n = t.tracesSampler(e) : e.parentSampled !== void 0 ? n = e.parentSampled : typeof t.tracesSampleRate < "u" ? n = t.tracesSampleRate : n = 1;
    const s = ym(n);
    return s === void 0 ? (lt && Re.warn("[Tracing] Discarding transaction because of invalid sample rate."),
        [!1]) : s ? Math.random() < s ? [!0, s] : (lt && Re.log(`[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(n)})`),
            [!1, s]) : (lt && Re.log(`[Tracing] Discarding transaction because ${typeof t.tracesSampler == "function" ? "tracesSampler returned 0 or false" : "a negative sampling decision was inherited or tracesSampleRate is set to 0"}`),
                [!1, s])
}
const e7 = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;
function t7(t) {
    return t === "http" || t === "https"
}
function of(t, e = !1) {
    const { host: n, path: s, pass: r, port: i, projectId: o, protocol: l, publicKey: a } = t;
    return `${l}://${a}${e && r ? `:${r}` : ""}@${n}${i ? `:${i}` : ""}/${s && `${s}/`}${o}`
}
function n7(t) {
    const e = e7.exec(t);
    if (!e) {
        pi(() => {
            console.error(`Invalid Sentry Dsn: ${t}`)
        }
        );
        return
    }
    const [n, s, r = "", i = "", o = "", l = ""] = e.slice(1);
    let a = ""
        , c = l;
    const u = c.split("/");
    if (u.length > 1 && (a = u.slice(0, -1).join("/"),
        c = u.pop()),
        c) {
        const h = c.match(/^\d+/);
        h && (c = h[0])
    }
    return qk({
        host: i,
        pass: r,
        path: a,
        projectId: c,
        port: o,
        protocol: n,
        publicKey: s
    })
}
function qk(t) {
    return {
        protocol: t.protocol,
        publicKey: t.publicKey || "",
        pass: t.pass || "",
        host: t.host,
        port: t.port || "",
        path: t.path || "",
        projectId: t.projectId
    }
}
function s7(t) {
    if (!el)
        return !0;
    const { port: e, projectId: n, protocol: s } = t;
    return ["protocol", "publicKey", "host", "projectId"].find(o => t[o] ? !1 : (Re.error(`Invalid Sentry Dsn: ${o} missing`),
        !0)) ? !1 : n.match(/^\d+$/) ? t7(s) ? e && isNaN(parseInt(e, 10)) ? (Re.error(`Invalid Sentry Dsn: Invalid port ${e}`),
            !1) : !0 : (Re.error(`Invalid Sentry Dsn: Invalid protocol ${s}`),
                !1) : (Re.error(`Invalid Sentry Dsn: Invalid projectId ${n}`),
                    !1)
}
function r7(t) {
    const e = typeof t == "string" ? n7(t) : qk(t);
    if (!(!e || !s7(e)))
        return e
}
function i7() {
    const t = typeof WeakSet == "function"
        , e = t ? new WeakSet : [];
    function n(r) {
        if (t)
            return e.has(r) ? !0 : (e.add(r),
                !1);
        for (let i = 0; i < e.length; i++)
            if (e[i] === r)
                return !0;
        return e.push(r),
            !1
    }
    function s(r) {
        if (t)
            e.delete(r);
        else
            for (let i = 0; i < e.length; i++)
                if (e[i] === r) {
                    e.splice(i, 1);
                    break
                }
    }
    return [n, s]
}
var cT = {};
function Li(t, e = 100, n = 1 / 0) {
    try {
        return dy("", t, e, n)
    } catch (s) {
        return {
            ERROR: `**non-serializable** (${s})`
        }
    }
}
function Kk(t, e = 3, n = 100 * 1024) {
    const s = Li(t, e);
    return c7(s) > n ? Kk(t, e - 1, n) : s
}
function dy(t, e, n = 1 / 0, s = 1 / 0, r = i7()) {
    const [i, o] = r;
    if (e == null || ["boolean", "string"].includes(typeof e) || typeof e == "number" && Number.isFinite(e))
        return e;
    const l = o7(t, e);
    if (!l.startsWith("[object "))
        return l;
    if (e.__sentry_skip_normalization__)
        return e;
    const a = typeof e.__sentry_override_normalization_depth__ == "number" ? e.__sentry_override_normalization_depth__ : n;
    if (a === 0)
        return l.replace("object ", "");
    if (i(e))
        return "[Circular ~]";
    const c = e;
    if (c && typeof c.toJSON == "function")
        try {
            const f = c.toJSON();
            return dy("", f, a - 1, s, r)
        } catch { }
    const u = Array.isArray(e) ? [] : {};
    let h = 0;
    const d = Rk(e);
    for (const f in d) {
        if (!Object.prototype.hasOwnProperty.call(d, f))
            continue;
        if (h >= s) {
            u[f] = "[MaxProperties ~]";
            break
        }
        const p = d[f];
        u[f] = dy(f, p, a - 1, s, r),
            h++
    }
    return o(e),
        u
}
function o7(t, e) {
    try {
        if (t === "domain" && e && typeof e == "object" && e._events)
            return "[Domain]";
        if (t === "domainEmitter")
            return "[DomainEmitter]";
        if (typeof cT < "u" && e === cT)
            return "[Global]";
        if (typeof window < "u" && e === window)
            return "[Window]";
        if (typeof document < "u" && e === document)
            return "[Document]";
        if (Ck(e))
            return "[VueViewModel]";
        if (hB(e))
            return "[SyntheticEvent]";
        if (typeof e == "number" && !Number.isFinite(e))
            return `[${e}]`;
        if (typeof e == "function")
            return `[Function: ${Ro(e)}]`;
        if (typeof e == "symbol")
            return `[${String(e)}]`;
        if (typeof e == "bigint")
            return `[BigInt: ${String(e)}]`;
        const n = a7(e);
        return /^HTML(\w*)Element$/.test(n) ? `[HTMLElement: ${n}]` : `[object ${n}]`
    } catch (n) {
        return `**non-serializable** (${n})`
    }
}
function a7(t) {
    const e = Object.getPrototypeOf(t);
    return e ? e.constructor.name : "null prototype"
}
function l7(t) {
    return ~-encodeURI(t).split(/%..|./).length
}
function c7(t) {
    return l7(JSON.stringify(t))
}
function yc(t, e = []) {
    return [t, e]
}
function u7(t, e) {
    const [n, s] = t;
    return [n, [...s, e]]
}
function uT(t, e) {
    const n = t[1];
    for (const s of n) {
        const r = s[0].type;
        if (e(s, r))
            return !0
    }
    return !1
}
function fy(t) {
    return St.__SENTRY__ && St.__SENTRY__.encodePolyfill ? St.__SENTRY__.encodePolyfill(t) : new TextEncoder().encode(t)
}
function h7(t) {
    const [e, n] = t;
    let s = JSON.stringify(e);
    function r(i) {
        typeof s == "string" ? s = typeof i == "string" ? s + i : [fy(s), i] : s.push(typeof i == "string" ? fy(i) : i)
    }
    for (const i of n) {
        const [o, l] = i;
        if (r(`
${JSON.stringify(o)}
`),
            typeof l == "string" || l instanceof Uint8Array)
            r(l);
        else {
            let a;
            try {
                a = JSON.stringify(l)
            } catch {
                a = JSON.stringify(Li(l))
            }
            r(a)
        }
    }
    return typeof s == "string" ? s : d7(s)
}
function d7(t) {
    const e = t.reduce((r, i) => r + i.length, 0)
        , n = new Uint8Array(e);
    let s = 0;
    for (const r of t)
        n.set(r, s),
            s += r.length;
    return n
}
function f7(t) {
    return [{
        type: "span"
    }, t]
}
function p7(t) {
    const e = typeof t.data == "string" ? fy(t.data) : t.data;
    return [On({
        type: "attachment",
        length: e.length,
        filename: t.filename,
        content_type: t.contentType,
        attachment_type: t.attachmentType
    }), e]
}
const m7 = {
    session: "session",
    sessions: "session",
    attachment: "attachment",
    transaction: "transaction",
    event: "error",
    client_report: "internal",
    user_report: "default",
    profile: "profile",
    profile_chunk: "profile",
    replay_event: "replay",
    replay_recording: "replay",
    check_in: "monitor",
    feedback: "feedback",
    span: "span",
    statsd: "metric_bucket"
};
function hT(t) {
    return m7[t]
}
function qv(t) {
    if (!t || !t.sdk)
        return;
    const { name: e, version: n } = t.sdk;
    return {
        name: e,
        version: n
    }
}
function Jk(t, e, n, s) {
    const r = t.sdkProcessingMetadata && t.sdkProcessingMetadata.dynamicSamplingContext;
    return {
        event_id: t.event_id,
        sent_at: new Date().toISOString(),
        ...e && {
            sdk: e
        },
        ...!!n && s && {
            dsn: of(s)
        },
        ...r && {
            trace: On({
                ...r
            })
        }
    }
}
function g7(t, e) {
    return e && (t.sdk = t.sdk || {},
        t.sdk.name = t.sdk.name || e.name,
        t.sdk.version = t.sdk.version || e.version,
        t.sdk.integrations = [...t.sdk.integrations || [], ...e.integrations || []],
        t.sdk.packages = [...t.sdk.packages || [], ...e.packages || []]),
        t
}
function _7(t, e, n, s) {
    const r = qv(n)
        , i = {
            sent_at: new Date().toISOString(),
            ...r && {
                sdk: r
            },
            ...!!s && e && {
                dsn: of(e)
            }
        }
        , o = "aggregates" in t ? [{
            type: "sessions"
        }, t] : [{
            type: "session"
        }, t.toJSON()];
    return yc(i, [o])
}
function y7(t, e, n, s) {
    const r = qv(n)
        , i = t.type && t.type !== "replay_event" ? t.type : "event";
    g7(t, n && n.sdk);
    const o = Jk(t, r, s, e);
    return delete t.sdkProcessingMetadata,
        yc(o, [[{
            type: i
        }, t]])
}
function b7(t, e) {
    function n(u) {
        return !!u.trace_id && !!u.public_key
    }
    const s = _c(t[0])
        , r = e && e.getDsn()
        , i = e && e.getOptions().tunnel
        , o = {
            sent_at: new Date().toISOString(),
            ...n(s) && {
                trace: s
            },
            ...!!i && r && {
                dsn: of(r)
            }
        }
        , l = e && e.getOptions().beforeSendSpan
        , a = l ? u => {
            const h = l(It(u));
            return h || Hk(),
                h
        }
            : u => It(u)
        , c = [];
    for (const u of t) {
        const h = a(u);
        h && c.push(f7(h))
    }
    return yc(o, c)
}
function v7(t, e, n, s = Cn()) {
    const r = s && zn(s);
    r && (lt && Re.log(`[Measurement] Setting measurement on root span: ${t} = ${e} ${n}`),
        r.addEvent(t, {
            [Qg]: e,
            [Zg]: n
        }))
}
function dT(t) {
    if (!t || t.length === 0)
        return;
    const e = {};
    return t.forEach(n => {
        const s = n.attributes || {}
            , r = s[Zg]
            , i = s[Qg];
        typeof r == "string" && typeof i == "number" && (e[n.name] = {
            value: i,
            unit: r
        })
    }
    ),
        e
}
const fT = 1e3;
class Kv {
    constructor(e = {}) {
        this._traceId = e.traceId || Nn(),
            this._spanId = e.spanId || Nn().substring(16),
            this._startTime = e.startTimestamp || ps(),
            this._attributes = {},
            this.setAttributes({
                [an]: "manual",
                [Ql]: e.op,
                ...e.attributes
            }),
            this._name = e.name,
            e.parentSpanId && (this._parentSpanId = e.parentSpanId),
            "sampled" in e && (this._sampled = e.sampled),
            e.endTimestamp && (this._endTime = e.endTimestamp),
            this._events = [],
            this._isStandaloneSpan = e.isStandalone,
            this._endTime && this._onSpanEnded()
    }
    addLink(e) {
        return this
    }
    addLinks(e) {
        return this
    }
    recordException(e, n) { }
    spanContext() {
        const { _spanId: e, _traceId: n, _sampled: s } = this;
        return {
            spanId: e,
            traceId: n,
            traceFlags: s ? Uk : $k
        }
    }
    setAttribute(e, n) {
        return n === void 0 ? delete this._attributes[e] : this._attributes[e] = n,
            this
    }
    setAttributes(e) {
        return Object.keys(e).forEach(n => this.setAttribute(n, e[n])),
            this
    }
    updateStartTime(e) {
        this._startTime = Vl(e)
    }
    setStatus(e) {
        return this._status = e,
            this
    }
    updateName(e) {
        return this._name = e,
            this.setAttribute(or, "custom"),
            this
    }
    end(e) {
        this._endTime || (this._endTime = Vl(e),
            ZB(this),
            this._onSpanEnded())
    }
    getSpanJSON() {
        return On({
            data: this._attributes,
            description: this._name,
            op: this._attributes[Ql],
            parent_span_id: this._parentSpanId,
            span_id: this._spanId,
            start_timestamp: this._startTime,
            status: Vk(this._status),
            timestamp: this._endTime,
            trace_id: this._traceId,
            origin: this._attributes[an],
            _metrics_summary: ly(this),
            profile_id: this._attributes[LB],
            exclusive_time: this._attributes[Xv],
            measurements: dT(this._events),
            is_segment: this._isStandaloneSpan && zn(this) === this || void 0,
            segment_id: this._isStandaloneSpan ? zn(this).spanContext().spanId : void 0
        })
    }
    isRecording() {
        return !this._endTime && !!this._sampled
    }
    addEvent(e, n, s) {
        lt && Re.log("[Tracing] Adding an event to span:", e);
        const r = pT(n) ? n : s || ps()
            , i = pT(n) ? {} : n || {}
            , o = {
                name: e,
                time: Vl(r),
                attributes: i
            };
        return this._events.push(o),
            this
    }
    isStandaloneSpan() {
        return !!this._isStandaloneSpan
    }
    _onSpanEnded() {
        const e = bt();
        if (e && e.emit("spanEnd", this),
            !(this._isStandaloneSpan || this === zn(this)))
            return;
        if (this._isStandaloneSpan) {
            this._sampled ? w7(b7([this], e)) : (lt && Re.log("[Tracing] Discarding standalone span because its trace was not chosen to be sampled."),
                e && e.recordDroppedEvent("sample_rate", "span"));
            return
        }
        const s = this._convertSpanToTransaction();
        s && (aT(this).scope || Ut()).captureEvent(s)
    }
    _convertSpanToTransaction() {
        if (!mT(It(this)))
            return;
        this._name || (lt && Re.warn("Transaction has no name, falling back to `<unlabeled transaction>`."),
            this._name = "<unlabeled transaction>");
        const { scope: e, isolationScope: n } = aT(this)
            , r = (e || Ut()).getClient() || bt();
        if (this._sampled !== !0) {
            lt && Re.log("[Tracing] Discarding transaction because its trace was not chosen to be sampled."),
                r && r.recordDroppedEvent("sample_rate", "transaction");
            return
        }
        const o = Np(this).filter(h => h !== this && !x7(h)).map(h => It(h)).filter(mT)
            , l = this._attributes[or]
            , a = {
                contexts: {
                    trace: HB(this)
                },
                spans: o.length > fT ? o.sort((h, d) => h.start_timestamp - d.start_timestamp).slice(0, fT) : o,
                start_timestamp: this._startTime,
                timestamp: this._endTime,
                transaction: this._name,
                type: "transaction",
                sdkProcessingMetadata: {
                    capturedSpanScope: e,
                    capturedSpanIsolationScope: n,
                    ...On({
                        dynamicSamplingContext: _c(this)
                    })
                },
                _metrics_summary: ly(this),
                ...l && {
                    transaction_info: {
                        source: l
                    }
                }
            }
            , c = dT(this._events);
        return c && Object.keys(c).length && (lt && Re.log("[Measurements] Adding measurements to transaction event", JSON.stringify(c, void 0, 2)),
            a.measurements = c),
            a
    }
}
function pT(t) {
    return t && typeof t == "number" || t instanceof Date || Array.isArray(t)
}
function mT(t) {
    return !!t.start_timestamp && !!t.timestamp && !!t.span_id && !!t.trace_id
}
function x7(t) {
    return t instanceof Kv && t.isStandaloneSpan()
}
function w7(t) {
    const e = bt();
    if (!e)
        return;
    const n = t[1];
    if (!n || n.length === 0) {
        e.recordDroppedEvent("before_send", "span");
        return
    }
    e.sendEnvelope(t)
}
const Zk = "__SENTRY_SUPPRESS_TRACING__";
function ec(t) {
    const e = eR();
    if (e.startInactiveSpan)
        return e.startInactiveSpan(t);
    const n = E7(t)
        , { forceTransaction: s, parentSpan: r } = t;
    return (t.scope ? o => Yv(t.scope, o) : r !== void 0 ? o => Qk(r, o) : o => o())(() => {
        const o = Ut()
            , l = C7(o);
        return t.onlyIfParent && !l ? new nh : S7({
            parentSpan: l,
            spanArguments: n,
            forceTransaction: s,
            scope: o
        })
    }
    )
}
function Qk(t, e) {
    const n = eR();
    return n.withActiveSpan ? n.withActiveSpan(t, e) : Yv(s => (wd(s, t || void 0),
        e(s)))
}
function S7({ parentSpan: t, spanArguments: e, forceTransaction: n, scope: s }) {
    if (!Oo())
        return new nh;
    const r = qi();
    let i;
    if (t && !n)
        i = T7(t, s, e),
            Gk(t, i);
    else if (t) {
        const o = _c(t)
            , { traceId: l, spanId: a } = t.spanContext()
            , c = gc(t);
        i = gT({
            traceId: l,
            parentSpanId: a,
            ...e
        }, s, c),
            lT(i, o)
    } else {
        const { traceId: o, dsc: l, parentSpanId: a, sampled: c } = {
            ...r.getPropagationContext(),
            ...s.getPropagationContext()
        };
        i = gT({
            traceId: o,
            parentSpanId: a,
            ...e
        }, s, c),
            l && lT(i, l)
    }
    return JB(i),
        KB(i, s, r),
        i
}
function E7(t) {
    const n = {
        isStandalone: (t.experimental || {}).standalone,
        ...t
    };
    if (t.startTime) {
        const s = {
            ...n
        };
        return s.startTimestamp = Vl(t.startTime),
            delete s.startTime,
            s
    }
    return n
}
function eR() {
    const t = mc();
    return th(t)
}
function gT(t, e, n) {
    const s = bt()
        , r = s && s.getOptions() || {}
        , { name: i = "", attributes: o } = t
        , [l, a] = e.getScopeData().sdkProcessingMetadata[Zk] ? [!1] : QB(r, {
            name: i,
            parentSampled: n,
            attributes: o,
            transactionContext: {
                name: i,
                parentSampled: n
            }
        })
        , c = new Kv({
            ...t,
            attributes: {
                [or]: "custom",
                ...t.attributes
            },
            sampled: l
        });
    return a !== void 0 && c.setAttribute(Lk, a),
        s && s.emit("spanStart", c),
        c
}
function T7(t, e, n) {
    const { spanId: s, traceId: r } = t.spanContext()
        , i = e.getScopeData().sdkProcessingMetadata[Zk] ? !1 : gc(t)
        , o = i ? new Kv({
            ...n,
            parentSpanId: s,
            traceId: r,
            sampled: i
        }) : new nh({
            traceId: r
        });
    Gk(t, o);
    const l = bt();
    return l && (l.emit("spanStart", o),
        n.endTimestamp && l.emit("spanEnd", o)),
        o
}
function C7(t) {
    const e = _m(t);
    if (!e)
        return;
    const n = bt();
    return (n ? n.getOptions() : {}).parentSpanIsAlwaysRootSpan ? zn(e) : e
}
const Dp = {
    idleTimeout: 1e3,
    finalTimeout: 3e4,
    childSpanTimeout: 15e3
}
    , I7 = "heartbeatFailed"
    , A7 = "idleTimeout"
    , k7 = "finalTimeout"
    , R7 = "externalFinish";
function tR(t, e = {}) {
    const n = new Map;
    let s = !1, r, i = R7, o = !e.disableAutoFinish;
    const l = []
        , { idleTimeout: a = Dp.idleTimeout, finalTimeout: c = Dp.finalTimeout, childSpanTimeout: u = Dp.childSpanTimeout, beforeSpanEnd: h } = e
        , d = bt();
    if (!d || !Oo())
        return new nh;
    const f = Ut()
        , p = Cn()
        , m = M7(t);
    m.end = new Proxy(m.end, {
        apply(w, S, E) {
            h && h(m);
            const [C, ...I] = E
                , L = C || ps()
                , k = Vl(L)
                , R = Np(m).filter(z => z !== m);
            if (!R.length)
                return x(k),
                    Reflect.apply(w, S, [k, ...I]);
            const U = R.map(z => It(z).timestamp).filter(z => !!z)
                , W = U.length ? Math.max(...U) : void 0
                , H = It(m).start_timestamp
                , j = Math.min(H ? H + c / 1e3 : 1 / 0, Math.max(H || -1 / 0, Math.min(k, W || 1 / 0)));
            return x(j),
                Reflect.apply(w, S, [j, ...I])
        }
    });
    function g() {
        r && (clearTimeout(r),
            r = void 0)
    }
    function b(w) {
        g(),
            r = setTimeout(() => {
                !s && n.size === 0 && o && (i = A7,
                    m.end(w))
            }
                , a)
    }
    function v(w) {
        r = setTimeout(() => {
            !s && o && (i = I7,
                m.end(w))
        }
            , u)
    }
    function _(w) {
        g(),
            n.set(w, !0);
        const S = ps();
        v(S + u / 1e3)
    }
    function y(w) {
        if (n.has(w) && n.delete(w),
            n.size === 0) {
            const S = ps();
            b(S + a / 1e3)
        }
    }
    function x(w) {
        s = !0,
            n.clear(),
            l.forEach(k => k()),
            wd(f, p);
        const S = It(m)
            , { start_timestamp: E } = S;
        if (!E)
            return;
        (S.data || {})[cy] || m.setAttribute(cy, i),
            Re.log(`[Tracing] Idle span "${S.op}" finished`);
        const I = Np(m).filter(k => k !== m);
        let L = 0;
        I.forEach(k => {
            k.isRecording() && (k.setStatus({
                code: Hn,
                message: "cancelled"
            }),
                k.end(w),
                lt && Re.log("[Tracing] Cancelling span since span ended early", JSON.stringify(k, void 0, 2)));
            const R = It(k)
                , { timestamp: U = 0, start_timestamp: W = 0 } = R
                , H = W <= w
                , j = (c + a) / 1e3
                , z = U - W <= j;
            if (lt) {
                const ee = JSON.stringify(k, void 0, 2);
                H ? z || Re.log("[Tracing] Discarding span since it finished after idle span final timeout", ee) : Re.log("[Tracing] Discarding span since it happened after idle span was finished", ee)
            }
            (!z || !H) && (zB(m, k),
                L++)
        }
        ),
            L > 0 && m.setAttribute("sentry.idle_span_discarded_spans", L)
    }
    return l.push(d.on("spanStart", w => {
        if (s || w === m || It(w).timestamp)
            return;
        Np(m).includes(w) && _(w.spanContext().spanId)
    }
    )),
        l.push(d.on("spanEnd", w => {
            s || y(w.spanContext().spanId)
        }
        )),
        l.push(d.on("idleSpanEnableAutoFinish", w => {
            w === m && (o = !0,
                b(),
                n.size && v())
        }
        )),
        e.disableAutoFinish || b(),
        setTimeout(() => {
            s || (m.setStatus({
                code: Hn,
                message: "deadline_exceeded"
            }),
                i = k7,
                m.end())
        }
            , c),
        m
}
function M7(t) {
    const e = ec(t);
    return wd(Ut(), e),
        lt && Re.log("[Tracing] Started span is an idle span"),
        e
}
function py(t, e, n, s = 0) {
    return new xr((r, i) => {
        const o = t[s];
        if (e === null || typeof o != "function")
            r(e);
        else {
            const l = o({
                ...e
            }, n);
            lt && o.id && l === null && Re.log(`Event processor "${o.id}" dropped event`),
                Kg(l) ? l.then(a => py(t, a, n, s + 1).then(r)).then(null, i) : py(t, l, n, s + 1).then(r).then(null, i)
        }
    }
    )
}
let Ff, _T, $f;
function P7(t) {
    const e = St._sentryDebugIds;
    if (!e)
        return {};
    const n = Object.keys(e);
    return $f && n.length === _T || (_T = n.length,
        $f = n.reduce((s, r) => {
            Ff || (Ff = {});
            const i = Ff[r];
            if (i)
                s[i[0]] = i[1];
            else {
                const o = t(r);
                for (let l = o.length - 1; l >= 0; l--) {
                    const a = o[l]
                        , c = a && a.filename
                        , u = e[r];
                    if (c && u) {
                        s[c] = u,
                            Ff[r] = [c, u];
                        break
                    }
                }
            }
            return s
        }
            , {})),
        $f
}
function L7(t, e) {
    const { fingerprint: n, span: s, breadcrumbs: r, sdkProcessingMetadata: i } = e;
    O7(t, e),
        s && B7(t, s),
        F7(t, n),
        N7(t, r),
        D7(t, i)
}
function yT(t, e) {
    const { extra: n, tags: s, user: r, contexts: i, level: o, sdkProcessingMetadata: l, breadcrumbs: a, fingerprint: c, eventProcessors: u, attachments: h, propagationContext: d, transactionName: f, span: p } = e;
    Uf(t, "extra", n),
        Uf(t, "tags", s),
        Uf(t, "user", r),
        Uf(t, "contexts", i),
        t.sdkProcessingMetadata = Jg(t.sdkProcessingMetadata, l, 2),
        o && (t.level = o),
        f && (t.transactionName = f),
        p && (t.span = p),
        a.length && (t.breadcrumbs = [...t.breadcrumbs, ...a]),
        c.length && (t.fingerprint = [...t.fingerprint, ...c]),
        u.length && (t.eventProcessors = [...t.eventProcessors, ...u]),
        h.length && (t.attachments = [...t.attachments, ...h]),
        t.propagationContext = {
            ...t.propagationContext,
            ...d
        }
}
function Uf(t, e, n) {
    t[e] = Jg(t[e], n, 1)
}
function O7(t, e) {
    const { extra: n, tags: s, user: r, contexts: i, level: o, transactionName: l } = e
        , a = On(n);
    a && Object.keys(a).length && (t.extra = {
        ...a,
        ...t.extra
    });
    const c = On(s);
    c && Object.keys(c).length && (t.tags = {
        ...c,
        ...t.tags
    });
    const u = On(r);
    u && Object.keys(u).length && (t.user = {
        ...u,
        ...t.user
    });
    const h = On(i);
    h && Object.keys(h).length && (t.contexts = {
        ...h,
        ...t.contexts
    }),
        o && (t.level = o),
        l && t.type !== "transaction" && (t.transaction = l)
}
function N7(t, e) {
    const n = [...t.breadcrumbs || [], ...e];
    t.breadcrumbs = n.length ? n : void 0
}
function D7(t, e) {
    t.sdkProcessingMetadata = {
        ...t.sdkProcessingMetadata,
        ...e
    }
}
function B7(t, e) {
    t.contexts = {
        trace: WB(e),
        ...t.contexts
    },
        t.sdkProcessingMetadata = {
            dynamicSamplingContext: _c(e),
            ...t.sdkProcessingMetadata
        };
    const n = zn(e)
        , s = It(n).description;
    s && !t.transaction && t.type === "transaction" && (t.transaction = s)
}
function F7(t, e) {
    t.fingerprint = t.fingerprint ? Array.isArray(t.fingerprint) ? t.fingerprint : [t.fingerprint] : [],
        e && (t.fingerprint = t.fingerprint.concat(e)),
        t.fingerprint && !t.fingerprint.length && delete t.fingerprint
}
function nR(t, e, n, s, r, i) {
    const { normalizeDepth: o = 3, normalizeMaxBreadth: l = 1e3 } = t
        , a = {
            ...e,
            event_id: e.event_id || n.event_id || Nn(),
            timestamp: e.timestamp || rf()
        }
        , c = n.integrations || t.integrations.map(g => g.name);
    $7(a, t),
        G7(a, c),
        r && r.emit("applyFrameMetadata", e),
        e.type === void 0 && U7(a, t.stackParser);
    const u = W7(s, n.captureContext);
    n.mechanism && vd(a, n.mechanism);
    const h = r ? r.getEventProcessors() : []
        , d = RB().getScopeData();
    if (i) {
        const g = i.getScopeData();
        yT(d, g)
    }
    if (u) {
        const g = u.getScopeData();
        yT(d, g)
    }
    const f = [...n.attachments || [], ...d.attachments];
    f.length && (n.attachments = f),
        L7(a, d);
    const p = [...h, ...d.eventProcessors];
    return py(p, a, n).then(g => (g && V7(g),
        typeof o == "number" && o > 0 ? H7(g, o, l) : g))
}
function $7(t, e) {
    const { environment: n, release: s, dist: r, maxValueLength: i = 250 } = e;
    t.environment = t.environment || n || zv,
        !t.release && s && (t.release = s),
        !t.dist && r && (t.dist = r),
        t.message && (t.message = fu(t.message, i));
    const o = t.exception && t.exception.values && t.exception.values[0];
    o && o.value && (o.value = fu(o.value, i));
    const l = t.request;
    l && l.url && (l.url = fu(l.url, i))
}
function U7(t, e) {
    const n = P7(e);
    try {
        t.exception.values.forEach(s => {
            s.stacktrace.frames.forEach(r => {
                n && r.filename && (r.debug_id = n[r.filename])
            }
            )
        }
        )
    } catch { }
}
function V7(t) {
    const e = {};
    try {
        t.exception.values.forEach(s => {
            s.stacktrace.frames.forEach(r => {
                r.debug_id && (r.abs_path ? e[r.abs_path] = r.debug_id : r.filename && (e[r.filename] = r.debug_id),
                    delete r.debug_id)
            }
            )
        }
        )
    } catch { }
    if (Object.keys(e).length === 0)
        return;
    t.debug_meta = t.debug_meta || {},
        t.debug_meta.images = t.debug_meta.images || [];
    const n = t.debug_meta.images;
    Object.entries(e).forEach(([s, r]) => {
        n.push({
            type: "sourcemap",
            code_file: s,
            debug_id: r
        })
    }
    )
}
function G7(t, e) {
    e.length > 0 && (t.sdk = t.sdk || {},
        t.sdk.integrations = [...t.sdk.integrations || [], ...e])
}
function H7(t, e, n) {
    if (!t)
        return null;
    const s = {
        ...t,
        ...t.breadcrumbs && {
            breadcrumbs: t.breadcrumbs.map(r => ({
                ...r,
                ...r.data && {
                    data: Li(r.data, e, n)
                }
            }))
        },
        ...t.user && {
            user: Li(t.user, e, n)
        },
        ...t.contexts && {
            contexts: Li(t.contexts, e, n)
        },
        ...t.extra && {
            extra: Li(t.extra, e, n)
        }
    };
    return t.contexts && t.contexts.trace && s.contexts && (s.contexts.trace = t.contexts.trace,
        t.contexts.trace.data && (s.contexts.trace.data = Li(t.contexts.trace.data, e, n))),
        t.spans && (s.spans = t.spans.map(r => ({
            ...r,
            ...r.data && {
                data: Li(r.data, e, n)
            }
        }))),
        s
}
function W7(t, e) {
    if (!e)
        return t;
    const n = t ? t.clone() : new Wa;
    return n.update(e),
        n
}
function Y7(t) {
    if (t)
        return X7(t) ? {
            captureContext: t
        } : z7(t) ? {
            captureContext: t
        } : t
}
function X7(t) {
    return t instanceof Wa || typeof t == "function"
}
const j7 = ["user", "level", "extra", "contexts", "tags", "fingerprint", "requestSession", "propagationContext"];
function z7(t) {
    return Object.keys(t).some(e => j7.includes(e))
}
function No(t, e) {
    return Ut().captureException(t, Y7(e))
}
function sR(t, e) {
    return Ut().captureEvent(t, e)
}
function q7(t, e) {
    qi().setContext(t, e)
}
function K7() {
    const t = bt();
    return !!t && t.getOptions().enabled !== !1 && !!t.getTransport()
}
function J7(t) {
    qi().addEventProcessor(t)
}
function bT(t) {
    const e = bt()
        , n = qi()
        , s = Ut()
        , { release: r, environment: i = zv } = e && e.getOptions() || {}
        , { userAgent: o } = St.navigator || {}
        , l = vB({
            release: r,
            environment: i,
            user: s.getUser() || n.getUser(),
            ...o && {
                userAgent: o
            },
            ...t
        })
        , a = n.getSession();
    return a && a.status === "ok" && Pu(a, {
        status: "exited"
    }),
        rR(),
        n.setSession(l),
        s.setSession(l),
        l
}
function rR() {
    const t = qi()
        , e = Ut()
        , n = e.getSession() || t.getSession();
    n && xB(n),
        iR(),
        t.setSession(),
        e.setSession()
}
function iR() {
    const t = qi()
        , e = Ut()
        , n = bt()
        , s = e.getSession() || t.getSession();
    s && n && n.captureSession(s)
}
function vT(t = !1) {
    if (t) {
        rR();
        return
    }
    iR()
}
const Z7 = "7";
function Q7(t) {
    const e = t.protocol ? `${t.protocol}:` : ""
        , n = t.port ? `:${t.port}` : "";
    return `${e}//${t.host}${n}${t.path ? `/${t.path}` : ""}/api/`
}
function eF(t) {
    return `${Q7(t)}${t.projectId}/envelope/`
}
function tF(t, e) {
    const n = {
        sentry_version: Z7
    };
    return t.publicKey && (n.sentry_key = t.publicKey),
        e && (n.sentry_client = `${e.name}/${e.version}`),
        new URLSearchParams(n).toString()
}
function nF(t, e, n) {
    return e || `${eF(t)}?${tF(t, n)}`
}
const xT = [];
function sF(t) {
    const e = {};
    return t.forEach(n => {
        const { name: s } = n
            , r = e[s];
        r && !r.isDefaultInstance && n.isDefaultInstance || (e[s] = n)
    }
    ),
        Object.values(e)
}
function rF(t) {
    const e = t.defaultIntegrations || []
        , n = t.integrations;
    e.forEach(o => {
        o.isDefaultInstance = !0
    }
    );
    let s;
    if (Array.isArray(n))
        s = [...e, ...n];
    else if (typeof n == "function") {
        const o = n(e);
        s = Array.isArray(o) ? o : [o]
    } else
        s = e;
    const r = sF(s)
        , i = r.findIndex(o => o.name === "Debug");
    if (i > -1) {
        const [o] = r.splice(i, 1);
        r.push(o)
    }
    return r
}
function iF(t, e) {
    const n = {};
    return e.forEach(s => {
        s && oR(t, s, n)
    }
    ),
        n
}
function wT(t, e) {
    for (const n of e)
        n && n.afterAllSetup && n.afterAllSetup(t)
}
function oR(t, e, n) {
    if (n[e.name]) {
        lt && Re.log(`Integration skipped because it was already installed: ${e.name}`);
        return
    }
    if (n[e.name] = e,
        xT.indexOf(e.name) === -1 && typeof e.setupOnce == "function" && (e.setupOnce(),
            xT.push(e.name)),
        e.setup && typeof e.setup == "function" && e.setup(t),
        typeof e.preprocessEvent == "function") {
        const s = e.preprocessEvent.bind(e);
        t.on("preprocessEvent", (r, i) => s(r, i, t))
    }
    if (typeof e.processEvent == "function") {
        const s = e.processEvent.bind(e)
            , r = Object.assign((i, o) => s(i, o, t), {
                id: e.name
            });
        t.addEventProcessor(r)
    }
    lt && Re.log(`Integration installed: ${e.name}`)
}
function oF(t, e, n) {
    const s = [{
        type: "client_report"
    }, {
        timestamp: rf(),
        discarded_events: t
    }];
    return yc(e ? {
        dsn: e
    } : {}, [s])
}
class Bi extends Error {
    constructor(e, n = "warn") {
        super(e),
            this.message = e,
            this.name = new.target.prototype.constructor.name,
            Object.setPrototypeOf(this, new.target.prototype),
            this.logLevel = n
    }
}
const ST = "Not capturing exception because it's already been captured.";
class aF {
    constructor(e) {
        if (this._options = e,
            this._integrations = {},
            this._numProcessing = 0,
            this._outcomes = {},
            this._hooks = {},
            this._eventProcessors = [],
            e.dsn ? this._dsn = r7(e.dsn) : lt && Re.warn("No DSN provided, client will not send events."),
            this._dsn) {
            const r = nF(this._dsn, e.tunnel, e._metadata ? e._metadata.sdk : void 0);
            this._transport = e.transport({
                tunnel: this._options.tunnel,
                recordDroppedEvent: this.recordDroppedEvent.bind(this),
                ...e.transportOptions,
                url: r
            })
        }
        const s = ["enableTracing", "tracesSampleRate", "tracesSampler"].find(r => r in e && e[r] == null);
        s && pi(() => {
            console.warn(`[Sentry] Deprecation warning: \`${s}\` is set to undefined, which leads to tracing being enabled. In v9, a value of \`undefined\` will result in tracing being disabled.`)
        }
        )
    }
    captureException(e, n, s) {
        const r = Nn();
        if (tT(e))
            return lt && Re.log(ST),
                r;
        const i = {
            event_id: r,
            ...n
        };
        return this._process(this.eventFromException(e, i).then(o => this._captureEvent(o, i, s))),
            i.event_id
    }
    captureMessage(e, n, s, r) {
        const i = {
            event_id: Nn(),
            ...s
        }
            , o = Vv(e) ? e : String(e)
            , l = Gv(e) ? this.eventFromMessage(o, n, i) : this.eventFromException(e, i);
        return this._process(l.then(a => this._captureEvent(a, i, r))),
            i.event_id
    }
    captureEvent(e, n, s) {
        const r = Nn();
        if (n && n.originalException && tT(n.originalException))
            return lt && Re.log(ST),
                r;
        const i = {
            event_id: r,
            ...n
        }
            , l = (e.sdkProcessingMetadata || {}).capturedSpanScope;
        return this._process(this._captureEvent(e, i, l || s)),
            i.event_id
    }
    captureSession(e) {
        typeof e.release != "string" ? lt && Re.warn("Discarded session because of missing or non-string release") : (this.sendSession(e),
            Pu(e, {
                init: !1
            }))
    }
    getDsn() {
        return this._dsn
    }
    getOptions() {
        return this._options
    }
    getSdkMetadata() {
        return this._options._metadata
    }
    getTransport() {
        return this._transport
    }
    flush(e) {
        const n = this._transport;
        return n ? (this.emit("flush"),
            this._isClientDoneProcessing(e).then(s => n.flush(e).then(r => s && r))) : Lo(!0)
    }
    close(e) {
        return this.flush(e).then(n => (this.getOptions().enabled = !1,
            this.emit("close"),
            n))
    }
    getEventProcessors() {
        return this._eventProcessors
    }
    addEventProcessor(e) {
        this._eventProcessors.push(e)
    }
    init() {
        (this._isEnabled() || this._options.integrations.some(({ name: e }) => e.startsWith("Spotlight"))) && this._setupIntegrations()
    }
    getIntegrationByName(e) {
        return this._integrations[e]
    }
    addIntegration(e) {
        const n = this._integrations[e.name];
        oR(this, e, this._integrations),
            n || wT(this, [e])
    }
    sendEvent(e, n = {}) {
        this.emit("beforeSendEvent", e, n);
        let s = y7(e, this._dsn, this._options._metadata, this._options.tunnel);
        for (const i of n.attachments || [])
            s = u7(s, p7(i));
        const r = this.sendEnvelope(s);
        r && r.then(i => this.emit("afterSendEvent", e, i), null)
    }
    sendSession(e) {
        const n = _7(e, this._dsn, this._options._metadata, this._options.tunnel);
        this.sendEnvelope(n)
    }
    recordDroppedEvent(e, n, s) {
        if (this._options.sendClientReports) {
            const r = typeof s == "number" ? s : 1
                , i = `${e}:${n}`;
            lt && Re.log(`Recording outcome: "${i}"${r > 1 ? ` (${r} times)` : ""}`),
                this._outcomes[i] = (this._outcomes[i] || 0) + r
        }
    }
    on(e, n) {
        const s = this._hooks[e] = this._hooks[e] || [];
        return s.push(n),
            () => {
                const r = s.indexOf(n);
                r > -1 && s.splice(r, 1)
            }
    }
    emit(e, ...n) {
        const s = this._hooks[e];
        s && s.forEach(r => r(...n))
    }
    sendEnvelope(e) {
        return this.emit("beforeEnvelope", e),
            this._isEnabled() && this._transport ? this._transport.send(e).then(null, n => (lt && Re.error("Error while sending envelope:", n),
                n)) : (lt && Re.error("Transport disabled"),
                    Lo({}))
    }
    _setupIntegrations() {
        const { integrations: e } = this._options;
        this._integrations = iF(this, e),
            wT(this, e)
    }
    _updateSessionFromEvent(e, n) {
        let s = !1
            , r = !1;
        const i = n.exception && n.exception.values;
        if (i) {
            r = !0;
            for (const a of i) {
                const c = a.mechanism;
                if (c && c.handled === !1) {
                    s = !0;
                    break
                }
            }
        }
        const o = e.status === "ok";
        (o && e.errors === 0 || o && s) && (Pu(e, {
            ...s && {
                status: "crashed"
            },
            errors: e.errors || Number(r || s)
        }),
            this.captureSession(e))
    }
    _isClientDoneProcessing(e) {
        return new xr(n => {
            let s = 0;
            const r = 1
                , i = setInterval(() => {
                    this._numProcessing == 0 ? (clearInterval(i),
                        n(!0)) : (s += r,
                            e && s >= e && (clearInterval(i),
                                n(!1)))
                }
                    , r)
        }
        )
    }
    _isEnabled() {
        return this.getOptions().enabled !== !1 && this._transport !== void 0
    }
    _prepareEvent(e, n, s = Ut(), r = qi()) {
        const i = this.getOptions()
            , o = Object.keys(this._integrations);
        return !n.integrations && o.length > 0 && (n.integrations = o),
            this.emit("preprocessEvent", e, n),
            e.type || r.setLastEventId(e.event_id || n.event_id),
            nR(i, e, n, s, this, r).then(l => {
                if (l === null)
                    return l;
                l.contexts = {
                    trace: MB(s),
                    ...l.contexts
                };
                const a = zk(this, s);
                return l.sdkProcessingMetadata = {
                    dynamicSamplingContext: a,
                    ...l.sdkProcessingMetadata
                },
                    l
            }
            )
    }
    _captureEvent(e, n = {}, s) {
        return this._processEvent(e, n, s).then(r => r.event_id, r => {
            if (lt) {
                const i = r;
                i.logLevel === "log" ? Re.log(i.message) : Re.warn(i)
            }
        }
        )
    }
    _processEvent(e, n, s) {
        const r = this.getOptions()
            , { sampleRate: i } = r
            , o = lR(e)
            , l = aR(e)
            , a = e.type || "error"
            , c = `before send for type \`${a}\``
            , u = typeof i > "u" ? void 0 : ym(i);
        if (l && typeof u == "number" && Math.random() > u)
            return this.recordDroppedEvent("sample_rate", "error", e),
                mm(new Bi(`Discarding event because it's not included in the random sample (sampling rate = ${i})`, "log"));
        const h = a === "replay_event" ? "replay" : a
            , f = (e.sdkProcessingMetadata || {}).capturedSpanIsolationScope;
        return this._prepareEvent(e, n, s, f).then(p => {
            if (p === null)
                throw this.recordDroppedEvent("event_processor", h, e),
                new Bi("An event processor returned `null`, will not send event.", "log");
            if (n.data && n.data.__sentry__ === !0)
                return p;
            const g = cF(this, r, p, n);
            return lF(g, c)
        }
        ).then(p => {
            if (p === null) {
                if (this.recordDroppedEvent("before_send", h, e),
                    o) {
                    const v = 1 + (e.spans || []).length;
                    this.recordDroppedEvent("before_send", "span", v)
                }
                throw new Bi(`${c} returned \`null\`, will not send event.`, "log")
            }
            const m = s && s.getSession();
            if (!o && m && this._updateSessionFromEvent(m, p),
                o) {
                const b = p.sdkProcessingMetadata && p.sdkProcessingMetadata.spanCountBeforeProcessing || 0
                    , v = p.spans ? p.spans.length : 0
                    , _ = b - v;
                _ > 0 && this.recordDroppedEvent("before_send", "span", _)
            }
            const g = p.transaction_info;
            if (o && g && p.transaction !== e.transaction) {
                const b = "custom";
                p.transaction_info = {
                    ...g,
                    source: b
                }
            }
            return this.sendEvent(p, n),
                p
        }
        ).then(null, p => {
            throw p instanceof Bi ? p : (this.captureException(p, {
                data: {
                    __sentry__: !0
                },
                originalException: p
            }),
                new Bi(`Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.
Reason: ${p}`))
        }
        )
    }
    _process(e) {
        this._numProcessing++,
            e.then(n => (this._numProcessing--,
                n), n => (this._numProcessing--,
                    n))
    }
    _clearOutcomes() {
        const e = this._outcomes;
        return this._outcomes = {},
            Object.entries(e).map(([n, s]) => {
                const [r, i] = n.split(":");
                return {
                    reason: r,
                    category: i,
                    quantity: s
                }
            }
            )
    }
    _flushOutcomes() {
        lt && Re.log("Flushing outcomes...");
        const e = this._clearOutcomes();
        if (e.length === 0) {
            lt && Re.log("No outcomes to send");
            return
        }
        if (!this._dsn) {
            lt && Re.log("No dsn provided, will not send outcomes");
            return
        }
        lt && Re.log("Sending outcomes:", e);
        const n = oF(e, this._options.tunnel && of(this._dsn));
        this.sendEnvelope(n)
    }
}
function lF(t, e) {
    const n = `${e} must return \`null\` or a valid event.`;
    if (Kg(t))
        return t.then(s => {
            if (!Mu(s) && s !== null)
                throw new Bi(n);
            return s
        }
            , s => {
                throw new Bi(`${e} rejected with ${s}`)
            }
        );
    if (!Mu(t) && t !== null)
        throw new Bi(n);
    return t
}
function cF(t, e, n, s) {
    const { beforeSend: r, beforeSendTransaction: i, beforeSendSpan: o } = e;
    if (aR(n) && r)
        return r(n, s);
    if (lR(n)) {
        if (n.spans && o) {
            const l = [];
            for (const a of n.spans) {
                const c = o(a);
                c ? l.push(c) : (Hk(),
                    t.recordDroppedEvent("before_send", "span"))
            }
            n.spans = l
        }
        if (i) {
            if (n.spans) {
                const l = n.spans.length;
                n.sdkProcessingMetadata = {
                    ...n.sdkProcessingMetadata,
                    spanCountBeforeProcessing: l
                }
            }
            return i(n, s)
        }
    }
    return n
}
function aR(t) {
    return t.type === void 0
}
function lR(t) {
    return t.type === "transaction"
}
function uF(t, e) {
    e.debug === !0 && (lt ? Re.enable() : pi(() => {
        console.warn("[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.")
    }
    )),
        Ut().update(e.initialScope);
    const s = new t(e);
    return hF(s),
        s.init(),
        s
}
function hF(t) {
    Ut().setClient(t)
}
function dF(t) {
    const e = [];
    function n() {
        return t === void 0 || e.length < t
    }
    function s(o) {
        return e.splice(e.indexOf(o), 1)[0] || Promise.resolve(void 0)
    }
    function r(o) {
        if (!n())
            return mm(new Bi("Not adding Promise because buffer limit was reached."));
        const l = o();
        return e.indexOf(l) === -1 && e.push(l),
            l.then(() => s(l)).then(null, () => s(l).then(null, () => { }
            )),
            l
    }
    function i(o) {
        return new xr((l, a) => {
            let c = e.length;
            if (!c)
                return l(!0);
            const u = setTimeout(() => {
                o && o > 0 && l(!1)
            }
                , o);
            e.forEach(h => {
                Lo(h).then(() => {
                    --c || (clearTimeout(u),
                        l(!0))
                }
                    , a)
            }
            )
        }
        )
    }
    return {
        $: e,
        add: r,
        drain: i
    }
}
const fF = 60 * 1e3;
function pF(t, e = Date.now()) {
    const n = parseInt(`${t}`, 10);
    if (!isNaN(n))
        return n * 1e3;
    const s = Date.parse(`${t}`);
    return isNaN(s) ? fF : s - e
}
function mF(t, e) {
    return t[e] || t.all || 0
}
function cR(t, e, n = Date.now()) {
    return mF(t, e) > n
}
function uR(t, { statusCode: e, headers: n }, s = Date.now()) {
    const r = {
        ...t
    }
        , i = n && n["x-sentry-rate-limits"]
        , o = n && n["retry-after"];
    if (i)
        for (const l of i.trim().split(",")) {
            const [a, c, , , u] = l.split(":", 5)
                , h = parseInt(a, 10)
                , d = (isNaN(h) ? 60 : h) * 1e3;
            if (!c)
                r.all = s + d;
            else
                for (const f of c.split(";"))
                    f === "metric_bucket" ? (!u || u.split(";").includes("custom")) && (r[f] = s + d) : r[f] = s + d
        }
    else
        o ? r.all = s + pF(o, s) : e === 429 && (r.all = s + 60 * 1e3);
    return r
}
const gF = 64;
function _F(t, e, n = dF(t.bufferSize || gF)) {
    let s = {};
    const r = o => n.drain(o);
    function i(o) {
        const l = [];
        if (uT(o, (h, d) => {
            const f = hT(d);
            if (cR(s, f)) {
                const p = ET(h, d);
                t.recordDroppedEvent("ratelimit_backoff", f, p)
            } else
                l.push(h)
        }
        ),
            l.length === 0)
            return Lo({});
        const a = yc(o[0], l)
            , c = h => {
                uT(a, (d, f) => {
                    const p = ET(d, f);
                    t.recordDroppedEvent(h, hT(f), p)
                }
                )
            }
            , u = () => e({
                body: h7(a)
            }).then(h => (h.statusCode !== void 0 && (h.statusCode < 200 || h.statusCode >= 300) && lt && Re.warn(`Sentry responded with status code ${h.statusCode} to sent event.`),
                s = uR(s, h),
                h), h => {
                    throw c("network_error"),
                    h
                }
            );
        return n.add(u).then(h => h, h => {
            if (h instanceof Bi)
                return lt && Re.error("Skipped sending event because buffer is full."),
                    c("queue_overflow"),
                    Lo({});
            throw h
        }
        )
    }
    return {
        send: i,
        flush: r
    }
}
function ET(t, e) {
    if (!(e !== "event" && e !== "transaction"))
        return Array.isArray(t) ? t[1] : void 0
}
function yF(t, e) {
    const n = e && e.getDsn()
        , s = e && e.getOptions().tunnel;
    return vF(t, n) || bF(t, s)
}
function bF(t, e) {
    return e ? TT(t) === TT(e) : !1
}
function vF(t, e) {
    return e ? t.includes(e.host) : !1
}
function TT(t) {
    return t[t.length - 1] === "/" ? t.slice(0, -1) : t
}
function xF(t, e, n = [e], s = "npm") {
    const r = t._metadata || {};
    r.sdk || (r.sdk = {
        name: `sentry.javascript.${e}`,
        packages: n.map(i => ({
            name: `${s}:@sentry/${i}`,
            version: To
        })),
        version: To
    }),
        t._metadata = r
}
function hR(t = {}) {
    const e = bt();
    if (!K7() || !e)
        return {};
    const n = mc()
        , s = th(n);
    if (s.getTraceData)
        return s.getTraceData(t);
    const r = Ut()
        , i = t.span || Cn()
        , o = i ? YB(i) : wF(r)
        , l = i ? _c(i) : zk(e, r)
        , a = FB(l);
    return Bk.test(o) ? {
        "sentry-trace": o,
        baggage: a
    } : (Re.warn("Invalid sentry-trace data. Cannot generate trace data"),
        {})
}
function wF(t) {
    const { traceId: e, sampled: n, spanId: s } = t.getPropagationContext();
    return Fk(e, s, n)
}
const SF = 100;
function Ya(t, e) {
    const n = bt()
        , s = qi();
    if (!n)
        return;
    const { beforeBreadcrumb: r = null, maxBreadcrumbs: i = SF } = n.getOptions();
    if (i <= 0)
        return;
    const l = {
        timestamp: rf(),
        ...t
    }
        , a = r ? pi(() => r(l, e)) : l;
    a !== null && (n.emit && n.emit("beforeAddBreadcrumb", a, e),
        s.addBreadcrumb(a, i))
}
let CT;
const EF = "FunctionToString"
    , IT = new WeakMap
    , TF = () => ({
        name: EF,
        setupOnce() {
            CT = Function.prototype.toString;
            try {
                Function.prototype.toString = function (...t) {
                    const e = Hv(this)
                        , n = IT.has(bt()) && e !== void 0 ? e : this;
                    return CT.apply(n, t)
                }
            } catch { }
        },
        setup(t) {
            IT.set(t, !0)
        }
    })
    , CF = TF
    , IF = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/, /^ResizeObserver loop completed with undelivered notifications.$/, /^Cannot redefine property: googletag$/, "undefined is not an object (evaluating 'a.L')", `can't redefine non-configurable property "solana"`, "vv().getRestrictions is not a function. (In 'vv().getRestrictions(1,a)', 'vv().getRestrictions' is undefined)", "Can't find variable: _AutofillCallbackHandler"]
    , AF = "InboundFilters"
    , kF = (t = {}) => ({
        name: AF,
        processEvent(e, n, s) {
            const r = s.getOptions()
                , i = MF(t, r);
            return PF(e, i) ? null : e
        }
    })
    , RF = kF;
function MF(t = {}, e = {}) {
    return {
        allowUrls: [...t.allowUrls || [], ...e.allowUrls || []],
        denyUrls: [...t.denyUrls || [], ...e.denyUrls || []],
        ignoreErrors: [...t.ignoreErrors || [], ...e.ignoreErrors || [], ...t.disableErrorDefaults ? [] : IF],
        ignoreTransactions: [...t.ignoreTransactions || [], ...e.ignoreTransactions || []],
        ignoreInternal: t.ignoreInternal !== void 0 ? t.ignoreInternal : !0
    }
}
function PF(t, e) {
    return e.ignoreInternal && FF(t) ? (lt && Re.warn(`Event dropped due to being internal Sentry Error.
Event: ${ma(t)}`),
        !0) : LF(t, e.ignoreErrors) ? (lt && Re.warn(`Event dropped due to being matched by \`ignoreErrors\` option.
Event: ${ma(t)}`),
            !0) : UF(t) ? (lt && Re.warn(`Event dropped due to not having an error message, error type or stacktrace.
Event: ${ma(t)}`),
                !0) : OF(t, e.ignoreTransactions) ? (lt && Re.warn(`Event dropped due to being matched by \`ignoreTransactions\` option.
Event: ${ma(t)}`),
                    !0) : NF(t, e.denyUrls) ? (lt && Re.warn(`Event dropped due to being matched by \`denyUrls\` option.
Event: ${ma(t)}.
Url: ${bm(t)}`),
                        !0) : DF(t, e.allowUrls) ? !1 : (lt && Re.warn(`Event dropped due to not being matched by \`allowUrls\` option.
Event: ${ma(t)}.
Url: ${bm(t)}`),
                            !0)
}
function LF(t, e) {
    return t.type || !e || !e.length ? !1 : BF(t).some(n => Ba(n, e))
}
function OF(t, e) {
    if (t.type !== "transaction" || !e || !e.length)
        return !1;
    const n = t.transaction;
    return n ? Ba(n, e) : !1
}
function NF(t, e) {
    if (!e || !e.length)
        return !1;
    const n = bm(t);
    return n ? Ba(n, e) : !1
}
function DF(t, e) {
    if (!e || !e.length)
        return !0;
    const n = bm(t);
    return n ? Ba(n, e) : !0
}
function BF(t) {
    const e = [];
    t.message && e.push(t.message);
    let n;
    try {
        n = t.exception.values[t.exception.values.length - 1]
    } catch { }
    return n && n.value && (e.push(n.value),
        n.type && e.push(`${n.type}: ${n.value}`)),
        e
}
function FF(t) {
    try {
        return t.exception.values[0].type === "SentryError"
    } catch { }
    return !1
}
function $F(t = []) {
    for (let e = t.length - 1; e >= 0; e--) {
        const n = t[e];
        if (n && n.filename !== "<anonymous>" && n.filename !== "[native code]")
            return n.filename || null
    }
    return null
}
function bm(t) {
    try {
        let e;
        try {
            e = t.exception.values[0].stacktrace.frames
        } catch { }
        return e ? $F(e) : null
    } catch {
        return lt && Re.error(`Cannot extract url for event ${ma(t)}`),
            null
    }
}
function UF(t) {
    return t.type || !t.exception || !t.exception.values || t.exception.values.length === 0 ? !1 : !t.message && !t.exception.values.some(e => e.stacktrace || e.type && e.type !== "Error" || e.value)
}
function VF(t, e, n = 250, s, r, i, o) {
    if (!i.exception || !i.exception.values || !o || !Mo(o.originalException, Error))
        return;
    const l = i.exception.values.length > 0 ? i.exception.values[i.exception.values.length - 1] : void 0;
    l && (i.exception.values = GF(my(t, e, r, o.originalException, s, i.exception.values, l, 0), n))
}
function my(t, e, n, s, r, i, o, l) {
    if (i.length >= n + 1)
        return i;
    let a = [...i];
    if (Mo(s[r], Error)) {
        AT(o, l);
        const c = t(e, s[r])
            , u = a.length;
        kT(c, r, u, l),
            a = my(t, e, n, s[r], r, [c, ...a], c, u)
    }
    return Array.isArray(s.errors) && s.errors.forEach((c, u) => {
        if (Mo(c, Error)) {
            AT(o, l);
            const h = t(e, c)
                , d = a.length;
            kT(h, `errors[${u}]`, d, l),
                a = my(t, e, n, c, r, [h, ...a], h, d)
        }
    }
    ),
        a
}
function AT(t, e) {
    t.mechanism = t.mechanism || {
        type: "generic",
        handled: !0
    },
        t.mechanism = {
            ...t.mechanism,
            ...t.type === "AggregateError" && {
                is_exception_group: !0
            },
            exception_id: e
        }
}
function kT(t, e, n, s) {
    t.mechanism = t.mechanism || {
        type: "generic",
        handled: !0
    },
        t.mechanism = {
            ...t.mechanism,
            type: "chained",
            source: e,
            exception_id: n,
            parent_id: s
        }
}
function GF(t, e) {
    return t.map(n => (n.value && (n.value = fu(n.value, e)),
        n))
}
function Hl(t) {
    if (!t)
        return {};
    const e = t.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
    if (!e)
        return {};
    const n = e[6] || ""
        , s = e[8] || "";
    return {
        host: e[4],
        path: e[5],
        protocol: e[2],
        search: n,
        hash: s,
        relative: e[5] + n + s
    }
}
function HF(t) {
    const e = "console";
    tl(e, t),
        nl(e, WF)
}
function WF() {
    "console" in St && ry.forEach(function (t) {
        t in St.console && Ys(St.console, t, function (e) {
            return pm[t] = e,
                function (...n) {
                    Rr("console", {
                        args: n,
                        level: t
                    });
                    const r = pm[t];
                    r && r.apply(St.console, n)
                }
        })
    })
}
function dR(t) {
    return t === "warn" ? "warning" : ["fatal", "error", "warning", "log", "info", "debug"].includes(t) ? t : "log"
}
const YF = "Dedupe"
    , XF = () => {
        let t;
        return {
            name: YF,
            processEvent(e) {
                if (e.type)
                    return e;
                try {
                    if (zF(e, t))
                        return lt && Re.warn("Event dropped due to being a duplicate of previously captured event."),
                            null
                } catch { }
                return t = e
            }
        }
    }
    , jF = XF;
function zF(t, e) {
    return e ? !!(qF(t, e) || KF(t, e)) : !1
}
function qF(t, e) {
    const n = t.message
        , s = e.message;
    return !(!n && !s || n && !s || !n && s || n !== s || !pR(t, e) || !fR(t, e))
}
function KF(t, e) {
    const n = RT(e)
        , s = RT(t);
    return !(!n || !s || n.type !== s.type || n.value !== s.value || !pR(t, e) || !fR(t, e))
}
function fR(t, e) {
    let n = qE(t)
        , s = qE(e);
    if (!n && !s)
        return !0;
    if (n && !s || !n && s || (n = n,
        s = s,
        s.length !== n.length))
        return !1;
    for (let r = 0; r < s.length; r++) {
        const i = s[r]
            , o = n[r];
        if (i.filename !== o.filename || i.lineno !== o.lineno || i.colno !== o.colno || i.function !== o.function)
            return !1
    }
    return !0
}
function pR(t, e) {
    let n = t.fingerprint
        , s = e.fingerprint;
    if (!n && !s)
        return !0;
    if (n && !s || !n && s)
        return !1;
    n = n,
        s = s;
    try {
        return n.join("") === s.join("")
    } catch {
        return !1
    }
}
function RT(t) {
    return t.exception && t.exception.values && t.exception.values[0]
}
function JF(t, e, n, s, r = "auto.http.browser") {
    if (!t.fetchData)
        return;
    const i = Oo() && e(t.fetchData.url);
    if (t.endTimestamp && i) {
        const d = t.fetchData.__span;
        if (!d)
            return;
        const f = s[d];
        f && (e$(f, t),
            delete s[d]);
        return
    }
    const { method: o, url: l } = t.fetchData
        , a = QF(l)
        , c = a ? Hl(a).host : void 0
        , u = !!Cn()
        , h = i && u ? ec({
            name: `${o} ${l}`,
            attributes: {
                url: l,
                type: "fetch",
                "http.method": o,
                "http.url": a,
                "server.address": c,
                [an]: r,
                [Ql]: "http.client"
            }
        }) : new nh;
    if (t.fetchData.__span = h.spanContext().spanId,
        s[h.spanContext().spanId] = h,
        n(t.fetchData.url)) {
        const d = t.args[0]
            , f = t.args[1] || {}
            , p = ZF(d, f, Oo() && u ? h : void 0);
        p && (t.args[1] = f,
            f.headers = p)
    }
    return h
}
function ZF(t, e, n) {
    const s = hR({
        span: n
    })
        , r = s["sentry-trace"]
        , i = s.baggage;
    if (!r)
        return;
    const o = e.headers || (t$(t) ? t.headers : void 0);
    if (o)
        if (n$(o)) {
            const l = new Headers(o);
            if (l.set("sentry-trace", r),
                i) {
                const a = l.get("baggage");
                if (a) {
                    const c = Vf(a);
                    l.set("baggage", c ? `${c},${i}` : i)
                } else
                    l.set("baggage", i)
            }
            return l
        } else if (Array.isArray(o)) {
            const l = [...o.filter(a => !(Array.isArray(a) && a[0] === "sentry-trace")).map(a => {
                if (Array.isArray(a) && a[0] === "baggage" && typeof a[1] == "string") {
                    const [c, u, ...h] = a;
                    return [c, Vf(u), ...h]
                } else
                    return a
            }
            ), ["sentry-trace", r]];
            return i && l.push(["baggage", i]),
                l
        } else {
            const l = "baggage" in o ? o.baggage : void 0;
            let a = [];
            return Array.isArray(l) ? a = l.map(c => typeof c == "string" ? Vf(c) : c).filter(c => c === "") : l && a.push(Vf(l)),
                i && a.push(i),
            {
                ...o,
                "sentry-trace": r,
                baggage: a.length > 0 ? a.join(",") : void 0
            }
        }
    else
        return {
            ...s
        }
}
function QF(t) {
    try {
        return new URL(t).href
    } catch {
        return
    }
}
function e$(t, e) {
    if (e.response) {
        Nk(t, e.response.status);
        const n = e.response && e.response.headers && e.response.headers.get("content-length");
        if (n) {
            const s = parseInt(n);
            s > 0 && t.setAttribute("http.response_content_length", s)
        }
    } else
        e.error && t.setStatus({
            code: Hn,
            message: "internal_error"
        });
    t.end()
}
function Vf(t) {
    return t.split(",").filter(e => !e.split("=")[0].startsWith(jv)).join(",")
}
function t$(t) {
    return typeof Request < "u" && Mo(t, Request)
}
function n$(t) {
    return typeof Headers < "u" && Mo(t, Headers)
}
function mR(t) {
    if (t !== void 0)
        return t >= 400 && t < 500 ? "warning" : t >= 500 ? "error" : void 0
}
const gy = St;
function gR() {
    if (!("fetch" in gy))
        return !1;
    try {
        return new Headers,
            new Request("http://www.example.com"),
            new Response,
            !0
    } catch {
        return !1
    }
}
function _y(t) {
    return t && /^function\s+\w+\(\)\s+\{\s+\[native code\]\s+\}$/.test(t.toString())
}
function s$() {
    if (typeof EdgeRuntime == "string")
        return !0;
    if (!gR())
        return !1;
    if (_y(gy.fetch))
        return !0;
    let t = !1;
    const e = gy.document;
    if (e && typeof e.createElement == "function")
        try {
            const n = e.createElement("iframe");
            n.hidden = !0,
                e.head.appendChild(n),
                n.contentWindow && n.contentWindow.fetch && (t = _y(n.contentWindow.fetch)),
                e.head.removeChild(n)
        } catch (n) {
            el && Re.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", n)
        }
    return t
}
function _R(t, e) {
    const n = "fetch";
    tl(n, t),
        nl(n, () => yR(void 0, e))
}
function r$(t) {
    const e = "fetch-body-resolved";
    tl(e, t),
        nl(e, () => yR(o$))
}
function yR(t, e = !1) {
    e && !s$() || Ys(St, "fetch", function (n) {
        return function (...s) {
            const { method: r, url: i } = a$(s)
                , o = {
                    args: s,
                    fetchData: {
                        method: r,
                        url: i
                    },
                    startTimestamp: ps() * 1e3
                };
            t || Rr("fetch", {
                ...o
            });
            const l = new Error().stack;
            return n.apply(St, s).then(async a => (t ? t(a) : Rr("fetch", {
                ...o,
                endTimestamp: ps() * 1e3,
                response: a
            }),
                a), a => {
                    throw Rr("fetch", {
                        ...o,
                        endTimestamp: ps() * 1e3,
                        error: a
                    }),
                    Uv(a) && a.stack === void 0 && (a.stack = l,
                        Pr(a, "framesToPop", 1)),
                    a
                }
            )
        }
    })
}
async function i$(t, e) {
    if (t && t.body) {
        const n = t.body
            , s = n.getReader()
            , r = setTimeout(() => {
                n.cancel().then(null, () => { }
                )
            }
                , 90 * 1e3);
        let i = !0;
        for (; i;) {
            let o;
            try {
                o = setTimeout(() => {
                    n.cancel().then(null, () => { }
                    )
                }
                    , 5e3);
                const { done: l } = await s.read();
                clearTimeout(o),
                    l && (e(),
                        i = !1)
            } catch {
                i = !1
            } finally {
                clearTimeout(o)
            }
        }
        clearTimeout(r),
            s.releaseLock(),
            n.cancel().then(null, () => { }
            )
    }
}
function o$(t) {
    let e;
    try {
        e = t.clone()
    } catch {
        return
    }
    i$(e, () => {
        Rr("fetch-body-resolved", {
            endTimestamp: ps() * 1e3,
            response: t
        })
    }
    )
}
function yy(t, e) {
    return !!t && typeof t == "object" && !!t[e]
}
function MT(t) {
    return typeof t == "string" ? t : t ? yy(t, "url") ? t.url : t.toString ? t.toString() : "" : ""
}
function a$(t) {
    if (t.length === 0)
        return {
            method: "GET",
            url: ""
        };
    if (t.length === 2) {
        const [n, s] = t;
        return {
            url: MT(n),
            method: yy(s, "method") ? String(s.method).toUpperCase() : "GET"
        }
    }
    const e = t[0];
    return {
        url: MT(e),
        method: yy(e, "method") ? String(e.method).toUpperCase() : "GET"
    }
}
function l$() {
    return typeof __SENTRY_BROWSER_BUNDLE__ < "u" && !!__SENTRY_BROWSER_BUNDLE__
}
function c$() {
    return "npm"
}
function u$() {
    return !l$() && Object.prototype.toString.call(typeof process < "u" ? process : 0) === "[object process]"
}
function PT() {
    return typeof window < "u" && (!u$() || h$())
}
function h$() {
    const t = St.process;
    return !!t && t.type === "renderer"
}
const Gf = St;
function d$() {
    const t = Gf.chrome
        , e = t && t.app && t.app.runtime
        , n = "history" in Gf && !!Gf.history.pushState && !!Gf.history.replaceState;
    return !e && n
}
function f$(t, e) {
    return t ?? e()
}
function Bp(t) {
    let e, n = t[0], s = 1;
    for (; s < t.length;) {
        const r = t[s]
            , i = t[s + 1];
        if (s += 2,
            (r === "optionalAccess" || r === "optionalCall") && n == null)
            return;
        r === "access" || r === "optionalAccess" ? (e = n,
            n = i(n)) : (r === "call" || r === "optionalCall") && (n = i((...o) => n.call(e, ...o)),
                e = void 0)
    }
    return n
}
const rt = St;
let by = 0;
function bR() {
    return by > 0
}
function p$() {
    by++,
        setTimeout(() => {
            by--
        }
        )
}
function Ou(t, e = {}) {
    function n(r) {
        return typeof r == "function"
    }
    if (!n(t))
        return t;
    try {
        const r = t.__sentry_wrapped__;
        if (r)
            return typeof r == "function" ? r : t;
        if (Hv(t))
            return t
    } catch {
        return t
    }
    const s = function (...r) {
        try {
            const i = r.map(o => Ou(o, e));
            return t.apply(this, i)
        } catch (i) {
            throw p$(),
            Yv(o => {
                o.addEventProcessor(l => (e.mechanism && (oy(l, void 0),
                    vd(l, e.mechanism)),
                    l.extra = {
                        ...l.extra,
                        arguments: r
                    },
                    l)),
                    No(i)
            }
            ),
            i
        }
    };
    try {
        for (const r in t)
            Object.prototype.hasOwnProperty.call(t, r) && (s[r] = t[r])
    } catch { }
    kk(s, t),
        Pr(t, "__sentry_wrapped__", s);
    try {
        Object.getOwnPropertyDescriptor(s, "name").configurable && Object.defineProperty(s, "name", {
            get() {
                return t.name
            }
        })
    } catch { }
    return s
}
const Xi = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__;
function Jv(t, e) {
    const n = Zv(t, e)
        , s = {
            type: b$(e),
            value: v$(e)
        };
    return n.length && (s.stacktrace = {
        frames: n
    }),
        s.type === void 0 && s.value === "" && (s.value = "Unrecoverable error caught"),
        s
}
function m$(t, e, n, s) {
    const r = bt()
        , i = r && r.getOptions().normalizeDepth
        , o = T$(e)
        , l = {
            __serialized__: Kk(e, i)
        };
    if (o)
        return {
            exception: {
                values: [Jv(t, o)]
            },
            extra: l
        };
    const a = {
        exception: {
            values: [{
                type: qg(e) ? e.constructor.name : s ? "UnhandledRejection" : "Error",
                value: S$(e, {
                    isUnhandledRejection: s
                })
            }]
        },
        extra: l
    };
    if (n) {
        const c = Zv(t, n);
        c.length && (a.exception.values[0].stacktrace = {
            frames: c
        })
    }
    return a
}
function b0(t, e) {
    return {
        exception: {
            values: [Jv(t, e)]
        }
    }
}
function Zv(t, e) {
    const n = e.stacktrace || e.stack || ""
        , s = _$(e)
        , r = y$(e);
    try {
        return t(n, s, r)
    } catch { }
    return []
}
const g$ = /Minified React error #\d+;/i;
function _$(t) {
    return t && g$.test(t.message) ? 1 : 0
}
function y$(t) {
    return typeof t.framesToPop == "number" ? t.framesToPop : 0
}
function vR(t) {
    return typeof WebAssembly < "u" && typeof WebAssembly.Exception < "u" ? t instanceof WebAssembly.Exception : !1
}
function b$(t) {
    const e = t && t.name;
    return !e && vR(t) ? t.message && Array.isArray(t.message) && t.message.length == 2 ? t.message[0] : "WebAssembly.Exception" : e
}
function v$(t) {
    const e = t && t.message;
    return e ? e.error && typeof e.error.message == "string" ? e.error.message : vR(t) && Array.isArray(t.message) && t.message.length == 2 ? t.message[1] : e : "No error message"
}
function x$(t, e, n, s) {
    const r = n && n.syntheticException || void 0
        , i = Qv(t, e, r, s);
    return vd(i),
        i.level = "error",
        n && n.event_id && (i.event_id = n.event_id),
        Lo(i)
}
function w$(t, e, n = "info", s, r) {
    const i = s && s.syntheticException || void 0
        , o = vy(t, e, i, r);
    return o.level = n,
        s && s.event_id && (o.event_id = s.event_id),
        Lo(o)
}
function Qv(t, e, n, s, r) {
    let i;
    if (Tk(e) && e.error)
        return b0(t, e.error);
    if (JE(e) || lB(e)) {
        const o = e;
        if ("stack" in e)
            i = b0(t, e);
        else {
            const l = o.name || (JE(o) ? "DOMError" : "DOMException")
                , a = o.message ? `${l}: ${o.message}` : l;
            i = vy(t, a, n, s),
                oy(i, a)
        }
        return "code" in o && (i.tags = {
            ...i.tags,
            "DOMException.code": `${o.code}`
        }),
            i
    }
    return Uv(e) ? b0(t, e) : Mu(e) || qg(e) ? (i = m$(t, e, n, r),
        vd(i, {
            synthetic: !0
        }),
        i) : (i = vy(t, e, n, s),
            oy(i, `${e}`),
            vd(i, {
                synthetic: !0
            }),
            i)
}
function vy(t, e, n, s) {
    const r = {};
    if (s && n) {
        const i = Zv(t, n);
        i.length && (r.exception = {
            values: [{
                value: e,
                stacktrace: {
                    frames: i
                }
            }]
        })
    }
    if (Vv(e)) {
        const { __sentry_template_string__: i, __sentry_template_values__: o } = e;
        return r.logentry = {
            message: i,
            params: o
        },
            r
    }
    return r.message = e,
        r
}
function S$(t, { isUnhandledRejection: e }) {
    const n = gB(t)
        , s = e ? "promise rejection" : "exception";
    return Tk(t) ? `Event \`ErrorEvent\` captured as ${s} with message \`${t.message}\`` : qg(t) ? `Event \`${E$(t)}\` (type=${t.type}) captured as ${s}` : `Object captured as ${s} with keys: ${n}`
}
function E$(t) {
    try {
        const e = Object.getPrototypeOf(t);
        return e ? e.constructor.name : void 0
    } catch { }
}
function T$(t) {
    for (const e in t)
        if (Object.prototype.hasOwnProperty.call(t, e)) {
            const n = t[e];
            if (n instanceof Error)
                return n
        }
}
function C$(t, { metadata: e, tunnel: n, dsn: s }) {
    const r = {
        event_id: t.event_id,
        sent_at: new Date().toISOString(),
        ...e && e.sdk && {
            sdk: {
                name: e.sdk.name,
                version: e.sdk.version
            }
        },
        ...!!n && !!s && {
            dsn: of(s)
        }
    }
        , i = I$(t);
    return yc(r, [i])
}
function I$(t) {
    return [{
        type: "user_report"
    }, t]
}
class A$ extends aF {
    constructor(e) {
        const n = {
            parentSpanIsAlwaysRootSpan: !0,
            ...e
        }
            , s = rt.SENTRY_SDK_SOURCE || c$();
        xF(n, "browser", ["browser"], s),
            super(n),
            n.sendClientReports && rt.document && rt.document.addEventListener("visibilitychange", () => {
                rt.document.visibilityState === "hidden" && this._flushOutcomes()
            }
            )
    }
    eventFromException(e, n) {
        return x$(this._options.stackParser, e, n, this._options.attachStacktrace)
    }
    eventFromMessage(e, n = "info", s) {
        return w$(this._options.stackParser, e, n, s, this._options.attachStacktrace)
    }
    captureUserFeedback(e) {
        if (!this._isEnabled()) {
            Xi && Re.warn("SDK not enabled, will not capture user feedback.");
            return
        }
        const n = C$(e, {
            metadata: this.getSdkMetadata(),
            dsn: this.getDsn(),
            tunnel: this.getOptions().tunnel
        });
        this.sendEnvelope(n)
    }
    _prepareEvent(e, n, s) {
        return e.platform = e.platform || "javascript",
            super._prepareEvent(e, n, s)
    }
}
const ex = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__
    , k$ = (t, e) => t > e[1] ? "poor" : t > e[0] ? "needs-improvement" : "good"
    , sh = (t, e, n, s) => {
        let r, i;
        return o => {
            e.value >= 0 && (o || s) && (i = e.value - (r || 0),
                (i || r === void 0) && (r = e.value,
                    e.delta = i,
                    e.rating = k$(e.value, n),
                    t(e)))
        }
    }
    , je = St
    , R$ = () => `v4-${Date.now()}-${Math.floor(Math.random() * (9e12 - 1)) + 1e12}`
    , af = (t = !0) => {
        const e = je.performance && je.performance.getEntriesByType && je.performance.getEntriesByType("navigation")[0];
        if (!t || e && e.responseStart > 0 && e.responseStart < performance.now())
            return e
    }
    , lf = () => {
        const t = af();
        return t && t.activationStart || 0
    }
    , rh = (t, e) => {
        const n = af();
        let s = "navigate";
        return n && (je.document && je.document.prerendering || lf() > 0 ? s = "prerender" : je.document && je.document.wasDiscarded ? s = "restore" : n.type && (s = n.type.replace(/_/g, "-"))),
        {
            name: t,
            value: typeof e > "u" ? -1 : e,
            rating: "good",
            delta: 0,
            entries: [],
            id: R$(),
            navigationType: s
        }
    }
    , bc = (t, e, n) => {
        try {
            if (PerformanceObserver.supportedEntryTypes.includes(t)) {
                const s = new PerformanceObserver(r => {
                    Promise.resolve().then(() => {
                        e(r.getEntries())
                    }
                    )
                }
                );
                return s.observe(Object.assign({
                    type: t,
                    buffered: !0
                }, n || {})),
                    s
            }
        } catch { }
    }
    , ih = t => {
        const e = n => {
            (n.type === "pagehide" || je.document && je.document.visibilityState === "hidden") && t(n)
        }
            ;
        je.document && (addEventListener("visibilitychange", e, !0),
            addEventListener("pagehide", e, !0))
    }
    , e_ = t => {
        let e = !1;
        return () => {
            e || (t(),
                e = !0)
        }
    }
    ;
let Jh = -1;
const M$ = () => je.document.visibilityState === "hidden" && !je.document.prerendering ? 0 : 1 / 0
    , vm = t => {
        je.document.visibilityState === "hidden" && Jh > -1 && (Jh = t.type === "visibilitychange" ? t.timeStamp : 0,
            L$())
    }
    , P$ = () => {
        addEventListener("visibilitychange", vm, !0),
            addEventListener("prerenderingchange", vm, !0)
    }
    , L$ = () => {
        removeEventListener("visibilitychange", vm, !0),
            removeEventListener("prerenderingchange", vm, !0)
    }
    , t_ = () => (je.document && Jh < 0 && (Jh = M$(),
        P$()),
    {
        get firstHiddenTime() {
            return Jh
        }
    })
    , cf = t => {
        je.document && je.document.prerendering ? addEventListener("prerenderingchange", () => t(), !0) : t()
    }
    , O$ = [1800, 3e3]
    , N$ = (t, e = {}) => {
        cf(() => {
            const n = t_()
                , s = rh("FCP");
            let r;
            const o = bc("paint", l => {
                l.forEach(a => {
                    a.name === "first-contentful-paint" && (o.disconnect(),
                        a.startTime < n.firstHiddenTime && (s.value = Math.max(a.startTime - lf(), 0),
                            s.entries.push(a),
                            r(!0)))
                }
                )
            }
            );
            o && (r = sh(t, s, O$, e.reportAllChanges))
        }
        )
    }
    , D$ = [.1, .25]
    , B$ = (t, e = {}) => {
        N$(e_(() => {
            const n = rh("CLS", 0);
            let s, r = 0, i = [];
            const o = a => {
                a.forEach(c => {
                    if (!c.hadRecentInput) {
                        const u = i[0]
                            , h = i[i.length - 1];
                        r && u && h && c.startTime - h.startTime < 1e3 && c.startTime - u.startTime < 5e3 ? (r += c.value,
                            i.push(c)) : (r = c.value,
                                i = [c])
                    }
                }
                ),
                    r > n.value && (n.value = r,
                        n.entries = i,
                        s())
            }
                , l = bc("layout-shift", o);
            l && (s = sh(t, n, D$, e.reportAllChanges),
                ih(() => {
                    o(l.takeRecords()),
                        s(!0)
                }
                ),
                setTimeout(s, 0))
        }
        ))
    }
    , F$ = [100, 300]
    , $$ = (t, e = {}) => {
        cf(() => {
            const n = t_()
                , s = rh("FID");
            let r;
            const i = a => {
                a.startTime < n.firstHiddenTime && (s.value = a.processingStart - a.startTime,
                    s.entries.push(a),
                    r(!0))
            }
                , o = a => {
                    a.forEach(i)
                }
                , l = bc("first-input", o);
            r = sh(t, s, F$, e.reportAllChanges),
                l && ih(e_(() => {
                    o(l.takeRecords()),
                        l.disconnect()
                }
                ))
        }
        )
    }
    ;
let xR = 0
    , v0 = 1 / 0
    , Hf = 0;
const U$ = t => {
    t.forEach(e => {
        e.interactionId && (v0 = Math.min(v0, e.interactionId),
            Hf = Math.max(Hf, e.interactionId),
            xR = Hf ? (Hf - v0) / 7 + 1 : 0)
    }
    )
}
    ;
let xy;
const V$ = () => xy ? xR : performance.interactionCount || 0
    , G$ = () => {
        "interactionCount" in performance || xy || (xy = bc("event", U$, {
            type: "event",
            buffered: !0,
            durationThreshold: 0
        }))
    }
    , fo = []
    , x0 = new Map
    , H$ = 40;
let W$ = 0;
const Y$ = () => V$() - W$
    , X$ = () => {
        const t = Math.min(fo.length - 1, Math.floor(Y$() / 50));
        return fo[t]
    }
    , w0 = 10
    , j$ = []
    , z$ = t => {
        if (j$.forEach(s => s(t)),
            !(t.interactionId || t.entryType === "first-input"))
            return;
        const e = fo[fo.length - 1]
            , n = x0.get(t.interactionId);
        if (n || fo.length < w0 || e && t.duration > e.latency) {
            if (n)
                t.duration > n.latency ? (n.entries = [t],
                    n.latency = t.duration) : t.duration === n.latency && t.startTime === (n.entries[0] && n.entries[0].startTime) && n.entries.push(t);
            else {
                const s = {
                    id: t.interactionId,
                    latency: t.duration,
                    entries: [t]
                };
                x0.set(s.id, s),
                    fo.push(s)
            }
            fo.sort((s, r) => r.latency - s.latency),
                fo.length > w0 && fo.splice(w0).forEach(s => x0.delete(s.id))
        }
    }
    , wR = t => {
        const e = je.requestIdleCallback || je.setTimeout;
        let n = -1;
        return t = e_(t),
            je.document && je.document.visibilityState === "hidden" ? t() : (n = e(t),
                ih(t)),
            n
    }
    , q$ = [200, 500]
    , K$ = (t, e = {}) => {
        "PerformanceEventTiming" in je && "interactionId" in PerformanceEventTiming.prototype && cf(() => {
            G$();
            const n = rh("INP");
            let s;
            const r = o => {
                wR(() => {
                    o.forEach(z$);
                    const l = X$();
                    l && l.latency !== n.value && (n.value = l.latency,
                        n.entries = l.entries,
                        s())
                }
                )
            }
                , i = bc("event", r, {
                    durationThreshold: e.durationThreshold != null ? e.durationThreshold : H$
                });
            s = sh(t, n, q$, e.reportAllChanges),
                i && (i.observe({
                    type: "first-input",
                    buffered: !0
                }),
                    ih(() => {
                        r(i.takeRecords()),
                            s(!0)
                    }
                    ))
        }
        )
    }
    , J$ = [2500, 4e3]
    , LT = {}
    , Z$ = (t, e = {}) => {
        cf(() => {
            const n = t_()
                , s = rh("LCP");
            let r;
            const i = l => {
                e.reportAllChanges || (l = l.slice(-1)),
                    l.forEach(a => {
                        a.startTime < n.firstHiddenTime && (s.value = Math.max(a.startTime - lf(), 0),
                            s.entries = [a],
                            r())
                    }
                    )
            }
                , o = bc("largest-contentful-paint", i);
            if (o) {
                r = sh(t, s, J$, e.reportAllChanges);
                const l = e_(() => {
                    LT[s.id] || (i(o.takeRecords()),
                        o.disconnect(),
                        LT[s.id] = !0,
                        r(!0))
                }
                );
                ["keydown", "click"].forEach(a => {
                    je.document && addEventListener(a, () => wR(l), {
                        once: !0,
                        capture: !0
                    })
                }
                ),
                    ih(l)
            }
        }
        )
    }
    , Q$ = [800, 1800]
    , wy = t => {
        je.document && je.document.prerendering ? cf(() => wy(t)) : je.document && je.document.readyState !== "complete" ? addEventListener("load", () => wy(t), !0) : setTimeout(t, 0)
    }
    , eU = (t, e = {}) => {
        const n = rh("TTFB")
            , s = sh(t, n, Q$, e.reportAllChanges);
        wy(() => {
            const r = af();
            r && (n.value = Math.max(r.responseStart - lf(), 0),
                n.entries = [r],
                s(!0))
        }
        )
    }
    , Zh = {}
    , xm = {};
let SR, ER, TR, CR, IR;
function tx(t, e = !1) {
    return uf("cls", t, nU, SR, e)
}
function AR(t, e = !1) {
    return uf("lcp", t, rU, TR, e)
}
function kR(t) {
    return uf("fid", t, sU, ER)
}
function tU(t) {
    return uf("ttfb", t, iU, CR)
}
function RR(t) {
    return uf("inp", t, oU, IR)
}
function Nu(t, e) {
    return MR(t, e),
        xm[t] || (aU(t),
            xm[t] = !0),
        PR(t, e)
}
function oh(t, e) {
    const n = Zh[t];
    if (!(!n || !n.length))
        for (const s of n)
            try {
                s(e)
            } catch (r) {
                ex && Re.error(`Error while triggering instrumentation handler.
Type: ${t}
Name: ${Ro(s)}
Error:`, r)
            }
}
function nU() {
    return B$(t => {
        oh("cls", {
            metric: t
        }),
            SR = t
    }
        , {
            reportAllChanges: !0
        })
}
function sU() {
    return $$(t => {
        oh("fid", {
            metric: t
        }),
            ER = t
    }
    )
}
function rU() {
    return Z$(t => {
        oh("lcp", {
            metric: t
        }),
            TR = t
    }
        , {
            reportAllChanges: !0
        })
}
function iU() {
    return eU(t => {
        oh("ttfb", {
            metric: t
        }),
            CR = t
    }
    )
}
function oU() {
    return K$(t => {
        oh("inp", {
            metric: t
        }),
            IR = t
    }
    )
}
function uf(t, e, n, s, r = !1) {
    MR(t, e);
    let i;
    return xm[t] || (i = n(),
        xm[t] = !0),
        s && e({
            metric: s
        }),
        PR(t, e, r ? i : void 0)
}
function aU(t) {
    const e = {};
    t === "event" && (e.durationThreshold = 0),
        bc(t, n => {
            oh(t, {
                entries: n
            })
        }
            , e)
}
function MR(t, e) {
    Zh[t] = Zh[t] || [],
        Zh[t].push(e)
}
function PR(t, e, n) {
    return () => {
        n && n();
        const s = Zh[t];
        if (!s)
            return;
        const r = s.indexOf(e);
        r !== -1 && s.splice(r, 1)
    }
}
function lU(t) {
    return "duration" in t
}
function S0(t) {
    return typeof t == "number" && isFinite(t)
}
function Do(t, e, n, { ...s }) {
    const r = It(t).start_timestamp;
    return r && r > e && typeof t.updateStartTime == "function" && t.updateStartTime(e),
        Qk(t, () => {
            const i = ec({
                startTime: e,
                ...s
            });
            return i && i.end(n),
                i
        }
        )
}
function LR(t) {
    const e = bt();
    if (!e)
        return;
    const { name: n, transaction: s, attributes: r, startTime: i } = t
        , { release: o, environment: l } = e.getOptions()
        , a = e.getIntegrationByName("Replay")
        , c = a && a.getReplayId()
        , u = Ut()
        , h = u.getUser()
        , d = h !== void 0 ? h.email || h.id || h.ip_address : void 0;
    let f;
    try {
        f = u.getScopeData().contexts.profile.profile_id
    } catch { }
    const p = {
        release: o,
        environment: l,
        user: d || void 0,
        profile_id: f || void 0,
        replay_id: c || void 0,
        transaction: s,
        "user_agent.original": je.navigator && je.navigator.userAgent,
        ...r
    };
    return ec({
        name: n,
        attributes: p,
        startTime: i,
        experimental: {
            standalone: !0
        }
    })
}
function nx() {
    return je && je.addEventListener && je.performance
}
function yn(t) {
    return t / 1e3
}
function cU() {
    let t = 0, e, n;
    if (!hU())
        return;
    let s = !1;
    function r() {
        s || (s = !0,
            n && uU(t, e, n),
            i())
    }
    const i = tx(({ metric: o }) => {
        const l = o.entries[o.entries.length - 1];
        l && (t = o.value,
            e = l)
    }
        , !0);
    ih(() => {
        r()
    }
    ),
        setTimeout(() => {
            const o = bt();
            if (!o)
                return;
            const l = o.on("startNavigationSpan", () => {
                r(),
                    l && l()
            }
            )
                , a = Cn()
                , c = a && zn(a)
                , u = c && It(c);
            u && u.op === "pageload" && (n = c.spanContext().spanId)
        }
            , 0)
}
function uU(t, e, n) {
    ex && Re.log(`Sending CLS span (${t})`);
    const s = yn((Ps || 0) + (e && e.startTime || 0))
        , r = Ut().getScopeData().transactionName
        , i = e ? Po(e.sources[0] && e.sources[0].node) : "Layout shift"
        , o = On({
            [an]: "auto.http.browser.cls",
            [Ql]: "ui.webvital.cls",
            [Xv]: e && e.duration || 0,
            "sentry.pageload.span_id": n
        })
        , l = LR({
            name: i,
            transaction: r,
            attributes: o,
            startTime: s
        });
    l && (l.addEvent("cls", {
        [Zg]: "",
        [Qg]: t
    }),
        l.end(s))
}
function hU() {
    try {
        return PerformanceObserver.supportedEntryTypes.includes("layout-shift")
    } catch {
        return !1
    }
}
const dU = 2147483647;
let OT = 0, es = {}, Fs, Qh;
function fU({ recordClsStandaloneSpans: t }) {
    const e = nx();
    if (e && Ps) {
        e.mark && je.performance.mark("sentry-tracing-init");
        const n = bU()
            , s = yU()
            , r = vU()
            , i = t ? cU() : _U();
        return () => {
            n(),
                s(),
                r(),
                i && i()
        }
    }
    return () => { }
}
function pU() {
    Nu("longtask", ({ entries: t }) => {
        const e = Cn();
        if (!e)
            return;
        const { op: n, start_timestamp: s } = It(e);
        for (const r of t) {
            const i = yn(Ps + r.startTime)
                , o = yn(r.duration);
            n === "navigation" && s && i < s || Do(e, i, i + o, {
                name: "Main UI thread blocked",
                op: "ui.long-task",
                attributes: {
                    [an]: "auto.ui.browser.metrics"
                }
            })
        }
    }
    )
}
function mU() {
    new PerformanceObserver(e => {
        const n = Cn();
        if (n)
            for (const s of e.getEntries()) {
                if (!s.scripts[0])
                    continue;
                const r = yn(Ps + s.startTime)
                    , { start_timestamp: i, op: o } = It(n);
                if (o === "navigation" && i && r < i)
                    continue;
                const l = yn(s.duration)
                    , a = {
                        [an]: "auto.ui.browser.metrics"
                    }
                    , c = s.scripts[0]
                    , { invoker: u, invokerType: h, sourceURL: d, sourceFunctionName: f, sourceCharPosition: p } = c;
                a["browser.script.invoker"] = u,
                    a["browser.script.invoker_type"] = h,
                    d && (a["code.filepath"] = d),
                    f && (a["code.function"] = f),
                    p !== -1 && (a["browser.script.source_char_position"] = p),
                    Do(n, r, r + l, {
                        name: "Main UI thread blocked",
                        op: "ui.long-animation-frame",
                        attributes: a
                    })
            }
    }
    ).observe({
        type: "long-animation-frame",
        buffered: !0
    })
}
function gU() {
    Nu("event", ({ entries: t }) => {
        const e = Cn();
        if (e) {
            for (const n of t)
                if (n.name === "click") {
                    const s = yn(Ps + n.startTime)
                        , r = yn(n.duration)
                        , i = {
                            name: Po(n.target),
                            op: `ui.interaction.${n.name}`,
                            startTime: s,
                            attributes: {
                                [an]: "auto.ui.browser.metrics"
                            }
                        }
                        , o = Ak(n.target);
                    o && (i.attributes["ui.component_name"] = o),
                        Do(e, s, s + r, i)
                }
        }
    }
    )
}
function _U() {
    return tx(({ metric: t }) => {
        const e = t.entries[t.entries.length - 1];
        e && (es.cls = {
            value: t.value,
            unit: ""
        },
            Qh = e)
    }
        , !0)
}
function yU() {
    return AR(({ metric: t }) => {
        const e = t.entries[t.entries.length - 1];
        e && (es.lcp = {
            value: t.value,
            unit: "millisecond"
        },
            Fs = e)
    }
        , !0)
}
function bU() {
    return kR(({ metric: t }) => {
        const e = t.entries[t.entries.length - 1];
        if (!e)
            return;
        const n = yn(Ps)
            , s = yn(e.startTime);
        es.fid = {
            value: t.value,
            unit: "millisecond"
        },
            es["mark.fid"] = {
                value: n + s,
                unit: "second"
            }
    }
    )
}
function vU() {
    return tU(({ metric: t }) => {
        t.entries[t.entries.length - 1] && (es.ttfb = {
            value: t.value,
            unit: "millisecond"
        })
    }
    )
}
function xU(t, e) {
    const n = nx();
    if (!n || !je.performance.getEntries || !Ps)
        return;
    const s = yn(Ps)
        , r = n.getEntries()
        , { op: i, start_timestamp: o } = It(t);
    if (r.slice(OT).forEach(l => {
        const a = yn(l.startTime)
            , c = yn(Math.max(0, l.duration));
        if (!(i === "navigation" && o && s + a < o))
            switch (l.entryType) {
                case "navigation":
                    {
                        SU(t, l, s);
                        break
                    }
                case "mark":
                case "paint":
                case "measure":
                    {
                        wU(t, l, a, c, s);
                        const u = t_()
                            , h = l.startTime < u.firstHiddenTime;
                        l.name === "first-paint" && h && (es.fp = {
                            value: l.startTime,
                            unit: "millisecond"
                        }),
                            l.name === "first-contentful-paint" && h && (es.fcp = {
                                value: l.startTime,
                                unit: "millisecond"
                            });
                        break
                    }
                case "resource":
                    {
                        TU(t, l, l.name, a, c, s);
                        break
                    }
            }
    }
    ),
        OT = Math.max(r.length - 1, 0),
        CU(t),
        i === "pageload") {
        AU(es);
        const l = es["mark.fid"];
        l && es.fid && (Do(t, l.value, l.value + yn(es.fid.value), {
            name: "first input delay",
            op: "ui.action",
            attributes: {
                [an]: "auto.ui.browser.metrics"
            }
        }),
            delete es["mark.fid"]),
            (!("fcp" in es) || !e.recordClsOnPageloadSpan) && delete es.cls,
            Object.entries(es).forEach(([a, c]) => {
                v7(a, c.value, c.unit)
            }
            ),
            t.setAttribute("performance.timeOrigin", s),
            t.setAttribute("performance.activationStart", lf()),
            IU(t)
    }
    Fs = void 0,
        Qh = void 0,
        es = {}
}
function wU(t, e, n, s, r) {
    const i = af(!1)
        , o = yn(i ? i.requestStart : 0)
        , l = r + Math.max(n, o)
        , a = r + n
        , c = a + s
        , u = {
            [an]: "auto.resource.browser.metrics"
        };
    return l !== a && (u["sentry.browser.measure_happened_before_request"] = !0,
        u["sentry.browser.measure_start_time"] = l),
        Do(t, l, c, {
            name: e.name,
            op: e.entryType,
            attributes: u
        }),
        l
}
function SU(t, e, n) {
    ["unloadEvent", "redirect", "domContentLoadedEvent", "loadEvent", "connect"].forEach(s => {
        Wf(t, e, s, n)
    }
    ),
        Wf(t, e, "secureConnection", n, "TLS/SSL", "connectEnd"),
        Wf(t, e, "fetch", n, "cache", "domainLookupStart"),
        Wf(t, e, "domainLookup", n, "DNS"),
        EU(t, e, n)
}
function Wf(t, e, n, s, r, i) {
    const o = i ? e[i] : e[`${n}End`]
        , l = e[`${n}Start`];
    !l || !o || Do(t, s + yn(l), s + yn(o), {
        op: `browser.${r || n}`,
        name: e.name,
        attributes: {
            [an]: "auto.ui.browser.metrics"
        }
    })
}
function EU(t, e, n) {
    const s = n + yn(e.requestStart)
        , r = n + yn(e.responseEnd)
        , i = n + yn(e.responseStart);
    e.responseEnd && (Do(t, s, r, {
        op: "browser.request",
        name: e.name,
        attributes: {
            [an]: "auto.ui.browser.metrics"
        }
    }),
        Do(t, i, r, {
            op: "browser.response",
            name: e.name,
            attributes: {
                [an]: "auto.ui.browser.metrics"
            }
        }))
}
function TU(t, e, n, s, r, i) {
    if (e.initiatorType === "xmlhttprequest" || e.initiatorType === "fetch")
        return;
    const o = Hl(n)
        , l = {
            [an]: "auto.resource.browser.metrics"
        };
    E0(l, e, "transferSize", "http.response_transfer_size"),
        E0(l, e, "encodedBodySize", "http.response_content_length"),
        E0(l, e, "decodedBodySize", "http.decoded_response_content_length"),
        e.deliveryType != null && (l["http.response_delivery_type"] = e.deliveryType),
        "renderBlockingStatus" in e && (l["resource.render_blocking_status"] = e.renderBlockingStatus),
        o.protocol && (l["url.scheme"] = o.protocol.split(":").pop()),
        o.host && (l["server.address"] = o.host),
        l["url.same_origin"] = n.includes(je.location.origin);
    const a = i + s
        , c = a + r;
    Do(t, a, c, {
        name: n.replace(je.location.origin, ""),
        op: e.initiatorType ? `resource.${e.initiatorType}` : "resource.other",
        attributes: l
    })
}
function CU(t) {
    const e = je.navigator;
    if (!e)
        return;
    const n = e.connection;
    n && (n.effectiveType && t.setAttribute("effectiveConnectionType", n.effectiveType),
        n.type && t.setAttribute("connectionType", n.type),
        S0(n.rtt) && (es["connection.rtt"] = {
            value: n.rtt,
            unit: "millisecond"
        })),
        S0(e.deviceMemory) && t.setAttribute("deviceMemory", `${e.deviceMemory} GB`),
        S0(e.hardwareConcurrency) && t.setAttribute("hardwareConcurrency", String(e.hardwareConcurrency))
}
function IU(t) {
    Fs && (Fs.element && t.setAttribute("lcp.element", Po(Fs.element)),
        Fs.id && t.setAttribute("lcp.id", Fs.id),
        Fs.url && t.setAttribute("lcp.url", Fs.url.trim().slice(0, 200)),
        Fs.loadTime != null && t.setAttribute("lcp.loadTime", Fs.loadTime),
        Fs.renderTime != null && t.setAttribute("lcp.renderTime", Fs.renderTime),
        t.setAttribute("lcp.size", Fs.size)),
        Qh && Qh.sources && Qh.sources.forEach((e, n) => t.setAttribute(`cls.source.${n + 1}`, Po(e.node)))
}
function E0(t, e, n, s) {
    const r = e[n];
    r != null && r < dU && (t[s] = r)
}
function AU(t) {
    const e = af(!1);
    if (!e)
        return;
    const { responseStart: n, requestStart: s } = e;
    s <= n && (t["ttfb.requestTime"] = {
        value: n - s,
        unit: "millisecond"
    })
}
const kU = 1e3;
let NT, Sy, Ey;
function OR(t) {
    const e = "dom";
    tl(e, t),
        nl(e, RU)
}
function RU() {
    if (!je.document)
        return;
    const t = Rr.bind(null, "dom")
        , e = DT(t, !0);
    je.document.addEventListener("click", e, !1),
        je.document.addEventListener("keypress", e, !1),
        ["EventTarget", "Node"].forEach(n => {
            const r = je[n]
                , i = r && r.prototype;
            !i || !i.hasOwnProperty || !i.hasOwnProperty("addEventListener") || (Ys(i, "addEventListener", function (o) {
                return function (l, a, c) {
                    if (l === "click" || l == "keypress")
                        try {
                            const u = this.__sentry_instrumentation_handlers__ = this.__sentry_instrumentation_handlers__ || {}
                                , h = u[l] = u[l] || {
                                    refCount: 0
                                };
                            if (!h.handler) {
                                const d = DT(t);
                                h.handler = d,
                                    o.call(this, l, d, c)
                            }
                            h.refCount++
                        } catch { }
                    return o.call(this, l, a, c)
                }
            }),
                Ys(i, "removeEventListener", function (o) {
                    return function (l, a, c) {
                        if (l === "click" || l == "keypress")
                            try {
                                const u = this.__sentry_instrumentation_handlers__ || {}
                                    , h = u[l];
                                h && (h.refCount--,
                                    h.refCount <= 0 && (o.call(this, l, h.handler, c),
                                        h.handler = void 0,
                                        delete u[l]),
                                    Object.keys(u).length === 0 && delete this.__sentry_instrumentation_handlers__)
                            } catch { }
                        return o.call(this, l, a, c)
                    }
                }))
        }
        )
}
function MU(t) {
    if (t.type !== Sy)
        return !1;
    try {
        if (!t.target || t.target._sentryId !== Ey)
            return !1
    } catch { }
    return !0
}
function PU(t, e) {
    return t !== "keypress" ? !1 : !e || !e.tagName ? !0 : !(e.tagName === "INPUT" || e.tagName === "TEXTAREA" || e.isContentEditable)
}
function DT(t, e = !1) {
    return n => {
        if (!n || n._sentryCaptured)
            return;
        const s = LU(n);
        if (PU(n.type, s))
            return;
        Pr(n, "_sentryCaptured", !0),
            s && !s._sentryId && Pr(s, "_sentryId", Nn());
        const r = n.type === "keypress" ? "input" : n.type;
        MU(n) || (t({
            event: n,
            name: r,
            global: e
        }),
            Sy = n.type,
            Ey = s ? s._sentryId : void 0),
            clearTimeout(NT),
            NT = je.setTimeout(() => {
                Ey = void 0,
                    Sy = void 0
            }
                , kU)
    }
}
function LU(t) {
    try {
        return t.target
    } catch {
        return null
    }
}
let Yf;
function n_(t) {
    const e = "history";
    tl(e, t),
        nl(e, OU)
}
function OU() {
    if (!d$())
        return;
    const t = je.onpopstate;
    je.onpopstate = function (...n) {
        const s = je.location.href
            , r = Yf;
        if (Yf = s,
            Rr("history", {
                from: r,
                to: s
            }),
            t)
            try {
                return t.apply(this, n)
            } catch { }
    }
        ;
    function e(n) {
        return function (...s) {
            const r = s.length > 2 ? s[2] : void 0;
            if (r) {
                const i = Yf
                    , o = String(r);
                Yf = o,
                    Rr("history", {
                        from: i,
                        to: o
                    })
            }
            return n.apply(this, s)
        }
    }
    Ys(je.history, "pushState", e),
        Ys(je.history, "replaceState", e)
}
const Fp = {};
function NR(t) {
    const e = Fp[t];
    if (e)
        return e;
    let n = je[t];
    if (_y(n))
        return Fp[t] = n.bind(je);
    const s = je.document;
    if (s && typeof s.createElement == "function")
        try {
            const r = s.createElement("iframe");
            r.hidden = !0,
                s.head.appendChild(r);
            const i = r.contentWindow;
            i && i[t] && (n = i[t]),
                s.head.removeChild(r)
        } catch (r) {
            ex && Re.warn(`Could not create sandbox iframe for ${t} check, bailing to window.${t}: `, r)
        }
    return n && (Fp[t] = n.bind(je))
}
function BT(t) {
    Fp[t] = void 0
}
function Du(...t) {
    return NR("setTimeout")(...t)
}
const Pl = "__sentry_xhr_v3__";
function DR(t) {
    const e = "xhr";
    tl(e, t),
        nl(e, NU)
}
function NU() {
    if (!je.XMLHttpRequest)
        return;
    const t = XMLHttpRequest.prototype;
    t.open = new Proxy(t.open, {
        apply(e, n, s) {
            const r = ps() * 1e3
                , i = Co(s[0]) ? s[0].toUpperCase() : void 0
                , o = DU(s[1]);
            if (!i || !o)
                return e.apply(n, s);
            n[Pl] = {
                method: i,
                url: o,
                request_headers: {}
            },
                i === "POST" && o.match(/sentry_key/) && (n.__sentry_own_request__ = !0);
            const l = () => {
                const a = n[Pl];
                if (a && n.readyState === 4) {
                    try {
                        a.status_code = n.status
                    } catch { }
                    const c = {
                        endTimestamp: ps() * 1e3,
                        startTimestamp: r,
                        xhr: n
                    };
                    Rr("xhr", c)
                }
            }
                ;
            return "onreadystatechange" in n && typeof n.onreadystatechange == "function" ? n.onreadystatechange = new Proxy(n.onreadystatechange, {
                apply(a, c, u) {
                    return l(),
                        a.apply(c, u)
                }
            }) : n.addEventListener("readystatechange", l),
                n.setRequestHeader = new Proxy(n.setRequestHeader, {
                    apply(a, c, u) {
                        const [h, d] = u
                            , f = c[Pl];
                        return f && Co(h) && Co(d) && (f.request_headers[h.toLowerCase()] = d),
                            a.apply(c, u)
                    }
                }),
                e.apply(n, s)
        }
    }),
        t.send = new Proxy(t.send, {
            apply(e, n, s) {
                const r = n[Pl];
                if (!r)
                    return e.apply(n, s);
                s[0] !== void 0 && (r.body = s[0]);
                const i = {
                    startTimestamp: ps() * 1e3,
                    xhr: n
                };
                return Rr("xhr", i),
                    e.apply(n, s)
            }
        })
}
function DU(t) {
    if (Co(t))
        return t;
    try {
        return t.toString()
    } catch { }
}
const T0 = []
    , $p = new Map;
function BU() {
    if (nx() && Ps) {
        const e = FU();
        return () => {
            e()
        }
    }
    return () => { }
}
const FT = {
    click: "click",
    pointerdown: "click",
    pointerup: "click",
    mousedown: "click",
    mouseup: "click",
    touchstart: "click",
    touchend: "click",
    mouseover: "hover",
    mouseout: "hover",
    mouseenter: "hover",
    mouseleave: "hover",
    pointerover: "hover",
    pointerout: "hover",
    pointerenter: "hover",
    pointerleave: "hover",
    dragstart: "drag",
    dragend: "drag",
    drag: "drag",
    dragenter: "drag",
    dragleave: "drag",
    dragover: "drag",
    drop: "drag",
    keydown: "press",
    keyup: "press",
    keypress: "press",
    input: "press"
};
function FU() {
    return RR(({ metric: t }) => {
        if (t.value == null)
            return;
        const e = t.entries.find(p => p.duration === t.value && FT[p.name]);
        if (!e)
            return;
        const { interactionId: n } = e
            , s = FT[e.name]
            , r = yn(Ps + e.startTime)
            , i = yn(t.value)
            , o = Cn()
            , l = o ? zn(o) : void 0
            , c = (n != null ? $p.get(n) : void 0) || l
            , u = c ? It(c).description : Ut().getScopeData().transactionName
            , h = Po(e.target)
            , d = On({
                [an]: "auto.http.browser.inp",
                [Ql]: `ui.interaction.${s}`,
                [Xv]: e.duration
            })
            , f = LR({
                name: h,
                transaction: u,
                attributes: d,
                startTime: r
            });
        f && (f.addEvent("inp", {
            [Zg]: "millisecond",
            [Qg]: t.value
        }),
            f.end(r + i))
    }
    )
}
function $U(t) {
    const e = ({ entries: n }) => {
        const s = Cn()
            , r = s && zn(s);
        n.forEach(i => {
            if (!lU(i) || !r)
                return;
            const o = i.interactionId;
            if (o != null && !$p.has(o)) {
                if (T0.length > 10) {
                    const l = T0.shift();
                    $p.delete(l)
                }
                T0.push(o),
                    $p.set(o, r)
            }
        }
        )
    }
        ;
    Nu("event", e),
        Nu("first-input", e)
}
function UU(t, e = NR("fetch")) {
    let n = 0
        , s = 0;
    function r(i) {
        const o = i.body.length;
        n += o,
            s++;
        const l = {
            body: i.body,
            method: "POST",
            referrerPolicy: "origin",
            headers: t.headers,
            keepalive: n <= 6e4 && s < 15,
            ...t.fetchOptions
        };
        if (!e)
            return BT("fetch"),
                mm("No fetch implementation available");
        try {
            return e(t.url, l).then(a => (n -= o,
                s--,
            {
                statusCode: a.status,
                headers: {
                    "x-sentry-rate-limits": a.headers.get("X-Sentry-Rate-Limits"),
                    "retry-after": a.headers.get("Retry-After")
                }
            }))
        } catch (a) {
            return BT("fetch"),
                n -= o,
                s--,
                mm(a)
        }
    }
    return _F(t, r)
}
const VU = 30
    , GU = 50;
function Ty(t, e, n, s) {
    const r = {
        filename: t,
        function: e === "<anonymous>" ? Zl : e,
        in_app: !0
    };
    return n !== void 0 && (r.lineno = n),
        s !== void 0 && (r.colno = s),
        r
}
const HU = /^\s*at (\S+?)(?::(\d+))(?::(\d+))\s*$/i
    , WU = /^\s*at (?:(.+?\)(?: \[.+\])?|.*?) ?\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\/)?.*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i
    , YU = /\((\S*)(?::(\d+))(?::(\d+))\)/
    , XU = t => {
        const e = HU.exec(t);
        if (e) {
            const [, s, r, i] = e;
            return Ty(s, Zl, +r, +i)
        }
        const n = WU.exec(t);
        if (n) {
            if (n[2] && n[2].indexOf("eval") === 0) {
                const o = YU.exec(n[2]);
                o && (n[2] = o[1],
                    n[3] = o[2],
                    n[4] = o[3])
            }
            const [r, i] = BR(n[1] || Zl, n[2]);
            return Ty(i, r, n[3] ? +n[3] : void 0, n[4] ? +n[4] : void 0)
        }
    }
    , jU = [VU, XU]
    , zU = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:[-a-z]+)?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i
    , qU = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i
    , KU = t => {
        const e = zU.exec(t);
        if (e) {
            if (e[3] && e[3].indexOf(" > eval") > -1) {
                const i = qU.exec(e[3]);
                i && (e[1] = e[1] || "eval",
                    e[3] = i[1],
                    e[4] = i[2],
                    e[5] = "")
            }
            let s = e[3]
                , r = e[1] || Zl;
            return [r, s] = BR(r, s),
                Ty(s, r, e[4] ? +e[4] : void 0, e[5] ? +e[5] : void 0)
        }
    }
    , JU = [GU, KU]
    , ZU = [jU, JU]
    , QU = xk(...ZU)
    , BR = (t, e) => {
        const n = t.indexOf("safari-extension") !== -1
            , s = t.indexOf("safari-web-extension") !== -1;
        return n || s ? [t.indexOf("@") !== -1 ? t.split("@")[0] : Zl, n ? `safari-extension:${e}` : `safari-web-extension:${e}`] : [t, e]
    }
    , Xf = 1024
    , eV = "Breadcrumbs"
    , tV = (t = {}) => {
        const e = {
            console: !0,
            dom: !0,
            fetch: !0,
            history: !0,
            sentry: !0,
            xhr: !0,
            ...t
        };
        return {
            name: eV,
            setup(n) {
                e.console && HF(iV(n)),
                    e.dom && OR(rV(n, e.dom)),
                    e.xhr && DR(oV(n)),
                    e.fetch && _R(aV(n)),
                    e.history && n_(lV(n)),
                    e.sentry && n.on("beforeSendEvent", sV(n))
            }
        }
    }
    , nV = tV;
function sV(t) {
    return function (n) {
        bt() === t && Ya({
            category: `sentry.${n.type === "transaction" ? "transaction" : "event"}`,
            event_id: n.event_id,
            level: n.level,
            message: ma(n)
        }, {
            event: n
        })
    }
}
function rV(t, e) {
    return function (s) {
        if (bt() !== t)
            return;
        let r, i, o = typeof e == "object" ? e.serializeAttribute : void 0, l = typeof e == "object" && typeof e.maxStringLength == "number" ? e.maxStringLength : void 0;
        l && l > Xf && (Xi && Re.warn(`\`dom.maxStringLength\` cannot exceed ${Xf}, but a value of ${l} was configured. Sentry will use ${Xf} instead.`),
            l = Xf),
            typeof o == "string" && (o = [o]);
        try {
            const c = s.event
                , u = cV(c) ? c.target : c;
            r = Po(u, {
                keyAttrs: o,
                maxStringLength: l
            }),
                i = Ak(u)
        } catch {
            r = "<unknown>"
        }
        if (r.length === 0)
            return;
        const a = {
            category: `ui.${s.name}`,
            message: r
        };
        i && (a.data = {
            "ui.component_name": i
        }),
            Ya(a, {
                event: s.event,
                name: s.name,
                global: s.global
            })
    }
}
function iV(t) {
    return function (n) {
        if (bt() !== t)
            return;
        const s = {
            category: "console",
            data: {
                arguments: n.args,
                logger: "console"
            },
            level: dR(n.level),
            message: ZE(n.args, " ")
        };
        if (n.level === "assert")
            if (n.args[0] === !1)
                s.message = `Assertion failed: ${ZE(n.args.slice(1), " ") || "console.assert"}`,
                    s.data.arguments = n.args.slice(1);
            else
                return;
        Ya(s, {
            input: n.args,
            level: n.level
        })
    }
}
function oV(t) {
    return function (n) {
        if (bt() !== t)
            return;
        const { startTimestamp: s, endTimestamp: r } = n
            , i = n.xhr[Pl];
        if (!s || !r || !i)
            return;
        const { method: o, url: l, status_code: a, body: c } = i
            , u = {
                method: o,
                url: l,
                status_code: a
            }
            , h = {
                xhr: n.xhr,
                input: c,
                startTimestamp: s,
                endTimestamp: r
            }
            , d = mR(a);
        Ya({
            category: "xhr",
            data: u,
            type: "http",
            level: d
        }, h)
    }
}
function aV(t) {
    return function (n) {
        if (bt() !== t)
            return;
        const { startTimestamp: s, endTimestamp: r } = n;
        if (r && !(n.fetchData.url.match(/sentry_key/) && n.fetchData.method === "POST"))
            if (n.error) {
                const i = n.fetchData
                    , o = {
                        data: n.error,
                        input: n.args,
                        startTimestamp: s,
                        endTimestamp: r
                    };
                Ya({
                    category: "fetch",
                    data: i,
                    level: "error",
                    type: "http"
                }, o)
            } else {
                const i = n.response
                    , o = {
                        ...n.fetchData,
                        status_code: i && i.status
                    }
                    , l = {
                        input: n.args,
                        response: i,
                        startTimestamp: s,
                        endTimestamp: r
                    }
                    , a = mR(o.status_code);
                Ya({
                    category: "fetch",
                    data: o,
                    type: "http",
                    level: a
                }, l)
            }
    }
}
function lV(t) {
    return function (n) {
        if (bt() !== t)
            return;
        let s = n.from
            , r = n.to;
        const i = Hl(rt.location.href);
        let o = s ? Hl(s) : void 0;
        const l = Hl(r);
        (!o || !o.path) && (o = i),
            i.protocol === l.protocol && i.host === l.host && (r = l.relative),
            i.protocol === o.protocol && i.host === o.host && (s = o.relative),
            Ya({
                category: "navigation",
                data: {
                    from: s,
                    to: r
                }
            })
    }
}
function cV(t) {
    return !!t && !!t.target
}
const uV = ["EventTarget", "Window", "Node", "ApplicationCache", "AudioTrackList", "BroadcastChannel", "ChannelMergerNode", "CryptoOperation", "EventSource", "FileReader", "HTMLUnknownElement", "IDBDatabase", "IDBRequest", "IDBTransaction", "KeyOperation", "MediaController", "MessagePort", "ModalWindow", "Notification", "SVGElementInstance", "Screen", "SharedWorker", "TextTrack", "TextTrackCue", "TextTrackList", "WebSocket", "WebSocketWorker", "Worker", "XMLHttpRequest", "XMLHttpRequestEventTarget", "XMLHttpRequestUpload"]
    , hV = "BrowserApiErrors"
    , dV = (t = {}) => {
        const e = {
            XMLHttpRequest: !0,
            eventTarget: !0,
            requestAnimationFrame: !0,
            setInterval: !0,
            setTimeout: !0,
            ...t
        };
        return {
            name: hV,
            setupOnce() {
                e.setTimeout && Ys(rt, "setTimeout", $T),
                    e.setInterval && Ys(rt, "setInterval", $T),
                    e.requestAnimationFrame && Ys(rt, "requestAnimationFrame", pV),
                    e.XMLHttpRequest && "XMLHttpRequest" in rt && Ys(XMLHttpRequest.prototype, "send", mV);
                const n = e.eventTarget;
                n && (Array.isArray(n) ? n : uV).forEach(gV)
            }
        }
    }
    , fV = dV;
function $T(t) {
    return function (...e) {
        const n = e[0];
        return e[0] = Ou(n, {
            mechanism: {
                data: {
                    function: Ro(t)
                },
                handled: !1,
                type: "instrument"
            }
        }),
            t.apply(this, e)
    }
}
function pV(t) {
    return function (e) {
        return t.apply(this, [Ou(e, {
            mechanism: {
                data: {
                    function: "requestAnimationFrame",
                    handler: Ro(t)
                },
                handled: !1,
                type: "instrument"
            }
        })])
    }
}
function mV(t) {
    return function (...e) {
        const n = this;
        return ["onload", "onerror", "onprogress", "onreadystatechange"].forEach(r => {
            r in n && typeof n[r] == "function" && Ys(n, r, function (i) {
                const o = {
                    mechanism: {
                        data: {
                            function: r,
                            handler: Ro(i)
                        },
                        handled: !1,
                        type: "instrument"
                    }
                }
                    , l = Hv(i);
                return l && (o.mechanism.data.handler = Ro(l)),
                    Ou(i, o)
            })
        }
        ),
            t.apply(this, e)
    }
}
function gV(t) {
    const n = rt[t]
        , s = n && n.prototype;
    !s || !s.hasOwnProperty || !s.hasOwnProperty("addEventListener") || (Ys(s, "addEventListener", function (r) {
        return function (i, o, l) {
            try {
                _V(o) && (o.handleEvent = Ou(o.handleEvent, {
                    mechanism: {
                        data: {
                            function: "handleEvent",
                            handler: Ro(o),
                            target: t
                        },
                        handled: !1,
                        type: "instrument"
                    }
                }))
            } catch { }
            return r.apply(this, [i, Ou(o, {
                mechanism: {
                    data: {
                        function: "addEventListener",
                        handler: Ro(o),
                        target: t
                    },
                    handled: !1,
                    type: "instrument"
                }
            }), l])
        }
    }),
        Ys(s, "removeEventListener", function (r) {
            return function (i, o, l) {
                try {
                    const a = o.__sentry_wrapped__;
                    a && r.call(this, i, a, l)
                } catch { }
                return r.call(this, i, o, l)
            }
        }))
}
function _V(t) {
    return typeof t.handleEvent == "function"
}
const yV = "GlobalHandlers"
    , bV = (t = {}) => {
        const e = {
            onerror: !0,
            onunhandledrejection: !0,
            ...t
        };
        return {
            name: yV,
            setupOnce() {
                Error.stackTraceLimit = 50
            },
            setup(n) {
                e.onerror && (xV(n),
                    UT("onerror")),
                    e.onunhandledrejection && (wV(n),
                        UT("onunhandledrejection"))
            }
        }
    }
    , vV = bV;
function xV(t) {
    wk(e => {
        const { stackParser: n, attachStacktrace: s } = FR();
        if (bt() !== t || bR())
            return;
        const { msg: r, url: i, line: o, column: l, error: a } = e
            , c = TV(Qv(n, a || r, void 0, s, !1), i, o, l);
        c.level = "error",
            sR(c, {
                originalException: a,
                mechanism: {
                    handled: !1,
                    type: "onerror"
                }
            })
    }
    )
}
function wV(t) {
    Sk(e => {
        const { stackParser: n, attachStacktrace: s } = FR();
        if (bt() !== t || bR())
            return;
        const r = SV(e)
            , i = Gv(r) ? EV(r) : Qv(n, r, void 0, s, !0);
        i.level = "error",
            sR(i, {
                originalException: r,
                mechanism: {
                    handled: !1,
                    type: "onunhandledrejection"
                }
            })
    }
    )
}
function SV(t) {
    if (Gv(t))
        return t;
    try {
        if ("reason" in t)
            return t.reason;
        if ("detail" in t && "reason" in t.detail)
            return t.detail.reason
    } catch { }
    return t
}
function EV(t) {
    return {
        exception: {
            values: [{
                type: "UnhandledRejection",
                value: `Non-Error promise rejection captured with value: ${String(t)}`
            }]
        }
    }
}
function TV(t, e, n, s) {
    const r = t.exception = t.exception || {}
        , i = r.values = r.values || []
        , o = i[0] = i[0] || {}
        , l = o.stacktrace = o.stacktrace || {}
        , a = l.frames = l.frames || []
        , c = isNaN(parseInt(s, 10)) ? void 0 : s
        , u = isNaN(parseInt(n, 10)) ? void 0 : n
        , h = Co(e) && e.length > 0 ? e : Ik();
    return a.length === 0 && a.push({
        colno: c,
        filename: h,
        function: Zl,
        in_app: !0,
        lineno: u
    }),
        t
}
function UT(t) {
    Xi && Re.log(`Global Handler attached: ${t}`)
}
function FR() {
    const t = bt();
    return t && t.getOptions() || {
        stackParser: () => [],
        attachStacktrace: !1
    }
}
const CV = () => ({
    name: "HttpContext",
    preprocessEvent(t) {
        if (!rt.navigator && !rt.location && !rt.document)
            return;
        const e = t.request && t.request.url || rt.location && rt.location.href
            , { referrer: n } = rt.document || {}
            , { userAgent: s } = rt.navigator || {}
            , r = {
                ...t.request && t.request.headers,
                ...n && {
                    Referer: n
                },
                ...s && {
                    "User-Agent": s
                }
            }
            , i = {
                ...t.request,
                ...e && {
                    url: e
                },
                headers: r
            };
        t.request = i
    }
})
    , IV = "cause"
    , AV = 5
    , kV = "LinkedErrors"
    , RV = (t = {}) => {
        const e = t.limit || AV
            , n = t.key || IV;
        return {
            name: kV,
            preprocessEvent(s, r, i) {
                const o = i.getOptions();
                VF(Jv, o.stackParser, o.maxValueLength, n, e, s, r)
            }
        }
    }
    , MV = RV;
function $R(t) {
    return [RF(), CF(), fV(), nV(), vV(), MV(), jF(), CV()]
}
function PV(t = {}) {
    const e = {
        defaultIntegrations: $R(),
        release: typeof __SENTRY_RELEASE__ == "string" ? __SENTRY_RELEASE__ : rt.SENTRY_RELEASE && rt.SENTRY_RELEASE.id ? rt.SENTRY_RELEASE.id : void 0,
        autoSessionTracking: !0,
        sendClientReports: !0
    };
    return t.defaultIntegrations == null && delete t.defaultIntegrations,
    {
        ...e,
        ...t
    }
}
function LV() {
    const t = typeof rt.window < "u" && rt;
    if (!t)
        return !1;
    const e = t.chrome ? "chrome" : "browser"
        , n = t[e]
        , s = n && n.runtime && n.runtime.id
        , r = rt.location && rt.location.href || ""
        , i = ["chrome-extension:", "moz-extension:", "ms-browser-extension:", "safari-web-extension:"]
        , o = !!s && rt === rt.top && i.some(a => r.startsWith(`${a}//`))
        , l = typeof t.nw < "u";
    return !!s && !o && !l
}
function OV(t = {}) {
    const e = PV(t);
    if (!e.skipBrowserExtensionCheck && LV()) {
        pi(() => {
            console.error("[Sentry] You cannot run Sentry this way in a browser extension, check: https://docs.sentry.io/platforms/javascript/best-practices/browser-extensions/")
        }
        );
        return
    }
    Xi && (gR() || Re.warn("No Fetch API detected. The Sentry SDK requires a Fetch API compatible environment to send events. Please add a Fetch API polyfill."));
    const n = {
        ...e,
        stackParser: rB(e.stackParser || QU),
        integrations: rF(e),
        transport: e.transport || UU
    }
        , s = uF(A$, n);
    return e.autoSessionTracking && NV(),
        s
}
function NV() {
    if (typeof rt.document > "u") {
        Xi && Re.warn("Session tracking in non-browser environment with @sentry/browser is not supported.");
        return
    }
    bT({
        ignoreDuration: !0
    }),
        vT(),
        n_(({ from: t, to: e }) => {
            t !== void 0 && t !== e && (bT({
                ignoreDuration: !0
            }),
                vT())
        }
        )
}
const Gt = St
    , sx = "sentryReplaySession"
    , DV = "replay_event"
    , rx = "Unable to send Replay"
    , BV = 3e5
    , FV = 9e5
    , $V = 5e3
    , UV = 5500
    , VV = 6e4
    , GV = 5e3
    , HV = 3
    , VT = 15e4
    , jf = 5e3
    , WV = 3e3
    , YV = 300
    , ix = 2e7
    , XV = 4999
    , jV = 15e3
    , GT = 36e5;
function Cy(t, e) {
    return t ?? e()
}
function Sd(t) {
    let e, n = t[0], s = 1;
    for (; s < t.length;) {
        const r = t[s]
            , i = t[s + 1];
        if (s += 2,
            (r === "optionalAccess" || r === "optionalCall") && n == null)
            return;
        r === "access" || r === "optionalAccess" ? (e = n,
            n = i(n)) : (r === "call" || r === "optionalCall") && (n = i((...o) => n.call(e, ...o)),
                e = void 0)
    }
    return n
}
var kn;
(function (t) {
    t[t.Document = 0] = "Document",
        t[t.DocumentType = 1] = "DocumentType",
        t[t.Element = 2] = "Element",
        t[t.Text = 3] = "Text",
        t[t.CDATA = 4] = "CDATA",
        t[t.Comment = 5] = "Comment"
}
)(kn || (kn = {}));
function zV(t) {
    return t.nodeType === t.ELEMENT_NODE
}
function ed(t) {
    const e = Sd([t, "optionalAccess", n => n.host]);
    return Sd([e, "optionalAccess", n => n.shadowRoot]) === t
}
function td(t) {
    return Object.prototype.toString.call(t) === "[object ShadowRoot]"
}
function qV(t) {
    return t.includes(" background-clip: text;") && !t.includes(" -webkit-background-clip: text;") && (t = t.replace(/\sbackground-clip:\s*text;/g, " -webkit-background-clip: text; background-clip: text;")),
        t
}
function KV(t) {
    const { cssText: e } = t;
    if (e.split('"').length < 3)
        return e;
    const n = ["@import", `url(${JSON.stringify(t.href)})`];
    return t.layerName === "" ? n.push("layer") : t.layerName && n.push(`layer(${t.layerName})`),
        t.supportsText && n.push(`supports(${t.supportsText})`),
        t.media.length && n.push(t.media.mediaText),
        n.join(" ") + ";"
}
function wm(t) {
    try {
        const e = t.rules || t.cssRules;
        return e ? qV(Array.from(e, UR).join("")) : null
    } catch {
        return null
    }
}
function UR(t) {
    let e;
    if (ZV(t))
        try {
            e = wm(t.styleSheet) || KV(t)
        } catch { }
    else if (QV(t) && t.selectorText.includes(":"))
        return JV(t.cssText);
    return e || t.cssText
}
function JV(t) {
    const e = /(\[(?:[\w-]+)[^\\])(:(?:[\w-]+)\])/gm;
    return t.replace(e, "$1\\$2")
}
function ZV(t) {
    return "styleSheet" in t
}
function QV(t) {
    return "selectorText" in t
}
class VR {
    constructor() {
        this.idNodeMap = new Map,
            this.nodeMetaMap = new WeakMap
    }
    getId(e) {
        if (!e)
            return -1;
        const n = Sd([this, "access", s => s.getMeta, "call", s => s(e), "optionalAccess", s => s.id]);
        return Cy(n, () => -1)
    }
    getNode(e) {
        return this.idNodeMap.get(e) || null
    }
    getIds() {
        return Array.from(this.idNodeMap.keys())
    }
    getMeta(e) {
        return this.nodeMetaMap.get(e) || null
    }
    removeNodeFromMap(e) {
        const n = this.getId(e);
        this.idNodeMap.delete(n),
            e.childNodes && e.childNodes.forEach(s => this.removeNodeFromMap(s))
    }
    has(e) {
        return this.idNodeMap.has(e)
    }
    hasNode(e) {
        return this.nodeMetaMap.has(e)
    }
    add(e, n) {
        const s = n.id;
        this.idNodeMap.set(s, e),
            this.nodeMetaMap.set(e, n)
    }
    replace(e, n) {
        const s = this.getNode(e);
        if (s) {
            const r = this.nodeMetaMap.get(s);
            r && this.nodeMetaMap.set(n, r)
        }
        this.idNodeMap.set(e, n)
    }
    reset() {
        this.idNodeMap = new Map,
            this.nodeMetaMap = new WeakMap
    }
}
function eG() {
    return new VR
}
function s_({ maskInputOptions: t, tagName: e, type: n }) {
    return e === "OPTION" && (e = "SELECT"),
        !!(t[e.toLowerCase()] || n && t[n] || n === "password" || e === "INPUT" && !n && t.text)
}
function Ed({ isMasked: t, element: e, value: n, maskInputFn: s }) {
    let r = n || "";
    return t ? (s && (r = s(r, e)),
        "*".repeat(r.length)) : r
}
function Bu(t) {
    return t.toLowerCase()
}
function Iy(t) {
    return t.toUpperCase()
}
const HT = "__rrweb_original__";
function tG(t) {
    const e = t.getContext("2d");
    if (!e)
        return !0;
    const n = 50;
    for (let s = 0; s < t.width; s += n)
        for (let r = 0; r < t.height; r += n) {
            const i = e.getImageData
                , o = HT in i ? i[HT] : i;
            if (new Uint32Array(o.call(e, s, r, Math.min(n, t.width - s), Math.min(n, t.height - r)).data.buffer).some(a => a !== 0))
                return !1
        }
    return !0
}
function ox(t) {
    const e = t.type;
    return t.hasAttribute("data-rr-is-password") ? "password" : e ? Bu(e) : null
}
function Sm(t, e, n) {
    return e === "INPUT" && (n === "radio" || n === "checkbox") ? t.getAttribute("value") || "" : t.value
}
function GR(t, e) {
    let n;
    try {
        n = new URL(t, Cy(e, () => window.location.href))
    } catch {
        return null
    }
    const s = /\.([0-9a-z]+)(?:$)/i
        , r = n.pathname.match(s);
    return Cy(Sd([r, "optionalAccess", i => i[1]]), () => null)
}
const WT = {};
function HR(t) {
    const e = WT[t];
    if (e)
        return e;
    const n = window.document;
    let s = window[t];
    if (n && typeof n.createElement == "function")
        try {
            const r = n.createElement("iframe");
            r.hidden = !0,
                n.head.appendChild(r);
            const i = r.contentWindow;
            i && i[t] && (s = i[t]),
                n.head.removeChild(r)
        } catch { }
    return WT[t] = s.bind(window)
}
function Ay(...t) {
    return HR("setTimeout")(...t)
}
function WR(...t) {
    return HR("clearTimeout")(...t)
}
let nG = 1;
const sG = new RegExp("[^a-z0-9-_:]")
    , Td = -2;
function ax() {
    return nG++
}
function rG(t) {
    if (t instanceof HTMLFormElement)
        return "form";
    const e = Bu(t.tagName);
    return sG.test(e) ? "div" : e
}
function iG(t) {
    let e = "";
    return t.indexOf("//") > -1 ? e = t.split("/").slice(0, 3).join("/") : e = t.split("/")[0],
        e = e.split("?")[0],
        e
}
let Ac, YT;
const oG = /url\((?:(')([^']*)'|(")(.*?)"|([^)]*))\)/gm
    , aG = /^(?:[a-z+]+:)?\/\//i
    , lG = /^www\..*/i
    , cG = /^(data:)([^,]*),(.*)/i;
function Em(t, e) {
    return (t || "").replace(oG, (n, s, r, i, o, l) => {
        const a = r || o || l
            , c = s || i || "";
        if (!a)
            return n;
        if (aG.test(a) || lG.test(a))
            return `url(${c}${a}${c})`;
        if (cG.test(a))
            return `url(${c}${a}${c})`;
        if (a[0] === "/")
            return `url(${c}${iG(e) + a}${c})`;
        const u = e.split("/")
            , h = a.split("/");
        u.pop();
        for (const d of h)
            d !== "." && (d === ".." ? u.pop() : u.push(d));
        return `url(${c}${u.join("/")}${c})`
    }
    )
}
const uG = /^[^ \t\n\r\u000c]+/
    , hG = /^[, \t\n\r\u000c]+/;
function dG(t, e) {
    if (e.trim() === "")
        return e;
    let n = 0;
    function s(i) {
        let o;
        const l = i.exec(e.substring(n));
        return l ? (o = l[0],
            n += o.length,
            o) : ""
    }
    const r = [];
    for (; s(hG),
        !(n >= e.length);) {
        let i = s(uG);
        if (i.slice(-1) === ",")
            i = Kc(t, i.substring(0, i.length - 1)),
                r.push(i);
        else {
            let o = "";
            i = Kc(t, i);
            let l = !1;
            for (; ;) {
                const a = e.charAt(n);
                if (a === "") {
                    r.push((i + o).trim());
                    break
                } else if (l)
                    a === ")" && (l = !1);
                else if (a === ",") {
                    n += 1,
                        r.push((i + o).trim());
                    break
                } else
                    a === "(" && (l = !0);
                o += a,
                    n += 1
            }
        }
    }
    return r.join(", ")
}
const XT = new WeakMap;
function Kc(t, e) {
    return !e || e.trim() === "" ? e : r_(t, e)
}
function fG(t) {
    return !!(t.tagName === "svg" || t.ownerSVGElement)
}
function r_(t, e) {
    let n = XT.get(t);
    if (n || (n = t.createElement("a"),
        XT.set(t, n)),
        !e)
        e = "";
    else if (e.startsWith("blob:") || e.startsWith("data:"))
        return e;
    return n.setAttribute("href", e),
        n.href
}
function YR(t, e, n, s, r, i) {
    return s && (n === "src" || n === "href" && !(e === "use" && s[0] === "#") || n === "xlink:href" && s[0] !== "#" || n === "background" && (e === "table" || e === "td" || e === "th") ? Kc(t, s) : n === "srcset" ? dG(t, s) : n === "style" ? Em(s, r_(t)) : e === "object" && n === "data" ? Kc(t, s) : typeof i == "function" ? i(n, s, r) : s)
}
function XR(t, e, n) {
    return (t === "video" || t === "audio") && e === "autoplay"
}
function pG(t, e, n, s) {
    try {
        if (s && t.matches(s))
            return !1;
        if (typeof e == "string") {
            if (t.classList.contains(e))
                return !0
        } else
            for (let r = t.classList.length; r--;) {
                const i = t.classList[r];
                if (e.test(i))
                    return !0
            }
        if (n)
            return t.matches(n)
    } catch { }
    return !1
}
function mG(t, e) {
    for (let n = t.classList.length; n--;) {
        const s = t.classList[n];
        if (e.test(s))
            return !0
    }
    return !1
}
function Ll(t, e, n = 1 / 0, s = 0) {
    return !t || t.nodeType !== t.ELEMENT_NODE || s > n ? -1 : e(t) ? s : Ll(t.parentNode, e, n, s + 1)
}
function Jc(t, e) {
    return n => {
        const s = n;
        if (s === null)
            return !1;
        try {
            if (t) {
                if (typeof t == "string") {
                    if (s.matches(`.${t}`))
                        return !0
                } else if (mG(s, t))
                    return !0
            }
            return !!(e && s.matches(e))
        } catch {
            return !1
        }
    }
}
function Fu(t, e, n, s, r, i) {
    try {
        const o = t.nodeType === t.ELEMENT_NODE ? t : t.parentElement;
        if (o === null)
            return !1;
        if (o.tagName === "INPUT") {
            const c = o.getAttribute("autocomplete");
            if (["current-password", "new-password", "cc-number", "cc-exp", "cc-exp-month", "cc-exp-year", "cc-csc"].includes(c))
                return !0
        }
        let l = -1
            , a = -1;
        if (i) {
            if (a = Ll(o, Jc(s, r)),
                a < 0)
                return !0;
            l = Ll(o, Jc(e, n), a >= 0 ? a : 1 / 0)
        } else {
            if (l = Ll(o, Jc(e, n)),
                l < 0)
                return !1;
            a = Ll(o, Jc(s, r), l >= 0 ? l : 1 / 0)
        }
        return l >= 0 ? a >= 0 ? l <= a : !0 : a >= 0 ? !1 : !!i
    } catch { }
    return !!i
}
function gG(t, e, n) {
    const s = t.contentWindow;
    if (!s)
        return;
    let r = !1, i;
    try {
        i = s.document.readyState
    } catch {
        return
    }
    if (i !== "complete") {
        const l = Ay(() => {
            r || (e(),
                r = !0)
        }
            , n);
        t.addEventListener("load", () => {
            WR(l),
                r = !0,
                e()
        }
        );
        return
    }
    const o = "about:blank";
    if (s.location.href !== o || t.src === o || t.src === "")
        return Ay(e, 0),
            t.addEventListener("load", e);
    t.addEventListener("load", e)
}
function _G(t, e, n) {
    let s = !1, r;
    try {
        r = t.sheet
    } catch {
        return
    }
    if (r)
        return;
    const i = Ay(() => {
        s || (e(),
            s = !0)
    }
        , n);
    t.addEventListener("load", () => {
        WR(i),
            s = !0,
            e()
    }
    )
}
function yG(t, e) {
    const { doc: n, mirror: s, blockClass: r, blockSelector: i, unblockSelector: o, maskAllText: l, maskAttributeFn: a, maskTextClass: c, unmaskTextClass: u, maskTextSelector: h, unmaskTextSelector: d, inlineStylesheet: f, maskInputOptions: p = {}, maskTextFn: m, maskInputFn: g, dataURLOptions: b = {}, inlineImages: v, recordCanvas: _, keepIframeSrcFn: y, newlyAddedElement: x = !1 } = e
        , w = bG(n, s);
    switch (t.nodeType) {
        case t.DOCUMENT_NODE:
            return t.compatMode !== "CSS1Compat" ? {
                type: kn.Document,
                childNodes: [],
                compatMode: t.compatMode
            } : {
                type: kn.Document,
                childNodes: []
            };
        case t.DOCUMENT_TYPE_NODE:
            return {
                type: kn.DocumentType,
                name: t.name,
                publicId: t.publicId,
                systemId: t.systemId,
                rootId: w
            };
        case t.ELEMENT_NODE:
            return xG(t, {
                doc: n,
                blockClass: r,
                blockSelector: i,
                unblockSelector: o,
                inlineStylesheet: f,
                maskAttributeFn: a,
                maskInputOptions: p,
                maskInputFn: g,
                dataURLOptions: b,
                inlineImages: v,
                recordCanvas: _,
                keepIframeSrcFn: y,
                newlyAddedElement: x,
                rootId: w,
                maskAllText: l,
                maskTextClass: c,
                unmaskTextClass: u,
                maskTextSelector: h,
                unmaskTextSelector: d
            });
        case t.TEXT_NODE:
            return vG(t, {
                doc: n,
                maskAllText: l,
                maskTextClass: c,
                unmaskTextClass: u,
                maskTextSelector: h,
                unmaskTextSelector: d,
                maskTextFn: m,
                maskInputOptions: p,
                maskInputFn: g,
                rootId: w
            });
        case t.CDATA_SECTION_NODE:
            return {
                type: kn.CDATA,
                textContent: "",
                rootId: w
            };
        case t.COMMENT_NODE:
            return {
                type: kn.Comment,
                textContent: t.textContent || "",
                rootId: w
            };
        default:
            return !1
    }
}
function bG(t, e) {
    if (!e.hasNode(t))
        return;
    const n = e.getId(t);
    return n === 1 ? void 0 : n
}
function vG(t, e) {
    const { maskAllText: n, maskTextClass: s, unmaskTextClass: r, maskTextSelector: i, unmaskTextSelector: o, maskTextFn: l, maskInputOptions: a, maskInputFn: c, rootId: u } = e
        , h = t.parentNode && t.parentNode.tagName;
    let d = t.textContent;
    const f = h === "STYLE" ? !0 : void 0
        , p = h === "SCRIPT" ? !0 : void 0
        , m = h === "TEXTAREA" ? !0 : void 0;
    if (f && d) {
        try {
            t.nextSibling || t.previousSibling || Sd([t, "access", b => b.parentNode, "access", b => b.sheet, "optionalAccess", b => b.cssRules]) && (d = wm(t.parentNode.sheet))
        } catch (b) {
            console.warn(`Cannot get CSS styles from text's parentNode. Error: ${b}`, t)
        }
        d = Em(d, r_(e.doc))
    }
    p && (d = "SCRIPT_PLACEHOLDER");
    const g = Fu(t, s, i, r, o, n);
    if (!f && !p && !m && d && g && (d = l ? l(d, t.parentElement) : d.replace(/[\S]/g, "*")),
        m && d && (a.textarea || g) && (d = c ? c(d, t.parentNode) : d.replace(/[\S]/g, "*")),
        h === "OPTION" && d) {
        const b = s_({
            type: null,
            tagName: h,
            maskInputOptions: a
        });
        d = Ed({
            isMasked: Fu(t, s, i, r, o, b),
            element: t,
            value: d,
            maskInputFn: c
        })
    }
    return {
        type: kn.Text,
        textContent: d || "",
        isStyle: f,
        rootId: u
    }
}
function xG(t, e) {
    const { doc: n, blockClass: s, blockSelector: r, unblockSelector: i, inlineStylesheet: o, maskInputOptions: l = {}, maskAttributeFn: a, maskInputFn: c, dataURLOptions: u = {}, inlineImages: h, recordCanvas: d, keepIframeSrcFn: f, newlyAddedElement: p = !1, rootId: m, maskAllText: g, maskTextClass: b, unmaskTextClass: v, maskTextSelector: _, unmaskTextSelector: y } = e
        , x = pG(t, s, r, i)
        , w = rG(t);
    let S = {};
    const E = t.attributes.length;
    for (let I = 0; I < E; I++) {
        const L = t.attributes[I];
        L.name && !XR(w, L.name, L.value) && (S[L.name] = YR(n, w, Bu(L.name), L.value, t, a))
    }
    if (w === "link" && o) {
        const I = Array.from(n.styleSheets).find(k => k.href === t.href);
        let L = null;
        I && (L = wm(I)),
            L && (delete S.rel,
                delete S.href,
                S._cssText = Em(L, I.href))
    }
    if (w === "style" && t.sheet && !(t.innerText || t.textContent || "").trim().length) {
        const I = wm(t.sheet);
        I && (S._cssText = Em(I, r_(n)))
    }
    if (w === "input" || w === "textarea" || w === "select" || w === "option") {
        const I = t
            , L = ox(I)
            , k = Sm(I, Iy(w), L)
            , R = I.checked;
        if (L !== "submit" && L !== "button" && k) {
            const U = Fu(I, b, _, v, y, s_({
                type: L,
                tagName: Iy(w),
                maskInputOptions: l
            }));
            S.value = Ed({
                isMasked: U,
                element: I,
                value: k,
                maskInputFn: c
            })
        }
        R && (S.checked = R)
    }
    if (w === "option" && (t.selected && !l.select ? S.selected = !0 : delete S.selected),
        w === "canvas" && d) {
        if (t.__context === "2d")
            tG(t) || (S.rr_dataURL = t.toDataURL(u.type, u.quality));
        else if (!("__context" in t)) {
            const I = t.toDataURL(u.type, u.quality)
                , L = n.createElement("canvas");
            L.width = t.width,
                L.height = t.height;
            const k = L.toDataURL(u.type, u.quality);
            I !== k && (S.rr_dataURL = I)
        }
    }
    if (w === "img" && h) {
        Ac || (Ac = n.createElement("canvas"),
            YT = Ac.getContext("2d"));
        const I = t
            , L = I.currentSrc || I.getAttribute("src") || "<unknown-src>"
            , k = I.crossOrigin
            , R = () => {
                I.removeEventListener("load", R);
                try {
                    Ac.width = I.naturalWidth,
                        Ac.height = I.naturalHeight,
                        YT.drawImage(I, 0, 0),
                        S.rr_dataURL = Ac.toDataURL(u.type, u.quality)
                } catch (U) {
                    if (I.crossOrigin !== "anonymous") {
                        I.crossOrigin = "anonymous",
                            I.complete && I.naturalWidth !== 0 ? R() : I.addEventListener("load", R);
                        return
                    } else
                        console.warn(`Cannot inline img src=${L}! Error: ${U}`)
                }
                I.crossOrigin === "anonymous" && (k ? S.crossOrigin = k : I.removeAttribute("crossorigin"))
            }
            ;
        I.complete && I.naturalWidth !== 0 ? R() : I.addEventListener("load", R)
    }
    if ((w === "audio" || w === "video") && (S.rr_mediaState = t.paused ? "paused" : "played",
        S.rr_mediaCurrentTime = t.currentTime),
        p || (t.scrollLeft && (S.rr_scrollLeft = t.scrollLeft),
            t.scrollTop && (S.rr_scrollTop = t.scrollTop)),
        x) {
        const { width: I, height: L } = t.getBoundingClientRect();
        S = {
            class: S.class,
            rr_width: `${I}px`,
            rr_height: `${L}px`
        }
    }
    w === "iframe" && !f(S.src) && (!x && !t.contentDocument && (S.rr_src = S.src),
        delete S.src);
    let C;
    try {
        customElements.get(w) && (C = !0)
    } catch { }
    return {
        type: kn.Element,
        tagName: w,
        attributes: S,
        childNodes: [],
        isSVG: fG(t) || void 0,
        needBlock: x,
        rootId: m,
        isCustom: C
    }
}
function Vt(t) {
    return t == null ? "" : t.toLowerCase()
}
function wG(t, e) {
    if (e.comment && t.type === kn.Comment)
        return !0;
    if (t.type === kn.Element) {
        if (e.script && (t.tagName === "script" || t.tagName === "link" && (t.attributes.rel === "preload" || t.attributes.rel === "modulepreload") && t.attributes.as === "script" || t.tagName === "link" && t.attributes.rel === "prefetch" && typeof t.attributes.href == "string" && GR(t.attributes.href) === "js"))
            return !0;
        if (e.headFavicon && (t.tagName === "link" && t.attributes.rel === "shortcut icon" || t.tagName === "meta" && (Vt(t.attributes.name).match(/^msapplication-tile(image|color)$/) || Vt(t.attributes.name) === "application-name" || Vt(t.attributes.rel) === "icon" || Vt(t.attributes.rel) === "apple-touch-icon" || Vt(t.attributes.rel) === "shortcut icon")))
            return !0;
        if (t.tagName === "meta") {
            if (e.headMetaDescKeywords && Vt(t.attributes.name).match(/^description|keywords$/))
                return !0;
            if (e.headMetaSocial && (Vt(t.attributes.property).match(/^(og|twitter|fb):/) || Vt(t.attributes.name).match(/^(og|twitter):/) || Vt(t.attributes.name) === "pinterest"))
                return !0;
            if (e.headMetaRobots && (Vt(t.attributes.name) === "robots" || Vt(t.attributes.name) === "googlebot" || Vt(t.attributes.name) === "bingbot"))
                return !0;
            if (e.headMetaHttpEquiv && t.attributes["http-equiv"] !== void 0)
                return !0;
            if (e.headMetaAuthorship && (Vt(t.attributes.name) === "author" || Vt(t.attributes.name) === "generator" || Vt(t.attributes.name) === "framework" || Vt(t.attributes.name) === "publisher" || Vt(t.attributes.name) === "progid" || Vt(t.attributes.property).match(/^article:/) || Vt(t.attributes.property).match(/^product:/)))
                return !0;
            if (e.headMetaVerification && (Vt(t.attributes.name) === "google-site-verification" || Vt(t.attributes.name) === "yandex-verification" || Vt(t.attributes.name) === "csrf-token" || Vt(t.attributes.name) === "p:domain_verify" || Vt(t.attributes.name) === "verify-v1" || Vt(t.attributes.name) === "verification" || Vt(t.attributes.name) === "shopify-checkout-api-token"))
                return !0
        }
    }
    return !1
}
function Zc(t, e) {
    const { doc: n, mirror: s, blockClass: r, blockSelector: i, unblockSelector: o, maskAllText: l, maskTextClass: a, unmaskTextClass: c, maskTextSelector: u, unmaskTextSelector: h, skipChild: d = !1, inlineStylesheet: f = !0, maskInputOptions: p = {}, maskAttributeFn: m, maskTextFn: g, maskInputFn: b, slimDOMOptions: v, dataURLOptions: _ = {}, inlineImages: y = !1, recordCanvas: x = !1, onSerialize: w, onIframeLoad: S, iframeLoadTimeout: E = 5e3, onStylesheetLoad: C, stylesheetLoadTimeout: I = 5e3, keepIframeSrcFn: L = () => !1, newlyAddedElement: k = !1 } = e;
    let { preserveWhiteSpace: R = !0 } = e;
    const U = yG(t, {
        doc: n,
        mirror: s,
        blockClass: r,
        blockSelector: i,
        maskAllText: l,
        unblockSelector: o,
        maskTextClass: a,
        unmaskTextClass: c,
        maskTextSelector: u,
        unmaskTextSelector: h,
        inlineStylesheet: f,
        maskInputOptions: p,
        maskAttributeFn: m,
        maskTextFn: g,
        maskInputFn: b,
        dataURLOptions: _,
        inlineImages: y,
        recordCanvas: x,
        keepIframeSrcFn: L,
        newlyAddedElement: k
    });
    if (!U)
        return console.warn(t, "not serialized"),
            null;
    let W;
    s.hasNode(t) ? W = s.getId(t) : wG(U, v) || !R && U.type === kn.Text && !U.isStyle && !U.textContent.replace(/^\s+|\s+$/gm, "").length ? W = Td : W = ax();
    const H = Object.assign(U, {
        id: W
    });
    if (s.add(t, H),
        W === Td)
        return null;
    w && w(t);
    let j = !d;
    if (H.type === kn.Element) {
        j = j && !H.needBlock,
            delete H.needBlock;
        const z = t.shadowRoot;
        z && td(z) && (H.isShadowHost = !0)
    }
    if ((H.type === kn.Document || H.type === kn.Element) && j) {
        v.headWhitespace && H.type === kn.Element && H.tagName === "head" && (R = !1);
        const z = {
            doc: n,
            mirror: s,
            blockClass: r,
            blockSelector: i,
            maskAllText: l,
            unblockSelector: o,
            maskTextClass: a,
            unmaskTextClass: c,
            maskTextSelector: u,
            unmaskTextSelector: h,
            skipChild: d,
            inlineStylesheet: f,
            maskInputOptions: p,
            maskAttributeFn: m,
            maskTextFn: g,
            maskInputFn: b,
            slimDOMOptions: v,
            dataURLOptions: _,
            inlineImages: y,
            recordCanvas: x,
            preserveWhiteSpace: R,
            onSerialize: w,
            onIframeLoad: S,
            iframeLoadTimeout: E,
            onStylesheetLoad: C,
            stylesheetLoadTimeout: I,
            keepIframeSrcFn: L
        };
        for (const ee of Array.from(t.childNodes)) {
            const J = Zc(ee, z);
            J && H.childNodes.push(J)
        }
        if (zV(t) && t.shadowRoot)
            for (const ee of Array.from(t.shadowRoot.childNodes)) {
                const J = Zc(ee, z);
                J && (td(t.shadowRoot) && (J.isShadow = !0),
                    H.childNodes.push(J))
            }
    }
    return t.parentNode && ed(t.parentNode) && td(t.parentNode) && (H.isShadow = !0),
        H.type === kn.Element && H.tagName === "iframe" && gG(t, () => {
            const z = t.contentDocument;
            if (z && S) {
                const ee = Zc(z, {
                    doc: z,
                    mirror: s,
                    blockClass: r,
                    blockSelector: i,
                    unblockSelector: o,
                    maskAllText: l,
                    maskTextClass: a,
                    unmaskTextClass: c,
                    maskTextSelector: u,
                    unmaskTextSelector: h,
                    skipChild: !1,
                    inlineStylesheet: f,
                    maskInputOptions: p,
                    maskAttributeFn: m,
                    maskTextFn: g,
                    maskInputFn: b,
                    slimDOMOptions: v,
                    dataURLOptions: _,
                    inlineImages: y,
                    recordCanvas: x,
                    preserveWhiteSpace: R,
                    onSerialize: w,
                    onIframeLoad: S,
                    iframeLoadTimeout: E,
                    onStylesheetLoad: C,
                    stylesheetLoadTimeout: I,
                    keepIframeSrcFn: L
                });
                ee && S(t, ee)
            }
        }
            , E),
        H.type === kn.Element && H.tagName === "link" && typeof H.attributes.rel == "string" && (H.attributes.rel === "stylesheet" || H.attributes.rel === "preload" && typeof H.attributes.href == "string" && GR(H.attributes.href) === "css") && _G(t, () => {
            if (C) {
                const z = Zc(t, {
                    doc: n,
                    mirror: s,
                    blockClass: r,
                    blockSelector: i,
                    unblockSelector: o,
                    maskAllText: l,
                    maskTextClass: a,
                    unmaskTextClass: c,
                    maskTextSelector: u,
                    unmaskTextSelector: h,
                    skipChild: !1,
                    inlineStylesheet: f,
                    maskInputOptions: p,
                    maskAttributeFn: m,
                    maskTextFn: g,
                    maskInputFn: b,
                    slimDOMOptions: v,
                    dataURLOptions: _,
                    inlineImages: y,
                    recordCanvas: x,
                    preserveWhiteSpace: R,
                    onSerialize: w,
                    onIframeLoad: S,
                    iframeLoadTimeout: E,
                    onStylesheetLoad: C,
                    stylesheetLoadTimeout: I,
                    keepIframeSrcFn: L
                });
                z && C(t, z)
            }
        }
            , I),
        H
}
function SG(t, e) {
    const { mirror: n = new VR, blockClass: s = "rr-block", blockSelector: r = null, unblockSelector: i = null, maskAllText: o = !1, maskTextClass: l = "rr-mask", unmaskTextClass: a = null, maskTextSelector: c = null, unmaskTextSelector: u = null, inlineStylesheet: h = !0, inlineImages: d = !1, recordCanvas: f = !1, maskAllInputs: p = !1, maskAttributeFn: m, maskTextFn: g, maskInputFn: b, slimDOM: v = !1, dataURLOptions: _, preserveWhiteSpace: y, onSerialize: x, onIframeLoad: w, iframeLoadTimeout: S, onStylesheetLoad: E, stylesheetLoadTimeout: C, keepIframeSrcFn: I = () => !1 } = e || {};
    return Zc(t, {
        doc: t,
        mirror: n,
        blockClass: s,
        blockSelector: r,
        unblockSelector: i,
        maskAllText: o,
        maskTextClass: l,
        unmaskTextClass: a,
        maskTextSelector: c,
        unmaskTextSelector: u,
        skipChild: !1,
        inlineStylesheet: h,
        maskInputOptions: p === !0 ? {
            color: !0,
            date: !0,
            "datetime-local": !0,
            email: !0,
            month: !0,
            number: !0,
            range: !0,
            search: !0,
            tel: !0,
            text: !0,
            time: !0,
            url: !0,
            week: !0,
            textarea: !0,
            select: !0
        } : p === !1 ? {} : p,
        maskAttributeFn: m,
        maskTextFn: g,
        maskInputFn: b,
        slimDOMOptions: v === !0 || v === "all" ? {
            script: !0,
            comment: !0,
            headFavicon: !0,
            headWhitespace: !0,
            headMetaDescKeywords: v === "all",
            headMetaSocial: !0,
            headMetaRobots: !0,
            headMetaHttpEquiv: !0,
            headMetaAuthorship: !0,
            headMetaVerification: !0
        } : v === !1 ? {} : v,
        dataURLOptions: _,
        inlineImages: d,
        recordCanvas: f,
        preserveWhiteSpace: y,
        onSerialize: x,
        onIframeLoad: w,
        iframeLoadTimeout: S,
        onStylesheetLoad: E,
        stylesheetLoadTimeout: C,
        keepIframeSrcFn: I,
        newlyAddedElement: !1
    })
}
function ga(t) {
    let e, n = t[0], s = 1;
    for (; s < t.length;) {
        const r = t[s]
            , i = t[s + 1];
        if (s += 2,
            (r === "optionalAccess" || r === "optionalCall") && n == null)
            return;
        r === "access" || r === "optionalAccess" ? (e = n,
            n = i(n)) : (r === "call" || r === "optionalCall") && (n = i((...o) => n.call(e, ...o)),
                e = void 0)
    }
    return n
}
function Cs(t, e, n = document) {
    const s = {
        capture: !0,
        passive: !0
    };
    return n.addEventListener(t, e, s),
        () => n.removeEventListener(t, e, s)
}
const Bc = `Please stop import mirror directly. Instead of that,\r
now you can use replayer.getMirror() to access the mirror instance of a replayer,\r
or you can use record.mirror to access the mirror instance during recording.`;
let jT = {
    map: {},
    getId() {
        return console.error(Bc),
            -1
    },
    getNode() {
        return console.error(Bc),
            null
    },
    removeNodeFromMap() {
        console.error(Bc)
    },
    has() {
        return console.error(Bc),
            !1
    },
    reset() {
        console.error(Bc)
    }
};
typeof window < "u" && window.Proxy && window.Reflect && (jT = new Proxy(jT, {
    get(t, e, n) {
        return e === "map" && console.error(Bc),
            Reflect.get(t, e, n)
    }
}));
function Cd(t, e, n = {}) {
    let s = null
        , r = 0;
    return function (...i) {
        const o = Date.now();
        !r && n.leading === !1 && (r = o);
        const l = e - (o - r)
            , a = this;
        l <= 0 || l > e ? (s && (RG(s),
            s = null),
            r = o,
            t.apply(a, i)) : !s && n.trailing !== !1 && (s = i_(() => {
                r = n.leading === !1 ? 0 : Date.now(),
                    s = null,
                    t.apply(a, i)
            }
                , l))
    }
}
function jR(t, e, n, s, r = window) {
    const i = r.Object.getOwnPropertyDescriptor(t, e);
    return r.Object.defineProperty(t, e, s ? n : {
        set(o) {
            i_(() => {
                n.set.call(this, o)
            }
                , 0),
                i && i.set && i.set.call(this, o)
        }
    }),
        () => jR(t, e, i || {}, !0)
}
function lx(t, e, n) {
    try {
        if (!(e in t))
            return () => { }
                ;
        const s = t[e]
            , r = n(s);
        return typeof r == "function" && (r.prototype = r.prototype || {},
            Object.defineProperties(r, {
                __rrweb_original__: {
                    enumerable: !1,
                    value: s
                }
            })),
            t[e] = r,
            () => {
                t[e] = s
            }
    } catch {
        return () => { }
    }
}
let Tm = Date.now;
/[1-9][0-9]{12}/.test(Date.now().toString()) || (Tm = () => new Date().getTime());
function zR(t) {
    const e = t.document;
    return {
        left: e.scrollingElement ? e.scrollingElement.scrollLeft : t.pageXOffset !== void 0 ? t.pageXOffset : ga([e, "optionalAccess", n => n.documentElement, "access", n => n.scrollLeft]) || ga([e, "optionalAccess", n => n.body, "optionalAccess", n => n.parentElement, "optionalAccess", n => n.scrollLeft]) || ga([e, "optionalAccess", n => n.body, "optionalAccess", n => n.scrollLeft]) || 0,
        top: e.scrollingElement ? e.scrollingElement.scrollTop : t.pageYOffset !== void 0 ? t.pageYOffset : ga([e, "optionalAccess", n => n.documentElement, "access", n => n.scrollTop]) || ga([e, "optionalAccess", n => n.body, "optionalAccess", n => n.parentElement, "optionalAccess", n => n.scrollTop]) || ga([e, "optionalAccess", n => n.body, "optionalAccess", n => n.scrollTop]) || 0
    }
}
function qR() {
    return window.innerHeight || document.documentElement && document.documentElement.clientHeight || document.body && document.body.clientHeight
}
function KR() {
    return window.innerWidth || document.documentElement && document.documentElement.clientWidth || document.body && document.body.clientWidth
}
function JR(t) {
    return t ? t.nodeType === t.ELEMENT_NODE ? t : t.parentElement : null
}
function rr(t, e, n, s, r) {
    if (!t)
        return !1;
    const i = JR(t);
    if (!i)
        return !1;
    const o = Jc(e, n);
    if (!r) {
        const c = s && i.matches(s);
        return o(i) && !c
    }
    const l = Ll(i, o);
    let a = -1;
    return l < 0 ? !1 : (s && (a = Ll(i, Jc(null, s))),
        l > -1 && a < 0 ? !0 : l < a)
}
function EG(t, e) {
    return e.getId(t) !== -1
}
function C0(t, e) {
    return e.getId(t) === Td
}
function ZR(t, e) {
    if (ed(t))
        return !1;
    const n = e.getId(t);
    return e.has(n) ? t.parentNode && t.parentNode.nodeType === t.DOCUMENT_NODE ? !1 : t.parentNode ? ZR(t.parentNode, e) : !0 : !0
}
function ky(t) {
    return !!t.changedTouches
}
function TG(t = window) {
    "NodeList" in t && !t.NodeList.prototype.forEach && (t.NodeList.prototype.forEach = Array.prototype.forEach),
        "DOMTokenList" in t && !t.DOMTokenList.prototype.forEach && (t.DOMTokenList.prototype.forEach = Array.prototype.forEach),
        Node.prototype.contains || (Node.prototype.contains = (...e) => {
            let n = e[0];
            if (!(0 in e))
                throw new TypeError("1 argument is required");
            do
                if (this === n)
                    return !0;
            while (n = n && n.parentNode);
            return !1
        }
        )
}
function QR(t, e) {
    return !!(t.nodeName === "IFRAME" && e.getMeta(t))
}
function eM(t, e) {
    return !!(t.nodeName === "LINK" && t.nodeType === t.ELEMENT_NODE && t.getAttribute && t.getAttribute("rel") === "stylesheet" && e.getMeta(t))
}
function Ry(t) {
    return !!ga([t, "optionalAccess", e => e.shadowRoot])
}
class CG {
    constructor() {
        this.id = 1,
            this.styleIDMap = new WeakMap,
            this.idStyleMap = new Map
    }
    getId(e) {
        return f$(this.styleIDMap.get(e), () => -1)
    }
    has(e) {
        return this.styleIDMap.has(e)
    }
    add(e, n) {
        if (this.has(e))
            return this.getId(e);
        let s;
        return n === void 0 ? s = this.id++ : s = n,
            this.styleIDMap.set(e, s),
            this.idStyleMap.set(s, e),
            s
    }
    getStyle(e) {
        return this.idStyleMap.get(e) || null
    }
    reset() {
        this.styleIDMap = new WeakMap,
            this.idStyleMap = new Map,
            this.id = 1
    }
    generateId() {
        return this.id++
    }
}
function tM(t) {
    let e = null;
    return ga([t, "access", n => n.getRootNode, "optionalCall", n => n(), "optionalAccess", n => n.nodeType]) === Node.DOCUMENT_FRAGMENT_NODE && t.getRootNode().host && (e = t.getRootNode().host),
        e
}
function IG(t) {
    let e = t, n;
    for (; n = tM(e);)
        e = n;
    return e
}
function AG(t) {
    const e = t.ownerDocument;
    if (!e)
        return !1;
    const n = IG(t);
    return e.contains(n)
}
function nM(t) {
    const e = t.ownerDocument;
    return e ? e.contains(t) || AG(t) : !1
}
const zT = {};
function cx(t) {
    const e = zT[t];
    if (e)
        return e;
    const n = window.document;
    let s = window[t];
    if (n && typeof n.createElement == "function")
        try {
            const r = n.createElement("iframe");
            r.hidden = !0,
                n.head.appendChild(r);
            const i = r.contentWindow;
            i && i[t] && (s = i[t]),
                n.head.removeChild(r)
        } catch { }
    return zT[t] = s.bind(window)
}
function kG(...t) {
    return cx("requestAnimationFrame")(...t)
}
function i_(...t) {
    return cx("setTimeout")(...t)
}
function RG(...t) {
    return cx("clearTimeout")(...t)
}
var ht = (t => (t[t.DomContentLoaded = 0] = "DomContentLoaded",
    t[t.Load = 1] = "Load",
    t[t.FullSnapshot = 2] = "FullSnapshot",
    t[t.IncrementalSnapshot = 3] = "IncrementalSnapshot",
    t[t.Meta = 4] = "Meta",
    t[t.Custom = 5] = "Custom",
    t[t.Plugin = 6] = "Plugin",
    t))(ht || {})
    , et = (t => (t[t.Mutation = 0] = "Mutation",
        t[t.MouseMove = 1] = "MouseMove",
        t[t.MouseInteraction = 2] = "MouseInteraction",
        t[t.Scroll = 3] = "Scroll",
        t[t.ViewportResize = 4] = "ViewportResize",
        t[t.Input = 5] = "Input",
        t[t.TouchMove = 6] = "TouchMove",
        t[t.MediaInteraction = 7] = "MediaInteraction",
        t[t.StyleSheetRule = 8] = "StyleSheetRule",
        t[t.CanvasMutation = 9] = "CanvasMutation",
        t[t.Font = 10] = "Font",
        t[t.Log = 11] = "Log",
        t[t.Drag = 12] = "Drag",
        t[t.StyleDeclaration = 13] = "StyleDeclaration",
        t[t.Selection = 14] = "Selection",
        t[t.AdoptedStyleSheet = 15] = "AdoptedStyleSheet",
        t[t.CustomElement = 16] = "CustomElement",
        t))(et || {})
    , Ss = (t => (t[t.MouseUp = 0] = "MouseUp",
        t[t.MouseDown = 1] = "MouseDown",
        t[t.Click = 2] = "Click",
        t[t.ContextMenu = 3] = "ContextMenu",
        t[t.DblClick = 4] = "DblClick",
        t[t.Focus = 5] = "Focus",
        t[t.Blur = 6] = "Blur",
        t[t.TouchStart = 7] = "TouchStart",
        t[t.TouchMove_Departed = 8] = "TouchMove_Departed",
        t[t.TouchEnd = 9] = "TouchEnd",
        t[t.TouchCancel = 10] = "TouchCancel",
        t))(Ss || {})
    , io = (t => (t[t.Mouse = 0] = "Mouse",
        t[t.Pen = 1] = "Pen",
        t[t.Touch = 2] = "Touch",
        t))(io || {});
function MG(t) {
    let e, n = t[0], s = 1;
    for (; s < t.length;) {
        const r = t[s]
            , i = t[s + 1];
        if (s += 2,
            (r === "optionalAccess" || r === "optionalCall") && n == null)
            return;
        r === "access" || r === "optionalAccess" ? (e = n,
            n = i(n)) : (r === "call" || r === "optionalCall") && (n = i((...o) => n.call(e, ...o)),
                e = void 0)
    }
    return n
}
function qT(t) {
    return "__ln" in t
}
class PG {
    constructor() {
        this.length = 0,
            this.head = null,
            this.tail = null
    }
    get(e) {
        if (e >= this.length)
            throw new Error("Position outside of list range");
        let n = this.head;
        for (let s = 0; s < e; s++)
            n = MG([n, "optionalAccess", r => r.next]) || null;
        return n
    }
    addNode(e) {
        const n = {
            value: e,
            previous: null,
            next: null
        };
        if (e.__ln = n,
            e.previousSibling && qT(e.previousSibling)) {
            const s = e.previousSibling.__ln.next;
            n.next = s,
                n.previous = e.previousSibling.__ln,
                e.previousSibling.__ln.next = n,
                s && (s.previous = n)
        } else if (e.nextSibling && qT(e.nextSibling) && e.nextSibling.__ln.previous) {
            const s = e.nextSibling.__ln.previous;
            n.previous = s,
                n.next = e.nextSibling.__ln,
                e.nextSibling.__ln.previous = n,
                s && (s.next = n)
        } else
            this.head && (this.head.previous = n),
                n.next = this.head,
                this.head = n;
        n.next === null && (this.tail = n),
            this.length++
    }
    removeNode(e) {
        const n = e.__ln;
        this.head && (n.previous ? (n.previous.next = n.next,
            n.next ? n.next.previous = n.previous : this.tail = n.previous) : (this.head = n.next,
                this.head ? this.head.previous = null : this.tail = null),
            e.__ln && delete e.__ln,
            this.length--)
    }
}
const KT = (t, e) => `${t}@${e}`;
class LG {
    constructor() {
        this.frozen = !1,
            this.locked = !1,
            this.texts = [],
            this.attributes = [],
            this.attributeMap = new WeakMap,
            this.removes = [],
            this.mapRemoves = [],
            this.movedMap = {},
            this.addedSet = new Set,
            this.movedSet = new Set,
            this.droppedSet = new Set,
            this.processMutations = e => {
                e.forEach(this.processMutation),
                    this.emit()
            }
            ,
            this.emit = () => {
                if (this.frozen || this.locked)
                    return;
                const e = []
                    , n = new Set
                    , s = new PG
                    , r = a => {
                        let c = a
                            , u = Td;
                        for (; u === Td;)
                            c = c && c.nextSibling,
                                u = c && this.mirror.getId(c);
                        return u
                    }
                    , i = a => {
                        if (!a.parentNode || !nM(a))
                            return;
                        const c = ed(a.parentNode) ? this.mirror.getId(tM(a)) : this.mirror.getId(a.parentNode)
                            , u = r(a);
                        if (c === -1 || u === -1)
                            return s.addNode(a);
                        const h = Zc(a, {
                            doc: this.doc,
                            mirror: this.mirror,
                            blockClass: this.blockClass,
                            blockSelector: this.blockSelector,
                            maskAllText: this.maskAllText,
                            unblockSelector: this.unblockSelector,
                            maskTextClass: this.maskTextClass,
                            unmaskTextClass: this.unmaskTextClass,
                            maskTextSelector: this.maskTextSelector,
                            unmaskTextSelector: this.unmaskTextSelector,
                            skipChild: !0,
                            newlyAddedElement: !0,
                            inlineStylesheet: this.inlineStylesheet,
                            maskInputOptions: this.maskInputOptions,
                            maskAttributeFn: this.maskAttributeFn,
                            maskTextFn: this.maskTextFn,
                            maskInputFn: this.maskInputFn,
                            slimDOMOptions: this.slimDOMOptions,
                            dataURLOptions: this.dataURLOptions,
                            recordCanvas: this.recordCanvas,
                            inlineImages: this.inlineImages,
                            onSerialize: d => {
                                QR(d, this.mirror) && !rr(d, this.blockClass, this.blockSelector, this.unblockSelector, !1) && this.iframeManager.addIframe(d),
                                    eM(d, this.mirror) && this.stylesheetManager.trackLinkElement(d),
                                    Ry(a) && this.shadowDomManager.addShadowRoot(a.shadowRoot, this.doc)
                            }
                            ,
                            onIframeLoad: (d, f) => {
                                rr(d, this.blockClass, this.blockSelector, this.unblockSelector, !1) || (this.iframeManager.attachIframe(d, f),
                                    d.contentWindow && this.canvasManager.addWindow(d.contentWindow),
                                    this.shadowDomManager.observeAttachShadow(d))
                            }
                            ,
                            onStylesheetLoad: (d, f) => {
                                this.stylesheetManager.attachLinkElement(d, f)
                            }
                        });
                        h && (e.push({
                            parentId: c,
                            nextId: u,
                            node: h
                        }),
                            n.add(h.id))
                    }
                    ;
                for (; this.mapRemoves.length;)
                    this.mirror.removeNodeFromMap(this.mapRemoves.shift());
                for (const a of this.movedSet)
                    JT(this.removes, a, this.mirror) && !this.movedSet.has(a.parentNode) || i(a);
                for (const a of this.addedSet)
                    !ZT(this.droppedSet, a) && !JT(this.removes, a, this.mirror) || ZT(this.movedSet, a) ? i(a) : this.droppedSet.add(a);
                let o = null;
                for (; s.length;) {
                    let a = null;
                    if (o) {
                        const c = this.mirror.getId(o.value.parentNode)
                            , u = r(o.value);
                        c !== -1 && u !== -1 && (a = o)
                    }
                    if (!a) {
                        let c = s.tail;
                        for (; c;) {
                            const u = c;
                            if (c = c.previous,
                                u) {
                                const h = this.mirror.getId(u.value.parentNode);
                                if (r(u.value) === -1)
                                    continue;
                                if (h !== -1) {
                                    a = u;
                                    break
                                } else {
                                    const f = u.value;
                                    if (f.parentNode && f.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                                        const p = f.parentNode.host;
                                        if (this.mirror.getId(p) !== -1) {
                                            a = u;
                                            break
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (!a) {
                        for (; s.head;)
                            s.removeNode(s.head.value);
                        break
                    }
                    o = a.previous,
                        s.removeNode(a.value),
                        i(a.value)
                }
                const l = {
                    texts: this.texts.map(a => ({
                        id: this.mirror.getId(a.node),
                        value: a.value
                    })).filter(a => !n.has(a.id)).filter(a => this.mirror.has(a.id)),
                    attributes: this.attributes.map(a => {
                        const { attributes: c } = a;
                        if (typeof c.style == "string") {
                            const u = JSON.stringify(a.styleDiff)
                                , h = JSON.stringify(a._unchangedStyles);
                            u.length < c.style.length && (u + h).split("var(").length === c.style.split("var(").length && (c.style = a.styleDiff)
                        }
                        return {
                            id: this.mirror.getId(a.node),
                            attributes: c
                        }
                    }
                    ).filter(a => !n.has(a.id)).filter(a => this.mirror.has(a.id)),
                    removes: this.removes,
                    adds: e
                };
                !l.texts.length && !l.attributes.length && !l.removes.length && !l.adds.length || (this.texts = [],
                    this.attributes = [],
                    this.attributeMap = new WeakMap,
                    this.removes = [],
                    this.addedSet = new Set,
                    this.movedSet = new Set,
                    this.droppedSet = new Set,
                    this.movedMap = {},
                    this.mutationCb(l))
            }
            ,
            this.processMutation = e => {
                if (!C0(e.target, this.mirror))
                    switch (e.type) {
                        case "characterData":
                            {
                                const n = e.target.textContent;
                                !rr(e.target, this.blockClass, this.blockSelector, this.unblockSelector, !1) && n !== e.oldValue && this.texts.push({
                                    value: Fu(e.target, this.maskTextClass, this.maskTextSelector, this.unmaskTextClass, this.unmaskTextSelector, this.maskAllText) && n ? this.maskTextFn ? this.maskTextFn(n, JR(e.target)) : n.replace(/[\S]/g, "*") : n,
                                    node: e.target
                                });
                                break
                            }
                        case "attributes":
                            {
                                const n = e.target;
                                let s = e.attributeName
                                    , r = e.target.getAttribute(s);
                                if (s === "value") {
                                    const o = ox(n)
                                        , l = n.tagName;
                                    r = Sm(n, l, o);
                                    const a = s_({
                                        maskInputOptions: this.maskInputOptions,
                                        tagName: l,
                                        type: o
                                    })
                                        , c = Fu(e.target, this.maskTextClass, this.maskTextSelector, this.unmaskTextClass, this.unmaskTextSelector, a);
                                    r = Ed({
                                        isMasked: c,
                                        element: n,
                                        value: r,
                                        maskInputFn: this.maskInputFn
                                    })
                                }
                                if (rr(e.target, this.blockClass, this.blockSelector, this.unblockSelector, !1) || r === e.oldValue)
                                    return;
                                let i = this.attributeMap.get(e.target);
                                if (n.tagName === "IFRAME" && s === "src" && !this.keepIframeSrcFn(r))
                                    if (!n.contentDocument)
                                        s = "rr_src";
                                    else
                                        return;
                                if (i || (i = {
                                    node: e.target,
                                    attributes: {},
                                    styleDiff: {},
                                    _unchangedStyles: {}
                                },
                                    this.attributes.push(i),
                                    this.attributeMap.set(e.target, i)),
                                    s === "type" && n.tagName === "INPUT" && (e.oldValue || "").toLowerCase() === "password" && n.setAttribute("data-rr-is-password", "true"),
                                    !XR(n.tagName, s) && (i.attributes[s] = YR(this.doc, Bu(n.tagName), Bu(s), r, n, this.maskAttributeFn),
                                        s === "style")) {
                                    if (!this.unattachedDoc)
                                        try {
                                            this.unattachedDoc = document.implementation.createHTMLDocument()
                                        } catch {
                                            this.unattachedDoc = this.doc
                                        }
                                    const o = this.unattachedDoc.createElement("span");
                                    e.oldValue && o.setAttribute("style", e.oldValue);
                                    for (const l of Array.from(n.style)) {
                                        const a = n.style.getPropertyValue(l)
                                            , c = n.style.getPropertyPriority(l);
                                        a !== o.style.getPropertyValue(l) || c !== o.style.getPropertyPriority(l) ? c === "" ? i.styleDiff[l] = a : i.styleDiff[l] = [a, c] : i._unchangedStyles[l] = [a, c]
                                    }
                                    for (const l of Array.from(o.style))
                                        n.style.getPropertyValue(l) === "" && (i.styleDiff[l] = !1)
                                }
                                break
                            }
                        case "childList":
                            {
                                if (rr(e.target, this.blockClass, this.blockSelector, this.unblockSelector, !0))
                                    return;
                                e.addedNodes.forEach(n => this.genAdds(n, e.target)),
                                    e.removedNodes.forEach(n => {
                                        const s = this.mirror.getId(n)
                                            , r = ed(e.target) ? this.mirror.getId(e.target.host) : this.mirror.getId(e.target);
                                        rr(e.target, this.blockClass, this.blockSelector, this.unblockSelector, !1) || C0(n, this.mirror) || !EG(n, this.mirror) || (this.addedSet.has(n) ? (My(this.addedSet, n),
                                            this.droppedSet.add(n)) : this.addedSet.has(e.target) && s === -1 || ZR(e.target, this.mirror) || (this.movedSet.has(n) && this.movedMap[KT(s, r)] ? My(this.movedSet, n) : this.removes.push({
                                                parentId: r,
                                                id: s,
                                                isShadow: ed(e.target) && td(e.target) ? !0 : void 0
                                            })),
                                            this.mapRemoves.push(n))
                                    }
                                    );
                                break
                            }
                    }
            }
            ,
            this.genAdds = (e, n) => {
                if (!this.processedNodeManager.inOtherBuffer(e, this) && !(this.addedSet.has(e) || this.movedSet.has(e))) {
                    if (this.mirror.hasNode(e)) {
                        if (C0(e, this.mirror))
                            return;
                        this.movedSet.add(e);
                        let s = null;
                        n && this.mirror.hasNode(n) && (s = this.mirror.getId(n)),
                            s && s !== -1 && (this.movedMap[KT(this.mirror.getId(e), s)] = !0)
                    } else
                        this.addedSet.add(e),
                            this.droppedSet.delete(e);
                    rr(e, this.blockClass, this.blockSelector, this.unblockSelector, !1) || (e.childNodes.forEach(s => this.genAdds(s)),
                        Ry(e) && e.shadowRoot.childNodes.forEach(s => {
                            this.processedNodeManager.add(s, this),
                                this.genAdds(s, e)
                        }
                        ))
                }
            }
    }
    init(e) {
        ["mutationCb", "blockClass", "blockSelector", "unblockSelector", "maskAllText", "maskTextClass", "unmaskTextClass", "maskTextSelector", "unmaskTextSelector", "inlineStylesheet", "maskInputOptions", "maskAttributeFn", "maskTextFn", "maskInputFn", "keepIframeSrcFn", "recordCanvas", "inlineImages", "slimDOMOptions", "dataURLOptions", "doc", "mirror", "iframeManager", "stylesheetManager", "shadowDomManager", "canvasManager", "processedNodeManager"].forEach(n => {
            this[n] = e[n]
        }
        )
    }
    freeze() {
        this.frozen = !0,
            this.canvasManager.freeze()
    }
    unfreeze() {
        this.frozen = !1,
            this.canvasManager.unfreeze(),
            this.emit()
    }
    isFrozen() {
        return this.frozen
    }
    lock() {
        this.locked = !0,
            this.canvasManager.lock()
    }
    unlock() {
        this.locked = !1,
            this.canvasManager.unlock(),
            this.emit()
    }
    reset() {
        this.shadowDomManager.reset(),
            this.canvasManager.reset()
    }
}
function My(t, e) {
    t.delete(e),
        e.childNodes.forEach(n => My(t, n))
}
function JT(t, e, n) {
    return t.length === 0 ? !1 : OG(t, e, n)
}
function OG(t, e, n) {
    let s = e.parentNode;
    for (; s;) {
        const r = n.getId(s);
        if (t.some(i => i.id === r))
            return !0;
        s = s.parentNode
    }
    return !1
}
function ZT(t, e) {
    return t.size === 0 ? !1 : sM(t, e)
}
function sM(t, e) {
    const { parentNode: n } = e;
    return n ? t.has(n) ? !0 : sM(t, n) : !1
}
let nd;
function NG(t) {
    nd = t
}
function DG() {
    nd = void 0
}
const Ct = t => nd ? (...n) => {
    try {
        return t(...n)
    } catch (s) {
        if (nd && nd(s) === !0)
            return () => { }
                ;
        throw s
    }
}
    : t;
function Zr(t) {
    let e, n = t[0], s = 1;
    for (; s < t.length;) {
        const r = t[s]
            , i = t[s + 1];
        if (s += 2,
            (r === "optionalAccess" || r === "optionalCall") && n == null)
            return;
        r === "access" || r === "optionalAccess" ? (e = n,
            n = i(n)) : (r === "call" || r === "optionalCall") && (n = i((...o) => n.call(e, ...o)),
                e = void 0)
    }
    return n
}
const Qc = [];
function hf(t) {
    try {
        if ("composedPath" in t) {
            const e = t.composedPath();
            if (e.length)
                return e[0]
        } else if ("path" in t && t.path.length)
            return t.path[0]
    } catch { }
    return t && t.target
}
function rM(t, e) {
    const n = new LG;
    Qc.push(n),
        n.init(t);
    let s = window.MutationObserver || window.__rrMutationObserver;
    const r = Zr([window, "optionalAccess", o => o.Zone, "optionalAccess", o => o.__symbol__, "optionalCall", o => o("MutationObserver")]);
    r && window[r] && (s = window[r]);
    const i = new s(Ct(o => {
        t.onMutation && t.onMutation(o) === !1 || n.processMutations.bind(n)(o)
    }
    ));
    return i.observe(e, {
        attributes: !0,
        attributeOldValue: !0,
        characterData: !0,
        characterDataOldValue: !0,
        childList: !0,
        subtree: !0
    }),
        i
}
function BG({ mousemoveCb: t, sampling: e, doc: n, mirror: s }) {
    if (e.mousemove === !1)
        return () => { }
            ;
    const r = typeof e.mousemove == "number" ? e.mousemove : 50
        , i = typeof e.mousemoveCallback == "number" ? e.mousemoveCallback : 500;
    let o = [], l;
    const a = Cd(Ct(h => {
        const d = Date.now() - l;
        t(o.map(f => (f.timeOffset -= d,
            f)), h),
            o = [],
            l = null
    }
    ), i)
        , c = Ct(Cd(Ct(h => {
            const d = hf(h)
                , { clientX: f, clientY: p } = ky(h) ? h.changedTouches[0] : h;
            l || (l = Tm()),
                o.push({
                    x: f,
                    y: p,
                    id: s.getId(d),
                    timeOffset: Tm() - l
                }),
                a(typeof DragEvent < "u" && h instanceof DragEvent ? et.Drag : h instanceof MouseEvent ? et.MouseMove : et.TouchMove)
        }
        ), r, {
            trailing: !1
        }))
        , u = [Cs("mousemove", c, n), Cs("touchmove", c, n), Cs("drag", c, n)];
    return Ct(() => {
        u.forEach(h => h())
    }
    )
}
function FG({ mouseInteractionCb: t, doc: e, mirror: n, blockClass: s, blockSelector: r, unblockSelector: i, sampling: o }) {
    if (o.mouseInteraction === !1)
        return () => { }
            ;
    const l = o.mouseInteraction === !0 || o.mouseInteraction === void 0 ? {} : o.mouseInteraction
        , a = [];
    let c = null;
    const u = h => d => {
        const f = hf(d);
        if (rr(f, s, r, i, !0))
            return;
        let p = null
            , m = h;
        if ("pointerType" in d) {
            switch (d.pointerType) {
                case "mouse":
                    p = io.Mouse;
                    break;
                case "touch":
                    p = io.Touch;
                    break;
                case "pen":
                    p = io.Pen;
                    break
            }
            p === io.Touch ? Ss[h] === Ss.MouseDown ? m = "TouchStart" : Ss[h] === Ss.MouseUp && (m = "TouchEnd") : io.Pen
        } else
            ky(d) && (p = io.Touch);
        p !== null ? (c = p,
            (m.startsWith("Touch") && p === io.Touch || m.startsWith("Mouse") && p === io.Mouse) && (p = null)) : Ss[h] === Ss.Click && (p = c,
                c = null);
        const g = ky(d) ? d.changedTouches[0] : d;
        if (!g)
            return;
        const b = n.getId(f)
            , { clientX: v, clientY: _ } = g;
        Ct(t)({
            type: Ss[m],
            id: b,
            x: v,
            y: _,
            ...p !== null && {
                pointerType: p
            }
        })
    }
        ;
    return Object.keys(Ss).filter(h => Number.isNaN(Number(h)) && !h.endsWith("_Departed") && l[h] !== !1).forEach(h => {
        let d = Bu(h);
        const f = u(h);
        if (window.PointerEvent)
            switch (Ss[h]) {
                case Ss.MouseDown:
                case Ss.MouseUp:
                    d = d.replace("mouse", "pointer");
                    break;
                case Ss.TouchStart:
                case Ss.TouchEnd:
                    return
            }
        a.push(Cs(d, f, e))
    }
    ),
        Ct(() => {
            a.forEach(h => h())
        }
        )
}
function iM({ scrollCb: t, doc: e, mirror: n, blockClass: s, blockSelector: r, unblockSelector: i, sampling: o }) {
    const l = Ct(Cd(Ct(a => {
        const c = hf(a);
        if (!c || rr(c, s, r, i, !0))
            return;
        const u = n.getId(c);
        if (c === e && e.defaultView) {
            const h = zR(e.defaultView);
            t({
                id: u,
                x: h.left,
                y: h.top
            })
        } else
            t({
                id: u,
                x: c.scrollLeft,
                y: c.scrollTop
            })
    }
    ), o.scroll || 100));
    return Cs("scroll", l, e)
}
function $G({ viewportResizeCb: t }, { win: e }) {
    let n = -1
        , s = -1;
    const r = Ct(Cd(Ct(() => {
        const i = qR()
            , o = KR();
        (n !== i || s !== o) && (t({
            width: Number(o),
            height: Number(i)
        }),
            n = i,
            s = o)
    }
    ), 200));
    return Cs("resize", r, e)
}
const UG = ["INPUT", "TEXTAREA", "SELECT"]
    , QT = new WeakMap;
function VG({ inputCb: t, doc: e, mirror: n, blockClass: s, blockSelector: r, unblockSelector: i, ignoreClass: o, ignoreSelector: l, maskInputOptions: a, maskInputFn: c, sampling: u, userTriggeredOnInput: h, maskTextClass: d, unmaskTextClass: f, maskTextSelector: p, unmaskTextSelector: m }) {
    function g(S) {
        let E = hf(S);
        const C = S.isTrusted
            , I = E && Iy(E.tagName);
        if (I === "OPTION" && (E = E.parentElement),
            !E || !I || UG.indexOf(I) < 0 || rr(E, s, r, i, !0))
            return;
        const L = E;
        if (L.classList.contains(o) || l && L.matches(l))
            return;
        const k = ox(E);
        let R = Sm(L, I, k)
            , U = !1;
        const W = s_({
            maskInputOptions: a,
            tagName: I,
            type: k
        })
            , H = Fu(E, d, p, f, m, W);
        (k === "radio" || k === "checkbox") && (U = E.checked),
            R = Ed({
                isMasked: H,
                element: E,
                value: R,
                maskInputFn: c
            }),
            b(E, h ? {
                text: R,
                isChecked: U,
                userTriggered: C
            } : {
                text: R,
                isChecked: U
            });
        const j = E.name;
        k === "radio" && j && U && e.querySelectorAll(`input[type="radio"][name="${j}"]`).forEach(z => {
            if (z !== E) {
                const ee = Ed({
                    isMasked: H,
                    element: z,
                    value: Sm(z, I, k),
                    maskInputFn: c
                });
                b(z, h ? {
                    text: ee,
                    isChecked: !U,
                    userTriggered: !1
                } : {
                    text: ee,
                    isChecked: !U
                })
            }
        }
        )
    }
    function b(S, E) {
        const C = QT.get(S);
        if (!C || C.text !== E.text || C.isChecked !== E.isChecked) {
            QT.set(S, E);
            const I = n.getId(S);
            Ct(t)({
                ...E,
                id: I
            })
        }
    }
    const _ = (u.input === "last" ? ["change"] : ["input", "change"]).map(S => Cs(S, Ct(g), e))
        , y = e.defaultView;
    if (!y)
        return () => {
            _.forEach(S => S())
        }
            ;
    const x = y.Object.getOwnPropertyDescriptor(y.HTMLInputElement.prototype, "value")
        , w = [[y.HTMLInputElement.prototype, "value"], [y.HTMLInputElement.prototype, "checked"], [y.HTMLSelectElement.prototype, "value"], [y.HTMLTextAreaElement.prototype, "value"], [y.HTMLSelectElement.prototype, "selectedIndex"], [y.HTMLOptionElement.prototype, "selected"]];
    return x && x.set && _.push(...w.map(S => jR(S[0], S[1], {
        set() {
            Ct(g)({
                target: this,
                isTrusted: !1
            })
        }
    }, !1, y))),
        Ct(() => {
            _.forEach(S => S())
        }
        )
}
function Cm(t) {
    const e = [];
    function n(s, r) {
        if (zf("CSSGroupingRule") && s.parentRule instanceof CSSGroupingRule || zf("CSSMediaRule") && s.parentRule instanceof CSSMediaRule || zf("CSSSupportsRule") && s.parentRule instanceof CSSSupportsRule || zf("CSSConditionRule") && s.parentRule instanceof CSSConditionRule) {
            const o = Array.from(s.parentRule.cssRules).indexOf(s);
            r.unshift(o)
        } else if (s.parentStyleSheet) {
            const o = Array.from(s.parentStyleSheet.cssRules).indexOf(s);
            r.unshift(o)
        }
        return r
    }
    return n(t, e)
}
function _a(t, e, n) {
    let s, r;
    return t ? (t.ownerNode ? s = e.getId(t.ownerNode) : r = n.getId(t),
    {
        styleId: r,
        id: s
    }) : {}
}
function GG({ styleSheetRuleCb: t, mirror: e, stylesheetManager: n }, { win: s }) {
    if (!s.CSSStyleSheet || !s.CSSStyleSheet.prototype)
        return () => { }
            ;
    const r = s.CSSStyleSheet.prototype.insertRule;
    s.CSSStyleSheet.prototype.insertRule = new Proxy(r, {
        apply: Ct((u, h, d) => {
            const [f, p] = d
                , { id: m, styleId: g } = _a(h, e, n.styleMirror);
            return (m && m !== -1 || g && g !== -1) && t({
                id: m,
                styleId: g,
                adds: [{
                    rule: f,
                    index: p
                }]
            }),
                u.apply(h, d)
        }
        )
    });
    const i = s.CSSStyleSheet.prototype.deleteRule;
    s.CSSStyleSheet.prototype.deleteRule = new Proxy(i, {
        apply: Ct((u, h, d) => {
            const [f] = d
                , { id: p, styleId: m } = _a(h, e, n.styleMirror);
            return (p && p !== -1 || m && m !== -1) && t({
                id: p,
                styleId: m,
                removes: [{
                    index: f
                }]
            }),
                u.apply(h, d)
        }
        )
    });
    let o;
    s.CSSStyleSheet.prototype.replace && (o = s.CSSStyleSheet.prototype.replace,
        s.CSSStyleSheet.prototype.replace = new Proxy(o, {
            apply: Ct((u, h, d) => {
                const [f] = d
                    , { id: p, styleId: m } = _a(h, e, n.styleMirror);
                return (p && p !== -1 || m && m !== -1) && t({
                    id: p,
                    styleId: m,
                    replace: f
                }),
                    u.apply(h, d)
            }
            )
        }));
    let l;
    s.CSSStyleSheet.prototype.replaceSync && (l = s.CSSStyleSheet.prototype.replaceSync,
        s.CSSStyleSheet.prototype.replaceSync = new Proxy(l, {
            apply: Ct((u, h, d) => {
                const [f] = d
                    , { id: p, styleId: m } = _a(h, e, n.styleMirror);
                return (p && p !== -1 || m && m !== -1) && t({
                    id: p,
                    styleId: m,
                    replaceSync: f
                }),
                    u.apply(h, d)
            }
            )
        }));
    const a = {};
    qf("CSSGroupingRule") ? a.CSSGroupingRule = s.CSSGroupingRule : (qf("CSSMediaRule") && (a.CSSMediaRule = s.CSSMediaRule),
        qf("CSSConditionRule") && (a.CSSConditionRule = s.CSSConditionRule),
        qf("CSSSupportsRule") && (a.CSSSupportsRule = s.CSSSupportsRule));
    const c = {};
    return Object.entries(a).forEach(([u, h]) => {
        c[u] = {
            insertRule: h.prototype.insertRule,
            deleteRule: h.prototype.deleteRule
        },
            h.prototype.insertRule = new Proxy(c[u].insertRule, {
                apply: Ct((d, f, p) => {
                    const [m, g] = p
                        , { id: b, styleId: v } = _a(f.parentStyleSheet, e, n.styleMirror);
                    return (b && b !== -1 || v && v !== -1) && t({
                        id: b,
                        styleId: v,
                        adds: [{
                            rule: m,
                            index: [...Cm(f), g || 0]
                        }]
                    }),
                        d.apply(f, p)
                }
                )
            }),
            h.prototype.deleteRule = new Proxy(c[u].deleteRule, {
                apply: Ct((d, f, p) => {
                    const [m] = p
                        , { id: g, styleId: b } = _a(f.parentStyleSheet, e, n.styleMirror);
                    return (g && g !== -1 || b && b !== -1) && t({
                        id: g,
                        styleId: b,
                        removes: [{
                            index: [...Cm(f), m]
                        }]
                    }),
                        d.apply(f, p)
                }
                )
            })
    }
    ),
        Ct(() => {
            s.CSSStyleSheet.prototype.insertRule = r,
                s.CSSStyleSheet.prototype.deleteRule = i,
                o && (s.CSSStyleSheet.prototype.replace = o),
                l && (s.CSSStyleSheet.prototype.replaceSync = l),
                Object.entries(a).forEach(([u, h]) => {
                    h.prototype.insertRule = c[u].insertRule,
                        h.prototype.deleteRule = c[u].deleteRule
                }
                )
        }
        )
}
function oM({ mirror: t, stylesheetManager: e }, n) {
    let s = null;
    n.nodeName === "#document" ? s = t.getId(n) : s = t.getId(n.host);
    const r = n.nodeName === "#document" ? Zr([n, "access", o => o.defaultView, "optionalAccess", o => o.Document]) : Zr([n, "access", o => o.ownerDocument, "optionalAccess", o => o.defaultView, "optionalAccess", o => o.ShadowRoot])
        , i = Zr([r, "optionalAccess", o => o.prototype]) ? Object.getOwnPropertyDescriptor(Zr([r, "optionalAccess", o => o.prototype]), "adoptedStyleSheets") : void 0;
    return s === null || s === -1 || !r || !i ? () => { }
        : (Object.defineProperty(n, "adoptedStyleSheets", {
            configurable: i.configurable,
            enumerable: i.enumerable,
            get() {
                return Zr([i, "access", o => o.get, "optionalAccess", o => o.call, "call", o => o(this)])
            },
            set(o) {
                const l = Zr([i, "access", a => a.set, "optionalAccess", a => a.call, "call", a => a(this, o)]);
                if (s !== null && s !== -1)
                    try {
                        e.adoptStyleSheets(o, s)
                    } catch { }
                return l
            }
        }),
            Ct(() => {
                Object.defineProperty(n, "adoptedStyleSheets", {
                    configurable: i.configurable,
                    enumerable: i.enumerable,
                    get: i.get,
                    set: i.set
                })
            }
            ))
}
function HG({ styleDeclarationCb: t, mirror: e, ignoreCSSAttributes: n, stylesheetManager: s }, { win: r }) {
    const i = r.CSSStyleDeclaration.prototype.setProperty;
    r.CSSStyleDeclaration.prototype.setProperty = new Proxy(i, {
        apply: Ct((l, a, c) => {
            const [u, h, d] = c;
            if (n.has(u))
                return i.apply(a, [u, h, d]);
            const { id: f, styleId: p } = _a(Zr([a, "access", m => m.parentRule, "optionalAccess", m => m.parentStyleSheet]), e, s.styleMirror);
            return (f && f !== -1 || p && p !== -1) && t({
                id: f,
                styleId: p,
                set: {
                    property: u,
                    value: h,
                    priority: d
                },
                index: Cm(a.parentRule)
            }),
                l.apply(a, c)
        }
        )
    });
    const o = r.CSSStyleDeclaration.prototype.removeProperty;
    return r.CSSStyleDeclaration.prototype.removeProperty = new Proxy(o, {
        apply: Ct((l, a, c) => {
            const [u] = c;
            if (n.has(u))
                return o.apply(a, [u]);
            const { id: h, styleId: d } = _a(Zr([a, "access", f => f.parentRule, "optionalAccess", f => f.parentStyleSheet]), e, s.styleMirror);
            return (h && h !== -1 || d && d !== -1) && t({
                id: h,
                styleId: d,
                remove: {
                    property: u
                },
                index: Cm(a.parentRule)
            }),
                l.apply(a, c)
        }
        )
    }),
        Ct(() => {
            r.CSSStyleDeclaration.prototype.setProperty = i,
                r.CSSStyleDeclaration.prototype.removeProperty = o
        }
        )
}
function WG({ mediaInteractionCb: t, blockClass: e, blockSelector: n, unblockSelector: s, mirror: r, sampling: i, doc: o }) {
    const l = Ct(c => Cd(Ct(u => {
        const h = hf(u);
        if (!h || rr(h, e, n, s, !0))
            return;
        const { currentTime: d, volume: f, muted: p, playbackRate: m } = h;
        t({
            type: c,
            id: r.getId(h),
            currentTime: d,
            volume: f,
            muted: p,
            playbackRate: m
        })
    }
    ), i.media || 500))
        , a = [Cs("play", l(0), o), Cs("pause", l(1), o), Cs("seeked", l(2), o), Cs("volumechange", l(3), o), Cs("ratechange", l(4), o)];
    return Ct(() => {
        a.forEach(c => c())
    }
    )
}
function YG({ fontCb: t, doc: e }) {
    const n = e.defaultView;
    if (!n)
        return () => { }
            ;
    const s = []
        , r = new WeakMap
        , i = n.FontFace;
    n.FontFace = function (a, c, u) {
        const h = new i(a, c, u);
        return r.set(h, {
            family: a,
            buffer: typeof c != "string",
            descriptors: u,
            fontSource: typeof c == "string" ? c : JSON.stringify(Array.from(new Uint8Array(c)))
        }),
            h
    }
        ;
    const o = lx(e.fonts, "add", function (l) {
        return function (a) {
            return i_(Ct(() => {
                const c = r.get(a);
                c && (t(c),
                    r.delete(a))
            }
            ), 0),
                l.apply(this, [a])
        }
    });
    return s.push(() => {
        n.FontFace = i
    }
    ),
        s.push(o),
        Ct(() => {
            s.forEach(l => l())
        }
        )
}
function XG(t) {
    const { doc: e, mirror: n, blockClass: s, blockSelector: r, unblockSelector: i, selectionCb: o } = t;
    let l = !0;
    const a = Ct(() => {
        const c = e.getSelection();
        if (!c || l && Zr([c, "optionalAccess", d => d.isCollapsed]))
            return;
        l = c.isCollapsed || !1;
        const u = []
            , h = c.rangeCount || 0;
        for (let d = 0; d < h; d++) {
            const f = c.getRangeAt(d)
                , { startContainer: p, startOffset: m, endContainer: g, endOffset: b } = f;
            rr(p, s, r, i, !0) || rr(g, s, r, i, !0) || u.push({
                start: n.getId(p),
                startOffset: m,
                end: n.getId(g),
                endOffset: b
            })
        }
        o({
            ranges: u
        })
    }
    );
    return a(),
        Cs("selectionchange", a)
}
function jG({ doc: t, customElementCb: e }) {
    const n = t.defaultView;
    return !n || !n.customElements ? () => { }
        : lx(n.customElements, "define", function (r) {
            return function (i, o, l) {
                try {
                    e({
                        define: {
                            name: i
                        }
                    })
                } catch { }
                return r.apply(this, [i, o, l])
            }
        })
}
function zG(t, e = {}) {
    const n = t.doc.defaultView;
    if (!n)
        return () => { }
            ;
    let s;
    t.recordDOM && (s = rM(t, t.doc));
    const r = BG(t)
        , i = FG(t)
        , o = iM(t)
        , l = $G(t, {
            win: n
        })
        , a = VG(t)
        , c = WG(t);
    let u = () => { }
        , h = () => { }
        , d = () => { }
        , f = () => { }
        ;
    t.recordDOM && (u = GG(t, {
        win: n
    }),
        h = oM(t, t.doc),
        d = HG(t, {
            win: n
        }),
        t.collectFonts && (f = YG(t)));
    const p = XG(t)
        , m = jG(t)
        , g = [];
    for (const b of t.plugins)
        g.push(b.observer(b.callback, n, b.options));
    return Ct(() => {
        Qc.forEach(b => b.reset()),
            Zr([s, "optionalAccess", b => b.disconnect, "call", b => b()]),
            r(),
            i(),
            o(),
            l(),
            a(),
            c(),
            u(),
            h(),
            d(),
            f(),
            p(),
            m(),
            g.forEach(b => b())
    }
    )
}
function zf(t) {
    return typeof window[t] < "u"
}
function qf(t) {
    return !!(typeof window[t] < "u" && window[t].prototype && "insertRule" in window[t].prototype && "deleteRule" in window[t].prototype)
}
class Py {
    constructor(e) {
        this.generateIdFn = e,
            this.iframeIdToRemoteIdMap = new WeakMap,
            this.iframeRemoteIdToIdMap = new WeakMap
    }
    getId(e, n, s, r) {
        const i = s || this.getIdToRemoteIdMap(e)
            , o = r || this.getRemoteIdToIdMap(e);
        let l = i.get(n);
        return l || (l = this.generateIdFn(),
            i.set(n, l),
            o.set(l, n)),
            l
    }
    getIds(e, n) {
        const s = this.getIdToRemoteIdMap(e)
            , r = this.getRemoteIdToIdMap(e);
        return n.map(i => this.getId(e, i, s, r))
    }
    getRemoteId(e, n, s) {
        const r = s || this.getRemoteIdToIdMap(e);
        if (typeof n != "number")
            return n;
        const i = r.get(n);
        return i || -1
    }
    getRemoteIds(e, n) {
        const s = this.getRemoteIdToIdMap(e);
        return n.map(r => this.getRemoteId(e, r, s))
    }
    reset(e) {
        if (!e) {
            this.iframeIdToRemoteIdMap = new WeakMap,
                this.iframeRemoteIdToIdMap = new WeakMap;
            return
        }
        this.iframeIdToRemoteIdMap.delete(e),
            this.iframeRemoteIdToIdMap.delete(e)
    }
    getIdToRemoteIdMap(e) {
        let n = this.iframeIdToRemoteIdMap.get(e);
        return n || (n = new Map,
            this.iframeIdToRemoteIdMap.set(e, n)),
            n
    }
    getRemoteIdToIdMap(e) {
        let n = this.iframeRemoteIdToIdMap.get(e);
        return n || (n = new Map,
            this.iframeRemoteIdToIdMap.set(e, n)),
            n
    }
}
function eC(t) {
    let e, n = t[0], s = 1;
    for (; s < t.length;) {
        const r = t[s]
            , i = t[s + 1];
        if (s += 2,
            (r === "optionalAccess" || r === "optionalCall") && n == null)
            return;
        r === "access" || r === "optionalAccess" ? (e = n,
            n = i(n)) : (r === "call" || r === "optionalCall") && (n = i((...o) => n.call(e, ...o)),
                e = void 0)
    }
    return n
}
class qG {
    constructor() {
        this.crossOriginIframeMirror = new Py(ax),
            this.crossOriginIframeRootIdMap = new WeakMap
    }
    addIframe() { }
    addLoadListener() { }
    attachIframe() { }
}
class KG {
    constructor(e) {
        this.iframes = new WeakMap,
            this.crossOriginIframeMap = new WeakMap,
            this.crossOriginIframeMirror = new Py(ax),
            this.crossOriginIframeRootIdMap = new WeakMap,
            this.mutationCb = e.mutationCb,
            this.wrappedEmit = e.wrappedEmit,
            this.stylesheetManager = e.stylesheetManager,
            this.recordCrossOriginIframes = e.recordCrossOriginIframes,
            this.crossOriginIframeStyleMirror = new Py(this.stylesheetManager.styleMirror.generateId.bind(this.stylesheetManager.styleMirror)),
            this.mirror = e.mirror,
            this.recordCrossOriginIframes && window.addEventListener("message", this.handleMessage.bind(this))
    }
    addIframe(e) {
        this.iframes.set(e, !0),
            e.contentWindow && this.crossOriginIframeMap.set(e.contentWindow, e)
    }
    addLoadListener(e) {
        this.loadListener = e
    }
    attachIframe(e, n) {
        this.mutationCb({
            adds: [{
                parentId: this.mirror.getId(e),
                nextId: null,
                node: n
            }],
            removes: [],
            texts: [],
            attributes: [],
            isAttachIframe: !0
        }),
            eC([this, "access", s => s.loadListener, "optionalCall", s => s(e)]),
            e.contentDocument && e.contentDocument.adoptedStyleSheets && e.contentDocument.adoptedStyleSheets.length > 0 && this.stylesheetManager.adoptStyleSheets(e.contentDocument.adoptedStyleSheets, this.mirror.getId(e.contentDocument))
    }
    handleMessage(e) {
        const n = e;
        if (n.data.type !== "rrweb" || n.origin !== n.data.origin || !e.source)
            return;
        const r = this.crossOriginIframeMap.get(e.source);
        if (!r)
            return;
        const i = this.transformCrossOriginEvent(r, n.data.event);
        i && this.wrappedEmit(i, n.data.isCheckout)
    }
    transformCrossOriginEvent(e, n) {
        switch (n.type) {
            case ht.FullSnapshot:
                {
                    this.crossOriginIframeMirror.reset(e),
                        this.crossOriginIframeStyleMirror.reset(e),
                        this.replaceIdOnNode(n.data.node, e);
                    const s = n.data.node.id;
                    return this.crossOriginIframeRootIdMap.set(e, s),
                        this.patchRootIdOnNode(n.data.node, s),
                    {
                        timestamp: n.timestamp,
                        type: ht.IncrementalSnapshot,
                        data: {
                            source: et.Mutation,
                            adds: [{
                                parentId: this.mirror.getId(e),
                                nextId: null,
                                node: n.data.node
                            }],
                            removes: [],
                            texts: [],
                            attributes: [],
                            isAttachIframe: !0
                        }
                    }
                }
            case ht.Meta:
            case ht.Load:
            case ht.DomContentLoaded:
                return !1;
            case ht.Plugin:
                return n;
            case ht.Custom:
                return this.replaceIds(n.data.payload, e, ["id", "parentId", "previousId", "nextId"]),
                    n;
            case ht.IncrementalSnapshot:
                switch (n.data.source) {
                    case et.Mutation:
                        return n.data.adds.forEach(s => {
                            this.replaceIds(s, e, ["parentId", "nextId", "previousId"]),
                                this.replaceIdOnNode(s.node, e);
                            const r = this.crossOriginIframeRootIdMap.get(e);
                            r && this.patchRootIdOnNode(s.node, r)
                        }
                        ),
                            n.data.removes.forEach(s => {
                                this.replaceIds(s, e, ["parentId", "id"])
                            }
                            ),
                            n.data.attributes.forEach(s => {
                                this.replaceIds(s, e, ["id"])
                            }
                            ),
                            n.data.texts.forEach(s => {
                                this.replaceIds(s, e, ["id"])
                            }
                            ),
                            n;
                    case et.Drag:
                    case et.TouchMove:
                    case et.MouseMove:
                        return n.data.positions.forEach(s => {
                            this.replaceIds(s, e, ["id"])
                        }
                        ),
                            n;
                    case et.ViewportResize:
                        return !1;
                    case et.MediaInteraction:
                    case et.MouseInteraction:
                    case et.Scroll:
                    case et.CanvasMutation:
                    case et.Input:
                        return this.replaceIds(n.data, e, ["id"]),
                            n;
                    case et.StyleSheetRule:
                    case et.StyleDeclaration:
                        return this.replaceIds(n.data, e, ["id"]),
                            this.replaceStyleIds(n.data, e, ["styleId"]),
                            n;
                    case et.Font:
                        return n;
                    case et.Selection:
                        return n.data.ranges.forEach(s => {
                            this.replaceIds(s, e, ["start", "end"])
                        }
                        ),
                            n;
                    case et.AdoptedStyleSheet:
                        return this.replaceIds(n.data, e, ["id"]),
                            this.replaceStyleIds(n.data, e, ["styleIds"]),
                            eC([n, "access", s => s.data, "access", s => s.styles, "optionalAccess", s => s.forEach, "call", s => s(r => {
                                this.replaceStyleIds(r, e, ["styleId"])
                            }
                            )]),
                            n
                }
        }
        return !1
    }
    replace(e, n, s, r) {
        for (const i of r)
            !Array.isArray(n[i]) && typeof n[i] != "number" || (Array.isArray(n[i]) ? n[i] = e.getIds(s, n[i]) : n[i] = e.getId(s, n[i]));
        return n
    }
    replaceIds(e, n, s) {
        return this.replace(this.crossOriginIframeMirror, e, n, s)
    }
    replaceStyleIds(e, n, s) {
        return this.replace(this.crossOriginIframeStyleMirror, e, n, s)
    }
    replaceIdOnNode(e, n) {
        this.replaceIds(e, n, ["id", "rootId"]),
            "childNodes" in e && e.childNodes.forEach(s => {
                this.replaceIdOnNode(s, n)
            }
            )
    }
    patchRootIdOnNode(e, n) {
        e.type !== kn.Document && !e.rootId && (e.rootId = n),
            "childNodes" in e && e.childNodes.forEach(s => {
                this.patchRootIdOnNode(s, n)
            }
            )
    }
}
class JG {
    init() { }
    addShadowRoot() { }
    observeAttachShadow() { }
    reset() { }
}
class ZG {
    constructor(e) {
        this.shadowDoms = new WeakSet,
            this.restoreHandlers = [],
            this.mutationCb = e.mutationCb,
            this.scrollCb = e.scrollCb,
            this.bypassOptions = e.bypassOptions,
            this.mirror = e.mirror,
            this.init()
    }
    init() {
        this.reset(),
            this.patchAttachShadow(Element, document)
    }
    addShadowRoot(e, n) {
        if (!td(e) || this.shadowDoms.has(e))
            return;
        this.shadowDoms.add(e),
            this.bypassOptions.canvasManager.addShadowRoot(e);
        const s = rM({
            ...this.bypassOptions,
            doc: n,
            mutationCb: this.mutationCb,
            mirror: this.mirror,
            shadowDomManager: this
        }, e);
        this.restoreHandlers.push(() => s.disconnect()),
            this.restoreHandlers.push(iM({
                ...this.bypassOptions,
                scrollCb: this.scrollCb,
                doc: e,
                mirror: this.mirror
            })),
            i_(() => {
                e.adoptedStyleSheets && e.adoptedStyleSheets.length > 0 && this.bypassOptions.stylesheetManager.adoptStyleSheets(e.adoptedStyleSheets, this.mirror.getId(e.host)),
                    this.restoreHandlers.push(oM({
                        mirror: this.mirror,
                        stylesheetManager: this.bypassOptions.stylesheetManager
                    }, e))
            }
                , 0)
    }
    observeAttachShadow(e) {
        !e.contentWindow || !e.contentDocument || this.patchAttachShadow(e.contentWindow.Element, e.contentDocument)
    }
    patchAttachShadow(e, n) {
        const s = this;
        this.restoreHandlers.push(lx(e.prototype, "attachShadow", function (r) {
            return function (i) {
                const o = r.call(this, i);
                return this.shadowRoot && nM(this) && s.addShadowRoot(this.shadowRoot, n),
                    o
            }
        }))
    }
    reset() {
        this.restoreHandlers.forEach(e => {
            try {
                e()
            } catch { }
        }
        ),
            this.restoreHandlers = [],
            this.shadowDoms = new WeakSet,
            this.bypassOptions.canvasManager.resetShadowRoots()
    }
}
class tC {
    reset() { }
    freeze() { }
    unfreeze() { }
    lock() { }
    unlock() { }
    snapshot() { }
    addWindow() { }
    addShadowRoot() { }
    resetShadowRoots() { }
}
class QG {
    constructor(e) {
        this.trackedLinkElements = new WeakSet,
            this.styleMirror = new CG,
            this.mutationCb = e.mutationCb,
            this.adoptedStyleSheetCb = e.adoptedStyleSheetCb
    }
    attachLinkElement(e, n) {
        "_cssText" in n.attributes && this.mutationCb({
            adds: [],
            removes: [],
            texts: [],
            attributes: [{
                id: n.id,
                attributes: n.attributes
            }]
        }),
            this.trackLinkElement(e)
    }
    trackLinkElement(e) {
        this.trackedLinkElements.has(e) || (this.trackedLinkElements.add(e),
            this.trackStylesheetInLinkElement(e))
    }
    adoptStyleSheets(e, n) {
        if (e.length === 0)
            return;
        const s = {
            id: n,
            styleIds: []
        }
            , r = [];
        for (const i of e) {
            let o;
            this.styleMirror.has(i) ? o = this.styleMirror.getId(i) : (o = this.styleMirror.add(i),
                r.push({
                    styleId: o,
                    rules: Array.from(i.rules || CSSRule, (l, a) => ({
                        rule: UR(l),
                        index: a
                    }))
                })),
                s.styleIds.push(o)
        }
        r.length > 0 && (s.styles = r),
            this.adoptedStyleSheetCb(s)
    }
    reset() {
        this.styleMirror.reset(),
            this.trackedLinkElements = new WeakSet
    }
    trackStylesheetInLinkElement(e) { }
}
class eH {
    constructor() {
        this.nodeMap = new WeakMap,
            this.active = !1
    }
    inOtherBuffer(e, n) {
        const s = this.nodeMap.get(e);
        return s && Array.from(s).some(r => r !== n)
    }
    add(e, n) {
        this.active || (this.active = !0,
            kG(() => {
                this.nodeMap = new WeakMap,
                    this.active = !1
            }
            )),
            this.nodeMap.set(e, (this.nodeMap.get(e) || new Set).add(n))
    }
    destroy() { }
}
let cn, Im;
try {
    if (Array.from([1], t => t * 2)[0] !== 2) {
        const t = document.createElement("iframe");
        document.body.appendChild(t),
            Array.from = Bp([t, "access", e => e.contentWindow, "optionalAccess", e => e.Array, "access", e => e.from]) || Array.from,
            document.body.removeChild(t)
    }
} catch (t) {
    console.debug("Unable to override Array.from", t)
}
const Ur = eG();
function Io(t = {}) {
    const { emit: e, checkoutEveryNms: n, checkoutEveryNth: s, blockClass: r = "rr-block", blockSelector: i = null, unblockSelector: o = null, ignoreClass: l = "rr-ignore", ignoreSelector: a = null, maskAllText: c = !1, maskTextClass: u = "rr-mask", unmaskTextClass: h = null, maskTextSelector: d = null, unmaskTextSelector: f = null, inlineStylesheet: p = !0, maskAllInputs: m, maskInputOptions: g, slimDOMOptions: b, maskAttributeFn: v, maskInputFn: _, maskTextFn: y, maxCanvasSize: x = null, packFn: w, sampling: S = {}, dataURLOptions: E = {}, mousemoveWait: C, recordDOM: I = !0, recordCanvas: L = !1, recordCrossOriginIframes: k = !1, recordAfter: R = t.recordAfter === "DOMContentLoaded" ? t.recordAfter : "load", userTriggeredOnInput: U = !1, collectFonts: W = !1, inlineImages: H = !1, plugins: j, keepIframeSrcFn: z = () => !1, ignoreCSSAttributes: ee = new Set([]), errorHandler: J, onMutation: Y, getCanvasManager: ne } = t;
    NG(J);
    const oe = k ? window.parent === window : !0;
    let ce = !1;
    if (!oe)
        try {
            window.parent.document && (ce = !1)
        } catch {
            ce = !0
        }
    if (oe && !e)
        throw new Error("emit function is required");
    if (!oe && !ce)
        return () => { }
            ;
    C !== void 0 && S.mousemove === void 0 && (S.mousemove = C),
        Ur.reset();
    const ue = m === !0 ? {
        color: !0,
        date: !0,
        "datetime-local": !0,
        email: !0,
        month: !0,
        number: !0,
        range: !0,
        search: !0,
        tel: !0,
        text: !0,
        time: !0,
        url: !0,
        week: !0,
        textarea: !0,
        select: !0,
        radio: !0,
        checkbox: !0
    } : g !== void 0 ? g : {}
        , we = b === !0 || b === "all" ? {
            script: !0,
            comment: !0,
            headFavicon: !0,
            headWhitespace: !0,
            headMetaSocial: !0,
            headMetaRobots: !0,
            headMetaHttpEquiv: !0,
            headMetaVerification: !0,
            headMetaAuthorship: b === "all",
            headMetaDescKeywords: b === "all"
        } : b || {};
    TG();
    let K, ge = 0;
    const he = P => {
        for (const B of j || [])
            B.eventProcessor && (P = B.eventProcessor(P));
        return w && !ce && (P = w(P)),
            P
    }
        ;
    cn = (P, B) => {
        const V = P;
        if (V.timestamp = Tm(),
            Bp([Qc, "access", re => re[0], "optionalAccess", re => re.isFrozen, "call", re => re()]) && V.type !== ht.FullSnapshot && !(V.type === ht.IncrementalSnapshot && V.data.source === et.Mutation) && Qc.forEach(re => re.unfreeze()),
            oe)
            Bp([e, "optionalCall", re => re(he(V), B)]);
        else if (ce) {
            const re = {
                type: "rrweb",
                event: he(V),
                origin: window.location.origin,
                isCheckout: B
            };
            window.parent.postMessage(re, "*")
        }
        if (V.type === ht.FullSnapshot)
            K = V,
                ge = 0;
        else if (V.type === ht.IncrementalSnapshot) {
            if (V.data.source === et.Mutation && V.data.isAttachIframe)
                return;
            ge++;
            const re = s && ge >= s
                , ye = n && K && V.timestamp - K.timestamp > n;
            (re || ye) && xe(!0)
        }
    }
        ;
    const be = P => {
        cn({
            type: ht.IncrementalSnapshot,
            data: {
                source: et.Mutation,
                ...P
            }
        })
    }
        , Pe = P => cn({
            type: ht.IncrementalSnapshot,
            data: {
                source: et.Scroll,
                ...P
            }
        })
        , De = P => cn({
            type: ht.IncrementalSnapshot,
            data: {
                source: et.CanvasMutation,
                ...P
            }
        })
        , D = P => cn({
            type: ht.IncrementalSnapshot,
            data: {
                source: et.AdoptedStyleSheet,
                ...P
            }
        })
        , M = new QG({
            mutationCb: be,
            adoptedStyleSheetCb: D
        })
        , X = typeof __RRWEB_EXCLUDE_IFRAME__ == "boolean" && __RRWEB_EXCLUDE_IFRAME__ ? new qG : new KG({
            mirror: Ur,
            mutationCb: be,
            stylesheetManager: M,
            recordCrossOriginIframes: k,
            wrappedEmit: cn
        });
    for (const P of j || [])
        P.getMirror && P.getMirror({
            nodeMirror: Ur,
            crossOriginIframeMirror: X.crossOriginIframeMirror,
            crossOriginIframeStyleMirror: X.crossOriginIframeStyleMirror
        });
    const ae = new eH
        , ie = nH(ne, {
            mirror: Ur,
            win: window,
            mutationCb: P => cn({
                type: ht.IncrementalSnapshot,
                data: {
                    source: et.CanvasMutation,
                    ...P
                }
            }),
            recordCanvas: L,
            blockClass: r,
            blockSelector: i,
            unblockSelector: o,
            maxCanvasSize: x,
            sampling: S.canvas,
            dataURLOptions: E,
            errorHandler: J
        })
        , pe = typeof __RRWEB_EXCLUDE_SHADOW_DOM__ == "boolean" && __RRWEB_EXCLUDE_SHADOW_DOM__ ? new JG : new ZG({
            mutationCb: be,
            scrollCb: Pe,
            bypassOptions: {
                onMutation: Y,
                blockClass: r,
                blockSelector: i,
                unblockSelector: o,
                maskAllText: c,
                maskTextClass: u,
                unmaskTextClass: h,
                maskTextSelector: d,
                unmaskTextSelector: f,
                inlineStylesheet: p,
                maskInputOptions: ue,
                dataURLOptions: E,
                maskAttributeFn: v,
                maskTextFn: y,
                maskInputFn: _,
                recordCanvas: L,
                inlineImages: H,
                sampling: S,
                slimDOMOptions: we,
                iframeManager: X,
                stylesheetManager: M,
                canvasManager: ie,
                keepIframeSrcFn: z,
                processedNodeManager: ae
            },
            mirror: Ur
        })
        , xe = (P = !1) => {
            if (!I)
                return;
            cn({
                type: ht.Meta,
                data: {
                    href: window.location.href,
                    width: KR(),
                    height: qR()
                }
            }, P),
                M.reset(),
                pe.init(),
                Qc.forEach(V => V.lock());
            const B = SG(document, {
                mirror: Ur,
                blockClass: r,
                blockSelector: i,
                unblockSelector: o,
                maskAllText: c,
                maskTextClass: u,
                unmaskTextClass: h,
                maskTextSelector: d,
                unmaskTextSelector: f,
                inlineStylesheet: p,
                maskAllInputs: ue,
                maskAttributeFn: v,
                maskInputFn: _,
                maskTextFn: y,
                slimDOM: we,
                dataURLOptions: E,
                recordCanvas: L,
                inlineImages: H,
                onSerialize: V => {
                    QR(V, Ur) && X.addIframe(V),
                        eM(V, Ur) && M.trackLinkElement(V),
                        Ry(V) && pe.addShadowRoot(V.shadowRoot, document)
                }
                ,
                onIframeLoad: (V, re) => {
                    X.attachIframe(V, re),
                        V.contentWindow && ie.addWindow(V.contentWindow),
                        pe.observeAttachShadow(V)
                }
                ,
                onStylesheetLoad: (V, re) => {
                    M.attachLinkElement(V, re)
                }
                ,
                keepIframeSrcFn: z
            });
            if (!B)
                return console.warn("Failed to snapshot the document");
            cn({
                type: ht.FullSnapshot,
                data: {
                    node: B,
                    initialOffset: zR(window)
                }
            }),
                Qc.forEach(V => V.unlock()),
                document.adoptedStyleSheets && document.adoptedStyleSheets.length > 0 && M.adoptStyleSheets(document.adoptedStyleSheets, Ur.getId(document))
        }
        ;
    Im = xe;
    try {
        const P = []
            , B = re => Ct(zG)({
                onMutation: Y,
                mutationCb: be,
                mousemoveCb: (ye, me) => cn({
                    type: ht.IncrementalSnapshot,
                    data: {
                        source: me,
                        positions: ye
                    }
                }),
                mouseInteractionCb: ye => cn({
                    type: ht.IncrementalSnapshot,
                    data: {
                        source: et.MouseInteraction,
                        ...ye
                    }
                }),
                scrollCb: Pe,
                viewportResizeCb: ye => cn({
                    type: ht.IncrementalSnapshot,
                    data: {
                        source: et.ViewportResize,
                        ...ye
                    }
                }),
                inputCb: ye => cn({
                    type: ht.IncrementalSnapshot,
                    data: {
                        source: et.Input,
                        ...ye
                    }
                }),
                mediaInteractionCb: ye => cn({
                    type: ht.IncrementalSnapshot,
                    data: {
                        source: et.MediaInteraction,
                        ...ye
                    }
                }),
                styleSheetRuleCb: ye => cn({
                    type: ht.IncrementalSnapshot,
                    data: {
                        source: et.StyleSheetRule,
                        ...ye
                    }
                }),
                styleDeclarationCb: ye => cn({
                    type: ht.IncrementalSnapshot,
                    data: {
                        source: et.StyleDeclaration,
                        ...ye
                    }
                }),
                canvasMutationCb: De,
                fontCb: ye => cn({
                    type: ht.IncrementalSnapshot,
                    data: {
                        source: et.Font,
                        ...ye
                    }
                }),
                selectionCb: ye => {
                    cn({
                        type: ht.IncrementalSnapshot,
                        data: {
                            source: et.Selection,
                            ...ye
                        }
                    })
                }
                ,
                customElementCb: ye => {
                    cn({
                        type: ht.IncrementalSnapshot,
                        data: {
                            source: et.CustomElement,
                            ...ye
                        }
                    })
                }
                ,
                blockClass: r,
                ignoreClass: l,
                ignoreSelector: a,
                maskAllText: c,
                maskTextClass: u,
                unmaskTextClass: h,
                maskTextSelector: d,
                unmaskTextSelector: f,
                maskInputOptions: ue,
                inlineStylesheet: p,
                sampling: S,
                recordDOM: I,
                recordCanvas: L,
                inlineImages: H,
                userTriggeredOnInput: U,
                collectFonts: W,
                doc: re,
                maskAttributeFn: v,
                maskInputFn: _,
                maskTextFn: y,
                keepIframeSrcFn: z,
                blockSelector: i,
                unblockSelector: o,
                slimDOMOptions: we,
                dataURLOptions: E,
                mirror: Ur,
                iframeManager: X,
                stylesheetManager: M,
                shadowDomManager: pe,
                processedNodeManager: ae,
                canvasManager: ie,
                ignoreCSSAttributes: ee,
                plugins: Bp([j, "optionalAccess", ye => ye.filter, "call", ye => ye(me => me.observer), "optionalAccess", ye => ye.map, "call", ye => ye(me => ({
                    observer: me.observer,
                    options: me.options,
                    callback: Z => cn({
                        type: ht.Plugin,
                        data: {
                            plugin: me.name,
                            payload: Z
                        }
                    })
                }))]) || []
            }, {});
        X.addLoadListener(re => {
            try {
                P.push(B(re.contentDocument))
            } catch (ye) {
                console.warn(ye)
            }
        }
        );
        const V = () => {
            xe(),
                P.push(B(document))
        }
            ;
        return document.readyState === "interactive" || document.readyState === "complete" ? V() : (P.push(Cs("DOMContentLoaded", () => {
            cn({
                type: ht.DomContentLoaded,
                data: {}
            }),
                R === "DOMContentLoaded" && V()
        }
        )),
            P.push(Cs("load", () => {
                cn({
                    type: ht.Load,
                    data: {}
                }),
                    R === "load" && V()
            }
                , window))),
            () => {
                P.forEach(re => re()),
                    ae.destroy(),
                    Im = void 0,
                    DG()
            }
    } catch (P) {
        console.warn(P)
    }
}
function tH(t) {
    if (!Im)
        throw new Error("please take full snapshot after start recording");
    Im(t)
}
Io.mirror = Ur;
Io.takeFullSnapshot = tH;
function nH(t, e) {
    try {
        return t ? t(e) : new tC
    } catch {
        return console.warn("Unable to initialize CanvasManager"),
            new tC
    }
}
const sH = 3
    , rH = 5;
function ux(t) {
    return t > 9999999999 ? t : t * 1e3
}
function I0(t) {
    return t > 9999999999 ? t / 1e3 : t
}
function df(t, e) {
    e.category !== "sentry.transaction" && (["ui.click", "ui.input"].includes(e.category) ? t.triggerUserActivity() : t.checkAndHandleExpiredSession(),
        t.addUpdate(() => (t.throttledAddEvent({
            type: ht.Custom,
            timestamp: (e.timestamp || 0) * 1e3,
            data: {
                tag: "breadcrumb",
                payload: Li(e, 10, 1e3)
            }
        }),
            e.category === "console")))
}
const iH = "button,a";
function aM(t) {
    return t.closest(iH) || t
}
function lM(t) {
    const e = cM(t);
    return !e || !(e instanceof Element) ? e : aM(e)
}
function cM(t) {
    return oH(t) ? t.target : t
}
function oH(t) {
    return typeof t == "object" && !!t && "target" in t
}
let ya;
function aH(t) {
    return ya || (ya = [],
        lH()),
        ya.push(t),
        () => {
            const e = ya ? ya.indexOf(t) : -1;
            e > -1 && ya.splice(e, 1)
        }
}
function lH() {
    Ys(Gt, "open", function (t) {
        return function (...e) {
            if (ya)
                try {
                    ya.forEach(n => n())
                } catch { }
            return t.apply(Gt, e)
        }
    })
}
const cH = new Set([et.Mutation, et.StyleSheetRule, et.StyleDeclaration, et.AdoptedStyleSheet, et.CanvasMutation, et.Selection, et.MediaInteraction]);
function uH(t, e, n) {
    t.handleClick(e, n)
}
class hH {
    constructor(e, n, s = df) {
        this._lastMutation = 0,
            this._lastScroll = 0,
            this._clicks = [],
            this._timeout = n.timeout / 1e3,
            this._threshold = n.threshold / 1e3,
            this._scrollTimeout = n.scrollTimeout / 1e3,
            this._replay = e,
            this._ignoreSelector = n.ignoreSelector,
            this._addBreadcrumbEvent = s
    }
    addListeners() {
        const e = aH(() => {
            this._lastMutation = nC()
        }
        );
        this._teardown = () => {
            e(),
                this._clicks = [],
                this._lastMutation = 0,
                this._lastScroll = 0
        }
    }
    removeListeners() {
        this._teardown && this._teardown(),
            this._checkClickTimeout && clearTimeout(this._checkClickTimeout)
    }
    handleClick(e, n) {
        if (fH(n, this._ignoreSelector) || !pH(e))
            return;
        const s = {
            timestamp: I0(e.timestamp),
            clickBreadcrumb: e,
            clickCount: 0,
            node: n
        };
        this._clicks.some(r => r.node === s.node && Math.abs(r.timestamp - s.timestamp) < 1) || (this._clicks.push(s),
            this._clicks.length === 1 && this._scheduleCheckClicks())
    }
    registerMutation(e = Date.now()) {
        this._lastMutation = I0(e)
    }
    registerScroll(e = Date.now()) {
        this._lastScroll = I0(e)
    }
    registerClick(e) {
        const n = aM(e);
        this._handleMultiClick(n)
    }
    _handleMultiClick(e) {
        this._getClicks(e).forEach(n => {
            n.clickCount++
        }
        )
    }
    _getClicks(e) {
        return this._clicks.filter(n => n.node === e)
    }
    _checkClicks() {
        const e = []
            , n = nC();
        this._clicks.forEach(s => {
            !s.mutationAfter && this._lastMutation && (s.mutationAfter = s.timestamp <= this._lastMutation ? this._lastMutation - s.timestamp : void 0),
                !s.scrollAfter && this._lastScroll && (s.scrollAfter = s.timestamp <= this._lastScroll ? this._lastScroll - s.timestamp : void 0),
                s.timestamp + this._timeout <= n && e.push(s)
        }
        );
        for (const s of e) {
            const r = this._clicks.indexOf(s);
            r > -1 && (this._generateBreadcrumbs(s),
                this._clicks.splice(r, 1))
        }
        this._clicks.length && this._scheduleCheckClicks()
    }
    _generateBreadcrumbs(e) {
        const n = this._replay
            , s = e.scrollAfter && e.scrollAfter <= this._scrollTimeout
            , r = e.mutationAfter && e.mutationAfter <= this._threshold
            , i = !s && !r
            , { clickCount: o, clickBreadcrumb: l } = e;
        if (i) {
            const a = Math.min(e.mutationAfter || this._timeout, this._timeout) * 1e3
                , c = a < this._timeout * 1e3 ? "mutation" : "timeout"
                , u = {
                    type: "default",
                    message: l.message,
                    timestamp: l.timestamp,
                    category: "ui.slowClickDetected",
                    data: {
                        ...l.data,
                        url: Gt.location.href,
                        route: n.getCurrentRoute(),
                        timeAfterClickMs: a,
                        endReason: c,
                        clickCount: o || 1
                    }
                };
            this._addBreadcrumbEvent(n, u);
            return
        }
        if (o > 1) {
            const a = {
                type: "default",
                message: l.message,
                timestamp: l.timestamp,
                category: "ui.multiClick",
                data: {
                    ...l.data,
                    url: Gt.location.href,
                    route: n.getCurrentRoute(),
                    clickCount: o,
                    metric: !0
                }
            };
            this._addBreadcrumbEvent(n, a)
        }
    }
    _scheduleCheckClicks() {
        this._checkClickTimeout && clearTimeout(this._checkClickTimeout),
            this._checkClickTimeout = Du(() => this._checkClicks(), 1e3)
    }
}
const dH = ["A", "BUTTON", "INPUT"];
function fH(t, e) {
    return !!(!dH.includes(t.tagName) || t.tagName === "INPUT" && !["submit", "button"].includes(t.getAttribute("type") || "") || t.tagName === "A" && (t.hasAttribute("download") || t.hasAttribute("target") && t.getAttribute("target") !== "_self") || e && t.matches(e))
}
function pH(t) {
    return !!(t.data && typeof t.data.nodeId == "number" && t.timestamp)
}
function nC() {
    return Date.now() / 1e3
}
function mH(t, e) {
    try {
        if (!gH(e))
            return;
        const { source: n } = e.data;
        if (cH.has(n) && t.registerMutation(e.timestamp),
            n === et.Scroll && t.registerScroll(e.timestamp),
            _H(e)) {
            const { type: s, id: r } = e.data
                , i = Io.mirror.getNode(r);
            i instanceof HTMLElement && s === Ss.Click && t.registerClick(i)
        }
    } catch { }
}
function gH(t) {
    return t.type === sH
}
function _H(t) {
    return t.data.source === et.MouseInteraction
}
function Fi(t) {
    return {
        timestamp: Date.now() / 1e3,
        type: "default",
        ...t
    }
}
var Am;
(function (t) {
    t[t.Document = 0] = "Document",
        t[t.DocumentType = 1] = "DocumentType",
        t[t.Element = 2] = "Element",
        t[t.Text = 3] = "Text",
        t[t.CDATA = 4] = "CDATA",
        t[t.Comment = 5] = "Comment"
}
)(Am || (Am = {}));
const yH = new Set(["id", "class", "aria-label", "role", "name", "alt", "title", "data-test-id", "data-testid", "disabled", "aria-disabled", "data-sentry-component"]);
function bH(t) {
    const e = {};
    !t["data-sentry-component"] && t["data-sentry-element"] && (t["data-sentry-component"] = t["data-sentry-element"]);
    for (const n in t)
        if (yH.has(n)) {
            let s = n;
            (n === "data-testid" || n === "data-test-id") && (s = "testId"),
                e[s] = t[n]
        }
    return e
}
const vH = t => e => {
    if (!t.isEnabled())
        return;
    const n = xH(e);
    if (!n)
        return;
    const s = e.name === "click"
        , r = s ? e.event : void 0;
    s && t.clickDetector && r && r.target && !r.altKey && !r.metaKey && !r.ctrlKey && !r.shiftKey && uH(t.clickDetector, n, lM(e.event)),
        df(t, n)
}
    ;
function uM(t, e) {
    const n = Io.mirror.getId(t)
        , s = n && Io.mirror.getNode(n)
        , r = s && Io.mirror.getMeta(s)
        , i = r && SH(r) ? r : null;
    return {
        message: e,
        data: i ? {
            nodeId: n,
            node: {
                id: n,
                tagName: i.tagName,
                textContent: Array.from(i.childNodes).map(o => o.type === Am.Text && o.textContent).filter(Boolean).map(o => o.trim()).join(""),
                attributes: bH(i.attributes)
            }
        } : {}
    }
}
function xH(t) {
    const { target: e, message: n } = wH(t);
    return Fi({
        category: `ui.${t.name}`,
        ...uM(e, n)
    })
}
function wH(t) {
    const e = t.name === "click";
    let n, s = null;
    try {
        s = e ? lM(t.event) : cM(t.event),
            n = Po(s, {
                maxStringLength: 200
            }) || "<unknown>"
    } catch {
        n = "<unknown>"
    }
    return {
        target: s,
        message: n
    }
}
function SH(t) {
    return t.type === Am.Element
}
function EH(t, e) {
    if (!t.isEnabled())
        return;
    t.updateUserActivity();
    const n = TH(e);
    n && df(t, n)
}
function TH(t) {
    const { metaKey: e, shiftKey: n, ctrlKey: s, altKey: r, key: i, target: o } = t;
    if (!o || CH(o) || !i)
        return null;
    const l = e || s || r
        , a = i.length === 1;
    if (!l && a)
        return null;
    const c = Po(o, {
        maxStringLength: 200
    }) || "<unknown>"
        , u = uM(o, c);
    return Fi({
        category: "ui.keyDown",
        message: c,
        data: {
            ...u.data,
            metaKey: e,
            shiftKey: n,
            ctrlKey: s,
            altKey: r,
            key: i
        }
    })
}
function CH(t) {
    return t.tagName === "INPUT" || t.tagName === "TEXTAREA" || t.isContentEditable
}
const IH = {
    resource: PH,
    paint: RH,
    navigation: MH
};
function Kf(t, e) {
    return ({ metric: n }) => void e.replayPerformanceEntries.push(t(n))
}
function AH(t) {
    return t.map(kH).filter(Boolean)
}
function kH(t) {
    const e = IH[t.entryType];
    return e ? e(t) : null
}
function $u(t) {
    return ((Ps || Gt.performance.timeOrigin) + t) / 1e3
}
function RH(t) {
    const { duration: e, entryType: n, name: s, startTime: r } = t
        , i = $u(r);
    return {
        type: n,
        name: s,
        start: i,
        end: i + e,
        data: void 0
    }
}
function MH(t) {
    const { entryType: e, name: n, decodedBodySize: s, duration: r, domComplete: i, encodedBodySize: o, domContentLoadedEventStart: l, domContentLoadedEventEnd: a, domInteractive: c, loadEventStart: u, loadEventEnd: h, redirectCount: d, startTime: f, transferSize: p, type: m } = t;
    return r === 0 ? null : {
        type: `${e}.${m}`,
        start: $u(f),
        end: $u(i),
        name: n,
        data: {
            size: p,
            decodedBodySize: s,
            encodedBodySize: o,
            duration: r,
            domInteractive: c,
            domContentLoadedEventStart: l,
            domContentLoadedEventEnd: a,
            loadEventStart: u,
            loadEventEnd: h,
            domComplete: i,
            redirectCount: d
        }
    }
}
function PH(t) {
    const { entryType: e, initiatorType: n, name: s, responseEnd: r, startTime: i, decodedBodySize: o, encodedBodySize: l, responseStatus: a, transferSize: c } = t;
    return ["fetch", "xmlhttprequest"].includes(n) ? null : {
        type: `${e}.${n}`,
        start: $u(i),
        end: $u(r),
        name: s,
        data: {
            size: c,
            statusCode: a,
            decodedBodySize: o,
            encodedBodySize: l
        }
    }
}
function LH(t) {
    const e = t.entries[t.entries.length - 1]
        , n = e && e.element ? [e.element] : void 0;
    return o_(t, "largest-contentful-paint", n)
}
function OH(t) {
    return t.sources !== void 0
}
function NH(t) {
    const e = []
        , n = [];
    for (const s of t.entries)
        if (OH(s)) {
            const r = [];
            for (const i of s.sources)
                if (i.node) {
                    n.push(i.node);
                    const o = Io.mirror.getId(i.node);
                    o && r.push(o)
                }
            e.push({
                value: s.value,
                nodeIds: r.length ? r : void 0
            })
        }
    return o_(t, "cumulative-layout-shift", n, e)
}
function DH(t) {
    const e = t.entries[t.entries.length - 1]
        , n = e && e.target ? [e.target] : void 0;
    return o_(t, "first-input-delay", n)
}
function BH(t) {
    const e = t.entries[t.entries.length - 1]
        , n = e && e.target ? [e.target] : void 0;
    return o_(t, "interaction-to-next-paint", n)
}
function o_(t, e, n, s) {
    const r = t.value
        , i = t.rating
        , o = $u(r);
    return {
        type: "web-vital",
        name: e,
        start: o,
        end: o,
        data: {
            value: r,
            size: r,
            rating: i,
            nodeIds: n ? n.map(l => Io.mirror.getId(l)) : void 0,
            attributions: s
        }
    }
}
function FH(t) {
    function e(r) {
        t.performanceEntries.includes(r) || t.performanceEntries.push(r)
    }
    function n({ entries: r }) {
        r.forEach(e)
    }
    const s = [];
    return ["navigation", "paint", "resource"].forEach(r => {
        s.push(Nu(r, n))
    }
    ),
        s.push(AR(Kf(LH, t)), tx(Kf(NH, t)), kR(Kf(DH, t)), RR(Kf(BH, t))),
        () => {
            s.forEach(r => r())
        }
}
const qe = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__
    , $H = 'var t=Uint8Array,n=Uint16Array,r=Int32Array,e=new t([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),i=new t([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),a=new t([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),s=function(t,e){for(var i=new n(31),a=0;a<31;++a)i[a]=e+=1<<t[a-1];var s=new r(i[30]);for(a=1;a<30;++a)for(var o=i[a];o<i[a+1];++o)s[o]=o-i[a]<<5|a;return{b:i,r:s}},o=s(e,2),f=o.b,h=o.r;f[28]=258,h[258]=28;for(var l=s(i,0).r,u=new n(32768),c=0;c<32768;++c){var v=(43690&c)>>1|(21845&c)<<1;v=(61680&(v=(52428&v)>>2|(13107&v)<<2))>>4|(3855&v)<<4,u[c]=((65280&v)>>8|(255&v)<<8)>>1}var d=function(t,r,e){for(var i=t.length,a=0,s=new n(r);a<i;++a)t[a]&&++s[t[a]-1];var o,f=new n(r);for(a=1;a<r;++a)f[a]=f[a-1]+s[a-1]<<1;if(e){o=new n(1<<r);var h=15-r;for(a=0;a<i;++a)if(t[a])for(var l=a<<4|t[a],c=r-t[a],v=f[t[a]-1]++<<c,d=v|(1<<c)-1;v<=d;++v)o[u[v]>>h]=l}else for(o=new n(i),a=0;a<i;++a)t[a]&&(o[a]=u[f[t[a]-1]++]>>15-t[a]);return o},g=new t(288);for(c=0;c<144;++c)g[c]=8;for(c=144;c<256;++c)g[c]=9;for(c=256;c<280;++c)g[c]=7;for(c=280;c<288;++c)g[c]=8;var w=new t(32);for(c=0;c<32;++c)w[c]=5;var p=d(g,9,0),y=d(w,5,0),m=function(t){return(t+7)/8|0},b=function(n,r,e){return(null==e||e>n.length)&&(e=n.length),new t(n.subarray(r,e))},M=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],E=function(t,n,r){var e=new Error(n||M[t]);if(e.code=t,Error.captureStackTrace&&Error.captureStackTrace(e,E),!r)throw e;return e},z=function(t,n,r){r<<=7&n;var e=n/8|0;t[e]|=r,t[e+1]|=r>>8},_=function(t,n,r){r<<=7&n;var e=n/8|0;t[e]|=r,t[e+1]|=r>>8,t[e+2]|=r>>16},x=function(r,e){for(var i=[],a=0;a<r.length;++a)r[a]&&i.push({s:a,f:r[a]});var s=i.length,o=i.slice();if(!s)return{t:F,l:0};if(1==s){var f=new t(i[0].s+1);return f[i[0].s]=1,{t:f,l:1}}i.sort((function(t,n){return t.f-n.f})),i.push({s:-1,f:25001});var h=i[0],l=i[1],u=0,c=1,v=2;for(i[0]={s:-1,f:h.f+l.f,l:h,r:l};c!=s-1;)h=i[i[u].f<i[v].f?u++:v++],l=i[u!=c&&i[u].f<i[v].f?u++:v++],i[c++]={s:-1,f:h.f+l.f,l:h,r:l};var d=o[0].s;for(a=1;a<s;++a)o[a].s>d&&(d=o[a].s);var g=new n(d+1),w=A(i[c-1],g,0);if(w>e){a=0;var p=0,y=w-e,m=1<<y;for(o.sort((function(t,n){return g[n.s]-g[t.s]||t.f-n.f}));a<s;++a){var b=o[a].s;if(!(g[b]>e))break;p+=m-(1<<w-g[b]),g[b]=e}for(p>>=y;p>0;){var M=o[a].s;g[M]<e?p-=1<<e-g[M]++-1:++a}for(;a>=0&&p;--a){var E=o[a].s;g[E]==e&&(--g[E],++p)}w=e}return{t:new t(g),l:w}},A=function(t,n,r){return-1==t.s?Math.max(A(t.l,n,r+1),A(t.r,n,r+1)):n[t.s]=r},D=function(t){for(var r=t.length;r&&!t[--r];);for(var e=new n(++r),i=0,a=t[0],s=1,o=function(t){e[i++]=t},f=1;f<=r;++f)if(t[f]==a&&f!=r)++s;else{if(!a&&s>2){for(;s>138;s-=138)o(32754);s>2&&(o(s>10?s-11<<5|28690:s-3<<5|12305),s=0)}else if(s>3){for(o(a),--s;s>6;s-=6)o(8304);s>2&&(o(s-3<<5|8208),s=0)}for(;s--;)o(a);s=1,a=t[f]}return{c:e.subarray(0,i),n:r}},T=function(t,n){for(var r=0,e=0;e<n.length;++e)r+=t[e]*n[e];return r},k=function(t,n,r){var e=r.length,i=m(n+2);t[i]=255&e,t[i+1]=e>>8,t[i+2]=255^t[i],t[i+3]=255^t[i+1];for(var a=0;a<e;++a)t[i+a+4]=r[a];return 8*(i+4+e)},U=function(t,r,s,o,f,h,l,u,c,v,m){z(r,m++,s),++f[256];for(var b=x(f,15),M=b.t,E=b.l,A=x(h,15),U=A.t,C=A.l,F=D(M),I=F.c,S=F.n,L=D(U),O=L.c,j=L.n,q=new n(19),B=0;B<I.length;++B)++q[31&I[B]];for(B=0;B<O.length;++B)++q[31&O[B]];for(var G=x(q,7),H=G.t,J=G.l,K=19;K>4&&!H[a[K-1]];--K);var N,P,Q,R,V=v+5<<3,W=T(f,g)+T(h,w)+l,X=T(f,M)+T(h,U)+l+14+3*K+T(q,H)+2*q[16]+3*q[17]+7*q[18];if(c>=0&&V<=W&&V<=X)return k(r,m,t.subarray(c,c+v));if(z(r,m,1+(X<W)),m+=2,X<W){N=d(M,E,0),P=M,Q=d(U,C,0),R=U;var Y=d(H,J,0);z(r,m,S-257),z(r,m+5,j-1),z(r,m+10,K-4),m+=14;for(B=0;B<K;++B)z(r,m+3*B,H[a[B]]);m+=3*K;for(var Z=[I,O],$=0;$<2;++$){var tt=Z[$];for(B=0;B<tt.length;++B){var nt=31&tt[B];z(r,m,Y[nt]),m+=H[nt],nt>15&&(z(r,m,tt[B]>>5&127),m+=tt[B]>>12)}}}else N=p,P=g,Q=y,R=w;for(B=0;B<u;++B){var rt=o[B];if(rt>255){_(r,m,N[(nt=rt>>18&31)+257]),m+=P[nt+257],nt>7&&(z(r,m,rt>>23&31),m+=e[nt]);var et=31&rt;_(r,m,Q[et]),m+=R[et],et>3&&(_(r,m,rt>>5&8191),m+=i[et])}else _(r,m,N[rt]),m+=P[rt]}return _(r,m,N[256]),m+P[256]},C=new r([65540,131080,131088,131104,262176,1048704,1048832,2114560,2117632]),F=new t(0),I=function(){for(var t=new Int32Array(256),n=0;n<256;++n){for(var r=n,e=9;--e;)r=(1&r&&-306674912)^r>>>1;t[n]=r}return t}(),S=function(){var t=-1;return{p:function(n){for(var r=t,e=0;e<n.length;++e)r=I[255&r^n[e]]^r>>>8;t=r},d:function(){return~t}}},L=function(){var t=1,n=0;return{p:function(r){for(var e=t,i=n,a=0|r.length,s=0;s!=a;){for(var o=Math.min(s+2655,a);s<o;++s)i+=e+=r[s];e=(65535&e)+15*(e>>16),i=(65535&i)+15*(i>>16)}t=e,n=i},d:function(){return(255&(t%=65521))<<24|(65280&t)<<8|(255&(n%=65521))<<8|n>>8}}},O=function(a,s,o,f,u){if(!u&&(u={l:1},s.dictionary)){var c=s.dictionary.subarray(-32768),v=new t(c.length+a.length);v.set(c),v.set(a,c.length),a=v,u.w=c.length}return function(a,s,o,f,u,c){var v=c.z||a.length,d=new t(f+v+5*(1+Math.ceil(v/7e3))+u),g=d.subarray(f,d.length-u),w=c.l,p=7&(c.r||0);if(s){p&&(g[0]=c.r>>3);for(var y=C[s-1],M=y>>13,E=8191&y,z=(1<<o)-1,_=c.p||new n(32768),x=c.h||new n(z+1),A=Math.ceil(o/3),D=2*A,T=function(t){return(a[t]^a[t+1]<<A^a[t+2]<<D)&z},F=new r(25e3),I=new n(288),S=new n(32),L=0,O=0,j=c.i||0,q=0,B=c.w||0,G=0;j+2<v;++j){var H=T(j),J=32767&j,K=x[H];if(_[J]=K,x[H]=J,B<=j){var N=v-j;if((L>7e3||q>24576)&&(N>423||!w)){p=U(a,g,0,F,I,S,O,q,G,j-G,p),q=L=O=0,G=j;for(var P=0;P<286;++P)I[P]=0;for(P=0;P<30;++P)S[P]=0}var Q=2,R=0,V=E,W=J-K&32767;if(N>2&&H==T(j-W))for(var X=Math.min(M,N)-1,Y=Math.min(32767,j),Z=Math.min(258,N);W<=Y&&--V&&J!=K;){if(a[j+Q]==a[j+Q-W]){for(var $=0;$<Z&&a[j+$]==a[j+$-W];++$);if($>Q){if(Q=$,R=W,$>X)break;var tt=Math.min(W,$-2),nt=0;for(P=0;P<tt;++P){var rt=j-W+P&32767,et=rt-_[rt]&32767;et>nt&&(nt=et,K=rt)}}}W+=(J=K)-(K=_[J])&32767}if(R){F[q++]=268435456|h[Q]<<18|l[R];var it=31&h[Q],at=31&l[R];O+=e[it]+i[at],++I[257+it],++S[at],B=j+Q,++L}else F[q++]=a[j],++I[a[j]]}}for(j=Math.max(j,B);j<v;++j)F[q++]=a[j],++I[a[j]];p=U(a,g,w,F,I,S,O,q,G,j-G,p),w||(c.r=7&p|g[p/8|0]<<3,p-=7,c.h=x,c.p=_,c.i=j,c.w=B)}else{for(j=c.w||0;j<v+w;j+=65535){var st=j+65535;st>=v&&(g[p/8|0]=w,st=v),p=k(g,p+1,a.subarray(j,st))}c.i=v}return b(d,0,f+m(p)+u)}(a,null==s.level?6:s.level,null==s.mem?Math.ceil(1.5*Math.max(8,Math.min(13,Math.log(a.length)))):12+s.mem,o,f,u)},j=function(t,n,r){for(;r;++n)t[n]=r,r>>>=8},q=function(t,n){var r=n.filename;if(t[0]=31,t[1]=139,t[2]=8,t[8]=n.level<2?4:9==n.level?2:0,t[9]=3,0!=n.mtime&&j(t,4,Math.floor(new Date(n.mtime||Date.now())/1e3)),r){t[3]=8;for(var e=0;e<=r.length;++e)t[e+10]=r.charCodeAt(e)}},B=function(t){return 10+(t.filename?t.filename.length+1:0)},G=function(){function n(n,r){if("function"==typeof n&&(r=n,n={}),this.ondata=r,this.o=n||{},this.s={l:0,i:32768,w:32768,z:32768},this.b=new t(98304),this.o.dictionary){var e=this.o.dictionary.subarray(-32768);this.b.set(e,32768-e.length),this.s.i=32768-e.length}}return n.prototype.p=function(t,n){this.ondata(O(t,this.o,0,0,this.s),n)},n.prototype.push=function(n,r){this.ondata||E(5),this.s.l&&E(4);var e=n.length+this.s.z;if(e>this.b.length){if(e>2*this.b.length-32768){var i=new t(-32768&e);i.set(this.b.subarray(0,this.s.z)),this.b=i}var a=this.b.length-this.s.z;a&&(this.b.set(n.subarray(0,a),this.s.z),this.s.z=this.b.length,this.p(this.b,!1)),this.b.set(this.b.subarray(-32768)),this.b.set(n.subarray(a),32768),this.s.z=n.length-a+32768,this.s.i=32766,this.s.w=32768}else this.b.set(n,this.s.z),this.s.z+=n.length;this.s.l=1&r,(this.s.z>this.s.w+8191||r)&&(this.p(this.b,r||!1),this.s.w=this.s.i,this.s.i-=2)},n}();var H=function(){function t(t,n){this.c=L(),this.v=1,G.call(this,t,n)}return t.prototype.push=function(t,n){this.c.p(t),G.prototype.push.call(this,t,n)},t.prototype.p=function(t,n){var r=O(t,this.o,this.v&&(this.o.dictionary?6:2),n&&4,this.s);this.v&&(function(t,n){var r=n.level,e=0==r?0:r<6?1:9==r?3:2;if(t[0]=120,t[1]=e<<6|(n.dictionary&&32),t[1]|=31-(t[0]<<8|t[1])%31,n.dictionary){var i=L();i.p(n.dictionary),j(t,2,i.d())}}(r,this.o),this.v=0),n&&j(r,r.length-4,this.c.d()),this.ondata(r,n)},t}(),J="undefined"!=typeof TextEncoder&&new TextEncoder,K="undefined"!=typeof TextDecoder&&new TextDecoder;try{K.decode(F,{stream:!0})}catch(t){}var N=function(){function t(t){this.ondata=t}return t.prototype.push=function(t,n){this.ondata||E(5),this.d&&E(4),this.ondata(P(t),this.d=n||!1)},t}();function P(n,r){if(J)return J.encode(n);for(var e=n.length,i=new t(n.length+(n.length>>1)),a=0,s=function(t){i[a++]=t},o=0;o<e;++o){if(a+5>i.length){var f=new t(a+8+(e-o<<1));f.set(i),i=f}var h=n.charCodeAt(o);h<128||r?s(h):h<2048?(s(192|h>>6),s(128|63&h)):h>55295&&h<57344?(s(240|(h=65536+(1047552&h)|1023&n.charCodeAt(++o))>>18),s(128|h>>12&63),s(128|h>>6&63),s(128|63&h)):(s(224|h>>12),s(128|h>>6&63),s(128|63&h))}return b(i,0,a)}function Q(t){return function(t,n){n||(n={});var r=S(),e=t.length;r.p(t);var i=O(t,n,B(n),8),a=i.length;return q(i,n),j(i,a-8,r.d()),j(i,a-4,e),i}(P(t))}const R=new class{constructor(){this._init()}clear(){this._init()}addEvent(t){if(!t)throw new Error("Adding invalid event");const n=this._hasEvents?",":"";this.stream.push(n+t),this._hasEvents=!0}finish(){this.stream.push("]",!0);const t=function(t){let n=0;for(const r of t)n+=r.length;const r=new Uint8Array(n);for(let n=0,e=0,i=t.length;n<i;n++){const i=t[n];r.set(i,e),e+=i.length}return r}(this._deflatedData);return this._init(),t}_init(){this._hasEvents=!1,this._deflatedData=[],this.deflate=new H,this.deflate.ondata=(t,n)=>{this._deflatedData.push(t)},this.stream=new N(((t,n)=>{this.deflate.push(t,n)})),this.stream.push("[")}},V={clear:()=>{R.clear()},addEvent:t=>R.addEvent(t),finish:()=>R.finish(),compress:t=>Q(t)};addEventListener("message",(function(t){const n=t.data.method,r=t.data.id,e=t.data.arg;if(n in V&&"function"==typeof V[n])try{const t=V[n](e);postMessage({id:r,method:n,success:!0,response:t})}catch(t){postMessage({id:r,method:n,success:!1,response:t.message}),console.error(t)}})),postMessage({id:void 0,method:"init",success:!0,response:void 0});';
function UH() {
    const t = new Blob([$H]);
    return URL.createObjectURL(t)
}
const sC = ["info", "warn", "error", "log"]
    , Up = "[Replay] ";
function A0(t, e = "info") {
    Ya({
        category: "console",
        data: {
            logger: "replay"
        },
        level: e,
        message: `${Up}${t}`
    }, {
        level: e
    })
}
function VH() {
    let t = !1
        , e = !1;
    const n = {
        exception: () => { }
        ,
        infoTick: () => { }
        ,
        setConfig: s => {
            t = s.captureExceptions,
                e = s.traceInternals
        }
    };
    return qe ? (sC.forEach(s => {
        n[s] = (...r) => {
            Re[s](Up, ...r),
                e && A0(r.join(""), dR(s))
        }
    }
    ),
        n.exception = (s, ...r) => {
            r.length && n.error && n.error(...r),
                Re.error(Up, s),
                t ? No(s) : e && A0(s, "error")
        }
        ,
        n.infoTick = (...s) => {
            Re.info(Up, ...s),
                e && setTimeout(() => A0(s[0]), 0)
        }
    ) : sC.forEach(s => {
        n[s] = () => { }
    }
    ),
        n
}
const Je = VH();
class hx extends Error {
    constructor() {
        super(`Event buffer exceeded maximum size of ${ix}.`)
    }
}
class hM {
    constructor() {
        this.events = [],
            this._totalSize = 0,
            this.hasCheckout = !1,
            this.waitForCheckout = !1
    }
    get hasEvents() {
        return this.events.length > 0
    }
    get type() {
        return "sync"
    }
    destroy() {
        this.events = []
    }
    async addEvent(e) {
        const n = JSON.stringify(e).length;
        if (this._totalSize += n,
            this._totalSize > ix)
            throw new hx;
        this.events.push(e)
    }
    finish() {
        return new Promise(e => {
            const n = this.events;
            this.clear(),
                e(JSON.stringify(n))
        }
        )
    }
    clear() {
        this.events = [],
            this._totalSize = 0,
            this.hasCheckout = !1
    }
    getEarliestTimestamp() {
        const e = this.events.map(n => n.timestamp).sort()[0];
        return e ? ux(e) : null
    }
}
class GH {
    constructor(e) {
        this._worker = e,
            this._id = 0
    }
    ensureReady() {
        return this._ensureReadyPromise ? this._ensureReadyPromise : (this._ensureReadyPromise = new Promise((e, n) => {
            this._worker.addEventListener("message", ({ data: s }) => {
                s.success ? e() : n()
            }
                , {
                    once: !0
                }),
                this._worker.addEventListener("error", s => {
                    n(s)
                }
                    , {
                        once: !0
                    })
        }
        ),
            this._ensureReadyPromise)
    }
    destroy() {
        qe && Je.info("Destroying compression worker"),
            this._worker.terminate()
    }
    postMessage(e, n) {
        const s = this._getAndIncrementId();
        return new Promise((r, i) => {
            const o = ({ data: l }) => {
                const a = l;
                if (a.method === e && a.id === s) {
                    if (this._worker.removeEventListener("message", o),
                        !a.success) {
                        qe && Je.error("Error in compression worker: ", a.response),
                            i(new Error("Error in compression worker"));
                        return
                    }
                    r(a.response)
                }
            }
                ;
            this._worker.addEventListener("message", o),
                this._worker.postMessage({
                    id: s,
                    method: e,
                    arg: n
                })
        }
        )
    }
    _getAndIncrementId() {
        return this._id++
    }
}
class HH {
    constructor(e) {
        this._worker = new GH(e),
            this._earliestTimestamp = null,
            this._totalSize = 0,
            this.hasCheckout = !1,
            this.waitForCheckout = !1
    }
    get hasEvents() {
        return !!this._earliestTimestamp
    }
    get type() {
        return "worker"
    }
    ensureReady() {
        return this._worker.ensureReady()
    }
    destroy() {
        this._worker.destroy()
    }
    addEvent(e) {
        const n = ux(e.timestamp);
        (!this._earliestTimestamp || n < this._earliestTimestamp) && (this._earliestTimestamp = n);
        const s = JSON.stringify(e);
        return this._totalSize += s.length,
            this._totalSize > ix ? Promise.reject(new hx) : this._sendEventToWorker(s)
    }
    finish() {
        return this._finishRequest()
    }
    clear() {
        this._earliestTimestamp = null,
            this._totalSize = 0,
            this.hasCheckout = !1,
            this._worker.postMessage("clear").then(null, e => {
                qe && Je.exception(e, 'Sending "clear" message to worker failed', e)
            }
            )
    }
    getEarliestTimestamp() {
        return this._earliestTimestamp
    }
    _sendEventToWorker(e) {
        return this._worker.postMessage("addEvent", e)
    }
    async _finishRequest() {
        const e = await this._worker.postMessage("finish");
        return this._earliestTimestamp = null,
            this._totalSize = 0,
            e
    }
}
class WH {
    constructor(e) {
        this._fallback = new hM,
            this._compression = new HH(e),
            this._used = this._fallback,
            this._ensureWorkerIsLoadedPromise = this._ensureWorkerIsLoaded()
    }
    get waitForCheckout() {
        return this._used.waitForCheckout
    }
    get type() {
        return this._used.type
    }
    get hasEvents() {
        return this._used.hasEvents
    }
    get hasCheckout() {
        return this._used.hasCheckout
    }
    set hasCheckout(e) {
        this._used.hasCheckout = e
    }
    set waitForCheckout(e) {
        this._used.waitForCheckout = e
    }
    destroy() {
        this._fallback.destroy(),
            this._compression.destroy()
    }
    clear() {
        return this._used.clear()
    }
    getEarliestTimestamp() {
        return this._used.getEarliestTimestamp()
    }
    addEvent(e) {
        return this._used.addEvent(e)
    }
    async finish() {
        return await this.ensureWorkerIsLoaded(),
            this._used.finish()
    }
    ensureWorkerIsLoaded() {
        return this._ensureWorkerIsLoadedPromise
    }
    async _ensureWorkerIsLoaded() {
        try {
            await this._compression.ensureReady()
        } catch (e) {
            qe && Je.exception(e, "Failed to load the compression worker, falling back to simple buffer");
            return
        }
        await this._switchToCompressionWorker()
    }
    async _switchToCompressionWorker() {
        const { events: e, hasCheckout: n, waitForCheckout: s } = this._fallback
            , r = [];
        for (const i of e)
            r.push(this._compression.addEvent(i));
        this._compression.hasCheckout = n,
            this._compression.waitForCheckout = s,
            this._used = this._compression;
        try {
            await Promise.all(r),
                this._fallback.clear()
        } catch (i) {
            qe && Je.exception(i, "Failed to add events when switching buffers.")
        }
    }
}
function YH({ useCompression: t, workerUrl: e }) {
    if (t && window.Worker) {
        const n = XH(e);
        if (n)
            return n
    }
    return qe && Je.info("Using simple buffer"),
        new hM
}
function XH(t) {
    try {
        const e = t || jH();
        if (!e)
            return;
        qe && Je.info(`Using compression worker${t ? ` from ${t}` : ""}`);
        const n = new Worker(e);
        return new WH(n)
    } catch (e) {
        qe && Je.exception(e, "Failed to create compression worker")
    }
}
function jH() {
    return typeof __SENTRY_EXCLUDE_REPLAY_WORKER__ > "u" || !__SENTRY_EXCLUDE_REPLAY_WORKER__ ? UH() : ""
}
function dx() {
    try {
        return "sessionStorage" in Gt && !!Gt.sessionStorage
    } catch {
        return !1
    }
}
function zH(t) {
    qH(),
        t.session = void 0
}
function qH() {
    if (dx())
        try {
            Gt.sessionStorage.removeItem(sx)
        } catch { }
}
function dM(t) {
    return t === void 0 ? !1 : Math.random() < t
}
function fM(t) {
    const e = Date.now()
        , n = t.id || Nn()
        , s = t.started || e
        , r = t.lastActivity || e
        , i = t.segmentId || 0
        , o = t.sampled
        , l = t.previousSessionId;
    return {
        id: n,
        started: s,
        lastActivity: r,
        segmentId: i,
        sampled: o,
        previousSessionId: l
    }
}
function fx(t) {
    if (dx())
        try {
            Gt.sessionStorage.setItem(sx, JSON.stringify(t))
        } catch { }
}
function KH(t, e) {
    return dM(t) ? "session" : e ? "buffer" : !1
}
function rC({ sessionSampleRate: t, allowBuffering: e, stickySession: n = !1 }, { previousSessionId: s } = {}) {
    const r = KH(t, e)
        , i = fM({
            sampled: r,
            previousSessionId: s
        });
    return n && fx(i),
        i
}
function JH() {
    if (!dx())
        return null;
    try {
        const t = Gt.sessionStorage.getItem(sx);
        if (!t)
            return null;
        const e = JSON.parse(t);
        return qe && Je.infoTick("Loading existing session"),
            fM(e)
    } catch {
        return null
    }
}
function Ly(t, e, n = +new Date) {
    return t === null || e === void 0 || e < 0 ? !0 : e === 0 ? !1 : t + e <= n
}
function pM(t, { maxReplayDuration: e, sessionIdleExpire: n, targetTime: s = Date.now() }) {
    return Ly(t.started, e, s) || Ly(t.lastActivity, n, s)
}
function mM(t, { sessionIdleExpire: e, maxReplayDuration: n }) {
    return !(!pM(t, {
        sessionIdleExpire: e,
        maxReplayDuration: n
    }) || t.sampled === "buffer" && t.segmentId === 0)
}
function k0({ sessionIdleExpire: t, maxReplayDuration: e, previousSessionId: n }, s) {
    const r = s.stickySession && JH();
    return r ? mM(r, {
        sessionIdleExpire: t,
        maxReplayDuration: e
    }) ? (qe && Je.infoTick("Session in sessionStorage is expired, creating new one..."),
        rC(s, {
            previousSessionId: r.id
        })) : r : (qe && Je.infoTick("Creating new session"),
            rC(s, {
                previousSessionId: n
            }))
}
function ZH(t) {
    return t.type === ht.Custom
}
function px(t, e, n) {
    return _M(t, e) ? (gM(t, e, n),
        !0) : !1
}
function QH(t, e, n) {
    return _M(t, e) ? gM(t, e, n) : Promise.resolve(null)
}
async function gM(t, e, n) {
    const { eventBuffer: s } = t;
    if (!s || s.waitForCheckout && !n)
        return null;
    const r = t.recordingMode === "buffer";
    try {
        n && r && s.clear(),
            n && (s.hasCheckout = !0,
                s.waitForCheckout = !1);
        const i = t.getOptions()
            , o = eW(e, i.beforeAddRecordingEvent);
        return o ? await s.addEvent(o) : void 0
    } catch (i) {
        const o = i && i instanceof hx
            , l = o ? "addEventSizeExceeded" : "addEvent";
        if (o && r)
            return s.clear(),
                s.waitForCheckout = !0,
                null;
        t.handleException(i),
            await t.stop({
                reason: l
            });
        const a = bt();
        a && a.recordDroppedEvent("internal_sdk_error", "replay")
    }
}
function _M(t, e) {
    if (!t.eventBuffer || t.isPaused() || !t.isEnabled())
        return !1;
    const n = ux(e.timestamp);
    return n + t.timeouts.sessionIdlePause < Date.now() ? !1 : n > t.getContext().initialTimestamp + t.getOptions().maxReplayDuration ? (qe && Je.infoTick(`Skipping event with timestamp ${n} because it is after maxReplayDuration`),
        !1) : !0
}
function eW(t, e) {
    try {
        if (typeof e == "function" && ZH(t))
            return e(t)
    } catch (n) {
        return qe && Je.exception(n, "An error occurred in the `beforeAddRecordingEvent` callback, skipping the event..."),
            null
    }
    return t
}
function mx(t) {
    return !t.type
}
function Oy(t) {
    return t.type === "transaction"
}
function tW(t) {
    return t.type === "replay_event"
}
function iC(t) {
    return t.type === "feedback"
}
function nW(t) {
    return (e, n) => {
        if (!t.isEnabled() || !mx(e) && !Oy(e))
            return;
        const s = n && n.statusCode;
        if (!(!s || s < 200 || s >= 300)) {
            if (Oy(e)) {
                sW(t, e);
                return
            }
            rW(t, e)
        }
    }
}
function sW(t, e) {
    const n = t.getContext();
    e.contexts && e.contexts.trace && e.contexts.trace.trace_id && n.traceIds.size < 100 && n.traceIds.add(e.contexts.trace.trace_id)
}
function rW(t, e) {
    const n = t.getContext();
    if (e.event_id && n.errorIds.size < 100 && n.errorIds.add(e.event_id),
        t.recordingMode !== "buffer" || !e.tags || !e.tags.replayId)
        return;
    const { beforeErrorSampling: s } = t.getOptions();
    typeof s == "function" && !s(e) || Du(async () => {
        try {
            await t.sendBufferedReplayOrFlush()
        } catch (r) {
            t.handleException(r)
        }
    }
    )
}
function iW(t) {
    return e => {
        !t.isEnabled() || !mx(e) || oW(t, e)
    }
}
function oW(t, e) {
    const n = e.exception && e.exception.values && e.exception.values[0] && e.exception.values[0].value;
    if (typeof n == "string" && (n.match(/(reactjs\.org\/docs\/error-decoder\.html\?invariant=|react\.dev\/errors\/)(418|419|422|423|425)/) || n.match(/(does not match server-rendered HTML|Hydration failed because)/i))) {
        const s = Fi({
            category: "replay.hydrate-error",
            data: {
                url: Ik()
            }
        });
        df(t, s)
    }
}
function aW(t) {
    const e = bt();
    e && e.on("beforeAddBreadcrumb", n => lW(t, n))
}
function lW(t, e) {
    if (!t.isEnabled() || !yM(e))
        return;
    const n = cW(e);
    n && df(t, n)
}
function cW(t) {
    return !yM(t) || ["fetch", "xhr", "sentry.event", "sentry.transaction"].includes(t.category) || t.category.startsWith("ui.") ? null : t.category === "console" ? uW(t) : Fi(t)
}
function uW(t) {
    const e = t.data && t.data.arguments;
    if (!Array.isArray(e) || e.length === 0)
        return Fi(t);
    let n = !1;
    const s = e.map(r => {
        if (!r)
            return r;
        if (typeof r == "string")
            return r.length > jf ? (n = !0,
                `${r.slice(0, jf)}`) : r;
        if (typeof r == "object")
            try {
                const i = Li(r, 7);
                return JSON.stringify(i).length > jf ? (n = !0,
                    `${JSON.stringify(i, null, 2).slice(0, jf)}`) : i
            } catch { }
        return r
    }
    );
    return Fi({
        ...t,
        data: {
            ...t.data,
            arguments: s,
            ...n ? {
                _meta: {
                    warnings: ["CONSOLE_ARG_TRUNCATED"]
                }
            } : {}
        }
    })
}
function yM(t) {
    return !!t.category
}
function hW(t, e) {
    return t.type || !t.exception || !t.exception.values || !t.exception.values.length ? !1 : !!(e.originalException && e.originalException.__rrweb__)
}
function bM() {
    const t = Ut().getPropagationContext().dsc;
    t && delete t.replay_id;
    const e = Cn();
    if (e) {
        const n = _c(e);
        delete n.replay_id
    }
}
function dW(t, e) {
    t.triggerUserActivity(),
        t.addUpdate(() => e.timestamp ? (t.throttledAddEvent({
            type: ht.Custom,
            timestamp: e.timestamp * 1e3,
            data: {
                tag: "breadcrumb",
                payload: {
                    timestamp: e.timestamp,
                    type: "default",
                    category: "sentry.feedback",
                    data: {
                        feedbackId: e.event_id
                    }
                }
            }
        }),
            !1) : !0)
}
function fW(t, e) {
    return t.recordingMode !== "buffer" || e.message === rx || !e.exception || e.type ? !1 : dM(t.getOptions().errorSampleRate)
}
function pW(t) {
    return Object.assign((e, n) => !t.isEnabled() || t.isPaused() ? e : tW(e) ? (delete e.breadcrumbs,
        e) : !mx(e) && !Oy(e) && !iC(e) ? e : t.checkAndHandleExpiredSession() ? iC(e) ? (t.flush(),
            e.contexts.feedback.replay_id = t.getSessionId(),
            dW(t, e),
            e) : hW(e, n) && !t.getOptions()._experiments.captureExceptions ? (qe && Je.log("Ignoring error from rrweb internals", e),
                null) : ((fW(t, e) || t.recordingMode === "session") && (e.tags = {
                    ...e.tags,
                    replayId: t.getSessionId()
                }),
                    e) : (bM(),
                        e), {
        id: "Replay"
    })
}
function a_(t, e) {
    return e.map(({ type: n, start: s, end: r, name: i, data: o }) => {
        const l = t.throttledAddEvent({
            type: ht.Custom,
            timestamp: s,
            data: {
                tag: "performanceSpan",
                payload: {
                    op: n,
                    description: i,
                    startTimestamp: s,
                    endTimestamp: r,
                    data: o
                }
            }
        });
        return typeof l == "string" ? Promise.resolve(null) : l
    }
    )
}
function mW(t) {
    const { from: e, to: n } = t
        , s = Date.now() / 1e3;
    return {
        type: "navigation.push",
        start: s,
        end: s,
        name: n,
        data: {
            previous: e
        }
    }
}
function gW(t) {
    return e => {
        if (!t.isEnabled())
            return;
        const n = mW(e);
        n !== null && (t.getContext().urls.push(n.name),
            t.triggerUserActivity(),
            t.addUpdate(() => (a_(t, [n]),
                !1)))
    }
}
function _W(t, e) {
    return qe && t.getOptions()._experiments.traceInternals ? !1 : yF(e, bt())
}
function vM(t, e) {
    t.isEnabled() && e !== null && (_W(t, e.name) || t.addUpdate(() => (a_(t, [e]),
        !0)))
}
function l_(t) {
    if (!t)
        return;
    const e = new TextEncoder;
    try {
        if (typeof t == "string")
            return e.encode(t).length;
        if (t instanceof URLSearchParams)
            return e.encode(t.toString()).length;
        if (t instanceof FormData) {
            const n = EM(t);
            return e.encode(n).length
        }
        if (t instanceof Blob)
            return t.size;
        if (t instanceof ArrayBuffer)
            return t.byteLength
    } catch { }
}
function xM(t) {
    if (!t)
        return;
    const e = parseInt(t, 10);
    return isNaN(e) ? void 0 : e
}
function wM(t) {
    try {
        if (typeof t == "string")
            return [t];
        if (t instanceof URLSearchParams)
            return [t.toString()];
        if (t instanceof FormData)
            return [EM(t)];
        if (!t)
            return [void 0]
    } catch (e) {
        return qe && Je.exception(e, "Failed to serialize body", t),
            [void 0, "BODY_PARSE_ERROR"]
    }
    return qe && Je.info("Skipping network body because of body type", t),
        [void 0, "UNPARSEABLE_BODY_TYPE"]
}
function km(t, e) {
    if (!t)
        return {
            headers: {},
            size: void 0,
            _meta: {
                warnings: [e]
            }
        };
    const n = {
        ...t._meta
    }
        , s = n.warnings || [];
    return n.warnings = [...s, e],
        t._meta = n,
        t
}
function SM(t, e) {
    if (!e)
        return null;
    const { startTimestamp: n, endTimestamp: s, url: r, method: i, statusCode: o, request: l, response: a } = e;
    return {
        type: t,
        start: n / 1e3,
        end: s / 1e3,
        name: r,
        data: On({
            method: i,
            statusCode: o,
            request: l,
            response: a
        })
    }
}
function Id(t) {
    return {
        headers: {},
        size: t,
        _meta: {
            warnings: ["URL_SKIPPED"]
        }
    }
}
function Fa(t, e, n) {
    if (!e && Object.keys(t).length === 0)
        return;
    if (!e)
        return {
            headers: t
        };
    if (!n)
        return {
            headers: t,
            size: e
        };
    const s = {
        headers: t,
        size: e
    }
        , { body: r, warnings: i } = yW(n);
    return s.body = r,
        i && i.length > 0 && (s._meta = {
            warnings: i
        }),
        s
}
function Ny(t, e) {
    return Object.entries(t).reduce((n, [s, r]) => {
        const i = s.toLowerCase();
        return e.includes(i) && t[s] && (n[i] = r),
            n
    }
        , {})
}
function EM(t) {
    return new URLSearchParams(t).toString()
}
function yW(t) {
    if (!t || typeof t != "string")
        return {
            body: t
        };
    const e = t.length > VT
        , n = bW(t);
    if (e) {
        const s = t.slice(0, VT);
        return n ? {
            body: s,
            warnings: ["MAYBE_JSON_TRUNCATED"]
        } : {
            body: `${s}`,
            warnings: ["TEXT_TRUNCATED"]
        }
    }
    if (n)
        try {
            return {
                body: JSON.parse(t)
            }
        } catch { }
    return {
        body: t
    }
}
function bW(t) {
    const e = t[0]
        , n = t[t.length - 1];
    return e === "[" && n === "]" || e === "{" && n === "}"
}
function Rm(t, e) {
    const n = vW(t);
    return Ba(n, e)
}
function vW(t, e = Gt.document.baseURI) {
    if (t.startsWith("http://") || t.startsWith("https://") || t.startsWith(Gt.location.origin))
        return t;
    const n = new URL(t, e);
    if (n.origin !== new URL(e).origin)
        return t;
    const s = n.href;
    return !t.endsWith("/") && s.endsWith("/") ? s.slice(0, -1) : s
}
async function xW(t, e, n) {
    try {
        const s = await SW(t, e, n)
            , r = SM("resource.fetch", s);
        vM(n.replay, r)
    } catch (s) {
        qe && Je.exception(s, "Failed to capture fetch breadcrumb")
    }
}
function wW(t, e) {
    const { input: n, response: s } = e
        , r = n ? TM(n) : void 0
        , i = l_(r)
        , o = s ? xM(s.headers.get("content-length")) : void 0;
    i !== void 0 && (t.data.request_body_size = i),
        o !== void 0 && (t.data.response_body_size = o)
}
async function SW(t, e, n) {
    const s = Date.now()
        , { startTimestamp: r = s, endTimestamp: i = s } = e
        , { url: o, method: l, status_code: a = 0, request_body_size: c, response_body_size: u } = t.data
        , h = Rm(o, n.networkDetailAllowUrls) && !Rm(o, n.networkDetailDenyUrls)
        , d = h ? EW(n, e.input, c) : Id(c)
        , f = await TW(h, n, e.response, u);
    return {
        startTimestamp: r,
        endTimestamp: i,
        url: o,
        method: l,
        statusCode: a,
        request: d,
        response: f
    }
}
function EW({ networkCaptureBodies: t, networkRequestHeaders: e }, n, s) {
    const r = n ? AW(n, e) : {};
    if (!t)
        return Fa(r, s, void 0);
    const i = TM(n)
        , [o, l] = wM(i)
        , a = Fa(r, s, o);
    return l ? km(a, l) : a
}
async function TW(t, { networkCaptureBodies: e, networkResponseHeaders: n }, s, r) {
    if (!t && r !== void 0)
        return Id(r);
    const i = s ? CM(s.headers, n) : {};
    if (!s || !e && r !== void 0)
        return Fa(i, r, void 0);
    const [o, l] = await IW(s)
        , a = CW(o, {
            networkCaptureBodies: e,
            responseBodySize: r,
            captureDetails: t,
            headers: i
        });
    return l ? km(a, l) : a
}
function CW(t, { networkCaptureBodies: e, responseBodySize: n, captureDetails: s, headers: r }) {
    try {
        const i = t && t.length && n === void 0 ? l_(t) : n;
        return s ? e ? Fa(r, i, t) : Fa(r, i, void 0) : Id(i)
    } catch (i) {
        return qe && Je.exception(i, "Failed to serialize response body"),
            Fa(r, n, void 0)
    }
}
async function IW(t) {
    const e = kW(t);
    if (!e)
        return [void 0, "BODY_PARSE_ERROR"];
    try {
        return [await RW(e)]
    } catch (n) {
        return n instanceof Error && n.message.indexOf("Timeout") > -1 ? (qe && Je.warn("Parsing text body from response timed out"),
            [void 0, "BODY_PARSE_TIMEOUT"]) : (qe && Je.exception(n, "Failed to get text body from response"),
                [void 0, "BODY_PARSE_ERROR"])
    }
}
function TM(t = []) {
    if (!(t.length !== 2 || typeof t[1] != "object"))
        return t[1].body
}
function CM(t, e) {
    const n = {};
    return e.forEach(s => {
        t.get(s) && (n[s] = t.get(s))
    }
    ),
        n
}
function AW(t, e) {
    return t.length === 1 && typeof t[0] != "string" ? oC(t[0], e) : t.length === 2 ? oC(t[1], e) : {}
}
function oC(t, e) {
    if (!t)
        return {};
    const n = t.headers;
    return n ? n instanceof Headers ? CM(n, e) : Array.isArray(n) ? {} : Ny(n, e) : {}
}
function kW(t) {
    try {
        return t.clone()
    } catch (e) {
        qe && Je.exception(e, "Failed to clone response body")
    }
}
function RW(t) {
    return new Promise((e, n) => {
        const s = Du(() => n(new Error("Timeout while trying to read response body")), 500);
        MW(t).then(r => e(r), r => n(r)).finally(() => clearTimeout(s))
    }
    )
}
async function MW(t) {
    return await t.text()
}
async function PW(t, e, n) {
    try {
        const s = OW(t, e, n)
            , r = SM("resource.xhr", s);
        vM(n.replay, r)
    } catch (s) {
        qe && Je.exception(s, "Failed to capture xhr breadcrumb")
    }
}
function LW(t, e) {
    const { xhr: n, input: s } = e;
    if (!n)
        return;
    const r = l_(s)
        , i = n.getResponseHeader("content-length") ? xM(n.getResponseHeader("content-length")) : FW(n.response, n.responseType);
    r !== void 0 && (t.data.request_body_size = r),
        i !== void 0 && (t.data.response_body_size = i)
}
function OW(t, e, n) {
    const s = Date.now()
        , { startTimestamp: r = s, endTimestamp: i = s, input: o, xhr: l } = e
        , { url: a, method: c, status_code: u = 0, request_body_size: h, response_body_size: d } = t.data;
    if (!a)
        return null;
    if (!l || !Rm(a, n.networkDetailAllowUrls) || Rm(a, n.networkDetailDenyUrls)) {
        const w = Id(h)
            , S = Id(d);
        return {
            startTimestamp: r,
            endTimestamp: i,
            url: a,
            method: c,
            statusCode: u,
            request: w,
            response: S
        }
    }
    const f = l[Pl]
        , p = f ? Ny(f.request_headers, n.networkRequestHeaders) : {}
        , m = Ny(NW(l), n.networkResponseHeaders)
        , [g, b] = n.networkCaptureBodies ? wM(o) : [void 0]
        , [v, _] = n.networkCaptureBodies ? DW(l) : [void 0]
        , y = Fa(p, h, g)
        , x = Fa(m, d, v);
    return {
        startTimestamp: r,
        endTimestamp: i,
        url: a,
        method: c,
        statusCode: u,
        request: b ? km(y, b) : y,
        response: _ ? km(x, _) : x
    }
}
function NW(t) {
    const e = t.getAllResponseHeaders();
    return e ? e.split(`\r
`).reduce((n, s) => {
        const [r, i] = s.split(": ");
        return i && (n[r.toLowerCase()] = i),
            n
    }
        , {}) : {}
}
function DW(t) {
    const e = [];
    try {
        return [t.responseText]
    } catch (n) {
        e.push(n)
    }
    try {
        return BW(t.response, t.responseType)
    } catch (n) {
        e.push(n)
    }
    return qe && Je.warn("Failed to get xhr response body", ...e),
        [void 0]
}
function BW(t, e) {
    try {
        if (typeof t == "string")
            return [t];
        if (t instanceof Document)
            return [t.body.outerHTML];
        if (e === "json" && t && typeof t == "object")
            return [JSON.stringify(t)];
        if (!t)
            return [void 0]
    } catch (n) {
        return qe && Je.exception(n, "Failed to serialize body", t),
            [void 0, "BODY_PARSE_ERROR"]
    }
    return qe && Je.info("Skipping network body because of body type", t),
        [void 0, "UNPARSEABLE_BODY_TYPE"]
}
function FW(t, e) {
    try {
        const n = e === "json" && t && typeof t == "object" ? JSON.stringify(t) : t;
        return l_(n)
    } catch {
        return
    }
}
function $W(t) {
    const e = bt();
    try {
        const { networkDetailAllowUrls: n, networkDetailDenyUrls: s, networkCaptureBodies: r, networkRequestHeaders: i, networkResponseHeaders: o } = t.getOptions()
            , l = {
                replay: t,
                networkDetailAllowUrls: n,
                networkDetailDenyUrls: s,
                networkCaptureBodies: r,
                networkRequestHeaders: i,
                networkResponseHeaders: o
            };
        e && e.on("beforeAddBreadcrumb", (a, c) => UW(l, a, c))
    } catch { }
}
function UW(t, e, n) {
    if (e.data)
        try {
            VW(e) && HW(n) && (LW(e, n),
                PW(e, n, t)),
                GW(e) && WW(n) && (wW(e, n),
                    xW(e, n, t))
        } catch (s) {
            qe && Je.exception(s, "Error when enriching network breadcrumb")
        }
}
function VW(t) {
    return t.category === "xhr"
}
function GW(t) {
    return t.category === "fetch"
}
function HW(t) {
    return t && t.xhr
}
function WW(t) {
    return t && t.response
}
function YW(t) {
    const e = bt();
    OR(vH(t)),
        n_(gW(t)),
        aW(t),
        $W(t);
    const n = pW(t);
    J7(n),
        e && (e.on("beforeSendEvent", iW(t)),
            e.on("afterSendEvent", nW(t)),
            e.on("createDsc", s => {
                const r = t.getSessionId();
                r && t.isEnabled() && t.recordingMode === "session" && t.checkAndHandleExpiredSession() && (s.replay_id = r)
            }
            ),
            e.on("spanStart", s => {
                t.lastActiveSpan = s
            }
            ),
            e.on("spanEnd", s => {
                t.lastActiveSpan = s
            }
            ),
            e.on("beforeSendFeedback", (s, r) => {
                const i = t.getSessionId();
                r && r.includeReplay && t.isEnabled() && i && s.contexts && s.contexts.feedback && (s.contexts.feedback.replay_id = i)
            }
            ))
}
async function XW(t) {
    try {
        return Promise.all(a_(t, [jW(Gt.performance.memory)]))
    } catch {
        return []
    }
}
function jW(t) {
    const { jsHeapSizeLimit: e, totalJSHeapSize: n, usedJSHeapSize: s } = t
        , r = Date.now() / 1e3;
    return {
        type: "memory",
        name: "memory",
        start: r,
        end: r,
        data: {
            memory: {
                jsHeapSizeLimit: e,
                totalJSHeapSize: n,
                usedJSHeapSize: s
            }
        }
    }
}
function zW(t, e, n) {
    let s, r, i;
    const o = n && n.maxWait ? Math.max(n.maxWait, e) : 0;
    function l() {
        return a(),
            s = t(),
            s
    }
    function a() {
        r !== void 0 && clearTimeout(r),
            i !== void 0 && clearTimeout(i),
            r = i = void 0
    }
    function c() {
        return r !== void 0 || i !== void 0 ? l() : s
    }
    function u() {
        return r && clearTimeout(r),
            r = Du(l, e),
            o && i === void 0 && (i = Du(l, o)),
            s
    }
    return u.cancel = a,
        u.flush = c,
        u
}
function qW(t) {
    let e = !1;
    return (n, s) => {
        if (!t.checkAndHandleExpiredSession()) {
            qe && Je.warn("Received replay event after session expired.");
            return
        }
        const r = s || !e;
        e = !0,
            t.clickDetector && mH(t.clickDetector, n),
            t.addUpdate(() => {
                if (t.recordingMode === "buffer" && r && t.setInitialState(),
                    !px(t, n, r))
                    return !0;
                if (!r)
                    return !1;
                const i = t.session;
                if (JW(t, r),
                    t.recordingMode === "buffer" && i && t.eventBuffer) {
                    const o = t.eventBuffer.getEarliestTimestamp();
                    o && (qe && Je.info(`Updating session start time to earliest event in buffer to ${new Date(o)}`),
                        i.started = o,
                        t.getOptions().stickySession && fx(i))
                }
                return i && i.previousSessionId || t.recordingMode === "session" && t.flush(),
                    !0
            }
            )
    }
}
function KW(t) {
    const e = t.getOptions();
    return {
        type: ht.Custom,
        timestamp: Date.now(),
        data: {
            tag: "options",
            payload: {
                shouldRecordCanvas: t.isRecordingCanvas(),
                sessionSampleRate: e.sessionSampleRate,
                errorSampleRate: e.errorSampleRate,
                useCompressionOption: e.useCompression,
                blockAllMedia: e.blockAllMedia,
                maskAllText: e.maskAllText,
                maskAllInputs: e.maskAllInputs,
                useCompression: t.eventBuffer ? t.eventBuffer.type === "worker" : !1,
                networkDetailHasUrls: e.networkDetailAllowUrls.length > 0,
                networkCaptureBodies: e.networkCaptureBodies,
                networkRequestHasHeaders: e.networkRequestHeaders.length > 0,
                networkResponseHasHeaders: e.networkResponseHeaders.length > 0
            }
        }
    }
}
function JW(t, e) {
    !e || !t.session || t.session.segmentId !== 0 || px(t, KW(t), !1)
}
function ZW(t, e, n, s) {
    return yc(Jk(t, qv(t), s, n), [[{
        type: "replay_event"
    }, t], [{
        type: "replay_recording",
        length: typeof e == "string" ? new TextEncoder().encode(e).length : e.length
    }, e]])
}
function QW({ recordingData: t, headers: e }) {
    let n;
    const s = `${JSON.stringify(e)}
`;
    if (typeof t == "string")
        n = `${s}${t}`;
    else {
        const i = new TextEncoder().encode(s);
        n = new Uint8Array(i.length + t.length),
            n.set(i),
            n.set(t, i.length)
    }
    return n
}
async function eY({ client: t, scope: e, replayId: n, event: s }) {
    const r = typeof t._integrations == "object" && t._integrations !== null && !Array.isArray(t._integrations) ? Object.keys(t._integrations) : void 0
        , i = {
            event_id: n,
            integrations: r
        };
    t.emit("preprocessEvent", s, i);
    const o = await nR(t.getOptions(), s, i, e, t, qi());
    if (!o)
        return null;
    o.platform = o.platform || "javascript";
    const l = t.getSdkMetadata()
        , { name: a, version: c } = l && l.sdk || {};
    return o.sdk = {
        ...o.sdk,
        name: a || "sentry.javascript.unknown",
        version: c || "0.0.0"
    },
        o
}
async function tY({ recordingData: t, replayId: e, segmentId: n, eventContext: s, timestamp: r, session: i }) {
    const o = QW({
        recordingData: t,
        headers: {
            segment_id: n
        }
    })
        , { urls: l, errorIds: a, traceIds: c, initialTimestamp: u } = s
        , h = bt()
        , d = Ut()
        , f = h && h.getTransport()
        , p = h && h.getDsn();
    if (!h || !f || !p || !i.sampled)
        return Lo({});
    const m = {
        type: DV,
        replay_start_timestamp: u / 1e3,
        timestamp: r / 1e3,
        error_ids: a,
        trace_ids: c,
        urls: l,
        replay_id: e,
        segment_id: n,
        replay_type: i.sampled
    }
        , g = await eY({
            scope: d,
            client: h,
            replayId: e,
            event: m
        });
    if (!g)
        return h.recordDroppedEvent("event_processor", "replay", m),
            qe && Je.info("An event processor returned `null`, will not send event."),
            Lo({});
    delete g.sdkProcessingMetadata;
    const b = ZW(g, o, p, h.getOptions().tunnel);
    let v;
    try {
        v = await f.send(b)
    } catch (y) {
        const x = new Error(rx);
        try {
            x.cause = y
        } catch { }
        throw x
    }
    if (typeof v.statusCode == "number" && (v.statusCode < 200 || v.statusCode >= 300))
        throw new IM(v.statusCode);
    const _ = uR({}, v);
    if (cR(_, "replay"))
        throw new gx(_);
    return v
}
class IM extends Error {
    constructor(e) {
        super(`Transport returned status code ${e}`)
    }
}
class gx extends Error {
    constructor(e) {
        super("Rate limit hit"),
            this.rateLimits = e
    }
}
async function AM(t, e = {
    count: 0,
    interval: GV
}) {
    const { recordingData: n, onError: s } = t;
    if (n.length)
        try {
            return await tY(t),
                !0
        } catch (r) {
            if (r instanceof IM || r instanceof gx)
                throw r;
            if (q7("Replays", {
                _retryCount: e.count
            }),
                s && s(r),
                e.count >= HV) {
                const i = new Error(`${rx} - max retries exceeded`);
                try {
                    i.cause = r
                } catch { }
                throw i
            }
            return e.interval *= ++e.count,
                new Promise((i, o) => {
                    Du(async () => {
                        try {
                            await AM(t, e),
                                i(!0)
                        } catch (l) {
                            o(l)
                        }
                    }
                        , e.interval)
                }
                )
        }
}
const kM = "__THROTTLED"
    , nY = "__SKIPPED";
function sY(t, e, n) {
    const s = new Map
        , r = l => {
            const a = l - n;
            s.forEach((c, u) => {
                u < a && s.delete(u)
            }
            )
        }
        , i = () => [...s.values()].reduce((l, a) => l + a, 0);
    let o = !1;
    return (...l) => {
        const a = Math.floor(Date.now() / 1e3);
        if (r(a),
            i() >= e) {
            const u = o;
            return o = !0,
                u ? nY : kM
        }
        o = !1;
        const c = s.get(a) || 0;
        return s.set(a, c + 1),
            t(...l)
    }
}
class ba {
    constructor({ options: e, recordingOptions: n }) {
        ba.prototype.__init.call(this),
            ba.prototype.__init2.call(this),
            ba.prototype.__init3.call(this),
            ba.prototype.__init4.call(this),
            ba.prototype.__init5.call(this),
            ba.prototype.__init6.call(this),
            this.eventBuffer = null,
            this.performanceEntries = [],
            this.replayPerformanceEntries = [],
            this.recordingMode = "session",
            this.timeouts = {
                sessionIdlePause: BV,
                sessionIdleExpire: FV
            },
            this._lastActivity = Date.now(),
            this._isEnabled = !1,
            this._isPaused = !1,
            this._requiresManualStart = !1,
            this._hasInitializedCoreListeners = !1,
            this._context = {
                errorIds: new Set,
                traceIds: new Set,
                urls: [],
                initialTimestamp: Date.now(),
                initialUrl: ""
            },
            this._recordingOptions = n,
            this._options = e,
            this._debouncedFlush = zW(() => this._flush(), this._options.flushMinDelay, {
                maxWait: this._options.flushMaxDelay
            }),
            this._throttledAddEvent = sY((o, l) => QH(this, o, l), 300, 5);
        const { slowClickTimeout: s, slowClickIgnoreSelectors: r } = this.getOptions()
            , i = s ? {
                threshold: Math.min(WV, s),
                timeout: s,
                scrollTimeout: YV,
                ignoreSelector: r ? r.join(",") : ""
            } : void 0;
        if (i && (this.clickDetector = new hH(this, i)),
            qe) {
            const o = e._experiments;
            Je.setConfig({
                captureExceptions: !!o.captureExceptions,
                traceInternals: !!o.traceInternals
            })
        }
    }
    getContext() {
        return this._context
    }
    isEnabled() {
        return this._isEnabled
    }
    isPaused() {
        return this._isPaused
    }
    isRecordingCanvas() {
        return !!this._canvas
    }
    getOptions() {
        return this._options
    }
    handleException(e) {
        qe && Je.exception(e),
            this._options.onError && this._options.onError(e)
    }
    initializeSampling(e) {
        const { errorSampleRate: n, sessionSampleRate: s } = this._options
            , r = n <= 0 && s <= 0;
        if (this._requiresManualStart = r,
            !r) {
            if (this._initializeSessionForSampling(e),
                !this.session) {
                qe && Je.exception(new Error("Unable to initialize and create session"));
                return
            }
            this.session.sampled !== !1 && (this.recordingMode = this.session.sampled === "buffer" && this.session.segmentId === 0 ? "buffer" : "session",
                qe && Je.infoTick(`Starting replay in ${this.recordingMode} mode`),
                this._initializeRecording())
        }
    }
    start() {
        if (this._isEnabled && this.recordingMode === "session") {
            qe && Je.info("Recording is already in progress");
            return
        }
        if (this._isEnabled && this.recordingMode === "buffer") {
            qe && Je.info("Buffering is in progress, call `flush()` to save the replay");
            return
        }
        qe && Je.infoTick("Starting replay in session mode"),
            this._updateUserActivity();
        const e = k0({
            maxReplayDuration: this._options.maxReplayDuration,
            sessionIdleExpire: this.timeouts.sessionIdleExpire
        }, {
            stickySession: this._options.stickySession,
            sessionSampleRate: 1,
            allowBuffering: !1
        });
        this.session = e,
            this._initializeRecording()
    }
    startBuffering() {
        if (this._isEnabled) {
            qe && Je.info("Buffering is in progress, call `flush()` to save the replay");
            return
        }
        qe && Je.infoTick("Starting replay in buffer mode");
        const e = k0({
            sessionIdleExpire: this.timeouts.sessionIdleExpire,
            maxReplayDuration: this._options.maxReplayDuration
        }, {
            stickySession: this._options.stickySession,
            sessionSampleRate: 0,
            allowBuffering: !0
        });
        this.session = e,
            this.recordingMode = "buffer",
            this._initializeRecording()
    }
    startRecording() {
        try {
            const e = this._canvas;
            this._stopRecording = Io({
                ...this._recordingOptions,
                ...this.recordingMode === "buffer" ? {
                    checkoutEveryNms: VV
                } : this._options._experiments.continuousCheckout && {
                    checkoutEveryNms: Math.max(36e4, this._options._experiments.continuousCheckout)
                },
                emit: qW(this),
                onMutation: this._onMutationHandler,
                ...e ? {
                    recordCanvas: e.recordCanvas,
                    getCanvasManager: e.getCanvasManager,
                    sampling: e.sampling,
                    dataURLOptions: e.dataURLOptions
                } : {}
            })
        } catch (e) {
            this.handleException(e)
        }
    }
    stopRecording() {
        try {
            return this._stopRecording && (this._stopRecording(),
                this._stopRecording = void 0),
                !0
        } catch (e) {
            return this.handleException(e),
                !1
        }
    }
    async stop({ forceFlush: e = !1, reason: n } = {}) {
        if (this._isEnabled) {
            this._isEnabled = !1;
            try {
                qe && Je.info(`Stopping Replay${n ? ` triggered by ${n}` : ""}`),
                    bM(),
                    this._removeListeners(),
                    this.stopRecording(),
                    this._debouncedFlush.cancel(),
                    e && await this._flush({
                        force: !0
                    }),
                    this.eventBuffer && this.eventBuffer.destroy(),
                    this.eventBuffer = null,
                    zH(this)
            } catch (s) {
                this.handleException(s)
            }
        }
    }
    pause() {
        this._isPaused || (this._isPaused = !0,
            this.stopRecording(),
            qe && Je.info("Pausing replay"))
    }
    resume() {
        !this._isPaused || !this._checkSession() || (this._isPaused = !1,
            this.startRecording(),
            qe && Je.info("Resuming replay"))
    }
    async sendBufferedReplayOrFlush({ continueRecording: e = !0 } = {}) {
        if (this.recordingMode === "session")
            return this.flushImmediate();
        const n = Date.now();
        qe && Je.info("Converting buffer to session"),
            await this.flushImmediate();
        const s = this.stopRecording();
        !e || !s || this.recordingMode !== "session" && (this.recordingMode = "session",
            this.session && (this._updateUserActivity(n),
                this._updateSessionActivity(n),
                this._maybeSaveSession()),
            this.startRecording())
    }
    addUpdate(e) {
        const n = e();
        this.recordingMode !== "buffer" && n !== !0 && this._debouncedFlush()
    }
    triggerUserActivity() {
        if (this._updateUserActivity(),
            !this._stopRecording) {
            if (!this._checkSession())
                return;
            this.resume();
            return
        }
        this.checkAndHandleExpiredSession(),
            this._updateSessionActivity()
    }
    updateUserActivity() {
        this._updateUserActivity(),
            this._updateSessionActivity()
    }
    conditionalFlush() {
        return this.recordingMode === "buffer" ? Promise.resolve() : this.flushImmediate()
    }
    flush() {
        return this._debouncedFlush()
    }
    flushImmediate() {
        return this._debouncedFlush(),
            this._debouncedFlush.flush()
    }
    cancelFlush() {
        this._debouncedFlush.cancel()
    }
    getSessionId() {
        return this.session && this.session.id
    }
    checkAndHandleExpiredSession() {
        if (this._lastActivity && Ly(this._lastActivity, this.timeouts.sessionIdlePause) && this.session && this.session.sampled === "session") {
            this.pause();
            return
        }
        return !!this._checkSession()
    }
    setInitialState() {
        const e = `${Gt.location.pathname}${Gt.location.hash}${Gt.location.search}`
            , n = `${Gt.location.origin}${e}`;
        this.performanceEntries = [],
            this.replayPerformanceEntries = [],
            this._clearContext(),
            this._context.initialUrl = n,
            this._context.initialTimestamp = Date.now(),
            this._context.urls.push(n)
    }
    throttledAddEvent(e, n) {
        const s = this._throttledAddEvent(e, n);
        if (s === kM) {
            const r = Fi({
                category: "replay.throttled"
            });
            this.addUpdate(() => !px(this, {
                type: rH,
                timestamp: r.timestamp || 0,
                data: {
                    tag: "breadcrumb",
                    payload: r,
                    metric: !0
                }
            }))
        }
        return s
    }
    getCurrentRoute() {
        const e = this.lastActiveSpan || Cn()
            , n = e && zn(e)
            , r = (n && It(n).data || {})[or];
        if (!(!n || !r || !["route", "custom"].includes(r)))
            return It(n).description
    }
    _initializeRecording() {
        this.setInitialState(),
            this._updateSessionActivity(),
            this.eventBuffer = YH({
                useCompression: this._options.useCompression,
                workerUrl: this._options.workerUrl
            }),
            this._removeListeners(),
            this._addListeners(),
            this._isEnabled = !0,
            this._isPaused = !1,
            this.startRecording()
    }
    _initializeSessionForSampling(e) {
        const n = this._options.errorSampleRate > 0
            , s = k0({
                sessionIdleExpire: this.timeouts.sessionIdleExpire,
                maxReplayDuration: this._options.maxReplayDuration,
                previousSessionId: e
            }, {
                stickySession: this._options.stickySession,
                sessionSampleRate: this._options.sessionSampleRate,
                allowBuffering: n
            });
        this.session = s
    }
    _checkSession() {
        if (!this.session)
            return !1;
        const e = this.session;
        return mM(e, {
            sessionIdleExpire: this.timeouts.sessionIdleExpire,
            maxReplayDuration: this._options.maxReplayDuration
        }) ? (this._refreshSession(e),
            !1) : !0
    }
    async _refreshSession(e) {
        this._isEnabled && (await this.stop({
            reason: "refresh session"
        }),
            this.initializeSampling(e.id))
    }
    _addListeners() {
        try {
            Gt.document.addEventListener("visibilitychange", this._handleVisibilityChange),
                Gt.addEventListener("blur", this._handleWindowBlur),
                Gt.addEventListener("focus", this._handleWindowFocus),
                Gt.addEventListener("keydown", this._handleKeyboardEvent),
                this.clickDetector && this.clickDetector.addListeners(),
                this._hasInitializedCoreListeners || (YW(this),
                    this._hasInitializedCoreListeners = !0)
        } catch (e) {
            this.handleException(e)
        }
        this._performanceCleanupCallback = FH(this)
    }
    _removeListeners() {
        try {
            Gt.document.removeEventListener("visibilitychange", this._handleVisibilityChange),
                Gt.removeEventListener("blur", this._handleWindowBlur),
                Gt.removeEventListener("focus", this._handleWindowFocus),
                Gt.removeEventListener("keydown", this._handleKeyboardEvent),
                this.clickDetector && this.clickDetector.removeListeners(),
                this._performanceCleanupCallback && this._performanceCleanupCallback()
        } catch (e) {
            this.handleException(e)
        }
    }
    __init() {
        this._handleVisibilityChange = () => {
            Gt.document.visibilityState === "visible" ? this._doChangeToForegroundTasks() : this._doChangeToBackgroundTasks()
        }
    }
    __init2() {
        this._handleWindowBlur = () => {
            const e = Fi({
                category: "ui.blur"
            });
            this._doChangeToBackgroundTasks(e)
        }
    }
    __init3() {
        this._handleWindowFocus = () => {
            const e = Fi({
                category: "ui.focus"
            });
            this._doChangeToForegroundTasks(e)
        }
    }
    __init4() {
        this._handleKeyboardEvent = e => {
            EH(this, e)
        }
    }
    _doChangeToBackgroundTasks(e) {
        !this.session || pM(this.session, {
            maxReplayDuration: this._options.maxReplayDuration,
            sessionIdleExpire: this.timeouts.sessionIdleExpire
        }) || (e && this._createCustomBreadcrumb(e),
            this.conditionalFlush())
    }
    _doChangeToForegroundTasks(e) {
        if (!this.session)
            return;
        if (!this.checkAndHandleExpiredSession()) {
            qe && Je.info("Document has become active, but session has expired");
            return
        }
        e && this._createCustomBreadcrumb(e)
    }
    _updateUserActivity(e = Date.now()) {
        this._lastActivity = e
    }
    _updateSessionActivity(e = Date.now()) {
        this.session && (this.session.lastActivity = e,
            this._maybeSaveSession())
    }
    _createCustomBreadcrumb(e) {
        this.addUpdate(() => {
            this.throttledAddEvent({
                type: ht.Custom,
                timestamp: e.timestamp || 0,
                data: {
                    tag: "breadcrumb",
                    payload: e
                }
            })
        }
        )
    }
    _addPerformanceEntries() {
        let e = AH(this.performanceEntries).concat(this.replayPerformanceEntries);
        if (this.performanceEntries = [],
            this.replayPerformanceEntries = [],
            this._requiresManualStart) {
            const n = this._context.initialTimestamp / 1e3;
            e = e.filter(s => s.start >= n)
        }
        return Promise.all(a_(this, e))
    }
    _clearContext() {
        this._context.errorIds.clear(),
            this._context.traceIds.clear(),
            this._context.urls = []
    }
    _updateInitialTimestampFromEventBuffer() {
        const { session: e, eventBuffer: n } = this;
        if (!e || !n || this._requiresManualStart || e.segmentId)
            return;
        const s = n.getEarliestTimestamp();
        s && s < this._context.initialTimestamp && (this._context.initialTimestamp = s)
    }
    _popEventContext() {
        const e = {
            initialTimestamp: this._context.initialTimestamp,
            initialUrl: this._context.initialUrl,
            errorIds: Array.from(this._context.errorIds),
            traceIds: Array.from(this._context.traceIds),
            urls: this._context.urls
        };
        return this._clearContext(),
            e
    }
    async _runFlush() {
        const e = this.getSessionId();
        if (!this.session || !this.eventBuffer || !e) {
            qe && Je.error("No session or eventBuffer found to flush.");
            return
        }
        if (await this._addPerformanceEntries(),
            !(!this.eventBuffer || !this.eventBuffer.hasEvents) && (await XW(this),
                !!this.eventBuffer && e === this.getSessionId()))
            try {
                this._updateInitialTimestampFromEventBuffer();
                const n = Date.now();
                if (n - this._context.initialTimestamp > this._options.maxReplayDuration + 3e4)
                    throw new Error("Session is too long, not sending replay");
                const s = this._popEventContext()
                    , r = this.session.segmentId++;
                this._maybeSaveSession();
                const i = await this.eventBuffer.finish();
                await AM({
                    replayId: e,
                    recordingData: i,
                    segmentId: r,
                    eventContext: s,
                    session: this.session,
                    timestamp: n,
                    onError: o => this.handleException(o)
                })
            } catch (n) {
                this.handleException(n),
                    this.stop({
                        reason: "sendReplay"
                    });
                const s = bt();
                if (s) {
                    const r = n instanceof gx ? "ratelimit_backoff" : "send_error";
                    s.recordDroppedEvent(r, "replay")
                }
            }
    }
    __init5() {
        this._flush = async ({ force: e = !1 } = {}) => {
            if (!this._isEnabled && !e)
                return;
            if (!this.checkAndHandleExpiredSession()) {
                qe && Je.error("Attempting to finish replay event after session expired.");
                return
            }
            if (!this.session)
                return;
            const n = this.session.started
                , r = Date.now() - n;
            this._debouncedFlush.cancel();
            const i = r < this._options.minReplayDuration
                , o = r > this._options.maxReplayDuration + 5e3;
            if (i || o) {
                qe && Je.info(`Session duration (${Math.floor(r / 1e3)}s) is too ${i ? "short" : "long"}, not sending replay.`),
                    i && this._debouncedFlush();
                return
            }
            const l = this.eventBuffer;
            l && this.session.segmentId === 0 && !l.hasCheckout && qe && Je.info("Flushing initial segment without checkout.");
            const a = !!this._flushLock;
            this._flushLock || (this._flushLock = this._runFlush());
            try {
                await this._flushLock
            } catch (c) {
                this.handleException(c)
            } finally {
                this._flushLock = void 0,
                    a && this._debouncedFlush()
            }
        }
    }
    _maybeSaveSession() {
        this.session && this._options.stickySession && fx(this.session)
    }
    __init6() {
        this._onMutationHandler = e => {
            const n = e.length
                , s = this._options.mutationLimit
                , r = this._options.mutationBreadcrumbLimit
                , i = s && n > s;
            if (n > r || i) {
                const o = Fi({
                    category: "replay.mutations",
                    data: {
                        count: n,
                        limit: i
                    }
                });
                this._createCustomBreadcrumb(o)
            }
            return i ? (this.stop({
                reason: "mutationLimit",
                forceFlush: this.recordingMode === "session"
            }),
                !1) : !0
        }
    }
}
function Th(t, e) {
    return [...t, ...e].join(",")
}
function rY({ mask: t, unmask: e, block: n, unblock: s, ignore: r }) {
    const i = ['base[href="/"]']
        , o = Th(t, [".sentry-mask", "[data-sentry-mask]"])
        , l = Th(e, []);
    return {
        maskTextSelector: o,
        unmaskTextSelector: l,
        blockSelector: Th(n, [".sentry-block", "[data-sentry-block]", ...i]),
        unblockSelector: Th(s, []),
        ignoreSelector: Th(r, [".sentry-ignore", "[data-sentry-ignore]", 'input[type="file"]'])
    }
}
function iY({ el: t, key: e, maskAttributes: n, maskAllText: s, privacyOptions: r, value: i }) {
    return !s || r.unmaskTextSelector && t.matches(r.unmaskTextSelector) ? i : n.includes(e) || e === "value" && t.tagName === "INPUT" && ["submit", "button"].includes(t.getAttribute("type") || "") ? i.replace(/[\S]/g, "*") : i
}
const aC = 'img,image,svg,video,object,picture,embed,map,audio,link[rel="icon"],link[rel="apple-touch-icon"]'
    , oY = ["content-length", "content-type", "accept"];
let lC = !1;
const aY = t => new c_(t);
class c_ {
    static __initStatic() {
        this.id = "Replay"
    }
    constructor({ flushMinDelay: e = $V, flushMaxDelay: n = UV, minReplayDuration: s = XV, maxReplayDuration: r = GT, stickySession: i = !0, useCompression: o = !0, workerUrl: l, _experiments: a = {}, maskAllText: c = !0, maskAllInputs: u = !0, blockAllMedia: h = !0, mutationBreadcrumbLimit: d = 750, mutationLimit: f = 1e4, slowClickTimeout: p = 7e3, slowClickIgnoreSelectors: m = [], networkDetailAllowUrls: g = [], networkDetailDenyUrls: b = [], networkCaptureBodies: v = !0, networkRequestHeaders: _ = [], networkResponseHeaders: y = [], mask: x = [], maskAttributes: w = ["title", "placeholder"], unmask: S = [], block: E = [], unblock: C = [], ignore: I = [], maskFn: L, beforeAddRecordingEvent: k, beforeErrorSampling: R, onError: U } = {}) {
        this.name = c_.id;
        const W = rY({
            mask: x,
            unmask: S,
            block: E,
            unblock: C,
            ignore: I
        });
        if (this._recordingOptions = {
            maskAllInputs: u,
            maskAllText: c,
            maskInputOptions: {
                password: !0
            },
            maskTextFn: L,
            maskInputFn: L,
            maskAttributeFn: (H, j, z) => iY({
                maskAttributes: w,
                maskAllText: c,
                privacyOptions: W,
                key: H,
                value: j,
                el: z
            }),
            ...W,
            slimDOMOptions: "all",
            inlineStylesheet: !0,
            inlineImages: !1,
            collectFonts: !0,
            errorHandler: H => {
                try {
                    H.__rrweb__ = !0
                } catch { }
            }
        },
            this._initialOptions = {
                flushMinDelay: e,
                flushMaxDelay: n,
                minReplayDuration: Math.min(s, jV),
                maxReplayDuration: Math.min(r, GT),
                stickySession: i,
                useCompression: o,
                workerUrl: l,
                blockAllMedia: h,
                maskAllInputs: u,
                maskAllText: c,
                mutationBreadcrumbLimit: d,
                mutationLimit: f,
                slowClickTimeout: p,
                slowClickIgnoreSelectors: m,
                networkDetailAllowUrls: g,
                networkDetailDenyUrls: b,
                networkCaptureBodies: v,
                networkRequestHeaders: cC(_),
                networkResponseHeaders: cC(y),
                beforeAddRecordingEvent: k,
                beforeErrorSampling: R,
                onError: U,
                _experiments: a
            },
            this._initialOptions.blockAllMedia && (this._recordingOptions.blockSelector = this._recordingOptions.blockSelector ? `${this._recordingOptions.blockSelector},${aC}` : aC),
            this._isInitialized && PT())
            throw new Error("Multiple Sentry Session Replay instances are not supported");
        this._isInitialized = !0
    }
    get _isInitialized() {
        return lC
    }
    set _isInitialized(e) {
        lC = e
    }
    afterAllSetup(e) {
        !PT() || this._replay || (this._setup(e),
            this._initialize(e))
    }
    start() {
        this._replay && this._replay.start()
    }
    startBuffering() {
        this._replay && this._replay.startBuffering()
    }
    stop() {
        return this._replay ? this._replay.stop({
            forceFlush: this._replay.recordingMode === "session"
        }) : Promise.resolve()
    }
    flush(e) {
        return this._replay ? this._replay.isEnabled() ? this._replay.sendBufferedReplayOrFlush(e) : (this._replay.start(),
            Promise.resolve()) : Promise.resolve()
    }
    getReplayId() {
        if (!(!this._replay || !this._replay.isEnabled()))
            return this._replay.getSessionId()
    }
    getRecordingMode() {
        if (!(!this._replay || !this._replay.isEnabled()))
            return this._replay.recordingMode
    }
    _initialize(e) {
        this._replay && (this._maybeLoadFromReplayCanvasIntegration(e),
            this._replay.initializeSampling())
    }
    _setup(e) {
        const n = lY(this._initialOptions, e);
        this._replay = new ba({
            options: n,
            recordingOptions: this._recordingOptions
        })
    }
    _maybeLoadFromReplayCanvasIntegration(e) {
        try {
            const n = e.getIntegrationByName("ReplayCanvas");
            if (!n)
                return;
            this._replay._canvas = n.getOptions()
        } catch { }
    }
}
c_.__initStatic();
function lY(t, e) {
    const n = e.getOptions()
        , s = {
            sessionSampleRate: 0,
            errorSampleRate: 0,
            ...On(t)
        }
        , r = ym(n.replaysSessionSampleRate)
        , i = ym(n.replaysOnErrorSampleRate);
    return r == null && i == null && pi(() => {
        console.warn("Replay is disabled because neither `replaysSessionSampleRate` nor `replaysOnErrorSampleRate` are set.")
    }
    ),
        r != null && (s.sessionSampleRate = r),
        i != null && (s.errorSampleRate = i),
        s
}
function cC(t) {
    return [...oY, ...t.map(e => e.toLowerCase())]
}
const uC = new WeakMap
    , R0 = new Map
    , Vp = {
        traceFetch: !0,
        traceXHR: !0,
        enableHTTPTimings: !0,
        trackFetchStreamPerformance: !1
    };
function cY(t, e) {
    const { traceFetch: n, traceXHR: s, trackFetchStreamPerformance: r, shouldCreateSpanForRequest: i, enableHTTPTimings: o, tracePropagationTargets: l } = {
        traceFetch: Vp.traceFetch,
        traceXHR: Vp.traceXHR,
        trackFetchStreamPerformance: Vp.trackFetchStreamPerformance,
        ...e
    }
        , a = typeof i == "function" ? i : h => !0
        , c = h => fY(h, l)
        , u = {};
    n && (t.addEventProcessor(h => (h.type === "transaction" && h.spans && h.spans.forEach(d => {
        if (d.op === "http.client") {
            const f = R0.get(d.span_id);
            f && (d.timestamp = f / 1e3,
                R0.delete(d.span_id))
        }
    }
    ),
        h)),
        r && r$(h => {
            if (h.response) {
                const d = uC.get(h.response);
                d && h.endTimestamp && R0.set(d, h.endTimestamp)
            }
        }
        ),
        _R(h => {
            const d = JF(h, a, c, u);
            if (h.response && h.fetchData.__span && uC.set(h.response, h.fetchData.__span),
                d) {
                const f = RM(h.fetchData.url)
                    , p = f ? Hl(f).host : void 0;
                d.setAttributes({
                    "http.url": f,
                    "server.address": p
                })
            }
            o && d && hC(d)
        }
        )),
        s && DR(h => {
            const d = pY(h, a, c, u);
            o && d && hC(d)
        }
        )
}
function uY(t) {
    return t.entryType === "resource" && "initiatorType" in t && typeof t.nextHopProtocol == "string" && (t.initiatorType === "fetch" || t.initiatorType === "xmlhttprequest")
}
function hC(t) {
    const { url: e } = It(t).data || {};
    if (!e || typeof e != "string")
        return;
    const n = Nu("resource", ({ entries: s }) => {
        s.forEach(r => {
            uY(r) && r.name.endsWith(e) && (dY(r).forEach(o => t.setAttribute(...o)),
                setTimeout(n))
        }
        )
    }
    )
}
function hY(t) {
    let e = "unknown"
        , n = "unknown"
        , s = "";
    for (const r of t) {
        if (r === "/") {
            [e, n] = t.split("/");
            break
        }
        if (!isNaN(Number(r))) {
            e = s === "h" ? "http" : s,
                n = t.split(s)[1];
            break
        }
        s += r
    }
    return s === t && (e = s),
    {
        name: e,
        version: n
    }
}
function vi(t = 0) {
    return ((Ps || performance.timeOrigin) + t) / 1e3
}
function dY(t) {
    const { name: e, version: n } = hY(t.nextHopProtocol)
        , s = [];
    return s.push(["network.protocol.version", n], ["network.protocol.name", e]),
        Ps ? [...s, ["http.request.redirect_start", vi(t.redirectStart)], ["http.request.fetch_start", vi(t.fetchStart)], ["http.request.domain_lookup_start", vi(t.domainLookupStart)], ["http.request.domain_lookup_end", vi(t.domainLookupEnd)], ["http.request.connect_start", vi(t.connectStart)], ["http.request.secure_connection_start", vi(t.secureConnectionStart)], ["http.request.connection_end", vi(t.connectEnd)], ["http.request.request_start", vi(t.requestStart)], ["http.request.response_start", vi(t.responseStart)], ["http.request.response_end", vi(t.responseEnd)]] : s
}
function fY(t, e) {
    const n = rt.location && rt.location.href;
    if (n) {
        let s, r;
        try {
            s = new URL(t, n),
                r = new URL(n).origin
        } catch {
            return !1
        }
        const i = s.origin === r;
        return e ? Ba(s.toString(), e) || i && Ba(s.pathname, e) : i
    } else {
        const s = !!t.match(/^\/(?!\/)/);
        return e ? Ba(t, e) : s
    }
}
function pY(t, e, n, s) {
    const r = t.xhr
        , i = r && r[Pl];
    if (!r || r.__sentry_own_request__ || !i)
        return;
    const o = Oo() && e(i.url);
    if (t.endTimestamp && o) {
        const h = r.__sentry_xhr_span_id__;
        if (!h)
            return;
        const d = s[h];
        d && i.status_code !== void 0 && (Nk(d, i.status_code),
            d.end(),
            delete s[h]);
        return
    }
    const l = RM(i.url)
        , a = l ? Hl(l).host : void 0
        , c = !!Cn()
        , u = o && c ? ec({
            name: `${i.method} ${i.url}`,
            attributes: {
                type: "xhr",
                "http.method": i.method,
                "http.url": l,
                url: i.url,
                "server.address": a,
                [an]: "auto.http.browser",
                [Ql]: "http.client"
            }
        }) : new nh;
    return r.__sentry_xhr_span_id__ = u.spanContext().spanId,
        s[r.__sentry_xhr_span_id__] = u,
        n(i.url) && mY(r, Oo() && c ? u : void 0),
        u
}
function mY(t, e) {
    const { "sentry-trace": n, baggage: s } = hR({
        span: e
    });
    n && gY(t, n, s)
}
function gY(t, e, n) {
    try {
        t.setRequestHeader("sentry-trace", e),
            n && t.setRequestHeader("baggage", n)
    } catch { }
}
function RM(t) {
    try {
        return new URL(t, rt.location.origin).href
    } catch {
        return
    }
}
function _Y() {
    rt && rt.document ? rt.document.addEventListener("visibilitychange", () => {
        const t = Cn();
        if (!t)
            return;
        const e = zn(t);
        if (rt.document.hidden && e) {
            const n = "cancelled"
                , { op: s, status: r } = It(e);
            Xi && Re.log(`[Tracing] Transaction: ${n} -> since tab moved to the background, op: ${s}`),
                r || e.setStatus({
                    code: Hn,
                    message: n
                }),
                e.setAttribute("sentry.cancellation_reason", "document.hidden"),
                e.end()
        }
    }
    ) : Xi && Re.warn("[Tracing] Could not set up background tab detection due to lack of global document")
}
const yY = "BrowserTracing"
    , bY = {
        ...Dp,
        instrumentNavigation: !0,
        instrumentPageLoad: !0,
        markBackgroundSpan: !0,
        enableLongTask: !0,
        enableLongAnimationFrame: !0,
        enableInp: !0,
        _experiments: {},
        ...Vp
    }
    , dC = (t = {}) => {
        qB();
        const { enableInp: e, enableLongTask: n, enableLongAnimationFrame: s, _experiments: { enableInteractions: r, enableStandaloneClsSpans: i }, beforeStartSpan: o, idleTimeout: l, finalTimeout: a, childSpanTimeout: c, markBackgroundSpan: u, traceFetch: h, traceXHR: d, trackFetchStreamPerformance: f, shouldCreateSpanForRequest: p, enableHTTPTimings: m, instrumentPageLoad: g, instrumentNavigation: b } = {
            ...bY,
            ...t
        }
            , v = fU({
                recordClsStandaloneSpans: i || !1
            });
        e && BU(),
            s && St.PerformanceObserver && PerformanceObserver.supportedEntryTypes && PerformanceObserver.supportedEntryTypes.includes("long-animation-frame") ? mU() : n && pU(),
            r && gU();
        const _ = {
            name: void 0,
            source: void 0
        };
        function y(x, w) {
            const S = w.op === "pageload"
                , E = o ? o(w) : w
                , C = E.attributes || {};
            w.name !== E.name && (C[or] = "custom",
                E.attributes = C),
                _.name = E.name,
                _.source = C[or];
            const I = tR(E, {
                idleTimeout: l,
                finalTimeout: a,
                childSpanTimeout: c,
                disableAutoFinish: S,
                beforeSpanEnd: k => {
                    v(),
                        xU(k, {
                            recordClsOnPageloadSpan: !i
                        })
                }
            });
            function L() {
                ["interactive", "complete"].includes(rt.document.readyState) && x.emit("idleSpanEnableAutoFinish", I)
            }
            return S && rt.document && (rt.document.addEventListener("readystatechange", () => {
                L()
            }
            ),
                L()),
                I
        }
        return {
            name: yY,
            afterAllSetup(x) {
                let w, S = rt.location && rt.location.href;
                function E() {
                    w && !It(w).timestamp && (Xi && Re.log(`[Tracing] Finishing current active span with op: ${It(w).op}`),
                        w.end())
                }
                x.on("startNavigationSpan", C => {
                    bt() === x && (E(),
                        w = y(x, {
                            op: "navigation",
                            ...C
                        }))
                }
                ),
                    x.on("startPageLoadSpan", (C, I = {}) => {
                        if (bt() !== x)
                            return;
                        E();
                        const L = I.sentryTrace || fC("sentry-trace")
                            , k = I.baggage || fC("baggage")
                            , R = GB(L, k);
                        Ut().setPropagationContext(R),
                            w = y(x, {
                                op: "pageload",
                                ...C
                            })
                    }
                    ),
                    x.on("spanEnd", C => {
                        const I = It(C).op;
                        if (C !== zn(C) || I !== "navigation" && I !== "pageload")
                            return;
                        const L = Ut()
                            , k = L.getPropagationContext();
                        L.setPropagationContext({
                            ...k,
                            sampled: k.sampled !== void 0 ? k.sampled : gc(C),
                            dsc: k.dsc || _c(C)
                        })
                    }
                    ),
                    rt.location && (g && vY(x, {
                        name: rt.location.pathname,
                        startTime: Ps ? Ps / 1e3 : void 0,
                        attributes: {
                            [or]: "url",
                            [an]: "auto.pageload.browser"
                        }
                    }),
                        b && n_(({ to: C, from: I }) => {
                            if (I === void 0 && S && S.indexOf(C) !== -1) {
                                S = void 0;
                                return
                            }
                            I !== C && (S = void 0,
                                MM(x, {
                                    name: rt.location.pathname,
                                    attributes: {
                                        [or]: "url",
                                        [an]: "auto.navigation.browser"
                                    }
                                }))
                        }
                        )),
                    u && _Y(),
                    r && xY(l, a, c, _),
                    e && $U(),
                    cY(x, {
                        traceFetch: h,
                        traceXHR: d,
                        trackFetchStreamPerformance: f,
                        tracePropagationTargets: x.getOptions().tracePropagationTargets,
                        shouldCreateSpanForRequest: p,
                        enableHTTPTimings: m
                    })
            }
        }
    }
    ;
function vY(t, e, n) {
    t.emit("startPageLoadSpan", e, n),
        Ut().setTransactionName(e.name);
    const s = Cn();
    return (s && It(s).op) === "pageload" ? s : void 0
}
function MM(t, e) {
    qi().setPropagationContext({
        traceId: xd()
    }),
        Ut().setPropagationContext({
            traceId: xd()
        }),
        t.emit("startNavigationSpan", e),
        Ut().setTransactionName(e.name);
    const n = Cn();
    return (n && It(n).op) === "navigation" ? n : void 0
}
function fC(t) {
    const e = pB(`meta[name=${t}]`);
    return e ? e.getAttribute("content") : void 0
}
function xY(t, e, n, s) {
    let r;
    const i = () => {
        const o = "ui.action.click"
            , l = Cn()
            , a = l && zn(l);
        if (a) {
            const c = It(a).op;
            if (["navigation", "pageload"].includes(c)) {
                Xi && Re.warn(`[Tracing] Did not create ${o} span because a pageload or navigation span is in progress.`);
                return
            }
        }
        if (r && (r.setAttribute(cy, "interactionInterrupted"),
            r.end(),
            r = void 0),
            !s.name) {
            Xi && Re.warn(`[Tracing] Did not create ${o} transaction because _latestRouteName is missing.`);
            return
        }
        r = tR({
            name: s.name,
            op: o,
            attributes: {
                [or]: s.source || "url"
            }
        }, {
            idleTimeout: t,
            finalTimeout: e,
            childSpanTimeout: n
        })
    }
        ;
    rt.document && addEventListener("click", i, {
        once: !1,
        capture: !0
    })
}
const PM = ["activate", "mount", "update"]
    , LM = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__
    , wY = /(?:^|[-_])(\w)/g
    , SY = t => t.replace(wY, e => e.toUpperCase()).replace(/[-_]/g, "")
    , EY = "<Root>"
    , M0 = "<Anonymous>"
    , TY = (t, e) => t.repeat(e)
    , sd = (t, e) => {
        if (!t)
            return M0;
        if (t.$root === t)
            return EY;
        if (!t.$options)
            return M0;
        const n = t.$options;
        let s = n.name || n._componentTag || n.__name;
        const r = n.__file;
        if (!s && r) {
            const i = r.match(/([^/\\]+)\.vue$/);
            i && (s = i[1])
        }
        return (s ? `<${SY(s)}>` : M0) + (r && e !== !1 ? ` at ${r}` : "")
    }
    , CY = t => {
        if (t && (t._isVue || t.__isVue) && t.$parent) {
            const e = [];
            let n = 0;
            for (; t;) {
                if (e.length > 0) {
                    const r = e[e.length - 1];
                    if (r.constructor === t.constructor) {
                        n++,
                            t = t.$parent;
                        continue
                    } else
                        n > 0 && (e[e.length - 1] = [r, n],
                            n = 0)
                }
                e.push(t),
                    t = t.$parent
            }
            return `

found in

${e.map((r, i) => `${(i === 0 ? "---> " : TY(" ", 5 + i * 2)) + (Array.isArray(r) ? `${sd(r[0])}... (${r[1]} recursive calls)` : sd(r))}`).join(`
`)}`
        }
        return `

(found in ${sd(t)})`
    }
    , IY = (t, e) => {
        const { errorHandler: n, warnHandler: s, silent: r } = t.config;
        t.config.errorHandler = (i, o, l) => {
            const a = sd(o, !1)
                , c = o ? CY(o) : ""
                , u = {
                    componentName: a,
                    lifecycleHook: l,
                    trace: c
                };
            if (e.attachProps && o && (o.$options && o.$options.propsData ? u.propsData = o.$options.propsData : o.$props && (u.propsData = o.$props)),
                setTimeout(() => {
                    No(i, {
                        captureContext: {
                            contexts: {
                                vue: u
                            }
                        },
                        mechanism: {
                            handled: !1
                        }
                    })
                }
                ),
                typeof n == "function" && t.config.errorHandler && n.call(t, i, o, l),
                e.logErrors) {
                const h = typeof console < "u"
                    , d = `Error in ${l}: "${i && i.toString()}"`;
                s ? s.call(null, d, o, c) : h && !r && pi(() => {
                    console.error(`[Vue warn]: ${d}${c}`)
                }
                )
            }
        }
    }
    , pC = "ui.vue"
    , AY = {
        activate: ["activated", "deactivated"],
        create: ["beforeCreate", "created"],
        unmount: ["beforeUnmount", "unmounted"],
        destroy: ["beforeDestroy", "destroyed"],
        mount: ["beforeMount", "mounted"],
        update: ["beforeUpdate", "updated"]
    };
function kY(t, e, n) {
    t.$_sentryRootSpanTimer && clearTimeout(t.$_sentryRootSpanTimer),
        t.$_sentryRootSpanTimer = setTimeout(() => {
            t.$root && t.$root.$_sentryRootSpan && (t.$root.$_sentryRootSpan.end(e),
                t.$root.$_sentryRootSpan = void 0)
        }
            , n)
}
function RY(t, e) {
    function n(r) {
        return r.replace(/^<([^\s]*)>(?: at [^\s]*)?$/, "$1")
    }
    return t.some(r => n(e) === n(r))
}
const MY = t => {
    const e = (t.hooks || []).concat(PM).filter((s, r, i) => i.indexOf(s) === r)
        , n = {};
    for (const s of e) {
        const r = AY[s];
        if (!r) {
            LM && Re.warn(`Unknown hook: ${s}`);
            continue
        }
        for (const i of r)
            n[i] = function () {
                const o = this.$root === this;
                o && (this.$_sentryRootSpan = this.$_sentryRootSpan || ec({
                    name: "Application Render",
                    op: `${pC}.render`,
                    attributes: {
                        [an]: "auto.ui.vue"
                    },
                    onlyIfParent: !0
                }));
                const l = sd(this, !1)
                    , a = Array.isArray(t.trackComponents) ? RY(t.trackComponents, l) : t.trackComponents;
                if (!(!o && !a))
                    if (this.$_sentrySpans = this.$_sentrySpans || {},
                        i == r[0]) {
                        if (this.$root && this.$root.$_sentryRootSpan || Cn()) {
                            const u = this.$_sentrySpans[s];
                            u && u.end(),
                                this.$_sentrySpans[s] = ec({
                                    name: `Vue ${l}`,
                                    op: `${pC}.${s}`,
                                    attributes: {
                                        [an]: "auto.ui.vue"
                                    },
                                    onlyIfParent: !0
                                })
                        }
                    } else {
                        const c = this.$_sentrySpans[s];
                        if (!c)
                            return;
                        c.end(),
                            kY(this, ps(), t.timeout)
                    }
            }
    }
    return n
}
    , PY = St
    , LY = {
        Vue: PY.Vue,
        attachProps: !0,
        logErrors: !0,
        attachErrorHandler: !0,
        hooks: PM,
        timeout: 2e3,
        trackComponents: !1
    }
    , OY = "Vue"
    , NY = (t = {}) => ({
        name: OY,
        setup(e) {
            const n = {
                ...LY,
                ...e.getOptions(),
                ...t
            };
            if (!n.Vue && !n.app) {
                pi(() => {
                    console.warn("[@sentry/vue]: Misconfigured SDK. Vue specific errors will not be captured. Update your `Sentry.init` call with an appropriate config option: `app` (Application Instance - Vue 3) or `Vue` (Vue Constructor - Vue 2).")
                }
                );
                return
            }
            n.app ? (Array.isArray(n.app) ? n.app : [n.app]).forEach(r => mC(r, n)) : n.Vue && mC(n.Vue, n)
        }
    })
    , mC = (t, e) => {
        if (LM) {
            const n = t;
            (n._instance && n._instance.isMounted) === !0 && pi(() => {
                console.warn("[@sentry/vue]: Misconfigured SDK. Vue app is already mounted. Make sure to call `app.mount()` after `Sentry.init()`.")
            }
            )
        }
        e.attachErrorHandler && IY(t, e),
            Oo(e) && t.mixin(MY({
                ...e,
                ...e.tracingOptions
            }))
    }
    ;
function DY(t = {}) {
    const e = {
        _metadata: {
            sdk: {
                name: "sentry.javascript.vue",
                packages: [{
                    name: "npm:@sentry/vue",
                    version: To
                }],
                version: To
            }
        },
        defaultIntegrations: [...$R(), NY()],
        ...t
    };
    return OV(e)
}
function BY(t, e, n) {
    let s = !0;
    t.onError(r => No(r, {
        mechanism: {
            handled: !1
        }
    })),
        t.beforeEach((r, i, o) => {
            const l = i.name == null && i.matched.length === 0 || i.name === void 0 && s;
            s && (s = !1);
            const a = {
                [an]: "auto.navigation.vue"
            };
            for (const h of Object.keys(r.params))
                a[`params.${h}`] = r.params[h];
            for (const h of Object.keys(r.query)) {
                const d = r.query[h];
                d && (a[`query.${h}`] = d)
            }
            let c = r.path
                , u = "url";
            if (r.name && e.routeLabel !== "path")
                c = r.name.toString(),
                    u = "custom";
            else if (r.matched.length > 0) {
                const h = r.matched.length - 1;
                c = r.matched[h].path,
                    u = "route"
            }
            if (Ut().setTransactionName(c),
                e.instrumentPageLoad && l) {
                const h = FY();
                h && ((It(h).data || {})[or] !== "custom" && (h.updateName(c),
                    h.setAttribute(or, u)),
                    h.setAttributes({
                        ...a,
                        [an]: "auto.pageload.vue"
                    }))
            }
            e.instrumentNavigation && !l && (a[or] = u,
                a[an] = "auto.navigation.vue",
                n({
                    name: c,
                    op: "navigation",
                    attributes: a
                })),
                o && o()
        }
        )
}
function FY() {
    const t = Cn()
        , e = t && zn(t);
    if (!e)
        return;
    const n = It(e).op;
    return n === "navigation" || n === "pageload" ? e : void 0
}
function $Y(t = {}) {
    if (!t.router)
        return dC(t);
    const e = dC({
        ...t,
        instrumentNavigation: !1
    })
        , { router: n, instrumentNavigation: s = !0, instrumentPageLoad: r = !0, routeLabel: i = "name" } = t;
    return {
        ...e,
        afterAllSetup(o) {
            e.afterAllSetup(o),
                BY(n, {
                    routeLabel: i,
                    instrumentNavigation: s,
                    instrumentPageLoad: r
                }, a => {
                    MM(o, a)
                }
                )
        }
    }
}
const gC = "/background.jpg"
    , UY = "8.0"
    , VY = "6.0"
    , Dy = ["demo", "prod"].includes("prod")
    , _C = {
        duration: 250,
        interval: 2500
    }
    , yC = {
        common: 1,
        rare: 2,
        epic: 3,
        legendary: 4
    }
    , Uu = {
        COIN: "coin",
        STAR: "star"
    }
    , Wl = {
        common: {
            rate: 550 / 3600,
            limit: 5500,
            next_level_experience: 1100,
            max_level: 99,
            rate_inc: 1.01,
            limit_inc: 1.01,
            next_level_experience_inc: 1.04
        },
        rare: {
            rate: 650 / 3600,
            limit: 6500,
            next_level_experience: 1210,
            max_level: 99,
            rate_inc: 1.013,
            limit_inc: 1.013,
            next_level_experience_inc: 1.04
        },
        epic: {
            rate: 850 / 3600,
            limit: 8500,
            next_level_experience: 1375,
            max_level: 99,
            rate_inc: 1.017,
            limit_inc: 1.017,
            next_level_experience_inc: 1.04
        },
        legendary: {
            rate: 1150 / 3600,
            limit: 11500,
            next_level_experience: 1925,
            max_level: 99,
            rate_inc: 1.022,
            limit_inc: 1.022,
            next_level_experience_inc: 1.04
        }
    }
    , GY = {
        MAX_SLOTS_COUNT: 6,
        DOUBLE_TAP_DELAY_MS: 300
    }
    , By = {
        "marusia-standard": {
            id: "marusia-standard",
            path: "/girls/marusia/marusia-standard.webp",
            poses: {
                1: {
                    spineAsset: "/girls/marusia/spine_marusia",
                    animationLayers: [],
                    scale: .6,
                    position: {
                        x: 1 / 2,
                        y: .66
                    }
                },
                2: {
                    spineAsset: "/girls/marusia/spine_marusia_back",
                    animationLayers: ["default", "Body/Marusia", "Wear_Legs/Leggins_1", "Wear_Body/Top_1"]
                },
                3: {
                    spineAsset: "/girls/marusia/spine_marusia_full_face",
                    animationLayers: ["default", "Body/Marusia", "Wear_Legs/Leggins_1", "Wear_Body/Top_1"],
                    disableSlap: !0
                }
            }
        },
        "kara-plaid": {
            id: "kara-plaid",
            path: "/girls/kara/kara-plaid.webp",
            poses: {
                1: {
                    spineAsset: "/girls/kara/spine_kara",
                    animationLayers: ["Kara/Kara_nude", "Kara/Kara_clothes"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/kara/spine_kara_back",
                    animationLayers: ["Kara/Kara_nude", "Kara/Kara_shirt"]
                }
            }
        },
        "kara-demobaza": {
            id: "kara-demobaza",
            path: "/girls/kara/kara-demobaza.webp",
            poses: {
                1: {
                    spineAsset: "/girls/kara/spine_kara",
                    animationLayers: ["Kara/Kara_nude", "Kara/Kara_demobaza"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/kara/spine_kara_back",
                    animationLayers: ["Kara/Kara_nude", "Kara/Kara_demobaza"]
                }
            }
        },
        "kara-red": {
            id: "kara-red",
            path: "/girls/kara/kara-red.webp",
            poses: {
                1: {
                    spineAsset: "/girls/kara/spine_kara",
                    animationLayers: ["Kara/Kara_nude", "Kara/Kara_red_sh_dress"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/kara/spine_kara_back",
                    animationLayers: ["Kara/Kara_nude", "Kara/Kara_red_s_dress"]
                }
            }
        },
        "kara-grey": {
            id: "kara-grey",
            path: "/girls/kara/kara-grey.webp",
            poses: {
                1: {
                    spineAsset: "/girls/kara/spine_kara",
                    animationLayers: ["Kara/Kara_nude", "Kara/Kara_grey_latex_dress"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/kara/spine_kara_back",
                    animationLayers: ["Kara/Kara_nude", "Kara/Kara_grey_latex_dress"]
                }
            }
        },
        "chan-jeans-jacket": {
            id: "chan-jeans-jacket",
            path: "/girls/chan/chan-jeans-jacket.webp",
            poses: {
                1: {
                    spineAsset: "/girls/chan/spine_chan",
                    animationLayers: ["Chan/Chan_nude", "Chan/Chan_accesories", "Chan/Chan_jeans_jacket"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/chan/spine_chan_back",
                    animationLayers: ["Chan_Zhi/Chan_nude", "Chan_Zhi/Chan_jeans"]
                }
            }
        },
        "chan-kimono": {
            id: "chan-kimono",
            path: "/girls/chan/chan-kimono.webp",
            poses: {
                1: {
                    spineAsset: "/girls/chan/spine_chan",
                    animationLayers: ["Chan/Chan_nude", "Chan/Chan_accesories", "Chan/Chan_kimono"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/chan/spine_chan_back",
                    animationLayers: ["Chan_Zhi/Chan_nude", "Chan_Zhi/Chan_Kimono"]
                }
            }
        },
        rihanna: {
            id: "rihanna",
            path: "/girls/rihanna/rihanna.webp",
            poses: {
                1: {
                    spineAsset: "/girls/rihanna/spine_rihanna",
                    animationLayers: ["Rihanna/Rihanna_nude", "Rihanna/Rihanna_jacket"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/rihanna/spine_rihanna_back",
                    animationLayers: ["Rihanna/Rihanna_nude", "Rihanna/Rihanna_jacket", "Rihanna/Rihanna_thong"]
                }
            }
        },
        "anna-standard": {
            id: "anna-standard",
            path: "/girls/anna/anna-standard.webp",
            poses: {
                1: {
                    spineAsset: "/girls/anna/spine_anna",
                    animationLayers: ["default", "Anna/Anna_nude", "Anna/Anna_cloth"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/anna/spine_anna_back",
                    animationLayers: ["Anna/Anna_nude", "Anna/Anna_cloth"]
                }
            }
        },
        "ember-standard": {
            id: "ember-standard",
            path: "/girls/ember/ember-standard.webp",
            poses: {
                1: {
                    spineAsset: "/girls/ember/spine_ember",
                    animationLayers: ["default", "Ember/Ember_nude", "Ember/Ember_cloth"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/ember/spine_ember_back",
                    animationLayers: ["Ember/Ember_nude", "Ember/Ember_cloth"]
                }
            }
        },
        "makima-standard": {
            id: "makima-standard",
            path: "/girls/makima/makima-standard.webp",
            poses: {
                1: {
                    spineAsset: "/girls/makima/spine_makima",
                    animationLayers: ["default", "Makima/Makima_nude", "Makima/Makima_cloth"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/makima/spine_makima_back",
                    animationLayers: ["Makima/Makima_nude", "Makima/Makima_cloth"]
                }
            }
        },
        "alisa-standard": {
            id: "alisa-standard",
            path: "/girls/alisa/alisa-standard.webp",
            poses: {
                1: {
                    spineAsset: "/girls/alisa/spine_alisa",
                    animationLayers: ["default", "Body/04", "Wear_Legs/04", "Wear_Body/04"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/alisa/spine_alisa_back",
                    animationLayers: ["default", "Body/04", "Wear_Body/04", "Wear_Legs/04"]
                }
            }
        },
        "diana-common": {
            id: "diana-common",
            path: "/girls/diana/diana-common.webp",
            poses: {
                1: {
                    spineAsset: "/girls/diana/spine_diana",
                    animationLayers: ["default", "Black/common1_orange_shirt"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/diana/spine_diana_back",
                    animationLayers: ["default", "Black/common1_orange_shirt"]
                }
            }
        },
        "diana-leggins": {
            id: "diana-leggins",
            path: "/girls/diana/diana-leggins.webp",
            poses: {
                1: {
                    spineAsset: "/girls/diana/spine_diana",
                    animationLayers: ["default", "Black/common2_green_wleggins"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/diana/spine_diana_back",
                    animationLayers: ["default", "Black/common2_green_wleggins"]
                }
            }
        },
        "diana-pink": {
            id: "diana-pink",
            path: "/girls/diana/diana-pink.webp",
            poses: {
                1: {
                    spineAsset: "/girls/diana/spine_diana",
                    animationLayers: ["default", "Black/Rar2_pink_latex"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/diana/spine_diana_back",
                    animationLayers: ["default", "Black/Rar2_pink_latex"]
                }
            }
        },
        "diana-teal": {
            id: "diana-teal",
            path: "/girls/diana/diana-teal.webp",
            poses: {
                1: {
                    spineAsset: "/girls/diana/spine_diana",
                    animationLayers: ["default", "Black/Rar1_white_teal"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/diana/spine_diana_back",
                    animationLayers: ["default", "Black/Rar1_white_teal"]
                }
            }
        },
        "diana-golden": {
            id: "diana-golden",
            path: "/girls/diana/diana-golden.webp",
            poses: {
                1: {
                    spineAsset: "/girls/diana/spine_diana",
                    animationLayers: ["default", "Black/Legendary_Golden_dress_1"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/diana/spine_diana_back",
                    animationLayers: ["default", "Black/Legendary_Golden_dress_1"]
                }
            }
        },
        "diana-legendary": {
            id: "diana-legendary",
            path: "/girls/diana/diana-legendary.webp",
            poses: {
                1: {
                    spineAsset: "/girls/diana/spine_diana",
                    animationLayers: ["default", "Black/Legendary_Golden_dress_2"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/diana/spine_diana_back",
                    animationLayers: ["default", "Black/Legendary_Golden_dress_2"]
                }
            }
        },
        "diana-silver": {
            id: "diana-silver",
            path: "/girls/diana/diana-silver.webp",
            poses: {
                1: {
                    spineAsset: "/girls/diana/spine_diana",
                    animationLayers: ["default", "Black/Epic_silver_dress"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/diana/spine_diana_back",
                    animationLayers: ["default", "Black/Epic_silver_dress"]
                }
            }
        },
        "diana-white": {
            id: "diana-white",
            path: "/girls/diana/diana-white.webp",
            poses: {
                1: {
                    spineAsset: "/girls/diana/spine_diana",
                    animationLayers: ["default", "Black/Epic_white_tribal_dress"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/diana/spine_diana_back",
                    animationLayers: ["default", "Black/Epic_white_tribal_dress"]
                }
            }
        },
        "diana-yellow": {
            id: "diana-yellow",
            path: "/girls/diana/diana-yellow.webp",
            poses: {
                1: {
                    spineAsset: "/girls/diana/spine_diana",
                    animationLayers: ["default", "Black/Rar1_yellow_blue"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/diana/spine_diana_back",
                    animationLayers: ["default", "Black/Rar1_yellow_blue"]
                }
            }
        },
        "diana-purple": {
            id: "diana-purple",
            path: "/girls/diana/diana-purple.webp",
            poses: {
                1: {
                    spineAsset: "/girls/diana/spine_diana",
                    animationLayers: ["default", "Black/Rar1_dark_purple"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/diana/spine_diana_back",
                    animationLayers: ["default", "Black/Rar1_dark_purple"]
                }
            }
        },
        "diana-blue": {
            id: "diana-blue",
            path: "/girls/diana/diana-blue.webp",
            poses: {
                1: {
                    spineAsset: "/girls/diana/spine_diana",
                    animationLayers: ["default", "Black/Rar2_blue_dress"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/diana/spine_diana_back",
                    animationLayers: ["default", "Black/Rar2_blue_dress"]
                }
            }
        },
        "diana-red": {
            id: "diana-red",
            path: "/girls/diana/diana-red.webp",
            poses: {
                1: {
                    spineAsset: "/girls/diana/spine_diana",
                    animationLayers: ["default", "Black/common3_red_top"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/diana/spine_diana_back",
                    animationLayers: ["default", "Black/common3_red_top"]
                }
            }
        },
        "diana-purple-shirt": {
            id: "diana-purple-shirt",
            path: "/girls/diana/diana-purple-shirt.webp",
            poses: {
                1: {
                    spineAsset: "/girls/diana/spine_diana",
                    animationLayers: ["default", "Black/common1_purple_shirt"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/diana/spine_diana_back",
                    animationLayers: ["default", "Black/common1_purple_shirt"]
                }
            }
        },
        "diana-red-leggins": {
            id: "diana-red-leggins",
            path: "/girls/diana/diana-red-leggins.webp",
            poses: {
                1: {
                    spineAsset: "/girls/diana/spine_diana",
                    animationLayers: ["default", "Black/common2_red_wleggins"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/diana/spine_diana_back",
                    animationLayers: ["default", "Black/common2_red_wleggins"]
                }
            }
        },
        "diana-yellow-leggins": {
            id: "diana-yellow-leggins",
            path: "/girls/diana/diana-yellow-leggins.webp",
            poses: {
                1: {
                    spineAsset: "/girls/diana/spine_diana",
                    animationLayers: ["default", "Black/common2_yellow_wleggins"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/diana/spine_diana_back",
                    animationLayers: ["default", "Black/common2_yellow_wleggins"]
                }
            }
        },
        "diana-orange-top": {
            id: "diana-orange-top",
            path: "/girls/diana/diana-orange-top.webp",
            poses: {
                1: {
                    spineAsset: "/girls/diana/spine_diana",
                    animationLayers: ["default", "Black/common3_orange_top"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/diana/spine_diana_back",
                    animationLayers: ["default", "Black/common3_orange_top"]
                }
            }
        },
        "diana-yellow-top": {
            id: "diana-yellow-top",
            path: "/girls/diana/diana-yellow-top.webp",
            poses: {
                1: {
                    spineAsset: "/girls/diana/spine_diana",
                    animationLayers: ["default", "Black/common3_yellow_top"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/diana/spine_diana_back",
                    animationLayers: ["default", "Black/common3_yellow_top"]
                }
            }
        },
        "diana-orange-shirt": {
            id: "diana-orange-shirt",
            path: "/girls/diana/diana-orange-shirt.webp",
            poses: {
                1: {
                    spineAsset: "/girls/diana/spine_diana",
                    animationLayers: ["default", "Black/common4_orange_shirt"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/diana/spine_diana_back",
                    animationLayers: ["default", "Black/common4_orange_shirt"]
                }
            }
        },
        "diana-pink-white": {
            id: "diana-pink-white",
            path: "/girls/diana/diana-pink-white.webp",
            poses: {
                1: {
                    spineAsset: "/girls/diana/spine_diana",
                    animationLayers: ["default", "Black/common4_pink_shirt"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/diana/spine_diana_back",
                    animationLayers: ["default", "Black/common4_pink_shirt"]
                }
            }
        },
        "diana-teal-shirt": {
            id: "diana-teal-shirt",
            path: "/girls/diana/diana-teal-shirt.webp",
            poses: {
                1: {
                    spineAsset: "/girls/diana/spine_diana",
                    animationLayers: ["default", "Black/common4_teal_shirt"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/diana/spine_diana_back",
                    animationLayers: ["default", "Black/common4_teal_shirt"]
                }
            }
        },
        "diana-blue-orange": {
            id: "diana-blue-orange",
            path: "/girls/diana/diana-blue-orange.webp",
            poses: {
                1: {
                    spineAsset: "/girls/diana/spine_diana",
                    animationLayers: ["default", "Black/Rar1_blue_orange"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/diana/spine_diana_back",
                    animationLayers: ["default", "Black/Rar1_blue_orange"]
                }
            }
        },
        "diana-white-latex": {
            id: "diana-white-latex",
            path: "/girls/diana/diana-white-latex.webp",
            poses: {
                1: {
                    spineAsset: "/girls/diana/spine_diana",
                    animationLayers: ["default", "Black/Rar2_white_latex"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/diana/spine_diana_back",
                    animationLayers: ["default", "Black/Rar2_white_latex"]
                }
            }
        },
        "avril-elf": {
            id: "avril-elf",
            path: "/girls/avril/avril-elf.webp",
            poses: {
                1: {
                    spineAsset: "/girls/avril/spine_avril",
                    animationLayers: ["default", "Avril/Avril_elf_dress"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/avril/spine_avril_back",
                    animationLayers: ["default", "Avril/Avril_elf_dress"]
                }
            }
        },
        "avril-black": {
            id: "avril-black",
            path: "/girls/avril/avril-black.webp",
            poses: {
                1: {
                    spineAsset: "/girls/avril/spine_avril",
                    animationLayers: ["default", "Avril/Avril_black_dress"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/avril/spine_avril_back",
                    animationLayers: ["default", "Avril/Avril_black_dress"]
                }
            }
        },
        "avril-golden": {
            id: "avril-golden",
            path: "/girls/avril/avril-golden.webp",
            poses: {
                1: {
                    spineAsset: "/girls/avril/spine_avril",
                    animationLayers: ["default", "Avril/Avril_golden_dress"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/avril/spine_avril_back",
                    animationLayers: ["default", "Avril/Avril_golden_dress"]
                }
            }
        },
        "avril-blue": {
            id: "avril-blue",
            path: "/girls/avril/avril-blue.webp",
            poses: {
                1: {
                    spineAsset: "/girls/avril/spine_avril",
                    animationLayers: ["default", "Avril/Avril_blue_dress"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/avril/spine_avril_back",
                    animationLayers: ["default", "Avril/Avril_blue_dress"]
                }
            }
        },
        "avril-green": {
            id: "avril-green",
            path: "/girls/avril/avril-green.webp",
            poses: {
                1: {
                    spineAsset: "/girls/avril/spine_avril",
                    animationLayers: ["default", "Avril/Avril_green_skirt"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/avril/spine_avril_back",
                    animationLayers: ["default", "Avril/Avril_green_skirt"]
                }
            }
        },
        "avril-pink": {
            id: "avril-pink",
            path: "/girls/avril/avril-pink.webp",
            poses: {
                1: {
                    spineAsset: "/girls/avril/spine_avril",
                    animationLayers: ["default", "Avril/Avril_pink_dress"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/avril/spine_avril_back",
                    animationLayers: ["default", "Avril/Avril_pink_dress"]
                }
            }
        },
        "avril-purple": {
            id: "avril-purple",
            path: "/girls/avril/avril-purple.webp",
            poses: {
                1: {
                    spineAsset: "/girls/avril/spine_avril",
                    animationLayers: ["default", "Avril/Avril_purple_dress"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/avril/spine_avril_back",
                    animationLayers: ["default", "Avril/Avril_purple_dress"]
                }
            }
        },
        "avril-pink-top": {
            id: "avril-pink-top",
            path: "/girls/avril/avril-pink-top.webp",
            poses: {
                1: {
                    spineAsset: "/girls/avril/spine_avril",
                    animationLayers: ["default", "Avril/Avril_pink_top"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/avril/spine_avril_back",
                    animationLayers: ["default", "Avril/Avril_pink_top"]
                }
            }
        },
        "avril-yellow-top": {
            id: "avril-yellow-top",
            path: "/girls/avril/avril-yellow-top.webp",
            poses: {
                1: {
                    spineAsset: "/girls/avril/spine_avril",
                    animationLayers: ["default", "Avril/Avril_yellow top"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/avril/spine_avril_back",
                    animationLayers: ["default", "Avril/Avril_yellow top"]
                }
            }
        },
        "avril-black-top": {
            id: "avril-black-top",
            path: "/girls/avril/avril-black-top.webp",
            poses: {
                1: {
                    spineAsset: "/girls/avril/spine_avril",
                    animationLayers: ["default", "Avril/Avril_black_top"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/avril/spine_avril_back",
                    animationLayers: ["default", "Avril/Avril_black_top"]
                }
            }
        },
        "avril-blue-top": {
            id: "avril-blue-top",
            path: "/girls/avril/avril-blue-top.webp",
            poses: {
                1: {
                    spineAsset: "/girls/avril/spine_avril",
                    animationLayers: ["default", "Avril/Avril_blue_top"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/avril/spine_avril_back",
                    animationLayers: ["default", "Avril/Avril_blue_top"]
                }
            }
        },
        "avril-pink-latex": {
            id: "avril-pink-latex",
            path: "/girls/avril/avril-pink-latex.webp",
            poses: {
                1: {
                    spineAsset: "/girls/avril/spine_avril",
                    animationLayers: ["default", "Avril/Avril_pink_latex_dress"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/avril/spine_avril_back",
                    animationLayers: ["default", "Avril/Avril_pink_latex_dress"]
                }
            }
        },
        "avril-ruby": {
            id: "avril-ruby",
            path: "/girls/avril/avril-ruby.webp",
            poses: {
                1: {
                    spineAsset: "/girls/avril/spine_avril",
                    animationLayers: ["default", "Avril/Avril_ruby_dress"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/avril/spine_avril_back",
                    animationLayers: ["default", "Avril/Avril_ruby_dress"]
                }
            }
        },
        "avril-silver": {
            id: "avril-silver",
            path: "/girls/avril/avril-silver.webp",
            poses: {
                1: {
                    spineAsset: "/girls/avril/spine_avril",
                    animationLayers: ["default", "Avril/Avril_silver_dress"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/avril/spine_avril_back",
                    animationLayers: ["default", "Avril/Avril_silver_dress"]
                }
            }
        },
        "avril-white": {
            id: "avril-white",
            path: "/girls/avril/avril-white.webp",
            poses: {
                1: {
                    spineAsset: "/girls/avril/spine_avril",
                    animationLayers: ["default", "Avril/Avril_white_dress"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/avril/spine_avril_back",
                    animationLayers: ["default", "Avril/Avril_white_dress"]
                }
            }
        },
        "belle-standard": {
            id: "belle-standard",
            path: "/girls/belle/belle-standard.webp",
            poses: {
                1: {
                    spineAsset: "/girls/belle/spine_belle",
                    animationLayers: ["default", "Belle/Belle_nude", "Belle/Belle_cloth"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/belle/spine_belle_back",
                    animationLayers: ["Belle/Belle_nude", "Belle/Belle_cloth"]
                }
            }
        },
        "jess-standard": {
            id: "jess-standard",
            path: "/girls/jess/jess-standard.webp",
            poses: {
                1: {
                    spineAsset: "/girls/jess/spine_jess",
                    animationLayers: ["Jess/Jess_nude", "Jess/Jess_jeans_jacket"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/jess/spine_jess_back",
                    animationLayers: ["Jess/Jess_nude", "Jess/Jess_jeans"]
                }
            }
        },
        "marishka-standard": {
            id: "marishka-standard",
            path: "/girls/marishka/marishka-standard.webp",
            poses: {
                1: {
                    spineAsset: "/girls/marishka/spine_marishka",
                    animationLayers: ["default", "Marishka/Marishka_nude", "Marishka/Marishka_cloth"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/marishka/spine_marishka_back",
                    animationLayers: ["Marishka/Marishka_nude", "Marishka/Marishka_cloth"]
                }
            }
        },
        "olivia-standard": {
            id: "olivia-standard",
            path: "/girls/olivia/olivia-standard.webp",
            poses: {
                1: {
                    spineAsset: "/girls/olivia/spine_olivia",
                    animationLayers: ["Olivia/Olivia_nude", "Olivia/Olivia_cloth"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/olivia/spine_olivia_back",
                    animationLayers: ["Olivia/Olivia_nude", "Olivia/Olivia_cloth"]
                }
            }
        },
        "olivia-red": {
            id: "olivia-red",
            path: "/girls/olivia/olivia-red.webp",
            poses: {
                1: {
                    spineAsset: "/girls/olivia/spine_olivia",
                    animationLayers: ["Olivia/Olivia_nude", "Olivia/Olivia_red_dress"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/olivia/spine_olivia_back",
                    animationLayers: ["Olivia/Olivia_nude", "Olivia/Olivia_red_dress"]
                }
            }
        },
        "olivia-white": {
            id: "olivia-white",
            path: "/girls/olivia/olivia-white.webp",
            poses: {
                1: {
                    spineAsset: "/girls/olivia/spine_olivia",
                    animationLayers: ["Olivia/Olivia_nude", "Olivia/Olivia_white_dress"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/olivia/spine_olivia_back",
                    animationLayers: ["Olivia/Olivia_nude", "Olivia/Olivia_white_dress"]
                }
            }
        },
        "olivia-pink": {
            id: "olivia-pink",
            path: "/girls/olivia/olivia-pink.webp",
            poses: {
                1: {
                    spineAsset: "/girls/olivia/spine_olivia",
                    animationLayers: ["Olivia/Olivia_nude", "Olivia/Olivia_pink_cloth"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/olivia/spine_olivia_back",
                    animationLayers: ["Olivia/Olivia_nude", "Olivia/Olivia_pink_cloth"]
                }
            }
        },
        "olivia-jacket": {
            id: "olivia-jacket",
            path: "/girls/olivia/olivia-jacket.webp",
            poses: {
                1: {
                    spineAsset: "/girls/olivia/spine_olivia",
                    animationLayers: ["Olivia/Olivia_nude", "Olivia/Olivia_jacket"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/olivia/spine_olivia_back",
                    animationLayers: ["Olivia/Olivia_nude", "Olivia/Olivia_jacket"]
                }
            }
        },
        "alt-standard": {
            id: "alt-standard",
            path: "/girls/alt/alt-standard.webp",
            poses: {
                1: {
                    spineAsset: "/girls/alt/spine_alt",
                    animationLayers: ["Alt/Alt_nude", "Alt/Alt_hoodie"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/alt/spine_alt_back",
                    animationLayers: ["Alt/Alt_nude", "Alt/Alt_hoodie"]
                }
            }
        },
        "megan-standard": {
            id: "megan-standard",
            path: "/girls/megan/megan-standard.webp",
            poses: {
                1: {
                    spineAsset: "/girls/megan/spine_megan",
                    animationLayers: ["Megan/Megan_nude", "Megan/Megan_cloth"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/megan/spine_megan_back",
                    animationLayers: ["Megan/Megan_nude", "Megan/Megan_cloth"]
                }
            }
        },
        "miray-standard": {
            id: "miray-standard",
            path: "/girls/miray/miray-standard.webp",
            poses: {
                1: {
                    spineAsset: "/girls/miray/spine_miray",
                    animationLayers: ["Miray/Miray_nude", "Miray/Miray_cloth"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/miray/spine_miray_back",
                    animationLayers: ["Miray/Miray_nude", "Miray/Miray_cloth"]
                }
            }
        },
        "naomi-standard": {
            id: "naomi-standard",
            path: "/girls/naomi/naomi-standard.webp",
            poses: {
                1: {
                    spineAsset: "/girls/naomi/spine_naomi",
                    animationLayers: ["Naomi/Naomi_nude", "Naomi/Naomi_cloth"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/naomi/spine_naomi_back",
                    animationLayers: ["Naomi/Naomi_nude", "Naomi/Naomi_cloth"]
                }
            }
        },
        "kate-standard": {
            id: "kate-standard",
            path: "/girls/kate/kate-standard.webp",
            poses: {
                1: {
                    spineAsset: "/girls/kate/spine_kate",
                    animationLayers: ["default", "Body/02", "Wear_Legs/02", "Wear_Body/02"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/kate/spine_kate_back",
                    animationLayers: ["default", "Body/02", "Wear_Body/02", "Wear_Legs/02"]
                }
            }
        },
        "karin-standard": {
            id: "karin-standard",
            path: "/girls/karin/karin-standard.webp",
            poses: {
                1: {
                    spineAsset: "/girls/karin/spine_karin",
                    animationLayers: ["default", "Karin/Karin_nude", "Karin/Karin_red_dress"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/karin/spine_karin_back",
                    animationLayers: ["Karin/Karin_nude", "Karin/Karin_red_dress"]
                }
            }
        },
        "seo-standard": {
            id: "seo-standard",
            path: "/girls/seo/seo-standard.webp",
            poses: {
                1: {
                    spineAsset: "/girls/seo/spine_seo",
                    animationLayers: ["default", "Body/01", "Wear_Legs/01", "Wear_Body/01"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/seo/spine_seo_back",
                    animationLayers: ["default", "Body/01", "Wear_Body/01", "Wear_Legs/01"]
                }
            }
        },
        "pom-standard": {
            id: "pom-standard",
            path: "/girls/pom/pom-standard.webp",
            poses: {
                1: {
                    spineAsset: "/girls/pom/spine_pom",
                    animationLayers: ["Pom/Pom_nude", "Pom/Pom_clothes"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/pom/spine_pom_back",
                    animationLayers: ["Pom/Pom_nude", "Pom/Pom_clothes"]
                }
            }
        },
        "mia-standard": {
            id: "mia-standard",
            path: "/girls/mia/mia-standard.webp",
            poses: {
                1: {
                    spineAsset: "/girls/mia/spine_mia",
                    animationLayers: ["default", "Mia/Mia_nude", "Mia/Mia_jacket"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/mia/spine_mia_back",
                    animationLayers: ["Mia/Mia_nude", "Mia/Mia_jacket"]
                }
            }
        },
        "mia-skirt": {
            id: "mia-standard",
            path: "/girls/mia/mia-skirt.webp",
            poses: {
                1: {
                    spineAsset: "/girls/mia/spine_mia",
                    animationLayers: ["default", "Mia/Mia_nude", "Mia/Mia_skirt"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/mia/spine_mia_back",
                    animationLayers: ["Mia/Mia_nude", "Mia/Mia_skirt"]
                }
            }
        },
        "mia-golden": {
            id: "mia-standard",
            path: "/girls/mia/mia-golden.webp",
            poses: {
                1: {
                    spineAsset: "/girls/mia/spine_mia",
                    animationLayers: ["default", "Mia/Mia_nude", "Mia/Mia_golden_dress"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/mia/spine_mia_back",
                    animationLayers: ["Mia/Mia_nude", "Mia/Mia_golden_dress"]
                }
            }
        },
        "mia-red": {
            id: "mia-standard",
            path: "/girls/mia/mia-red.webp",
            poses: {
                1: {
                    spineAsset: "/girls/mia/spine_mia",
                    animationLayers: ["default", "Mia/Mia_nude", "Mia/Mia_red_top"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/mia/spine_mia_back",
                    animationLayers: ["Mia/Mia_nude", "Mia/Mia_red_top"]
                }
            }
        },
        "mia-pink": {
            id: "mia-standard",
            path: "/girls/mia/mia-pink.webp",
            poses: {
                1: {
                    spineAsset: "/girls/mia/spine_mia",
                    animationLayers: ["default", "Mia/Mia_nude", "Mia/Mia_pink_dress"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/mia/spine_mia_back",
                    animationLayers: ["Mia/Mia_nude", "Mia/Mia_pink_dress"]
                }
            }
        },
        "zendaya-standard": {
            id: "zendaya-standard",
            path: "/girls/zendaya/zendaya-standard.webp",
            poses: {
                1: {
                    spineAsset: "/girls/zendaya/spine_zendaya",
                    animationLayers: ["Zendaya/Zendaya_nude", "Zendaya/Zendaya_clothes"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/zendaya/spine_zendaya_back",
                    animationLayers: ["Zendaya/Zendaya_nude", "Zendaya/Zendaya_clothes"]
                }
            }
        },
        "demi-standard": {
            id: "demi-standard",
            path: "/girls/demi/demi-standard.webp",
            poses: {
                1: {
                    spineAsset: "/girls/demi/spine_demi",
                    animationLayers: ["default", "Demi/Demi_nude", "Demi/Demi_cloth"],
                    disableSlap: !0
                },
                2: {
                    spineAsset: "/girls/demi/spine_demi_back",
                    animationLayers: ["Demi/Demi_nude", "Demi/Demi_cloth"]
                }
            }
        }
    }
    , Be = {
        CANT_HOLD: "cant-hold",
        CHOOSE_DAILY_REWARD: "choose-daily-reward",
        CHOOSE_DAILY_REWARD_DAY: "choose-daily-reward-day",
        DONE: "done",
        DONT_LEAVE: "dont-leave",
        GO_EARN: "go-earn",
        GO_SHOP: "go-shop",
        GO_TO_MY_LOOTBOXES: "go-to-lootboxes",
        OPEN_LOOTBOX: "open-lootbox",
        LOOTBOX_OPENED: "lootbox-opened",
        HI: "hi",
        MAIN_RESOURCE: "main-resource",
        NICE: "nice",
        PER_HOUR: "per-hour",
        SECOND_GIRL: "second-girl",
        SECOND_GIRL_CHOSEN: "second-girl-chosen",
        SECOND_GIRL_EQUIPPED: "second-girl-equipped",
        START_LESSON: "start-lesson",
        STASH_SLAP: "stash-slap",
        USE_BOOST: "use-boost",
        USE_BOOST_1: "use-boost1",
        USE_GIFT: "use-gift",
        USE_GIFT_1: "use-gift1",
        USE_GIFT_2: "use-gift2",
        GO_TO_WHEEL: "go-to-wheel",
        SPIN_WHEEL: "spin-wheel",
        CLAIM_REWARD: "claim-reward",
        CLOSE_WHEEL: "close-wheel"
    }
    , Jf = {
        SLAP: "slap",
        PROFIT: "profit",
        CAPACITY: "capacity"
    }
    , hs = {
        VERTICAL: 0,
        HORIZONTAL: 1,
        COMPACT: 2
    }
    , OM = {
        CURRENT_LOCALE: "current_locale"
    }
    , Vu = {
        common: {
            start: "#32B70D",
            end: "#1BFFAF"
        },
        rare: {
            start: "#0E47D8",
            end: "#29D5FB"
        },
        epic: {
            start: "#DD0A6F",
            end: "#FF5B70"
        },
        legendary: {
            start: "#FF9500",
            end: "#FFD237"
        }
    }
    , pu = {
        EVEN: "even",
        ODD: "odd",
        JACKPOT: "jackpot"
    }
    , HY = {
        [pu.JACKPOT]: "#jackpot-gradient",
        [pu.EVEN]: "#even-gradient",
        [pu.ODD]: "#odd-gradient"
    }
    , He = {
        CRYPTO_JACKPOT: "crypto_jackpot",
        LOOTBOX_JACKPOT: "lootbox_jackpot",
        SLAP_JACKPOT: "slap_jackpot",
        SLAP_LARGE: "slap_large",
        SLAP_MEDIUM: "slap_medium",
        SLAP_SMALL: "slap_small",
        LOOTBOX_PREMIUM: "lootbox_premium",
        LOOTBOX_STANDARD: "lootbox_standard",
        PROFIT_BOOST_LEGENDARY: "profit_boost_legendary",
        PROFIT_BOOST_EPIC: "profit_boost_epic",
        PROFIT_BOOST_RARE: "profit_boost_rare",
        PROFIT_BOOST_COMMON: "profit_boost_common",
        ENERGY_BOOST_LEGENDARY: "energy_boost_legendary",
        ENERGY_BOOST_EPIC: "energy_boost_epic",
        ENERGY_BOOST_RARE: "energy_boost_rare",
        ENERGY_BOOST_COMMON: "energy_boost_common",
        SLAP_PITTY_JACKPOT: "slap_pitty_jackpot",
        SPIN_REGULAR: "spin_regular",
        SPIN_PREMIUM: "spin_premium",
        GIRL_REGULAR: "girl_regular",
        GIRL_PREMIUM: "girl_premium",
        GIRL_JACKPOT: "girl_jackpot",
        STARTER_EPIC: "starter_epic",
        STARTER_RARE: "starter_rare",
        STARTER_LEGENDARY: "starter_legendary"
    }
    , WY = [He.SLAP_JACKPOT, He.SLAP_LARGE, He.SLAP_MEDIUM, He.SLAP_SMALL, He.SLAP_PITTY_JACKPOT]
    , YY = [He.ENERGY_BOOST_LEGENDARY, He.ENERGY_BOOST_EPIC, He.ENERGY_BOOST_RARE, He.ENERGY_BOOST_COMMON]
    , XY = [He.PROFIT_BOOST_LEGENDARY, He.PROFIT_BOOST_EPIC, He.PROFIT_BOOST_RARE, He.PROFIT_BOOST_COMMON]
    , jY = [He.LOOTBOX_PREMIUM, He.LOOTBOX_STANDARD, He.LOOTBOX_JACKPOT, He.STARTER_EPIC, He.STARTER_RARE, He.STARTER_LEGENDARY]
    , zY = [He.LOOTBOX_JACKPOT, He.SLAP_PITTY_JACKPOT, He.CRYPTO_JACKPOT, He.SLAP_JACKPOT, He.STARTER_LEGENDARY, He.GIRL_JACKPOT]
    , qY = [He.GIRL_REGULAR, He.GIRL_PREMIUM, He.GIRL_JACKPOT]
    , KY = [He.SPIN_REGULAR, He.SPIN_PREMIUM]
    , JY = [He.SLAP_JACKPOT, He.LOOTBOX_PREMIUM, He.LOOTBOX_JACKPOT, He.SPIN_PREMIUM, He.GIRL_PREMIUM, He.GIRL_REGULAR, He.GIRL_JACKPOT]
    , Pt = {
        COMMON: "common",
        RARE: "rare",
        EPIC: "epic",
        LEGENDARY: "legendary"
    }
    , ZY = {
        3: Pt.COMMON,
        4: Pt.RARE,
        5: Pt.EPIC,
        6: Pt.LEGENDARY
    }
    , rd = {
        DEFAULT: "default",
        STARTER: "starter"
    }
    , Dt = {
        STANDARD: "standard",
        ADVANCED: "advanced",
        PREMIUM: "premium",
        ULTRA_PREMIUM: "ultra_premium",
        BASIC_STAR: "basic_star",
        DELUXE_STAR: "deluxe_star",
        ELITE_STAR: "elite_star",
        PREMIUM_STAR: "premium_star",
        REFERRAL_BOX_STANDARD: "referral_box_standard",
        REFERRAL_BOX_PREMIUM: "referral_box_premium",
        STARTER_RARE: "starter_rare",
        STARTER_EPIC: "starter_epic",
        STARTER_LEGENDARY: "starter_legendary"
    }
    , NM = {
        [Dt.STANDARD]: Pt.COMMON,
        [Dt.ADVANCED]: Pt.RARE,
        [Dt.PREMIUM]: Pt.EPIC,
        [Dt.ULTRA_PREMIUM]: Pt.LEGENDARY,
        [Dt.BASIC_STAR]: Pt.COMMON,
        [Dt.DELUXE_STAR]: Pt.RARE,
        [Dt.ELITE_STAR]: Pt.EPIC,
        [Dt.PREMIUM_STAR]: Pt.LEGENDARY,
        [Dt.REFERRAL_BOX_STANDARD]: Pt.RARE,
        [Dt.REFERRAL_BOX_PREMIUM]: Pt.EPIC,
        [Dt.STARTER_RARE]: Pt.RARE,
        [Dt.STARTER_EPIC]: Pt.EPIC,
        [Dt.STARTER_LEGENDARY]: Pt.LEGENDARY
    }
    , Ls = async ({ action: t, onError: e = null, onSuccess: n = null, retries: s = 2 }) => {
        try {
            const r = await bk(() => t(), {
                retries: s,
                onFailedAttempt: i => {
                    console.warn(`Attempt ${i.attemptNumber} failed. ${i.retriesLeft} retries left.`)
                }
            });
            return n == null || n(r),
                r
        } catch (r) {
            No(r),
                Dy || (console.error("Request failed after retries:", r),
                    alert(r)),
                e == null || e(r)
        }
    }
    , Bo = (t = Date.now()) => Math.floor(t / 1e3)
    , QY = (t, e) => {
        if (!t.lock.time_lock || !e || e.level < t.lock.time_lock_level)
            return 0;
        const { time_lock: n, time_lock_multiplier: s, time_lock_level: r } = t.lock
            , { level: i, upgraded_at: o = 0 } = e
            , l = Math.floor(i / r)
            , a = Math.ceil(n * Math.pow(s, l - 1))
            , c = Bo()
            , u = o + a;
        return u < c ? 0 : u
    }
    , eX = (t, e) => {
        const n = Wl[t.tier].limit * Math.pow(Wl[t.tier].limit_inc, t.level - 1)
            , s = e ? n * e : 0;
        return {
            baseCapacity: Math.round(n),
            bonusCapacity: Math.round(s),
            capacity: Math.round(n + s)
        }
    }
    , DM = (t, e) => Number((Wl[t.tier].rate * Math.pow(Wl[t.tier].rate_inc, t.level - 1) * (1 + e)).toFixed(2))
    , P0 = 3e3
    , mi = Ds("toast", {
        state: () => ({
            toast: null,
            timeoutHandle: null
        }),
        getters: {
            hasToast(t) {
                return !!t.toast
            }
        },
        actions: {
            showToast(t, e, n = P0) {
                this.timeoutHandle && clearTimeout(this.timeoutHandle),
                    this.toast = {
                        message: t,
                        type: e,
                        duration: n
                    },
                    this.timeoutHandle = setTimeout(() => {
                        this.hideToast()
                    }
                        , n)
            },
            showSuccessToast(t, e = P0) {
                this.showToast(t, "success", e)
            },
            showErrorToast(t, e = P0) {
                this.showToast(t, "error", e)
            },
            hideToast() {
                this.timeoutHandle && clearTimeout(this.timeoutHandle),
                    this.toast = null
            }
        }
    });
var bC = {};
/*!
  * shared v9.13.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
const Mm = typeof window < "u"
    , sl = (t, e = !1) => e ? Symbol.for(t) : Symbol(t)
    , tX = (t, e, n) => nX({
        l: t,
        k: e,
        s: n
    })
    , nX = t => JSON.stringify(t).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027")
    , Mn = t => typeof t == "number" && isFinite(t)
    , sX = t => FM(t) === "[object Date]"
    , Xa = t => FM(t) === "[object RegExp]"
    , u_ = t => tt(t) && Object.keys(t).length === 0
    , os = Object.assign;
let vC;
const po = () => vC || (vC = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof bC < "u" ? bC : {});
function xC(t) {
    return t.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;")
}
const rX = Object.prototype.hasOwnProperty;
function Pm(t, e) {
    return rX.call(t, e)
}
const jt = Array.isArray
    , Ht = t => typeof t == "function"
    , Me = t => typeof t == "string"
    , pt = t => typeof t == "boolean"
    , Lt = t => t !== null && typeof t == "object"
    , iX = t => Lt(t) && Ht(t.then) && Ht(t.catch)
    , BM = Object.prototype.toString
    , FM = t => BM.call(t)
    , tt = t => {
        if (!Lt(t))
            return !1;
        const e = Object.getPrototypeOf(t);
        return e === null || e.constructor === Object
    }
    , oX = t => t == null ? "" : jt(t) || tt(t) && t.toString === BM ? JSON.stringify(t, null, 2) : String(t);
function aX(t, e = "") {
    return t.reduce((n, s, r) => r === 0 ? n + s : n + e + s, "")
}
function h_(t) {
    let e = t;
    return () => ++e
}
function lX(t, e) {
    typeof console < "u" && (console.warn("[intlify] " + t),
        e && console.warn(e.stack))
}
const Zf = t => !Lt(t) || jt(t);
function Gp(t, e) {
    if (Zf(t) || Zf(e))
        throw new Error("Invalid value");
    const n = [{
        src: t,
        des: e
    }];
    for (; n.length;) {
        const { src: s, des: r } = n.pop();
        Object.keys(s).forEach(i => {
            Zf(s[i]) || Zf(r[i]) ? r[i] = s[i] : n.push({
                src: s[i],
                des: r[i]
            })
        }
        )
    }
}
/*!
  * message-compiler v9.13.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
function cX(t, e, n) {
    return {
        line: t,
        column: e,
        offset: n
    }
}
function Lm(t, e, n) {
    return {
        start: t,
        end: e
    }
}
const uX = /\{([0-9a-zA-Z]+)\}/g;
function $M(t, ...e) {
    return e.length === 1 && hX(e[0]) && (e = e[0]),
        (!e || !e.hasOwnProperty) && (e = {}),
        t.replace(uX, (n, s) => e.hasOwnProperty(s) ? e[s] : "")
}
const UM = Object.assign
    , wC = t => typeof t == "string"
    , hX = t => t !== null && typeof t == "object";
function VM(t, e = "") {
    return t.reduce((n, s, r) => r === 0 ? n + s : n + e + s, "")
}
const _x = {
    USE_MODULO_SYNTAX: 1,
    __EXTEND_POINT__: 2
}
    , dX = {
        [_x.USE_MODULO_SYNTAX]: "Use modulo before '{{0}}'."
    };
function fX(t, e, ...n) {
    const s = $M(dX[t], ...n || [])
        , r = {
            message: String(s),
            code: t
        };
    return e && (r.location = e),
        r
}
const Ke = {
    EXPECTED_TOKEN: 1,
    INVALID_TOKEN_IN_PLACEHOLDER: 2,
    UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
    UNKNOWN_ESCAPE_SEQUENCE: 4,
    INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
    UNBALANCED_CLOSING_BRACE: 6,
    UNTERMINATED_CLOSING_BRACE: 7,
    EMPTY_PLACEHOLDER: 8,
    NOT_ALLOW_NEST_PLACEHOLDER: 9,
    INVALID_LINKED_FORMAT: 10,
    MUST_HAVE_MESSAGES_IN_PLURAL: 11,
    UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
    UNEXPECTED_EMPTY_LINKED_KEY: 13,
    UNEXPECTED_LEXICAL_ANALYSIS: 14,
    UNHANDLED_CODEGEN_NODE_TYPE: 15,
    UNHANDLED_MINIFIER_NODE_TYPE: 16,
    __EXTEND_POINT__: 17
}
    , pX = {
        [Ke.EXPECTED_TOKEN]: "Expected token: '{0}'",
        [Ke.INVALID_TOKEN_IN_PLACEHOLDER]: "Invalid token in placeholder: '{0}'",
        [Ke.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: "Unterminated single quote in placeholder",
        [Ke.UNKNOWN_ESCAPE_SEQUENCE]: "Unknown escape sequence: \\{0}",
        [Ke.INVALID_UNICODE_ESCAPE_SEQUENCE]: "Invalid unicode escape sequence: {0}",
        [Ke.UNBALANCED_CLOSING_BRACE]: "Unbalanced closing brace",
        [Ke.UNTERMINATED_CLOSING_BRACE]: "Unterminated closing brace",
        [Ke.EMPTY_PLACEHOLDER]: "Empty placeholder",
        [Ke.NOT_ALLOW_NEST_PLACEHOLDER]: "Not allowed nest placeholder",
        [Ke.INVALID_LINKED_FORMAT]: "Invalid linked format",
        [Ke.MUST_HAVE_MESSAGES_IN_PLURAL]: "Plural must have messages",
        [Ke.UNEXPECTED_EMPTY_LINKED_MODIFIER]: "Unexpected empty linked modifier",
        [Ke.UNEXPECTED_EMPTY_LINKED_KEY]: "Unexpected empty linked key",
        [Ke.UNEXPECTED_LEXICAL_ANALYSIS]: "Unexpected lexical analysis in token: '{0}'",
        [Ke.UNHANDLED_CODEGEN_NODE_TYPE]: "unhandled codegen node type: '{0}'",
        [Ke.UNHANDLED_MINIFIER_NODE_TYPE]: "unhandled mimifier node type: '{0}'"
    };
function ah(t, e, n = {}) {
    const { domain: s, messages: r, args: i } = n
        , o = $M((r || pX)[t] || "", ...i || [])
        , l = new SyntaxError(String(o));
    return l.code = t,
        e && (l.location = e),
        l.domain = s,
        l
}
function mX(t) {
    throw t
}
const Qi = " "
    , gX = "\r"
    , Es = `
`
    , _X = "\u2028"
    , yX = "\u2029";
function bX(t) {
    const e = t;
    let n = 0
        , s = 1
        , r = 1
        , i = 0;
    const o = S => e[S] === gX && e[S + 1] === Es
        , l = S => e[S] === Es
        , a = S => e[S] === yX
        , c = S => e[S] === _X
        , u = S => o(S) || l(S) || a(S) || c(S)
        , h = () => n
        , d = () => s
        , f = () => r
        , p = () => i
        , m = S => o(S) || a(S) || c(S) ? Es : e[S]
        , g = () => m(n)
        , b = () => m(n + i);
    function v() {
        return i = 0,
            u(n) && (s++,
                r = 0),
            o(n) && n++,
            n++,
            r++,
            e[n]
    }
    function _() {
        return o(n + i) && i++,
            i++,
            e[n + i]
    }
    function y() {
        n = 0,
            s = 1,
            r = 1,
            i = 0
    }
    function x(S = 0) {
        i = S
    }
    function w() {
        const S = n + i;
        for (; S !== n;)
            v();
        i = 0
    }
    return {
        index: h,
        line: d,
        column: f,
        peekOffset: p,
        charAt: m,
        currentChar: g,
        currentPeek: b,
        next: v,
        peek: _,
        reset: y,
        resetPeek: x,
        skipToPeek: w
    }
}
const Zo = void 0
    , vX = "."
    , SC = "'"
    , xX = "tokenizer";
function wX(t, e = {}) {
    const n = e.location !== !1
        , s = bX(t)
        , r = () => s.index()
        , i = () => cX(s.line(), s.column(), s.index())
        , o = i()
        , l = r()
        , a = {
            currentType: 14,
            offset: l,
            startLoc: o,
            endLoc: o,
            lastType: 14,
            lastOffset: l,
            lastStartLoc: o,
            lastEndLoc: o,
            braceNest: 0,
            inLinked: !1,
            text: ""
        }
        , c = () => a
        , { onError: u } = e;
    function h(P, B, V, ...re) {
        const ye = c();
        if (B.column += V,
            B.offset += V,
            u) {
            const me = n ? Lm(ye.startLoc, B) : null
                , Z = ah(P, me, {
                    domain: xX,
                    args: re
                });
            u(Z)
        }
    }
    function d(P, B, V) {
        P.endLoc = i(),
            P.currentType = B;
        const re = {
            type: B
        };
        return n && (re.loc = Lm(P.startLoc, P.endLoc)),
            V != null && (re.value = V),
            re
    }
    const f = P => d(P, 14);
    function p(P, B) {
        return P.currentChar() === B ? (P.next(),
            B) : (h(Ke.EXPECTED_TOKEN, i(), 0, B),
                "")
    }
    function m(P) {
        let B = "";
        for (; P.currentPeek() === Qi || P.currentPeek() === Es;)
            B += P.currentPeek(),
                P.peek();
        return B
    }
    function g(P) {
        const B = m(P);
        return P.skipToPeek(),
            B
    }
    function b(P) {
        if (P === Zo)
            return !1;
        const B = P.charCodeAt(0);
        return B >= 97 && B <= 122 || B >= 65 && B <= 90 || B === 95
    }
    function v(P) {
        if (P === Zo)
            return !1;
        const B = P.charCodeAt(0);
        return B >= 48 && B <= 57
    }
    function _(P, B) {
        const { currentType: V } = B;
        if (V !== 2)
            return !1;
        m(P);
        const re = b(P.currentPeek());
        return P.resetPeek(),
            re
    }
    function y(P, B) {
        const { currentType: V } = B;
        if (V !== 2)
            return !1;
        m(P);
        const re = P.currentPeek() === "-" ? P.peek() : P.currentPeek()
            , ye = v(re);
        return P.resetPeek(),
            ye
    }
    function x(P, B) {
        const { currentType: V } = B;
        if (V !== 2)
            return !1;
        m(P);
        const re = P.currentPeek() === SC;
        return P.resetPeek(),
            re
    }
    function w(P, B) {
        const { currentType: V } = B;
        if (V !== 8)
            return !1;
        m(P);
        const re = P.currentPeek() === ".";
        return P.resetPeek(),
            re
    }
    function S(P, B) {
        const { currentType: V } = B;
        if (V !== 9)
            return !1;
        m(P);
        const re = b(P.currentPeek());
        return P.resetPeek(),
            re
    }
    function E(P, B) {
        const { currentType: V } = B;
        if (!(V === 8 || V === 12))
            return !1;
        m(P);
        const re = P.currentPeek() === ":";
        return P.resetPeek(),
            re
    }
    function C(P, B) {
        const { currentType: V } = B;
        if (V !== 10)
            return !1;
        const re = () => {
            const me = P.currentPeek();
            return me === "{" ? b(P.peek()) : me === "@" || me === "%" || me === "|" || me === ":" || me === "." || me === Qi || !me ? !1 : me === Es ? (P.peek(),
                re()) : k(P, !1)
        }
            , ye = re();
        return P.resetPeek(),
            ye
    }
    function I(P) {
        m(P);
        const B = P.currentPeek() === "|";
        return P.resetPeek(),
            B
    }
    function L(P) {
        const B = m(P)
            , V = P.currentPeek() === "%" && P.peek() === "{";
        return P.resetPeek(),
        {
            isModulo: V,
            hasSpace: B.length > 0
        }
    }
    function k(P, B = !0) {
        const V = (ye = !1, me = "", Z = !1) => {
            const le = P.currentPeek();
            return le === "{" ? me === "%" ? !1 : ye : le === "@" || !le ? me === "%" ? !0 : ye : le === "%" ? (P.peek(),
                V(ye, "%", !0)) : le === "|" ? me === "%" || Z ? !0 : !(me === Qi || me === Es) : le === Qi ? (P.peek(),
                    V(!0, Qi, Z)) : le === Es ? (P.peek(),
                        V(!0, Es, Z)) : !0
        }
            , re = V();
        return B && P.resetPeek(),
            re
    }
    function R(P, B) {
        const V = P.currentChar();
        return V === Zo ? Zo : B(V) ? (P.next(),
            V) : null
    }
    function U(P) {
        const B = P.charCodeAt(0);
        return B >= 97 && B <= 122 || B >= 65 && B <= 90 || B >= 48 && B <= 57 || B === 95 || B === 36
    }
    function W(P) {
        return R(P, U)
    }
    function H(P) {
        const B = P.charCodeAt(0);
        return B >= 97 && B <= 122 || B >= 65 && B <= 90 || B >= 48 && B <= 57 || B === 95 || B === 36 || B === 45
    }
    function j(P) {
        return R(P, H)
    }
    function z(P) {
        const B = P.charCodeAt(0);
        return B >= 48 && B <= 57
    }
    function ee(P) {
        return R(P, z)
    }
    function J(P) {
        const B = P.charCodeAt(0);
        return B >= 48 && B <= 57 || B >= 65 && B <= 70 || B >= 97 && B <= 102
    }
    function Y(P) {
        return R(P, J)
    }
    function ne(P) {
        let B = ""
            , V = "";
        for (; B = ee(P);)
            V += B;
        return V
    }
    function oe(P) {
        g(P);
        const B = P.currentChar();
        return B !== "%" && h(Ke.EXPECTED_TOKEN, i(), 0, B),
            P.next(),
            "%"
    }
    function ce(P) {
        let B = "";
        for (; ;) {
            const V = P.currentChar();
            if (V === "{" || V === "}" || V === "@" || V === "|" || !V)
                break;
            if (V === "%")
                if (k(P))
                    B += V,
                        P.next();
                else
                    break;
            else if (V === Qi || V === Es)
                if (k(P))
                    B += V,
                        P.next();
                else {
                    if (I(P))
                        break;
                    B += V,
                        P.next()
                }
            else
                B += V,
                    P.next()
        }
        return B
    }
    function ue(P) {
        g(P);
        let B = ""
            , V = "";
        for (; B = j(P);)
            V += B;
        return P.currentChar() === Zo && h(Ke.UNTERMINATED_CLOSING_BRACE, i(), 0),
            V
    }
    function we(P) {
        g(P);
        let B = "";
        return P.currentChar() === "-" ? (P.next(),
            B += `-${ne(P)}`) : B += ne(P),
            P.currentChar() === Zo && h(Ke.UNTERMINATED_CLOSING_BRACE, i(), 0),
            B
    }
    function K(P) {
        return P !== SC && P !== Es
    }
    function ge(P) {
        g(P),
            p(P, "'");
        let B = ""
            , V = "";
        for (; B = R(P, K);)
            B === "\\" ? V += he(P) : V += B;
        const re = P.currentChar();
        return re === Es || re === Zo ? (h(Ke.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, i(), 0),
            re === Es && (P.next(),
                p(P, "'")),
            V) : (p(P, "'"),
                V)
    }
    function he(P) {
        const B = P.currentChar();
        switch (B) {
            case "\\":
            case "'":
                return P.next(),
                    `\\${B}`;
            case "u":
                return be(P, B, 4);
            case "U":
                return be(P, B, 6);
            default:
                return h(Ke.UNKNOWN_ESCAPE_SEQUENCE, i(), 0, B),
                    ""
        }
    }
    function be(P, B, V) {
        p(P, B);
        let re = "";
        for (let ye = 0; ye < V; ye++) {
            const me = Y(P);
            if (!me) {
                h(Ke.INVALID_UNICODE_ESCAPE_SEQUENCE, i(), 0, `\\${B}${re}${P.currentChar()}`);
                break
            }
            re += me
        }
        return `\\${B}${re}`
    }
    function Pe(P) {
        return P !== "{" && P !== "}" && P !== Qi && P !== Es
    }
    function De(P) {
        g(P);
        let B = ""
            , V = "";
        for (; B = R(P, Pe);)
            V += B;
        return V
    }
    function D(P) {
        let B = ""
            , V = "";
        for (; B = W(P);)
            V += B;
        return V
    }
    function M(P) {
        const B = V => {
            const re = P.currentChar();
            return re === "{" || re === "%" || re === "@" || re === "|" || re === "(" || re === ")" || !re || re === Qi ? V : (V += re,
                P.next(),
                B(V))
        }
            ;
        return B("")
    }
    function X(P) {
        g(P);
        const B = p(P, "|");
        return g(P),
            B
    }
    function ae(P, B) {
        let V = null;
        switch (P.currentChar()) {
            case "{":
                return B.braceNest >= 1 && h(Ke.NOT_ALLOW_NEST_PLACEHOLDER, i(), 0),
                    P.next(),
                    V = d(B, 2, "{"),
                    g(P),
                    B.braceNest++,
                    V;
            case "}":
                return B.braceNest > 0 && B.currentType === 2 && h(Ke.EMPTY_PLACEHOLDER, i(), 0),
                    P.next(),
                    V = d(B, 3, "}"),
                    B.braceNest--,
                    B.braceNest > 0 && g(P),
                    B.inLinked && B.braceNest === 0 && (B.inLinked = !1),
                    V;
            case "@":
                return B.braceNest > 0 && h(Ke.UNTERMINATED_CLOSING_BRACE, i(), 0),
                    V = ie(P, B) || f(B),
                    B.braceNest = 0,
                    V;
            default:
                {
                    let ye = !0
                        , me = !0
                        , Z = !0;
                    if (I(P))
                        return B.braceNest > 0 && h(Ke.UNTERMINATED_CLOSING_BRACE, i(), 0),
                            V = d(B, 1, X(P)),
                            B.braceNest = 0,
                            B.inLinked = !1,
                            V;
                    if (B.braceNest > 0 && (B.currentType === 5 || B.currentType === 6 || B.currentType === 7))
                        return h(Ke.UNTERMINATED_CLOSING_BRACE, i(), 0),
                            B.braceNest = 0,
                            pe(P, B);
                    if (ye = _(P, B))
                        return V = d(B, 5, ue(P)),
                            g(P),
                            V;
                    if (me = y(P, B))
                        return V = d(B, 6, we(P)),
                            g(P),
                            V;
                    if (Z = x(P, B))
                        return V = d(B, 7, ge(P)),
                            g(P),
                            V;
                    if (!ye && !me && !Z)
                        return V = d(B, 13, De(P)),
                            h(Ke.INVALID_TOKEN_IN_PLACEHOLDER, i(), 0, V.value),
                            g(P),
                            V;
                    break
                }
        }
        return V
    }
    function ie(P, B) {
        const { currentType: V } = B;
        let re = null;
        const ye = P.currentChar();
        switch ((V === 8 || V === 9 || V === 12 || V === 10) && (ye === Es || ye === Qi) && h(Ke.INVALID_LINKED_FORMAT, i(), 0),
        ye) {
            case "@":
                return P.next(),
                    re = d(B, 8, "@"),
                    B.inLinked = !0,
                    re;
            case ".":
                return g(P),
                    P.next(),
                    d(B, 9, ".");
            case ":":
                return g(P),
                    P.next(),
                    d(B, 10, ":");
            default:
                return I(P) ? (re = d(B, 1, X(P)),
                    B.braceNest = 0,
                    B.inLinked = !1,
                    re) : w(P, B) || E(P, B) ? (g(P),
                        ie(P, B)) : S(P, B) ? (g(P),
                            d(B, 12, D(P))) : C(P, B) ? (g(P),
                                ye === "{" ? ae(P, B) || re : d(B, 11, M(P))) : (V === 8 && h(Ke.INVALID_LINKED_FORMAT, i(), 0),
                                    B.braceNest = 0,
                                    B.inLinked = !1,
                                    pe(P, B))
        }
    }
    function pe(P, B) {
        let V = {
            type: 14
        };
        if (B.braceNest > 0)
            return ae(P, B) || f(B);
        if (B.inLinked)
            return ie(P, B) || f(B);
        switch (P.currentChar()) {
            case "{":
                return ae(P, B) || f(B);
            case "}":
                return h(Ke.UNBALANCED_CLOSING_BRACE, i(), 0),
                    P.next(),
                    d(B, 3, "}");
            case "@":
                return ie(P, B) || f(B);
            default:
                {
                    if (I(P))
                        return V = d(B, 1, X(P)),
                            B.braceNest = 0,
                            B.inLinked = !1,
                            V;
                    const { isModulo: ye, hasSpace: me } = L(P);
                    if (ye)
                        return me ? d(B, 0, ce(P)) : d(B, 4, oe(P));
                    if (k(P))
                        return d(B, 0, ce(P));
                    break
                }
        }
        return V
    }
    function xe() {
        const { currentType: P, offset: B, startLoc: V, endLoc: re } = a;
        return a.lastType = P,
            a.lastOffset = B,
            a.lastStartLoc = V,
            a.lastEndLoc = re,
            a.offset = r(),
            a.startLoc = i(),
            s.currentChar() === Zo ? d(a, 14) : pe(s, a)
    }
    return {
        nextToken: xe,
        currentOffset: r,
        currentPosition: i,
        context: c
    }
}
const SX = "parser"
    , EX = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
function TX(t, e, n) {
    switch (t) {
        case "\\\\":
            return "\\";
        case "\\'":
            return "'";
        default:
            {
                const s = parseInt(e || n, 16);
                return s <= 55295 || s >= 57344 ? String.fromCodePoint(s) : ""
            }
    }
}
function CX(t = {}) {
    const e = t.location !== !1
        , { onError: n, onWarn: s } = t;
    function r(_, y, x, w, ...S) {
        const E = _.currentPosition();
        if (E.offset += w,
            E.column += w,
            n) {
            const C = e ? Lm(x, E) : null
                , I = ah(y, C, {
                    domain: SX,
                    args: S
                });
            n(I)
        }
    }
    function i(_, y, x, w, ...S) {
        const E = _.currentPosition();
        if (E.offset += w,
            E.column += w,
            s) {
            const C = e ? Lm(x, E) : null;
            s(fX(y, C, S))
        }
    }
    function o(_, y, x) {
        const w = {
            type: _
        };
        return e && (w.start = y,
            w.end = y,
            w.loc = {
                start: x,
                end: x
            }),
            w
    }
    function l(_, y, x, w) {
        e && (_.end = y,
            _.loc && (_.loc.end = x))
    }
    function a(_, y) {
        const x = _.context()
            , w = o(3, x.offset, x.startLoc);
        return w.value = y,
            l(w, _.currentOffset(), _.currentPosition()),
            w
    }
    function c(_, y) {
        const x = _.context()
            , { lastOffset: w, lastStartLoc: S } = x
            , E = o(5, w, S);
        return E.index = parseInt(y, 10),
            _.nextToken(),
            l(E, _.currentOffset(), _.currentPosition()),
            E
    }
    function u(_, y, x) {
        const w = _.context()
            , { lastOffset: S, lastStartLoc: E } = w
            , C = o(4, S, E);
        return C.key = y,
            x === !0 && (C.modulo = !0),
            _.nextToken(),
            l(C, _.currentOffset(), _.currentPosition()),
            C
    }
    function h(_, y) {
        const x = _.context()
            , { lastOffset: w, lastStartLoc: S } = x
            , E = o(9, w, S);
        return E.value = y.replace(EX, TX),
            _.nextToken(),
            l(E, _.currentOffset(), _.currentPosition()),
            E
    }
    function d(_) {
        const y = _.nextToken()
            , x = _.context()
            , { lastOffset: w, lastStartLoc: S } = x
            , E = o(8, w, S);
        return y.type !== 12 ? (r(_, Ke.UNEXPECTED_EMPTY_LINKED_MODIFIER, x.lastStartLoc, 0),
            E.value = "",
            l(E, w, S),
        {
            nextConsumeToken: y,
            node: E
        }) : (y.value == null && r(_, Ke.UNEXPECTED_LEXICAL_ANALYSIS, x.lastStartLoc, 0, Br(y)),
            E.value = y.value || "",
            l(E, _.currentOffset(), _.currentPosition()),
        {
            node: E
        })
    }
    function f(_, y) {
        const x = _.context()
            , w = o(7, x.offset, x.startLoc);
        return w.value = y,
            l(w, _.currentOffset(), _.currentPosition()),
            w
    }
    function p(_) {
        const y = _.context()
            , x = o(6, y.offset, y.startLoc);
        let w = _.nextToken();
        if (w.type === 9) {
            const S = d(_);
            x.modifier = S.node,
                w = S.nextConsumeToken || _.nextToken()
        }
        switch (w.type !== 10 && r(_, Ke.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, Br(w)),
        w = _.nextToken(),
        w.type === 2 && (w = _.nextToken()),
        w.type) {
            case 11:
                w.value == null && r(_, Ke.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, Br(w)),
                    x.key = f(_, w.value || "");
                break;
            case 5:
                w.value == null && r(_, Ke.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, Br(w)),
                    x.key = u(_, w.value || "");
                break;
            case 6:
                w.value == null && r(_, Ke.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, Br(w)),
                    x.key = c(_, w.value || "");
                break;
            case 7:
                w.value == null && r(_, Ke.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, Br(w)),
                    x.key = h(_, w.value || "");
                break;
            default:
                {
                    r(_, Ke.UNEXPECTED_EMPTY_LINKED_KEY, y.lastStartLoc, 0);
                    const S = _.context()
                        , E = o(7, S.offset, S.startLoc);
                    return E.value = "",
                        l(E, S.offset, S.startLoc),
                        x.key = E,
                        l(x, S.offset, S.startLoc),
                    {
                        nextConsumeToken: w,
                        node: x
                    }
                }
        }
        return l(x, _.currentOffset(), _.currentPosition()),
        {
            node: x
        }
    }
    function m(_) {
        const y = _.context()
            , x = y.currentType === 1 ? _.currentOffset() : y.offset
            , w = y.currentType === 1 ? y.endLoc : y.startLoc
            , S = o(2, x, w);
        S.items = [];
        let E = null
            , C = null;
        do {
            const k = E || _.nextToken();
            switch (E = null,
            k.type) {
                case 0:
                    k.value == null && r(_, Ke.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, Br(k)),
                        S.items.push(a(_, k.value || ""));
                    break;
                case 6:
                    k.value == null && r(_, Ke.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, Br(k)),
                        S.items.push(c(_, k.value || ""));
                    break;
                case 4:
                    C = !0;
                    break;
                case 5:
                    k.value == null && r(_, Ke.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, Br(k)),
                        S.items.push(u(_, k.value || "", !!C)),
                        C && (i(_, _x.USE_MODULO_SYNTAX, y.lastStartLoc, 0, Br(k)),
                            C = null);
                    break;
                case 7:
                    k.value == null && r(_, Ke.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, Br(k)),
                        S.items.push(h(_, k.value || ""));
                    break;
                case 8:
                    {
                        const R = p(_);
                        S.items.push(R.node),
                            E = R.nextConsumeToken || null;
                        break
                    }
            }
        } while (y.currentType !== 14 && y.currentType !== 1);
        const I = y.currentType === 1 ? y.lastOffset : _.currentOffset()
            , L = y.currentType === 1 ? y.lastEndLoc : _.currentPosition();
        return l(S, I, L),
            S
    }
    function g(_, y, x, w) {
        const S = _.context();
        let E = w.items.length === 0;
        const C = o(1, y, x);
        C.cases = [],
            C.cases.push(w);
        do {
            const I = m(_);
            E || (E = I.items.length === 0),
                C.cases.push(I)
        } while (S.currentType !== 14);
        return E && r(_, Ke.MUST_HAVE_MESSAGES_IN_PLURAL, x, 0),
            l(C, _.currentOffset(), _.currentPosition()),
            C
    }
    function b(_) {
        const y = _.context()
            , { offset: x, startLoc: w } = y
            , S = m(_);
        return y.currentType === 14 ? S : g(_, x, w, S)
    }
    function v(_) {
        const y = wX(_, UM({}, t))
            , x = y.context()
            , w = o(0, x.offset, x.startLoc);
        return e && w.loc && (w.loc.source = _),
            w.body = b(y),
            t.onCacheKey && (w.cacheKey = t.onCacheKey(_)),
            x.currentType !== 14 && r(y, Ke.UNEXPECTED_LEXICAL_ANALYSIS, x.lastStartLoc, 0, _[x.offset] || ""),
            l(w, y.currentOffset(), y.currentPosition()),
            w
    }
    return {
        parse: v
    }
}
function Br(t) {
    if (t.type === 14)
        return "EOF";
    const e = (t.value || "").replace(/\r?\n/gu, "\\n");
    return e.length > 10 ? e.slice(0, 9) + "" : e
}
function IX(t, e = {}) {
    const n = {
        ast: t,
        helpers: new Set
    };
    return {
        context: () => n,
        helper: i => (n.helpers.add(i),
            i)
    }
}
function EC(t, e) {
    for (let n = 0; n < t.length; n++)
        yx(t[n], e)
}
function yx(t, e) {
    switch (t.type) {
        case 1:
            EC(t.cases, e),
                e.helper("plural");
            break;
        case 2:
            EC(t.items, e);
            break;
        case 6:
            {
                yx(t.key, e),
                    e.helper("linked"),
                    e.helper("type");
                break
            }
        case 5:
            e.helper("interpolate"),
                e.helper("list");
            break;
        case 4:
            e.helper("interpolate"),
                e.helper("named");
            break
    }
}
function AX(t, e = {}) {
    const n = IX(t);
    n.helper("normalize"),
        t.body && yx(t.body, n);
    const s = n.context();
    t.helpers = Array.from(s.helpers)
}
function kX(t) {
    const e = t.body;
    return e.type === 2 ? TC(e) : e.cases.forEach(n => TC(n)),
        t
}
function TC(t) {
    if (t.items.length === 1) {
        const e = t.items[0];
        (e.type === 3 || e.type === 9) && (t.static = e.value,
            delete e.value)
    } else {
        const e = [];
        for (let n = 0; n < t.items.length; n++) {
            const s = t.items[n];
            if (!(s.type === 3 || s.type === 9) || s.value == null)
                break;
            e.push(s.value)
        }
        if (e.length === t.items.length) {
            t.static = VM(e);
            for (let n = 0; n < t.items.length; n++) {
                const s = t.items[n];
                (s.type === 3 || s.type === 9) && delete s.value
            }
        }
    }
}
const RX = "minifier";
function Fc(t) {
    switch (t.t = t.type,
    t.type) {
        case 0:
            {
                const e = t;
                Fc(e.body),
                    e.b = e.body,
                    delete e.body;
                break
            }
        case 1:
            {
                const e = t
                    , n = e.cases;
                for (let s = 0; s < n.length; s++)
                    Fc(n[s]);
                e.c = n,
                    delete e.cases;
                break
            }
        case 2:
            {
                const e = t
                    , n = e.items;
                for (let s = 0; s < n.length; s++)
                    Fc(n[s]);
                e.i = n,
                    delete e.items,
                    e.static && (e.s = e.static,
                        delete e.static);
                break
            }
        case 3:
        case 9:
        case 8:
        case 7:
            {
                const e = t;
                e.value && (e.v = e.value,
                    delete e.value);
                break
            }
        case 6:
            {
                const e = t;
                Fc(e.key),
                    e.k = e.key,
                    delete e.key,
                    e.modifier && (Fc(e.modifier),
                        e.m = e.modifier,
                        delete e.modifier);
                break
            }
        case 5:
            {
                const e = t;
                e.i = e.index,
                    delete e.index;
                break
            }
        case 4:
            {
                const e = t;
                e.k = e.key,
                    delete e.key;
                break
            }
        default:
            throw ah(Ke.UNHANDLED_MINIFIER_NODE_TYPE, null, {
                domain: RX,
                args: [t.type]
            })
    }
    delete t.type
}
const MX = "parser";
function PX(t, e) {
    const { sourceMap: n, filename: s, breakLineCode: r, needIndent: i } = e
        , o = e.location !== !1
        , l = {
            filename: s,
            code: "",
            column: 1,
            line: 1,
            offset: 0,
            map: void 0,
            breakLineCode: r,
            needIndent: i,
            indentLevel: 0
        };
    o && t.loc && (l.source = t.loc.source);
    const a = () => l;
    function c(g, b) {
        l.code += g
    }
    function u(g, b = !0) {
        const v = b ? r : "";
        c(i ? v + "  ".repeat(g) : v)
    }
    function h(g = !0) {
        const b = ++l.indentLevel;
        g && u(b)
    }
    function d(g = !0) {
        const b = --l.indentLevel;
        g && u(b)
    }
    function f() {
        u(l.indentLevel)
    }
    return {
        context: a,
        push: c,
        indent: h,
        deindent: d,
        newline: f,
        helper: g => `_${g}`,
        needIndent: () => l.needIndent
    }
}
function LX(t, e) {
    const { helper: n } = t;
    t.push(`${n("linked")}(`),
        Gu(t, e.key),
        e.modifier ? (t.push(", "),
            Gu(t, e.modifier),
            t.push(", _type")) : t.push(", undefined, _type"),
        t.push(")")
}
function OX(t, e) {
    const { helper: n, needIndent: s } = t;
    t.push(`${n("normalize")}([`),
        t.indent(s());
    const r = e.items.length;
    for (let i = 0; i < r && (Gu(t, e.items[i]),
        i !== r - 1); i++)
        t.push(", ");
    t.deindent(s()),
        t.push("])")
}
function NX(t, e) {
    const { helper: n, needIndent: s } = t;
    if (e.cases.length > 1) {
        t.push(`${n("plural")}([`),
            t.indent(s());
        const r = e.cases.length;
        for (let i = 0; i < r && (Gu(t, e.cases[i]),
            i !== r - 1); i++)
            t.push(", ");
        t.deindent(s()),
            t.push("])")
    }
}
function DX(t, e) {
    e.body ? Gu(t, e.body) : t.push("null")
}
function Gu(t, e) {
    const { helper: n } = t;
    switch (e.type) {
        case 0:
            DX(t, e);
            break;
        case 1:
            NX(t, e);
            break;
        case 2:
            OX(t, e);
            break;
        case 6:
            LX(t, e);
            break;
        case 8:
            t.push(JSON.stringify(e.value), e);
            break;
        case 7:
            t.push(JSON.stringify(e.value), e);
            break;
        case 5:
            t.push(`${n("interpolate")}(${n("list")}(${e.index}))`, e);
            break;
        case 4:
            t.push(`${n("interpolate")}(${n("named")}(${JSON.stringify(e.key)}))`, e);
            break;
        case 9:
            t.push(JSON.stringify(e.value), e);
            break;
        case 3:
            t.push(JSON.stringify(e.value), e);
            break;
        default:
            throw ah(Ke.UNHANDLED_CODEGEN_NODE_TYPE, null, {
                domain: MX,
                args: [e.type]
            })
    }
}
const BX = (t, e = {}) => {
    const n = wC(e.mode) ? e.mode : "normal"
        , s = wC(e.filename) ? e.filename : "message.intl"
        , r = !!e.sourceMap
        , i = e.breakLineCode != null ? e.breakLineCode : n === "arrow" ? ";" : `
`
        , o = e.needIndent ? e.needIndent : n !== "arrow"
        , l = t.helpers || []
        , a = PX(t, {
            mode: n,
            filename: s,
            sourceMap: r,
            breakLineCode: i,
            needIndent: o
        });
    a.push(n === "normal" ? "function __msg__ (ctx) {" : "(ctx) => {"),
        a.indent(o),
        l.length > 0 && (a.push(`const { ${VM(l.map(h => `${h}: _${h}`), ", ")} } = ctx`),
            a.newline()),
        a.push("return "),
        Gu(a, t),
        a.deindent(o),
        a.push("}"),
        delete t.helpers;
    const { code: c, map: u } = a.context();
    return {
        ast: t,
        code: c,
        map: u ? u.toJSON() : void 0
    }
}
    ;
function FX(t, e = {}) {
    const n = UM({}, e)
        , s = !!n.jit
        , r = !!n.minify
        , i = n.optimize == null ? !0 : n.optimize
        , l = CX(n).parse(t);
    return s ? (i && kX(l),
        r && Fc(l),
    {
        ast: l,
        code: ""
    }) : (AX(l, n),
        BX(l, n))
}
/*!
  * core-base v9.13.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
function $X() {
    typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (po().__INTLIFY_PROD_DEVTOOLS__ = !1),
        typeof __INTLIFY_JIT_COMPILATION__ != "boolean" && (po().__INTLIFY_JIT_COMPILATION__ = !1),
        typeof __INTLIFY_DROP_MESSAGE_COMPILER__ != "boolean" && (po().__INTLIFY_DROP_MESSAGE_COMPILER__ = !1)
}
const rl = [];
rl[0] = {
    w: [0],
    i: [3, 0],
    "[": [4],
    o: [7]
};
rl[1] = {
    w: [1],
    ".": [2],
    "[": [4],
    o: [7]
};
rl[2] = {
    w: [2],
    i: [3, 0],
    0: [3, 0]
};
rl[3] = {
    i: [3, 0],
    0: [3, 0],
    w: [1, 1],
    ".": [2, 1],
    "[": [4, 1],
    o: [7, 1]
};
rl[4] = {
    "'": [5, 0],
    '"': [6, 0],
    "[": [4, 2],
    "]": [1, 3],
    o: 8,
    l: [4, 0]
};
rl[5] = {
    "'": [4, 0],
    o: 8,
    l: [5, 0]
};
rl[6] = {
    '"': [4, 0],
    o: 8,
    l: [6, 0]
};
const UX = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
function VX(t) {
    return UX.test(t)
}
function GX(t) {
    const e = t.charCodeAt(0)
        , n = t.charCodeAt(t.length - 1);
    return e === n && (e === 34 || e === 39) ? t.slice(1, -1) : t
}
function HX(t) {
    if (t == null)
        return "o";
    switch (t.charCodeAt(0)) {
        case 91:
        case 93:
        case 46:
        case 34:
        case 39:
            return t;
        case 95:
        case 36:
        case 45:
            return "i";
        case 9:
        case 10:
        case 13:
        case 160:
        case 65279:
        case 8232:
        case 8233:
            return "w"
    }
    return "i"
}
function WX(t) {
    const e = t.trim();
    return t.charAt(0) === "0" && isNaN(parseInt(t)) ? !1 : VX(e) ? GX(e) : "*" + e
}
function YX(t) {
    const e = [];
    let n = -1, s = 0, r = 0, i, o, l, a, c, u, h;
    const d = [];
    d[0] = () => {
        o === void 0 ? o = l : o += l
    }
        ,
        d[1] = () => {
            o !== void 0 && (e.push(o),
                o = void 0)
        }
        ,
        d[2] = () => {
            d[0](),
                r++
        }
        ,
        d[3] = () => {
            if (r > 0)
                r--,
                    s = 4,
                    d[0]();
            else {
                if (r = 0,
                    o === void 0 || (o = WX(o),
                        o === !1))
                    return !1;
                d[1]()
            }
        }
        ;
    function f() {
        const p = t[n + 1];
        if (s === 5 && p === "'" || s === 6 && p === '"')
            return n++,
                l = "\\" + p,
                d[0](),
                !0
    }
    for (; s !== null;)
        if (n++,
            i = t[n],
            !(i === "\\" && f())) {
            if (a = HX(i),
                h = rl[s],
                c = h[a] || h.l || 8,
                c === 8 || (s = c[0],
                    c[1] !== void 0 && (u = d[c[1]],
                        u && (l = i,
                            u() === !1))))
                return;
            if (s === 7)
                return e
        }
}
const CC = new Map;
function XX(t, e) {
    return Lt(t) ? t[e] : null
}
function jX(t, e) {
    if (!Lt(t))
        return null;
    let n = CC.get(e);
    if (n || (n = YX(e),
        n && CC.set(e, n)),
        !n)
        return null;
    const s = n.length;
    let r = t
        , i = 0;
    for (; i < s;) {
        const o = r[n[i]];
        if (o === void 0 || Ht(r))
            return null;
        r = o,
            i++
    }
    return r
}
const zX = t => t
    , qX = t => ""
    , KX = "text"
    , JX = t => t.length === 0 ? "" : aX(t)
    , ZX = oX;
function IC(t, e) {
    return t = Math.abs(t),
        e === 2 ? t ? t > 1 ? 1 : 0 : 1 : t ? Math.min(t, 2) : 0
}
function QX(t) {
    const e = Mn(t.pluralIndex) ? t.pluralIndex : -1;
    return t.named && (Mn(t.named.count) || Mn(t.named.n)) ? Mn(t.named.count) ? t.named.count : Mn(t.named.n) ? t.named.n : e : e
}
function ej(t, e) {
    e.count || (e.count = t),
        e.n || (e.n = t)
}
function tj(t = {}) {
    const e = t.locale
        , n = QX(t)
        , s = Lt(t.pluralRules) && Me(e) && Ht(t.pluralRules[e]) ? t.pluralRules[e] : IC
        , r = Lt(t.pluralRules) && Me(e) && Ht(t.pluralRules[e]) ? IC : void 0
        , i = b => b[s(n, b.length, r)]
        , o = t.list || []
        , l = b => o[b]
        , a = t.named || {};
    Mn(t.pluralIndex) && ej(n, a);
    const c = b => a[b];
    function u(b) {
        const v = Ht(t.messages) ? t.messages(b) : Lt(t.messages) ? t.messages[b] : !1;
        return v || (t.parent ? t.parent.message(b) : qX)
    }
    const h = b => t.modifiers ? t.modifiers[b] : zX
        , d = tt(t.processor) && Ht(t.processor.normalize) ? t.processor.normalize : JX
        , f = tt(t.processor) && Ht(t.processor.interpolate) ? t.processor.interpolate : ZX
        , p = tt(t.processor) && Me(t.processor.type) ? t.processor.type : KX
        , g = {
            list: l,
            named: c,
            plural: i,
            linked: (b, ...v) => {
                const [_, y] = v;
                let x = "text"
                    , w = "";
                v.length === 1 ? Lt(_) ? (w = _.modifier || w,
                    x = _.type || x) : Me(_) && (w = _ || w) : v.length === 2 && (Me(_) && (w = _ || w),
                        Me(y) && (x = y || x));
                const S = u(b)(g)
                    , E = x === "vnode" && jt(S) && w ? S[0] : S;
                return w ? h(w)(E, x) : E
            }
            ,
            message: u,
            type: p,
            interpolate: f,
            normalize: d,
            values: os({}, o, a)
        };
    return g
}
let Ad = null;
function nj(t) {
    Ad = t
}
function sj(t, e, n) {
    Ad && Ad.emit("i18n:init", {
        timestamp: Date.now(),
        i18n: t,
        version: e,
        meta: n
    })
}
const rj = ij("function:translate");
function ij(t) {
    return e => Ad && Ad.emit(t, e)
}
const GM = _x.__EXTEND_POINT__
    , ml = h_(GM)
    , oj = {
        NOT_FOUND_KEY: GM,
        FALLBACK_TO_TRANSLATE: ml(),
        CANNOT_FORMAT_NUMBER: ml(),
        FALLBACK_TO_NUMBER_FORMAT: ml(),
        CANNOT_FORMAT_DATE: ml(),
        FALLBACK_TO_DATE_FORMAT: ml(),
        EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER: ml(),
        __EXTEND_POINT__: ml()
    }
    , HM = Ke.__EXTEND_POINT__
    , gl = h_(HM)
    , ei = {
        INVALID_ARGUMENT: HM,
        INVALID_DATE_ARGUMENT: gl(),
        INVALID_ISO_DATE_ARGUMENT: gl(),
        NOT_SUPPORT_NON_STRING_MESSAGE: gl(),
        NOT_SUPPORT_LOCALE_PROMISE_VALUE: gl(),
        NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: gl(),
        NOT_SUPPORT_LOCALE_TYPE: gl(),
        __EXTEND_POINT__: gl()
    };
function $i(t) {
    return ah(t, null, void 0)
}
function bx(t, e) {
    return e.locale != null ? AC(e.locale) : AC(t.locale)
}
let L0;
function AC(t) {
    if (Me(t))
        return t;
    if (Ht(t)) {
        if (t.resolvedOnce && L0 != null)
            return L0;
        if (t.constructor.name === "Function") {
            const e = t();
            if (iX(e))
                throw $i(ei.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
            return L0 = e
        } else
            throw $i(ei.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION)
    } else
        throw $i(ei.NOT_SUPPORT_LOCALE_TYPE)
}
function aj(t, e, n) {
    return [...new Set([n, ...jt(e) ? e : Lt(e) ? Object.keys(e) : Me(e) ? [e] : [n]])]
}
function WM(t, e, n) {
    const s = Me(n) ? n : Hu
        , r = t;
    r.__localeChainCache || (r.__localeChainCache = new Map);
    let i = r.__localeChainCache.get(s);
    if (!i) {
        i = [];
        let o = [n];
        for (; jt(o);)
            o = kC(i, o, e);
        const l = jt(e) || !tt(e) ? e : e.default ? e.default : null;
        o = Me(l) ? [l] : l,
            jt(o) && kC(i, o, !1),
            r.__localeChainCache.set(s, i)
    }
    return i
}
function kC(t, e, n) {
    let s = !0;
    for (let r = 0; r < e.length && pt(s); r++) {
        const i = e[r];
        Me(i) && (s = lj(t, e[r], n))
    }
    return s
}
function lj(t, e, n) {
    let s;
    const r = e.split("-");
    do {
        const i = r.join("-");
        s = cj(t, i, n),
            r.splice(-1, 1)
    } while (r.length && s === !0);
    return s
}
function cj(t, e, n) {
    let s = !1;
    if (!t.includes(e) && (s = !0,
        e)) {
        s = e[e.length - 1] !== "!";
        const r = e.replace(/!/g, "");
        t.push(r),
            (jt(n) || tt(n)) && n[r] && (s = n[r])
    }
    return s
}
const uj = "9.13.1"
    , d_ = -1
    , Hu = "en-US"
    , RC = ""
    , MC = t => `${t.charAt(0).toLocaleUpperCase()}${t.substr(1)}`;
function hj() {
    return {
        upper: (t, e) => e === "text" && Me(t) ? t.toUpperCase() : e === "vnode" && Lt(t) && "__v_isVNode" in t ? t.children.toUpperCase() : t,
        lower: (t, e) => e === "text" && Me(t) ? t.toLowerCase() : e === "vnode" && Lt(t) && "__v_isVNode" in t ? t.children.toLowerCase() : t,
        capitalize: (t, e) => e === "text" && Me(t) ? MC(t) : e === "vnode" && Lt(t) && "__v_isVNode" in t ? MC(t.children) : t
    }
}
let YM;
function PC(t) {
    YM = t
}
let XM;
function dj(t) {
    XM = t
}
let jM;
function fj(t) {
    jM = t
}
let zM = null;
const pj = t => {
    zM = t
}
    , mj = () => zM;
let qM = null;
const LC = t => {
    qM = t
}
    , gj = () => qM;
let OC = 0;
function _j(t = {}) {
    const e = Ht(t.onWarn) ? t.onWarn : lX
        , n = Me(t.version) ? t.version : uj
        , s = Me(t.locale) || Ht(t.locale) ? t.locale : Hu
        , r = Ht(s) ? Hu : s
        , i = jt(t.fallbackLocale) || tt(t.fallbackLocale) || Me(t.fallbackLocale) || t.fallbackLocale === !1 ? t.fallbackLocale : r
        , o = tt(t.messages) ? t.messages : {
            [r]: {}
        }
        , l = tt(t.datetimeFormats) ? t.datetimeFormats : {
            [r]: {}
        }
        , a = tt(t.numberFormats) ? t.numberFormats : {
            [r]: {}
        }
        , c = os({}, t.modifiers || {}, hj())
        , u = t.pluralRules || {}
        , h = Ht(t.missing) ? t.missing : null
        , d = pt(t.missingWarn) || Xa(t.missingWarn) ? t.missingWarn : !0
        , f = pt(t.fallbackWarn) || Xa(t.fallbackWarn) ? t.fallbackWarn : !0
        , p = !!t.fallbackFormat
        , m = !!t.unresolving
        , g = Ht(t.postTranslation) ? t.postTranslation : null
        , b = tt(t.processor) ? t.processor : null
        , v = pt(t.warnHtmlMessage) ? t.warnHtmlMessage : !0
        , _ = !!t.escapeParameter
        , y = Ht(t.messageCompiler) ? t.messageCompiler : YM
        , x = Ht(t.messageResolver) ? t.messageResolver : XM || XX
        , w = Ht(t.localeFallbacker) ? t.localeFallbacker : jM || aj
        , S = Lt(t.fallbackContext) ? t.fallbackContext : void 0
        , E = t
        , C = Lt(E.__datetimeFormatters) ? E.__datetimeFormatters : new Map
        , I = Lt(E.__numberFormatters) ? E.__numberFormatters : new Map
        , L = Lt(E.__meta) ? E.__meta : {};
    OC++;
    const k = {
        version: n,
        cid: OC,
        locale: s,
        fallbackLocale: i,
        messages: o,
        modifiers: c,
        pluralRules: u,
        missing: h,
        missingWarn: d,
        fallbackWarn: f,
        fallbackFormat: p,
        unresolving: m,
        postTranslation: g,
        processor: b,
        warnHtmlMessage: v,
        escapeParameter: _,
        messageCompiler: y,
        messageResolver: x,
        localeFallbacker: w,
        fallbackContext: S,
        onWarn: e,
        __meta: L
    };
    return k.datetimeFormats = l,
        k.numberFormats = a,
        k.__datetimeFormatters = C,
        k.__numberFormatters = I,
        __INTLIFY_PROD_DEVTOOLS__ && sj(k, n, L),
        k
}
function vx(t, e, n, s, r) {
    const { missing: i, onWarn: o } = t;
    if (i !== null) {
        const l = i(t, n, e, r);
        return Me(l) ? l : e
    } else
        return e
}
function Ch(t, e, n) {
    const s = t;
    s.__localeChainCache = new Map,
        t.localeFallbacker(t, n, e)
}
function yj(t, e) {
    return t === e ? !1 : t.split("-")[0] === e.split("-")[0]
}
function bj(t, e) {
    const n = e.indexOf(t);
    if (n === -1)
        return !1;
    for (let s = n + 1; s < e.length; s++)
        if (yj(t, e[s]))
            return !0;
    return !1
}
function O0(t) {
    return n => vj(n, t)
}
function vj(t, e) {
    const n = e.b || e.body;
    if ((n.t || n.type) === 1) {
        const s = n
            , r = s.c || s.cases;
        return t.plural(r.reduce((i, o) => [...i, NC(t, o)], []))
    } else
        return NC(t, n)
}
function NC(t, e) {
    const n = e.s || e.static;
    if (n)
        return t.type === "text" ? n : t.normalize([n]);
    {
        const s = (e.i || e.items).reduce((r, i) => [...r, Fy(t, i)], []);
        return t.normalize(s)
    }
}
function Fy(t, e) {
    const n = e.t || e.type;
    switch (n) {
        case 3:
            {
                const s = e;
                return s.v || s.value
            }
        case 9:
            {
                const s = e;
                return s.v || s.value
            }
        case 4:
            {
                const s = e;
                return t.interpolate(t.named(s.k || s.key))
            }
        case 5:
            {
                const s = e;
                return t.interpolate(t.list(s.i != null ? s.i : s.index))
            }
        case 6:
            {
                const s = e
                    , r = s.m || s.modifier;
                return t.linked(Fy(t, s.k || s.key), r ? Fy(t, r) : void 0, t.type)
            }
        case 7:
            {
                const s = e;
                return s.v || s.value
            }
        case 8:
            {
                const s = e;
                return s.v || s.value
            }
        default:
            throw new Error(`unhandled node type on format message part: ${n}`)
    }
}
const KM = t => t;
let eu = Object.create(null);
const Wu = t => Lt(t) && (t.t === 0 || t.type === 0) && ("b" in t || "body" in t);
function JM(t, e = {}) {
    let n = !1;
    const s = e.onError || mX;
    return e.onError = r => {
        n = !0,
            s(r)
    }
        ,
    {
        ...FX(t, e),
        detectError: n
    }
}
const xj = (t, e) => {
    if (!Me(t))
        throw $i(ei.NOT_SUPPORT_NON_STRING_MESSAGE);
    {
        pt(e.warnHtmlMessage) && e.warnHtmlMessage;
        const s = (e.onCacheKey || KM)(t)
            , r = eu[s];
        if (r)
            return r;
        const { code: i, detectError: o } = JM(t, e)
            , l = new Function(`return ${i}`)();
        return o ? l : eu[s] = l
    }
}
    ;
function wj(t, e) {
    if (__INTLIFY_JIT_COMPILATION__ && !__INTLIFY_DROP_MESSAGE_COMPILER__ && Me(t)) {
        pt(e.warnHtmlMessage) && e.warnHtmlMessage;
        const s = (e.onCacheKey || KM)(t)
            , r = eu[s];
        if (r)
            return r;
        const { ast: i, detectError: o } = JM(t, {
            ...e,
            location: !1,
            jit: !0
        })
            , l = O0(i);
        return o ? l : eu[s] = l
    } else {
        const n = t.cacheKey;
        if (n) {
            const s = eu[n];
            return s || (eu[n] = O0(t))
        } else
            return O0(t)
    }
}
const DC = () => ""
    , wr = t => Ht(t);
function BC(t, ...e) {
    const { fallbackFormat: n, postTranslation: s, unresolving: r, messageCompiler: i, fallbackLocale: o, messages: l } = t
        , [a, c] = $y(...e)
        , u = pt(c.missingWarn) ? c.missingWarn : t.missingWarn
        , h = pt(c.fallbackWarn) ? c.fallbackWarn : t.fallbackWarn
        , d = pt(c.escapeParameter) ? c.escapeParameter : t.escapeParameter
        , f = !!c.resolvedMessage
        , p = Me(c.default) || pt(c.default) ? pt(c.default) ? i ? a : () => a : c.default : n ? i ? a : () => a : ""
        , m = n || p !== ""
        , g = bx(t, c);
    d && Sj(c);
    let [b, v, _] = f ? [a, g, l[g] || {}] : ZM(t, a, g, o, h, u)
        , y = b
        , x = a;
    if (!f && !(Me(y) || Wu(y) || wr(y)) && m && (y = p,
        x = y),
        !f && (!(Me(y) || Wu(y) || wr(y)) || !Me(v)))
        return r ? d_ : a;
    let w = !1;
    const S = () => {
        w = !0
    }
        , E = wr(y) ? y : QM(t, a, v, y, x, S);
    if (w)
        return y;
    const C = Cj(t, v, _, c)
        , I = tj(C)
        , L = Ej(t, E, I)
        , k = s ? s(L, a) : L;
    if (__INTLIFY_PROD_DEVTOOLS__) {
        const R = {
            timestamp: Date.now(),
            key: Me(a) ? a : wr(y) ? y.key : "",
            locale: v || (wr(y) ? y.locale : ""),
            format: Me(y) ? y : wr(y) ? y.source : "",
            message: k
        };
        R.meta = os({}, t.__meta, mj() || {}),
            rj(R)
    }
    return k
}
function Sj(t) {
    jt(t.list) ? t.list = t.list.map(e => Me(e) ? xC(e) : e) : Lt(t.named) && Object.keys(t.named).forEach(e => {
        Me(t.named[e]) && (t.named[e] = xC(t.named[e]))
    }
    )
}
function ZM(t, e, n, s, r, i) {
    const { messages: o, onWarn: l, messageResolver: a, localeFallbacker: c } = t
        , u = c(t, s, n);
    let h = {}, d, f = null;
    const p = "translate";
    for (let m = 0; m < u.length && (d = u[m],
        h = o[d] || {},
        (f = a(h, e)) === null && (f = h[e]),
        !(Me(f) || Wu(f) || wr(f))); m++)
        if (!bj(d, u)) {
            const g = vx(t, e, d, i, p);
            g !== e && (f = g)
        }
    return [f, d, h]
}
function QM(t, e, n, s, r, i) {
    const { messageCompiler: o, warnHtmlMessage: l } = t;
    if (wr(s)) {
        const c = s;
        return c.locale = c.locale || n,
            c.key = c.key || e,
            c
    }
    if (o == null) {
        const c = () => s;
        return c.locale = n,
            c.key = e,
            c
    }
    const a = o(s, Tj(t, n, r, s, l, i));
    return a.locale = n,
        a.key = e,
        a.source = s,
        a
}
function Ej(t, e, n) {
    return e(n)
}
function $y(...t) {
    const [e, n, s] = t
        , r = {};
    if (!Me(e) && !Mn(e) && !wr(e) && !Wu(e))
        throw $i(ei.INVALID_ARGUMENT);
    const i = Mn(e) ? String(e) : (wr(e),
        e);
    return Mn(n) ? r.plural = n : Me(n) ? r.default = n : tt(n) && !u_(n) ? r.named = n : jt(n) && (r.list = n),
        Mn(s) ? r.plural = s : Me(s) ? r.default = s : tt(s) && os(r, s),
        [i, r]
}
function Tj(t, e, n, s, r, i) {
    return {
        locale: e,
        key: n,
        warnHtmlMessage: r,
        onError: o => {
            throw i && i(o),
            o
        }
        ,
        onCacheKey: o => tX(e, n, o)
    }
}
function Cj(t, e, n, s) {
    const { modifiers: r, pluralRules: i, messageResolver: o, fallbackLocale: l, fallbackWarn: a, missingWarn: c, fallbackContext: u } = t
        , d = {
            locale: e,
            modifiers: r,
            pluralRules: i,
            messages: f => {
                let p = o(n, f);
                if (p == null && u) {
                    const [, , m] = ZM(u, f, e, l, a, c);
                    p = o(m, f)
                }
                if (Me(p) || Wu(p)) {
                    let m = !1;
                    const b = QM(t, f, e, p, f, () => {
                        m = !0
                    }
                    );
                    return m ? DC : b
                } else
                    return wr(p) ? p : DC
            }
        };
    return t.processor && (d.processor = t.processor),
        s.list && (d.list = s.list),
        s.named && (d.named = s.named),
        Mn(s.plural) && (d.pluralIndex = s.plural),
        d
}
function FC(t, ...e) {
    const { datetimeFormats: n, unresolving: s, fallbackLocale: r, onWarn: i, localeFallbacker: o } = t
        , { __datetimeFormatters: l } = t
        , [a, c, u, h] = Uy(...e)
        , d = pt(u.missingWarn) ? u.missingWarn : t.missingWarn;
    pt(u.fallbackWarn) ? u.fallbackWarn : t.fallbackWarn;
    const f = !!u.part
        , p = bx(t, u)
        , m = o(t, r, p);
    if (!Me(a) || a === "")
        return new Intl.DateTimeFormat(p, h).format(c);
    let g = {}, b, v = null;
    const _ = "datetime format";
    for (let w = 0; w < m.length && (b = m[w],
        g = n[b] || {},
        v = g[a],
        !tt(v)); w++)
        vx(t, a, b, d, _);
    if (!tt(v) || !Me(b))
        return s ? d_ : a;
    let y = `${b}__${a}`;
    u_(h) || (y = `${y}__${JSON.stringify(h)}`);
    let x = l.get(y);
    return x || (x = new Intl.DateTimeFormat(b, os({}, v, h)),
        l.set(y, x)),
        f ? x.formatToParts(c) : x.format(c)
}
const eP = ["localeMatcher", "weekday", "era", "year", "month", "day", "hour", "minute", "second", "timeZoneName", "formatMatcher", "hour12", "timeZone", "dateStyle", "timeStyle", "calendar", "dayPeriod", "numberingSystem", "hourCycle", "fractionalSecondDigits"];
function Uy(...t) {
    const [e, n, s, r] = t
        , i = {};
    let o = {}, l;
    if (Me(e)) {
        const a = e.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
        if (!a)
            throw $i(ei.INVALID_ISO_DATE_ARGUMENT);
        const c = a[3] ? a[3].trim().startsWith("T") ? `${a[1].trim()}${a[3].trim()}` : `${a[1].trim()}T${a[3].trim()}` : a[1].trim();
        l = new Date(c);
        try {
            l.toISOString()
        } catch {
            throw $i(ei.INVALID_ISO_DATE_ARGUMENT)
        }
    } else if (sX(e)) {
        if (isNaN(e.getTime()))
            throw $i(ei.INVALID_DATE_ARGUMENT);
        l = e
    } else if (Mn(e))
        l = e;
    else
        throw $i(ei.INVALID_ARGUMENT);
    return Me(n) ? i.key = n : tt(n) && Object.keys(n).forEach(a => {
        eP.includes(a) ? o[a] = n[a] : i[a] = n[a]
    }
    ),
        Me(s) ? i.locale = s : tt(s) && (o = s),
        tt(r) && (o = r),
        [i.key || "", l, i, o]
}
function $C(t, e, n) {
    const s = t;
    for (const r in n) {
        const i = `${e}__${r}`;
        s.__datetimeFormatters.has(i) && s.__datetimeFormatters.delete(i)
    }
}
function UC(t, ...e) {
    const { numberFormats: n, unresolving: s, fallbackLocale: r, onWarn: i, localeFallbacker: o } = t
        , { __numberFormatters: l } = t
        , [a, c, u, h] = Vy(...e)
        , d = pt(u.missingWarn) ? u.missingWarn : t.missingWarn;
    pt(u.fallbackWarn) ? u.fallbackWarn : t.fallbackWarn;
    const f = !!u.part
        , p = bx(t, u)
        , m = o(t, r, p);
    if (!Me(a) || a === "")
        return new Intl.NumberFormat(p, h).format(c);
    let g = {}, b, v = null;
    const _ = "number format";
    for (let w = 0; w < m.length && (b = m[w],
        g = n[b] || {},
        v = g[a],
        !tt(v)); w++)
        vx(t, a, b, d, _);
    if (!tt(v) || !Me(b))
        return s ? d_ : a;
    let y = `${b}__${a}`;
    u_(h) || (y = `${y}__${JSON.stringify(h)}`);
    let x = l.get(y);
    return x || (x = new Intl.NumberFormat(b, os({}, v, h)),
        l.set(y, x)),
        f ? x.formatToParts(c) : x.format(c)
}
const tP = ["localeMatcher", "style", "currency", "currencyDisplay", "currencySign", "useGrouping", "minimumIntegerDigits", "minimumFractionDigits", "maximumFractionDigits", "minimumSignificantDigits", "maximumSignificantDigits", "compactDisplay", "notation", "signDisplay", "unit", "unitDisplay", "roundingMode", "roundingPriority", "roundingIncrement", "trailingZeroDisplay"];
function Vy(...t) {
    const [e, n, s, r] = t
        , i = {};
    let o = {};
    if (!Mn(e))
        throw $i(ei.INVALID_ARGUMENT);
    const l = e;
    return Me(n) ? i.key = n : tt(n) && Object.keys(n).forEach(a => {
        tP.includes(a) ? o[a] = n[a] : i[a] = n[a]
    }
    ),
        Me(s) ? i.locale = s : tt(s) && (o = s),
        tt(r) && (o = r),
        [i.key || "", l, i, o]
}
function VC(t, e, n) {
    const s = t;
    for (const r in n) {
        const i = `${e}__${r}`;
        s.__numberFormatters.has(i) && s.__numberFormatters.delete(i)
    }
}
$X();
/*!
  * vue-i18n v9.13.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
const Ij = "9.13.1";
function Aj() {
    typeof __VUE_I18N_FULL_INSTALL__ != "boolean" && (po().__VUE_I18N_FULL_INSTALL__ = !0),
        typeof __VUE_I18N_LEGACY_API__ != "boolean" && (po().__VUE_I18N_LEGACY_API__ = !0),
        typeof __INTLIFY_JIT_COMPILATION__ != "boolean" && (po().__INTLIFY_JIT_COMPILATION__ = !1),
        typeof __INTLIFY_DROP_MESSAGE_COMPILER__ != "boolean" && (po().__INTLIFY_DROP_MESSAGE_COMPILER__ = !1),
        typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (po().__INTLIFY_PROD_DEVTOOLS__ = !1)
}
const nP = oj.__EXTEND_POINT__
    , eo = h_(nP);
eo(),
    eo(),
    eo(),
    eo(),
    eo(),
    eo(),
    eo(),
    eo(),
    eo();
const sP = ei.__EXTEND_POINT__
    , Bs = h_(sP)
    , Dn = {
        UNEXPECTED_RETURN_TYPE: sP,
        INVALID_ARGUMENT: Bs(),
        MUST_BE_CALL_SETUP_TOP: Bs(),
        NOT_INSTALLED: Bs(),
        NOT_AVAILABLE_IN_LEGACY_MODE: Bs(),
        REQUIRED_VALUE: Bs(),
        INVALID_VALUE: Bs(),
        CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: Bs(),
        NOT_INSTALLED_WITH_PROVIDE: Bs(),
        UNEXPECTED_ERROR: Bs(),
        NOT_COMPATIBLE_LEGACY_VUE_I18N: Bs(),
        BRIDGE_SUPPORT_VUE_2_ONLY: Bs(),
        MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION: Bs(),
        NOT_AVAILABLE_COMPOSITION_IN_LEGACY: Bs(),
        __EXTEND_POINT__: Bs()
    };
function qn(t, ...e) {
    return ah(t, null, void 0)
}
const Gy = sl("__translateVNode")
    , Hy = sl("__datetimeParts")
    , Wy = sl("__numberParts")
    , rP = sl("__setPluralRules")
    , iP = sl("__injectWithOption")
    , Yy = sl("__dispose");
function kd(t) {
    if (!Lt(t))
        return t;
    for (const e in t)
        if (Pm(t, e))
            if (!e.includes("."))
                Lt(t[e]) && kd(t[e]);
            else {
                const n = e.split(".")
                    , s = n.length - 1;
                let r = t
                    , i = !1;
                for (let o = 0; o < s; o++) {
                    if (n[o] in r || (r[n[o]] = {}),
                        !Lt(r[n[o]])) {
                        i = !0;
                        break
                    }
                    r = r[n[o]]
                }
                i || (r[n[s]] = t[e],
                    delete t[e]),
                    Lt(r[n[s]]) && kd(r[n[s]])
            }
    return t
}
function f_(t, e) {
    const { messages: n, __i18n: s, messageResolver: r, flatJson: i } = e
        , o = tt(n) ? n : jt(s) ? {} : {
            [t]: {}
        };
    if (jt(s) && s.forEach(l => {
        if ("locale" in l && "resource" in l) {
            const { locale: a, resource: c } = l;
            a ? (o[a] = o[a] || {},
                Gp(c, o[a])) : Gp(c, o)
        } else
            Me(l) && Gp(JSON.parse(l), o)
    }
    ),
        r == null && i)
        for (const l in o)
            Pm(o, l) && kd(o[l]);
    return o
}
function oP(t) {
    return t.type
}
function aP(t, e, n) {
    let s = Lt(e.messages) ? e.messages : {};
    "__i18nGlobal" in n && (s = f_(t.locale.value, {
        messages: s,
        __i18n: n.__i18nGlobal
    }));
    const r = Object.keys(s);
    r.length && r.forEach(i => {
        t.mergeLocaleMessage(i, s[i])
    }
    );
    {
        if (Lt(e.datetimeFormats)) {
            const i = Object.keys(e.datetimeFormats);
            i.length && i.forEach(o => {
                t.mergeDateTimeFormat(o, e.datetimeFormats[o])
            }
            )
        }
        if (Lt(e.numberFormats)) {
            const i = Object.keys(e.numberFormats);
            i.length && i.forEach(o => {
                t.mergeNumberFormat(o, e.numberFormats[o])
            }
            )
        }
    }
}
function GC(t) {
    return G(ef, null, t, 0)
}
const HC = "__INTLIFY_META__"
    , WC = () => []
    , kj = () => !1;
let YC = 0;
function XC(t) {
    return (e, n, s, r) => t(n, s, ku() || void 0, r)
}
const Rj = () => {
    const t = ku();
    let e = null;
    return t && (e = oP(t)[HC]) ? {
        [HC]: e
    } : null
}
    ;
function xx(t = {}, e) {
    const { __root: n, __injectWithOption: s } = t
        , r = n === void 0
        , i = t.flatJson
        , o = Mm ? ke : Sv
        , l = !!t.translateExistCompatible;
    let a = pt(t.inheritLocale) ? t.inheritLocale : !0;
    const c = o(n && a ? n.locale.value : Me(t.locale) ? t.locale : Hu)
        , u = o(n && a ? n.fallbackLocale.value : Me(t.fallbackLocale) || jt(t.fallbackLocale) || tt(t.fallbackLocale) || t.fallbackLocale === !1 ? t.fallbackLocale : c.value)
        , h = o(f_(c.value, t))
        , d = o(tt(t.datetimeFormats) ? t.datetimeFormats : {
            [c.value]: {}
        })
        , f = o(tt(t.numberFormats) ? t.numberFormats : {
            [c.value]: {}
        });
    let p = n ? n.missingWarn : pt(t.missingWarn) || Xa(t.missingWarn) ? t.missingWarn : !0
        , m = n ? n.fallbackWarn : pt(t.fallbackWarn) || Xa(t.fallbackWarn) ? t.fallbackWarn : !0
        , g = n ? n.fallbackRoot : pt(t.fallbackRoot) ? t.fallbackRoot : !0
        , b = !!t.fallbackFormat
        , v = Ht(t.missing) ? t.missing : null
        , _ = Ht(t.missing) ? XC(t.missing) : null
        , y = Ht(t.postTranslation) ? t.postTranslation : null
        , x = n ? n.warnHtmlMessage : pt(t.warnHtmlMessage) ? t.warnHtmlMessage : !0
        , w = !!t.escapeParameter;
    const S = n ? n.modifiers : tt(t.modifiers) ? t.modifiers : {};
    let E = t.pluralRules || n && n.pluralRules, C;
    C = (() => {
        r && LC(null);
        const Z = {
            version: Ij,
            locale: c.value,
            fallbackLocale: u.value,
            messages: h.value,
            modifiers: S,
            pluralRules: E,
            missing: _ === null ? void 0 : _,
            missingWarn: p,
            fallbackWarn: m,
            fallbackFormat: b,
            unresolving: !0,
            postTranslation: y === null ? void 0 : y,
            warnHtmlMessage: x,
            escapeParameter: w,
            messageResolver: t.messageResolver,
            messageCompiler: t.messageCompiler,
            __meta: {
                framework: "vue"
            }
        };
        Z.datetimeFormats = d.value,
            Z.numberFormats = f.value,
            Z.__datetimeFormatters = tt(C) ? C.__datetimeFormatters : void 0,
            Z.__numberFormatters = tt(C) ? C.__numberFormatters : void 0;
        const le = _j(Z);
        return r && LC(le),
            le
    }
    )(),
        Ch(C, c.value, u.value);
    function L() {
        return [c.value, u.value, h.value, d.value, f.value]
    }
    const k = ve({
        get: () => c.value,
        set: Z => {
            c.value = Z,
                C.locale = c.value
        }
    })
        , R = ve({
            get: () => u.value,
            set: Z => {
                u.value = Z,
                    C.fallbackLocale = u.value,
                    Ch(C, c.value, Z)
            }
        })
        , U = ve(() => h.value)
        , W = ve(() => d.value)
        , H = ve(() => f.value);
    function j() {
        return Ht(y) ? y : null
    }
    function z(Z) {
        y = Z,
            C.postTranslation = Z
    }
    function ee() {
        return v
    }
    function J(Z) {
        Z !== null && (_ = XC(Z)),
            v = Z,
            C.missing = _
    }
    const Y = (Z, le, We, Xe, Ft, cs) => {
        L();
        let Zs;
        try {
            __INTLIFY_PROD_DEVTOOLS__,
                r || (C.fallbackContext = n ? gj() : void 0),
                Zs = Z(C)
        } finally {
            __INTLIFY_PROD_DEVTOOLS__,
                r || (C.fallbackContext = void 0)
        }
        if (We !== "translate exists" && Mn(Zs) && Zs === d_ || We === "translate exists" && !Zs) {
            const [Cf, Cc] = le();
            return n && g ? Xe(n) : Ft(Cf)
        } else {
            if (cs(Zs))
                return Zs;
            throw qn(Dn.UNEXPECTED_RETURN_TYPE)
        }
    }
        ;
    function ne(...Z) {
        return Y(le => Reflect.apply(BC, null, [le, ...Z]), () => $y(...Z), "translate", le => Reflect.apply(le.t, le, [...Z]), le => le, le => Me(le))
    }
    function oe(...Z) {
        const [le, We, Xe] = Z;
        if (Xe && !Lt(Xe))
            throw qn(Dn.INVALID_ARGUMENT);
        return ne(le, We, os({
            resolvedMessage: !0
        }, Xe || {}))
    }
    function ce(...Z) {
        return Y(le => Reflect.apply(FC, null, [le, ...Z]), () => Uy(...Z), "datetime format", le => Reflect.apply(le.d, le, [...Z]), () => RC, le => Me(le))
    }
    function ue(...Z) {
        return Y(le => Reflect.apply(UC, null, [le, ...Z]), () => Vy(...Z), "number format", le => Reflect.apply(le.n, le, [...Z]), () => RC, le => Me(le))
    }
    function we(Z) {
        return Z.map(le => Me(le) || Mn(le) || pt(le) ? GC(String(le)) : le)
    }
    const ge = {
        normalize: we,
        interpolate: Z => Z,
        type: "vnode"
    };
    function he(...Z) {
        return Y(le => {
            let We;
            const Xe = le;
            try {
                Xe.processor = ge,
                    We = Reflect.apply(BC, null, [Xe, ...Z])
            } finally {
                Xe.processor = null
            }
            return We
        }
            , () => $y(...Z), "translate", le => le[Gy](...Z), le => [GC(le)], le => jt(le))
    }
    function be(...Z) {
        return Y(le => Reflect.apply(UC, null, [le, ...Z]), () => Vy(...Z), "number format", le => le[Wy](...Z), WC, le => Me(le) || jt(le))
    }
    function Pe(...Z) {
        return Y(le => Reflect.apply(FC, null, [le, ...Z]), () => Uy(...Z), "datetime format", le => le[Hy](...Z), WC, le => Me(le) || jt(le))
    }
    function De(Z) {
        E = Z,
            C.pluralRules = E
    }
    function D(Z, le) {
        return Y(() => {
            if (!Z)
                return !1;
            const We = Me(le) ? le : c.value
                , Xe = ae(We)
                , Ft = C.messageResolver(Xe, Z);
            return l ? Ft != null : Wu(Ft) || wr(Ft) || Me(Ft)
        }
            , () => [Z], "translate exists", We => Reflect.apply(We.te, We, [Z, le]), kj, We => pt(We))
    }
    function M(Z) {
        let le = null;
        const We = WM(C, u.value, c.value);
        for (let Xe = 0; Xe < We.length; Xe++) {
            const Ft = h.value[We[Xe]] || {}
                , cs = C.messageResolver(Ft, Z);
            if (cs != null) {
                le = cs;
                break
            }
        }
        return le
    }
    function X(Z) {
        const le = M(Z);
        return le ?? (n ? n.tm(Z) || {} : {})
    }
    function ae(Z) {
        return h.value[Z] || {}
    }
    function ie(Z, le) {
        if (i) {
            const We = {
                [Z]: le
            };
            for (const Xe in We)
                Pm(We, Xe) && kd(We[Xe]);
            le = We[Z]
        }
        h.value[Z] = le,
            C.messages = h.value
    }
    function pe(Z, le) {
        h.value[Z] = h.value[Z] || {};
        const We = {
            [Z]: le
        };
        if (i)
            for (const Xe in We)
                Pm(We, Xe) && kd(We[Xe]);
        le = We[Z],
            Gp(le, h.value[Z]),
            C.messages = h.value
    }
    function xe(Z) {
        return d.value[Z] || {}
    }
    function P(Z, le) {
        d.value[Z] = le,
            C.datetimeFormats = d.value,
            $C(C, Z, le)
    }
    function B(Z, le) {
        d.value[Z] = os(d.value[Z] || {}, le),
            C.datetimeFormats = d.value,
            $C(C, Z, le)
    }
    function V(Z) {
        return f.value[Z] || {}
    }
    function re(Z, le) {
        f.value[Z] = le,
            C.numberFormats = f.value,
            VC(C, Z, le)
    }
    function ye(Z, le) {
        f.value[Z] = os(f.value[Z] || {}, le),
            C.numberFormats = f.value,
            VC(C, Z, le)
    }
    YC++,
        n && Mm && (Ln(n.locale, Z => {
            a && (c.value = Z,
                C.locale = Z,
                Ch(C, c.value, u.value))
        }
        ),
            Ln(n.fallbackLocale, Z => {
                a && (u.value = Z,
                    C.fallbackLocale = Z,
                    Ch(C, c.value, u.value))
            }
            ));
    const me = {
        id: YC,
        locale: k,
        fallbackLocale: R,
        get inheritLocale() {
            return a
        },
        set inheritLocale(Z) {
            a = Z,
                Z && n && (c.value = n.locale.value,
                    u.value = n.fallbackLocale.value,
                    Ch(C, c.value, u.value))
        },
        get availableLocales() {
            return Object.keys(h.value).sort()
        },
        messages: U,
        get modifiers() {
            return S
        },
        get pluralRules() {
            return E || {}
        },
        get isGlobal() {
            return r
        },
        get missingWarn() {
            return p
        },
        set missingWarn(Z) {
            p = Z,
                C.missingWarn = p
        },
        get fallbackWarn() {
            return m
        },
        set fallbackWarn(Z) {
            m = Z,
                C.fallbackWarn = m
        },
        get fallbackRoot() {
            return g
        },
        set fallbackRoot(Z) {
            g = Z
        },
        get fallbackFormat() {
            return b
        },
        set fallbackFormat(Z) {
            b = Z,
                C.fallbackFormat = b
        },
        get warnHtmlMessage() {
            return x
        },
        set warnHtmlMessage(Z) {
            x = Z,
                C.warnHtmlMessage = Z
        },
        get escapeParameter() {
            return w
        },
        set escapeParameter(Z) {
            w = Z,
                C.escapeParameter = Z
        },
        t: ne,
        getLocaleMessage: ae,
        setLocaleMessage: ie,
        mergeLocaleMessage: pe,
        getPostTranslationHandler: j,
        setPostTranslationHandler: z,
        getMissingHandler: ee,
        setMissingHandler: J,
        [rP]: De
    };
    return me.datetimeFormats = W,
        me.numberFormats = H,
        me.rt = oe,
        me.te = D,
        me.tm = X,
        me.d = ce,
        me.n = ue,
        me.getDateTimeFormat = xe,
        me.setDateTimeFormat = P,
        me.mergeDateTimeFormat = B,
        me.getNumberFormat = V,
        me.setNumberFormat = re,
        me.mergeNumberFormat = ye,
        me[iP] = s,
        me[Gy] = he,
        me[Hy] = Pe,
        me[Wy] = be,
        me
}
function Mj(t) {
    const e = Me(t.locale) ? t.locale : Hu
        , n = Me(t.fallbackLocale) || jt(t.fallbackLocale) || tt(t.fallbackLocale) || t.fallbackLocale === !1 ? t.fallbackLocale : e
        , s = Ht(t.missing) ? t.missing : void 0
        , r = pt(t.silentTranslationWarn) || Xa(t.silentTranslationWarn) ? !t.silentTranslationWarn : !0
        , i = pt(t.silentFallbackWarn) || Xa(t.silentFallbackWarn) ? !t.silentFallbackWarn : !0
        , o = pt(t.fallbackRoot) ? t.fallbackRoot : !0
        , l = !!t.formatFallbackMessages
        , a = tt(t.modifiers) ? t.modifiers : {}
        , c = t.pluralizationRules
        , u = Ht(t.postTranslation) ? t.postTranslation : void 0
        , h = Me(t.warnHtmlInMessage) ? t.warnHtmlInMessage !== "off" : !0
        , d = !!t.escapeParameterHtml
        , f = pt(t.sync) ? t.sync : !0;
    let p = t.messages;
    if (tt(t.sharedMessages)) {
        const w = t.sharedMessages;
        p = Object.keys(w).reduce((E, C) => {
            const I = E[C] || (E[C] = {});
            return os(I, w[C]),
                E
        }
            , p || {})
    }
    const { __i18n: m, __root: g, __injectWithOption: b } = t
        , v = t.datetimeFormats
        , _ = t.numberFormats
        , y = t.flatJson
        , x = t.translateExistCompatible;
    return {
        locale: e,
        fallbackLocale: n,
        messages: p,
        flatJson: y,
        datetimeFormats: v,
        numberFormats: _,
        missing: s,
        missingWarn: r,
        fallbackWarn: i,
        fallbackRoot: o,
        fallbackFormat: l,
        modifiers: a,
        pluralRules: c,
        postTranslation: u,
        warnHtmlMessage: h,
        escapeParameter: d,
        messageResolver: t.messageResolver,
        inheritLocale: f,
        translateExistCompatible: x,
        __i18n: m,
        __root: g,
        __injectWithOption: b
    }
}
function Xy(t = {}, e) {
    {
        const n = xx(Mj(t))
            , { __extender: s } = t
            , r = {
                id: n.id,
                get locale() {
                    return n.locale.value
                },
                set locale(i) {
                    n.locale.value = i
                },
                get fallbackLocale() {
                    return n.fallbackLocale.value
                },
                set fallbackLocale(i) {
                    n.fallbackLocale.value = i
                },
                get messages() {
                    return n.messages.value
                },
                get datetimeFormats() {
                    return n.datetimeFormats.value
                },
                get numberFormats() {
                    return n.numberFormats.value
                },
                get availableLocales() {
                    return n.availableLocales
                },
                get formatter() {
                    return {
                        interpolate() {
                            return []
                        }
                    }
                },
                set formatter(i) { },
                get missing() {
                    return n.getMissingHandler()
                },
                set missing(i) {
                    n.setMissingHandler(i)
                },
                get silentTranslationWarn() {
                    return pt(n.missingWarn) ? !n.missingWarn : n.missingWarn
                },
                set silentTranslationWarn(i) {
                    n.missingWarn = pt(i) ? !i : i
                },
                get silentFallbackWarn() {
                    return pt(n.fallbackWarn) ? !n.fallbackWarn : n.fallbackWarn
                },
                set silentFallbackWarn(i) {
                    n.fallbackWarn = pt(i) ? !i : i
                },
                get modifiers() {
                    return n.modifiers
                },
                get formatFallbackMessages() {
                    return n.fallbackFormat
                },
                set formatFallbackMessages(i) {
                    n.fallbackFormat = i
                },
                get postTranslation() {
                    return n.getPostTranslationHandler()
                },
                set postTranslation(i) {
                    n.setPostTranslationHandler(i)
                },
                get sync() {
                    return n.inheritLocale
                },
                set sync(i) {
                    n.inheritLocale = i
                },
                get warnHtmlInMessage() {
                    return n.warnHtmlMessage ? "warn" : "off"
                },
                set warnHtmlInMessage(i) {
                    n.warnHtmlMessage = i !== "off"
                },
                get escapeParameterHtml() {
                    return n.escapeParameter
                },
                set escapeParameterHtml(i) {
                    n.escapeParameter = i
                },
                get preserveDirectiveContent() {
                    return !0
                },
                set preserveDirectiveContent(i) { },
                get pluralizationRules() {
                    return n.pluralRules || {}
                },
                __composer: n,
                t(...i) {
                    const [o, l, a] = i
                        , c = {};
                    let u = null
                        , h = null;
                    if (!Me(o))
                        throw qn(Dn.INVALID_ARGUMENT);
                    const d = o;
                    return Me(l) ? c.locale = l : jt(l) ? u = l : tt(l) && (h = l),
                        jt(a) ? u = a : tt(a) && (h = a),
                        Reflect.apply(n.t, n, [d, u || h || {}, c])
                },
                rt(...i) {
                    return Reflect.apply(n.rt, n, [...i])
                },
                tc(...i) {
                    const [o, l, a] = i
                        , c = {
                            plural: 1
                        };
                    let u = null
                        , h = null;
                    if (!Me(o))
                        throw qn(Dn.INVALID_ARGUMENT);
                    const d = o;
                    return Me(l) ? c.locale = l : Mn(l) ? c.plural = l : jt(l) ? u = l : tt(l) && (h = l),
                        Me(a) ? c.locale = a : jt(a) ? u = a : tt(a) && (h = a),
                        Reflect.apply(n.t, n, [d, u || h || {}, c])
                },
                te(i, o) {
                    return n.te(i, o)
                },
                tm(i) {
                    return n.tm(i)
                },
                getLocaleMessage(i) {
                    return n.getLocaleMessage(i)
                },
                setLocaleMessage(i, o) {
                    n.setLocaleMessage(i, o)
                },
                mergeLocaleMessage(i, o) {
                    n.mergeLocaleMessage(i, o)
                },
                d(...i) {
                    return Reflect.apply(n.d, n, [...i])
                },
                getDateTimeFormat(i) {
                    return n.getDateTimeFormat(i)
                },
                setDateTimeFormat(i, o) {
                    n.setDateTimeFormat(i, o)
                },
                mergeDateTimeFormat(i, o) {
                    n.mergeDateTimeFormat(i, o)
                },
                n(...i) {
                    return Reflect.apply(n.n, n, [...i])
                },
                getNumberFormat(i) {
                    return n.getNumberFormat(i)
                },
                setNumberFormat(i, o) {
                    n.setNumberFormat(i, o)
                },
                mergeNumberFormat(i, o) {
                    n.mergeNumberFormat(i, o)
                },
                getChoiceIndex(i, o) {
                    return -1
                }
            };
        return r.__extender = s,
            r
    }
}
const wx = {
    tag: {
        type: [String, Object]
    },
    locale: {
        type: String
    },
    scope: {
        type: String,
        validator: t => t === "parent" || t === "global",
        default: "parent"
    },
    i18n: {
        type: Object
    }
};
function Pj({ slots: t }, e) {
    return e.length === 1 && e[0] === "default" ? (t.default ? t.default() : []).reduce((s, r) => [...s, ...r.type === Ie ? r.children : [r]], []) : e.reduce((n, s) => {
        const r = t[s];
        return r && (n[s] = r()),
            n
    }
        , {})
}
function lP(t) {
    return Ie
}
const Lj = Qa({
    name: "i18n-t",
    props: os({
        keypath: {
            type: String,
            required: !0
        },
        plural: {
            type: [Number, String],
            validator: t => Mn(t) || !isNaN(t)
        }
    }, wx),
    setup(t, e) {
        const { slots: n, attrs: s } = e
            , r = t.i18n || gt({
                useScope: t.scope,
                __useComponent: !0
            });
        return () => {
            const i = Object.keys(n).filter(h => h !== "_")
                , o = {};
            t.locale && (o.locale = t.locale),
                t.plural !== void 0 && (o.plural = Me(t.plural) ? +t.plural : t.plural);
            const l = Pj(e, i)
                , a = r[Gy](t.keypath, l, o)
                , c = os({}, s)
                , u = Me(t.tag) || Lt(t.tag) ? t.tag : lP();
            return Wi(u, c, a)
        }
    }
})
    , jC = Lj;
function Oj(t) {
    return jt(t) && !Me(t[0])
}
function cP(t, e, n, s) {
    const { slots: r, attrs: i } = e;
    return () => {
        const o = {
            part: !0
        };
        let l = {};
        t.locale && (o.locale = t.locale),
            Me(t.format) ? o.key = t.format : Lt(t.format) && (Me(t.format.key) && (o.key = t.format.key),
                l = Object.keys(t.format).reduce((d, f) => n.includes(f) ? os({}, d, {
                    [f]: t.format[f]
                }) : d, {}));
        const a = s(t.value, o, l);
        let c = [o.key];
        jt(a) ? c = a.map((d, f) => {
            const p = r[d.type]
                , m = p ? p({
                    [d.type]: d.value,
                    index: f,
                    parts: a
                }) : [d.value];
            return Oj(m) && (m[0].key = `${d.type}-${f}`),
                m
        }
        ) : Me(a) && (c = [a]);
        const u = os({}, i)
            , h = Me(t.tag) || Lt(t.tag) ? t.tag : lP();
        return Wi(h, u, c)
    }
}
const Nj = Qa({
    name: "i18n-n",
    props: os({
        value: {
            type: Number,
            required: !0
        },
        format: {
            type: [String, Object]
        }
    }, wx),
    setup(t, e) {
        const n = t.i18n || gt({
            useScope: t.scope,
            __useComponent: !0
        });
        return cP(t, e, tP, (...s) => n[Wy](...s))
    }
})
    , zC = Nj
    , Dj = Qa({
        name: "i18n-d",
        props: os({
            value: {
                type: [Number, Date],
                required: !0
            },
            format: {
                type: [String, Object]
            }
        }, wx),
        setup(t, e) {
            const n = t.i18n || gt({
                useScope: t.scope,
                __useComponent: !0
            });
            return cP(t, e, eP, (...s) => n[Hy](...s))
        }
    })
    , qC = Dj;
function Bj(t, e) {
    const n = t;
    if (t.mode === "composition")
        return n.__getInstance(e) || t.global;
    {
        const s = n.__getInstance(e);
        return s != null ? s.__composer : t.global.__composer
    }
}
function Fj(t) {
    const e = o => {
        const { instance: l, modifiers: a, value: c } = o;
        if (!l || !l.$)
            throw qn(Dn.UNEXPECTED_ERROR);
        const u = Bj(t, l.$)
            , h = KC(c);
        return [Reflect.apply(u.t, u, [...JC(h)]), u]
    }
        ;
    return {
        created: (o, l) => {
            const [a, c] = e(l);
            Mm && t.global === c && (o.__i18nWatcher = Ln(c.locale, () => {
                l.instance && l.instance.$forceUpdate()
            }
            )),
                o.__composer = c,
                o.textContent = a
        }
        ,
        unmounted: o => {
            Mm && o.__i18nWatcher && (o.__i18nWatcher(),
                o.__i18nWatcher = void 0,
                delete o.__i18nWatcher),
                o.__composer && (o.__composer = void 0,
                    delete o.__composer)
        }
        ,
        beforeUpdate: (o, { value: l }) => {
            if (o.__composer) {
                const a = o.__composer
                    , c = KC(l);
                o.textContent = Reflect.apply(a.t, a, [...JC(c)])
            }
        }
        ,
        getSSRProps: o => {
            const [l] = e(o);
            return {
                textContent: l
            }
        }
    }
}
function KC(t) {
    if (Me(t))
        return {
            path: t
        };
    if (tt(t)) {
        if (!("path" in t))
            throw qn(Dn.REQUIRED_VALUE, "path");
        return t
    } else
        throw qn(Dn.INVALID_VALUE)
}
function JC(t) {
    const { path: e, locale: n, args: s, choice: r, plural: i } = t
        , o = {}
        , l = s || {};
    return Me(n) && (o.locale = n),
        Mn(r) && (o.plural = r),
        Mn(i) && (o.plural = i),
        [e, l, o]
}
function $j(t, e, ...n) {
    const s = tt(n[0]) ? n[0] : {}
        , r = !!s.useI18nComponentName;
    (pt(s.globalInstall) ? s.globalInstall : !0) && ([r ? "i18n" : jC.name, "I18nT"].forEach(o => t.component(o, jC)),
        [zC.name, "I18nN"].forEach(o => t.component(o, zC)),
        [qC.name, "I18nD"].forEach(o => t.component(o, qC))),
        t.directive("t", Fj(e))
}
function Uj(t, e, n) {
    return {
        beforeCreate() {
            const s = ku();
            if (!s)
                throw qn(Dn.UNEXPECTED_ERROR);
            const r = this.$options;
            if (r.i18n) {
                const i = r.i18n;
                if (r.__i18n && (i.__i18n = r.__i18n),
                    i.__root = e,
                    this === this.$root)
                    this.$i18n = ZC(t, i);
                else {
                    i.__injectWithOption = !0,
                        i.__extender = n.__vueI18nExtend,
                        this.$i18n = Xy(i);
                    const o = this.$i18n;
                    o.__extender && (o.__disposer = o.__extender(this.$i18n))
                }
            } else if (r.__i18n)
                if (this === this.$root)
                    this.$i18n = ZC(t, r);
                else {
                    this.$i18n = Xy({
                        __i18n: r.__i18n,
                        __injectWithOption: !0,
                        __extender: n.__vueI18nExtend,
                        __root: e
                    });
                    const i = this.$i18n;
                    i.__extender && (i.__disposer = i.__extender(this.$i18n))
                }
            else
                this.$i18n = t;
            r.__i18nGlobal && aP(e, r, r),
                this.$t = (...i) => this.$i18n.t(...i),
                this.$rt = (...i) => this.$i18n.rt(...i),
                this.$tc = (...i) => this.$i18n.tc(...i),
                this.$te = (i, o) => this.$i18n.te(i, o),
                this.$d = (...i) => this.$i18n.d(...i),
                this.$n = (...i) => this.$i18n.n(...i),
                this.$tm = i => this.$i18n.tm(i),
                n.__setInstance(s, this.$i18n)
        },
        mounted() { },
        unmounted() {
            const s = ku();
            if (!s)
                throw qn(Dn.UNEXPECTED_ERROR);
            const r = this.$i18n;
            delete this.$t,
                delete this.$rt,
                delete this.$tc,
                delete this.$te,
                delete this.$d,
                delete this.$n,
                delete this.$tm,
                r.__disposer && (r.__disposer(),
                    delete r.__disposer,
                    delete r.__extender),
                n.__deleteInstance(s),
                delete this.$i18n
        }
    }
}
function ZC(t, e) {
    t.locale = e.locale || t.locale,
        t.fallbackLocale = e.fallbackLocale || t.fallbackLocale,
        t.missing = e.missing || t.missing,
        t.silentTranslationWarn = e.silentTranslationWarn || t.silentFallbackWarn,
        t.silentFallbackWarn = e.silentFallbackWarn || t.silentFallbackWarn,
        t.formatFallbackMessages = e.formatFallbackMessages || t.formatFallbackMessages,
        t.postTranslation = e.postTranslation || t.postTranslation,
        t.warnHtmlInMessage = e.warnHtmlInMessage || t.warnHtmlInMessage,
        t.escapeParameterHtml = e.escapeParameterHtml || t.escapeParameterHtml,
        t.sync = e.sync || t.sync,
        t.__composer[rP](e.pluralizationRules || t.pluralizationRules);
    const n = f_(t.locale, {
        messages: e.messages,
        __i18n: e.__i18n
    });
    return Object.keys(n).forEach(s => t.mergeLocaleMessage(s, n[s])),
        e.datetimeFormats && Object.keys(e.datetimeFormats).forEach(s => t.mergeDateTimeFormat(s, e.datetimeFormats[s])),
        e.numberFormats && Object.keys(e.numberFormats).forEach(s => t.mergeNumberFormat(s, e.numberFormats[s])),
        t
}
const Vj = sl("global-vue-i18n");
function Gj(t = {}, e) {
    const n = __VUE_I18N_LEGACY_API__ && pt(t.legacy) ? t.legacy : __VUE_I18N_LEGACY_API__
        , s = pt(t.globalInjection) ? t.globalInjection : !0
        , r = __VUE_I18N_LEGACY_API__ && n ? !!t.allowComposition : !0
        , i = new Map
        , [o, l] = Hj(t, n)
        , a = sl("");
    function c(d) {
        return i.get(d) || null
    }
    function u(d, f) {
        i.set(d, f)
    }
    function h(d) {
        i.delete(d)
    }
    {
        const d = {
            get mode() {
                return __VUE_I18N_LEGACY_API__ && n ? "legacy" : "composition"
            },
            get allowComposition() {
                return r
            },
            async install(f, ...p) {
                if (f.__VUE_I18N_SYMBOL__ = a,
                    f.provide(f.__VUE_I18N_SYMBOL__, d),
                    tt(p[0])) {
                    const b = p[0];
                    d.__composerExtend = b.__composerExtend,
                        d.__vueI18nExtend = b.__vueI18nExtend
                }
                let m = null;
                !n && s && (m = Zj(f, d.global)),
                    __VUE_I18N_FULL_INSTALL__ && $j(f, d, ...p),
                    __VUE_I18N_LEGACY_API__ && n && f.mixin(Uj(l, l.__composer, d));
                const g = f.unmount;
                f.unmount = () => {
                    m && m(),
                        d.dispose(),
                        g()
                }
            },
            get global() {
                return l
            },
            dispose() {
                o.stop()
            },
            __instances: i,
            __getInstance: c,
            __setInstance: u,
            __deleteInstance: h
        };
        return d
    }
}
function gt(t = {}) {
    const e = ku();
    if (e == null)
        throw qn(Dn.MUST_BE_CALL_SETUP_TOP);
    if (!e.isCE && e.appContext.app != null && !e.appContext.app.__VUE_I18N_SYMBOL__)
        throw qn(Dn.NOT_INSTALLED);
    const n = Wj(e)
        , s = Xj(n)
        , r = oP(e)
        , i = Yj(t, r);
    if (__VUE_I18N_LEGACY_API__ && n.mode === "legacy" && !t.__useComponent) {
        if (!n.allowComposition)
            throw qn(Dn.NOT_AVAILABLE_IN_LEGACY_MODE);
        return Kj(e, i, s, t)
    }
    if (i === "global")
        return aP(s, t, r),
            s;
    if (i === "parent") {
        let a = jj(n, e, t.__useComponent);
        return a == null && (a = s),
            a
    }
    const o = n;
    let l = o.__getInstance(e);
    if (l == null) {
        const a = os({}, t);
        "__i18n" in r && (a.__i18n = r.__i18n),
            s && (a.__root = s),
            l = xx(a),
            o.__composerExtend && (l[Yy] = o.__composerExtend(l)),
            qj(o, e, l),
            o.__setInstance(e, l)
    }
    return l
}
function Hj(t, e, n) {
    const s = mv();
    {
        const r = __VUE_I18N_LEGACY_API__ && e ? s.run(() => Xy(t)) : s.run(() => xx(t));
        if (r == null)
            throw qn(Dn.UNEXPECTED_ERROR);
        return [s, r]
    }
}
function Wj(t) {
    {
        const e = Ar(t.isCE ? Vj : t.appContext.app.__VUE_I18N_SYMBOL__);
        if (!e)
            throw qn(t.isCE ? Dn.NOT_INSTALLED_WITH_PROVIDE : Dn.UNEXPECTED_ERROR);
        return e
    }
}
function Yj(t, e) {
    return u_(t) ? "__i18n" in e ? "local" : "global" : t.useScope ? t.useScope : "local"
}
function Xj(t) {
    return t.mode === "composition" ? t.global : t.global.__composer
}
function jj(t, e, n = !1) {
    let s = null;
    const r = e.root;
    let i = zj(e, n);
    for (; i != null;) {
        const o = t;
        if (t.mode === "composition")
            s = o.__getInstance(i);
        else if (__VUE_I18N_LEGACY_API__) {
            const l = o.__getInstance(i);
            l != null && (s = l.__composer,
                n && s && !s[iP] && (s = null))
        }
        if (s != null || r === i)
            break;
        i = i.parent
    }
    return s
}
function zj(t, e = !1) {
    return t == null ? null : e && t.vnode.ctx || t.parent
}
function qj(t, e, n) {
    Or(() => { }
        , e),
        Qd(() => {
            const s = n;
            t.__deleteInstance(e);
            const r = s[Yy];
            r && (r(),
                delete s[Yy])
        }
            , e)
}
function Kj(t, e, n, s = {}) {
    const r = e === "local"
        , i = Sv(null);
    if (r && t.proxy && !(t.proxy.$options.i18n || t.proxy.$options.__i18n))
        throw qn(Dn.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION);
    const o = pt(s.inheritLocale) ? s.inheritLocale : !Me(s.locale)
        , l = ke(!r || o ? n.locale.value : Me(s.locale) ? s.locale : Hu)
        , a = ke(!r || o ? n.fallbackLocale.value : Me(s.fallbackLocale) || jt(s.fallbackLocale) || tt(s.fallbackLocale) || s.fallbackLocale === !1 ? s.fallbackLocale : l.value)
        , c = ke(f_(l.value, s))
        , u = ke(tt(s.datetimeFormats) ? s.datetimeFormats : {
            [l.value]: {}
        })
        , h = ke(tt(s.numberFormats) ? s.numberFormats : {
            [l.value]: {}
        })
        , d = r ? n.missingWarn : pt(s.missingWarn) || Xa(s.missingWarn) ? s.missingWarn : !0
        , f = r ? n.fallbackWarn : pt(s.fallbackWarn) || Xa(s.fallbackWarn) ? s.fallbackWarn : !0
        , p = r ? n.fallbackRoot : pt(s.fallbackRoot) ? s.fallbackRoot : !0
        , m = !!s.fallbackFormat
        , g = Ht(s.missing) ? s.missing : null
        , b = Ht(s.postTranslation) ? s.postTranslation : null
        , v = r ? n.warnHtmlMessage : pt(s.warnHtmlMessage) ? s.warnHtmlMessage : !0
        , _ = !!s.escapeParameter
        , y = r ? n.modifiers : tt(s.modifiers) ? s.modifiers : {}
        , x = s.pluralRules || r && n.pluralRules;
    function w() {
        return [l.value, a.value, c.value, u.value, h.value]
    }
    const S = ve({
        get: () => i.value ? i.value.locale.value : l.value,
        set: M => {
            i.value && (i.value.locale.value = M),
                l.value = M
        }
    })
        , E = ve({
            get: () => i.value ? i.value.fallbackLocale.value : a.value,
            set: M => {
                i.value && (i.value.fallbackLocale.value = M),
                    a.value = M
            }
        })
        , C = ve(() => i.value ? i.value.messages.value : c.value)
        , I = ve(() => u.value)
        , L = ve(() => h.value);
    function k() {
        return i.value ? i.value.getPostTranslationHandler() : b
    }
    function R(M) {
        i.value && i.value.setPostTranslationHandler(M)
    }
    function U() {
        return i.value ? i.value.getMissingHandler() : g
    }
    function W(M) {
        i.value && i.value.setMissingHandler(M)
    }
    function H(M) {
        return w(),
            M()
    }
    function j(...M) {
        return i.value ? H(() => Reflect.apply(i.value.t, null, [...M])) : H(() => "")
    }
    function z(...M) {
        return i.value ? Reflect.apply(i.value.rt, null, [...M]) : ""
    }
    function ee(...M) {
        return i.value ? H(() => Reflect.apply(i.value.d, null, [...M])) : H(() => "")
    }
    function J(...M) {
        return i.value ? H(() => Reflect.apply(i.value.n, null, [...M])) : H(() => "")
    }
    function Y(M) {
        return i.value ? i.value.tm(M) : {}
    }
    function ne(M, X) {
        return i.value ? i.value.te(M, X) : !1
    }
    function oe(M) {
        return i.value ? i.value.getLocaleMessage(M) : {}
    }
    function ce(M, X) {
        i.value && (i.value.setLocaleMessage(M, X),
            c.value[M] = X)
    }
    function ue(M, X) {
        i.value && i.value.mergeLocaleMessage(M, X)
    }
    function we(M) {
        return i.value ? i.value.getDateTimeFormat(M) : {}
    }
    function K(M, X) {
        i.value && (i.value.setDateTimeFormat(M, X),
            u.value[M] = X)
    }
    function ge(M, X) {
        i.value && i.value.mergeDateTimeFormat(M, X)
    }
    function he(M) {
        return i.value ? i.value.getNumberFormat(M) : {}
    }
    function be(M, X) {
        i.value && (i.value.setNumberFormat(M, X),
            h.value[M] = X)
    }
    function Pe(M, X) {
        i.value && i.value.mergeNumberFormat(M, X)
    }
    const De = {
        get id() {
            return i.value ? i.value.id : -1
        },
        locale: S,
        fallbackLocale: E,
        messages: C,
        datetimeFormats: I,
        numberFormats: L,
        get inheritLocale() {
            return i.value ? i.value.inheritLocale : o
        },
        set inheritLocale(M) {
            i.value && (i.value.inheritLocale = M)
        },
        get availableLocales() {
            return i.value ? i.value.availableLocales : Object.keys(c.value)
        },
        get modifiers() {
            return i.value ? i.value.modifiers : y
        },
        get pluralRules() {
            return i.value ? i.value.pluralRules : x
        },
        get isGlobal() {
            return i.value ? i.value.isGlobal : !1
        },
        get missingWarn() {
            return i.value ? i.value.missingWarn : d
        },
        set missingWarn(M) {
            i.value && (i.value.missingWarn = M)
        },
        get fallbackWarn() {
            return i.value ? i.value.fallbackWarn : f
        },
        set fallbackWarn(M) {
            i.value && (i.value.missingWarn = M)
        },
        get fallbackRoot() {
            return i.value ? i.value.fallbackRoot : p
        },
        set fallbackRoot(M) {
            i.value && (i.value.fallbackRoot = M)
        },
        get fallbackFormat() {
            return i.value ? i.value.fallbackFormat : m
        },
        set fallbackFormat(M) {
            i.value && (i.value.fallbackFormat = M)
        },
        get warnHtmlMessage() {
            return i.value ? i.value.warnHtmlMessage : v
        },
        set warnHtmlMessage(M) {
            i.value && (i.value.warnHtmlMessage = M)
        },
        get escapeParameter() {
            return i.value ? i.value.escapeParameter : _
        },
        set escapeParameter(M) {
            i.value && (i.value.escapeParameter = M)
        },
        t: j,
        getPostTranslationHandler: k,
        setPostTranslationHandler: R,
        getMissingHandler: U,
        setMissingHandler: W,
        rt: z,
        d: ee,
        n: J,
        tm: Y,
        te: ne,
        getLocaleMessage: oe,
        setLocaleMessage: ce,
        mergeLocaleMessage: ue,
        getDateTimeFormat: we,
        setDateTimeFormat: K,
        mergeDateTimeFormat: ge,
        getNumberFormat: he,
        setNumberFormat: be,
        mergeNumberFormat: Pe
    };
    function D(M) {
        M.locale.value = l.value,
            M.fallbackLocale.value = a.value,
            Object.keys(c.value).forEach(X => {
                M.mergeLocaleMessage(X, c.value[X])
            }
            ),
            Object.keys(u.value).forEach(X => {
                M.mergeDateTimeFormat(X, u.value[X])
            }
            ),
            Object.keys(h.value).forEach(X => {
                M.mergeNumberFormat(X, h.value[X])
            }
            ),
            M.escapeParameter = _,
            M.fallbackFormat = m,
            M.fallbackRoot = p,
            M.fallbackWarn = f,
            M.missingWarn = d,
            M.warnHtmlMessage = v
    }
    return E3(() => {
        if (t.proxy == null || t.proxy.$i18n == null)
            throw qn(Dn.NOT_AVAILABLE_COMPOSITION_IN_LEGACY);
        const M = i.value = t.proxy.$i18n.__composer;
        e === "global" ? (l.value = M.locale.value,
            a.value = M.fallbackLocale.value,
            c.value = M.messages.value,
            u.value = M.datetimeFormats.value,
            h.value = M.numberFormats.value) : r && D(M)
    }
    ),
        De
}
const Jj = ["locale", "fallbackLocale", "availableLocales"]
    , QC = ["t", "rt", "d", "n", "tm", "te"];
function Zj(t, e) {
    const n = Object.create(null);
    return Jj.forEach(r => {
        const i = Object.getOwnPropertyDescriptor(e, r);
        if (!i)
            throw qn(Dn.UNEXPECTED_ERROR);
        const o = Tn(i.value) ? {
            get() {
                return i.value.value
            },
            set(l) {
                i.value.value = l
            }
        } : {
            get() {
                return i.get && i.get()
            }
        };
        Object.defineProperty(n, r, o)
    }
    ),
        t.config.globalProperties.$i18n = n,
        QC.forEach(r => {
            const i = Object.getOwnPropertyDescriptor(e, r);
            if (!i || !i.value)
                throw qn(Dn.UNEXPECTED_ERROR);
            Object.defineProperty(t.config.globalProperties, `$${r}`, i)
        }
        ),
        () => {
            delete t.config.globalProperties.$i18n,
                QC.forEach(r => {
                    delete t.config.globalProperties[`$${r}`]
                }
                )
        }
}
Aj();
__INTLIFY_JIT_COMPILATION__ ? PC(wj) : PC(xj);
dj(jX);
fj(WM);
if (__INTLIFY_PROD_DEVTOOLS__) {
    const t = po();
    t.__INTLIFY__ = !0,
        nj(t.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__)
}
const uP = "@firebase/installations"
    , Sx = "0.6.8";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const hP = 1e4
    , dP = `w:${Sx}`
    , fP = "FIS_v2"
    , Qj = "https://firebaseinstallations.googleapis.com/v1"
    , ez = 60 * 60 * 1e3
    , tz = "installations"
    , nz = "Installations";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const sz = {
    "missing-app-config-values": 'Missing App configuration value: "{$valueName}"',
    "not-registered": "Firebase Installation is not registered.",
    "installation-not-found": "Firebase Installation not found.",
    "request-failed": '{$requestName} request failed with error "{$serverCode} {$serverStatus}: {$serverMessage}"',
    "app-offline": "Could not process request. Application offline.",
    "delete-pending-registration": "Can't delete installation while there is a pending registration request."
}
    , tc = new fc(tz, nz, sz);
function pP(t) {
    return t instanceof fi && t.code.includes("request-failed")
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function mP({ projectId: t }) {
    return `${Qj}/projects/${t}/installations`
}
function gP(t) {
    return {
        token: t.token,
        requestStatus: 2,
        expiresIn: iz(t.expiresIn),
        creationTime: Date.now()
    }
}
async function _P(t, e) {
    const s = (await e.json()).error;
    return tc.create("request-failed", {
        requestName: t,
        serverCode: s.code,
        serverMessage: s.message,
        serverStatus: s.status
    })
}
function yP({ apiKey: t }) {
    return new Headers({
        "Content-Type": "application/json",
        Accept: "application/json",
        "x-goog-api-key": t
    })
}
function rz(t, { refreshToken: e }) {
    const n = yP(t);
    return n.append("Authorization", oz(e)),
        n
}
async function bP(t) {
    const e = await t();
    return e.status >= 500 && e.status < 600 ? t() : e
}
function iz(t) {
    return Number(t.replace("s", "000"))
}
function oz(t) {
    return `${fP} ${t}`
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function az({ appConfig: t, heartbeatServiceProvider: e }, { fid: n }) {
    const s = mP(t)
        , r = yP(t)
        , i = e.getImmediate({
            optional: !0
        });
    if (i) {
        const c = await i.getHeartbeatsHeader();
        c && r.append("x-firebase-client", c)
    }
    const o = {
        fid: n,
        authVersion: fP,
        appId: t.appId,
        sdkVersion: dP
    }
        , l = {
            method: "POST",
            headers: r,
            body: JSON.stringify(o)
        }
        , a = await bP(() => fetch(s, l));
    if (a.ok) {
        const c = await a.json();
        return {
            fid: c.fid || n,
            registrationStatus: 2,
            refreshToken: c.refreshToken,
            authToken: gP(c.authToken)
        }
    } else
        throw await _P("Create Installation", a)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function vP(t) {
    return new Promise(e => {
        setTimeout(e, t)
    }
    )
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function lz(t) {
    return btoa(String.fromCharCode(...t)).replace(/\+/g, "-").replace(/\//g, "_")
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const cz = /^[cdef][\w-]{21}$/
    , jy = "";
function uz() {
    try {
        const t = new Uint8Array(17);
        (self.crypto || self.msCrypto).getRandomValues(t),
            t[0] = 112 + t[0] % 16;
        const n = hz(t);
        return cz.test(n) ? n : jy
    } catch {
        return jy
    }
}
function hz(t) {
    return lz(t).substr(0, 22)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function p_(t) {
    return `${t.appName}!${t.appId}`
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const xP = new Map;
function wP(t, e) {
    const n = p_(t);
    SP(n, e),
        dz(n, e)
}
function SP(t, e) {
    const n = xP.get(t);
    if (n)
        for (const s of n)
            s(e)
}
function dz(t, e) {
    const n = fz();
    n && n.postMessage({
        key: t,
        fid: e
    }),
        pz()
}
let Ol = null;
function fz() {
    return !Ol && "BroadcastChannel" in self && (Ol = new BroadcastChannel("[Firebase] FID Change"),
        Ol.onmessage = t => {
            SP(t.data.key, t.data.fid)
        }
    ),
        Ol
}
function pz() {
    xP.size === 0 && Ol && (Ol.close(),
        Ol = null)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const mz = "firebase-installations-database"
    , gz = 1
    , nc = "firebase-installations-store";
let N0 = null;
function Ex() {
    return N0 || (N0 = fk(mz, gz, {
        upgrade: (t, e) => {
            switch (e) {
                case 0:
                    t.createObjectStore(nc)
            }
        }
    })),
        N0
}
async function Om(t, e) {
    const n = p_(t)
        , r = (await Ex()).transaction(nc, "readwrite")
        , i = r.objectStore(nc)
        , o = await i.get(n);
    return await i.put(e, n),
        await r.done,
        (!o || o.fid !== e.fid) && wP(t, e.fid),
        e
}
async function EP(t) {
    const e = p_(t)
        , s = (await Ex()).transaction(nc, "readwrite");
    await s.objectStore(nc).delete(e),
        await s.done
}
async function m_(t, e) {
    const n = p_(t)
        , r = (await Ex()).transaction(nc, "readwrite")
        , i = r.objectStore(nc)
        , o = await i.get(n)
        , l = e(o);
    return l === void 0 ? await i.delete(n) : await i.put(l, n),
        await r.done,
        l && (!o || o.fid !== l.fid) && wP(t, l.fid),
        l
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function Tx(t) {
    let e;
    const n = await m_(t.appConfig, s => {
        const r = _z(s)
            , i = yz(t, r);
        return e = i.registrationPromise,
            i.installationEntry
    }
    );
    return n.fid === jy ? {
        installationEntry: await e
    } : {
        installationEntry: n,
        registrationPromise: e
    }
}
function _z(t) {
    const e = t || {
        fid: uz(),
        registrationStatus: 0
    };
    return TP(e)
}
function yz(t, e) {
    if (e.registrationStatus === 0) {
        if (!navigator.onLine) {
            const r = Promise.reject(tc.create("app-offline"));
            return {
                installationEntry: e,
                registrationPromise: r
            }
        }
        const n = {
            fid: e.fid,
            registrationStatus: 1,
            registrationTime: Date.now()
        }
            , s = bz(t, n);
        return {
            installationEntry: n,
            registrationPromise: s
        }
    } else
        return e.registrationStatus === 1 ? {
            installationEntry: e,
            registrationPromise: vz(t)
        } : {
            installationEntry: e
        }
}
async function bz(t, e) {
    try {
        const n = await az(t, e);
        return Om(t.appConfig, n)
    } catch (n) {
        throw pP(n) && n.customData.serverCode === 409 ? await EP(t.appConfig) : await Om(t.appConfig, {
            fid: e.fid,
            registrationStatus: 0
        }),
        n
    }
}
async function vz(t) {
    let e = await e2(t.appConfig);
    for (; e.registrationStatus === 1;)
        await vP(100),
            e = await e2(t.appConfig);
    if (e.registrationStatus === 0) {
        const { installationEntry: n, registrationPromise: s } = await Tx(t);
        return s || n
    }
    return e
}
function e2(t) {
    return m_(t, e => {
        if (!e)
            throw tc.create("installation-not-found");
        return TP(e)
    }
    )
}
function TP(t) {
    return xz(t) ? {
        fid: t.fid,
        registrationStatus: 0
    } : t
}
function xz(t) {
    return t.registrationStatus === 1 && t.registrationTime + hP < Date.now()
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function wz({ appConfig: t, heartbeatServiceProvider: e }, n) {
    const s = Sz(t, n)
        , r = rz(t, n)
        , i = e.getImmediate({
            optional: !0
        });
    if (i) {
        const c = await i.getHeartbeatsHeader();
        c && r.append("x-firebase-client", c)
    }
    const o = {
        installation: {
            sdkVersion: dP,
            appId: t.appId
        }
    }
        , l = {
            method: "POST",
            headers: r,
            body: JSON.stringify(o)
        }
        , a = await bP(() => fetch(s, l));
    if (a.ok) {
        const c = await a.json();
        return gP(c)
    } else
        throw await _P("Generate Auth Token", a)
}
function Sz(t, { fid: e }) {
    return `${mP(t)}/${e}/authTokens:generate`
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function Cx(t, e = !1) {
    let n;
    const s = await m_(t.appConfig, i => {
        if (!CP(i))
            throw tc.create("not-registered");
        const o = i.authToken;
        if (!e && Cz(o))
            return i;
        if (o.requestStatus === 1)
            return n = Ez(t, e),
                i;
        {
            if (!navigator.onLine)
                throw tc.create("app-offline");
            const l = Az(i);
            return n = Tz(t, l),
                l
        }
    }
    );
    return n ? await n : s.authToken
}
async function Ez(t, e) {
    let n = await t2(t.appConfig);
    for (; n.authToken.requestStatus === 1;)
        await vP(100),
            n = await t2(t.appConfig);
    const s = n.authToken;
    return s.requestStatus === 0 ? Cx(t, e) : s
}
function t2(t) {
    return m_(t, e => {
        if (!CP(e))
            throw tc.create("not-registered");
        const n = e.authToken;
        return kz(n) ? Object.assign(Object.assign({}, e), {
            authToken: {
                requestStatus: 0
            }
        }) : e
    }
    )
}
async function Tz(t, e) {
    try {
        const n = await wz(t, e)
            , s = Object.assign(Object.assign({}, e), {
                authToken: n
            });
        return await Om(t.appConfig, s),
            n
    } catch (n) {
        if (pP(n) && (n.customData.serverCode === 401 || n.customData.serverCode === 404))
            await EP(t.appConfig);
        else {
            const s = Object.assign(Object.assign({}, e), {
                authToken: {
                    requestStatus: 0
                }
            });
            await Om(t.appConfig, s)
        }
        throw n
    }
}
function CP(t) {
    return t !== void 0 && t.registrationStatus === 2
}
function Cz(t) {
    return t.requestStatus === 2 && !Iz(t)
}
function Iz(t) {
    const e = Date.now();
    return e < t.creationTime || t.creationTime + t.expiresIn < e + ez
}
function Az(t) {
    const e = {
        requestStatus: 1,
        requestTime: Date.now()
    };
    return Object.assign(Object.assign({}, t), {
        authToken: e
    })
}
function kz(t) {
    return t.requestStatus === 1 && t.requestTime + hP < Date.now()
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function Rz(t) {
    const e = t
        , { installationEntry: n, registrationPromise: s } = await Tx(e);
    return s ? s.catch(console.error) : Cx(e).catch(console.error),
        n.fid
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function Mz(t, e = !1) {
    const n = t;
    return await Pz(n),
        (await Cx(n, e)).token
}
async function Pz(t) {
    const { registrationPromise: e } = await Tx(t);
    e && await e
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Lz(t) {
    if (!t || !t.options)
        throw D0("App Configuration");
    if (!t.name)
        throw D0("App Name");
    const e = ["projectId", "apiKey", "appId"];
    for (const n of e)
        if (!t.options[n])
            throw D0(n);
    return {
        appName: t.name,
        projectId: t.options.projectId,
        apiKey: t.options.apiKey,
        appId: t.options.appId
    }
}
function D0(t) {
    return tc.create("missing-app-config-values", {
        valueName: t
    })
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const IP = "installations"
    , Oz = "installations-internal"
    , Nz = t => {
        const e = t.getProvider("app").getImmediate()
            , n = Lz(e)
            , s = pc(e, "heartbeat");
        return {
            app: e,
            appConfig: n,
            heartbeatServiceProvider: s,
            _delete: () => Promise.resolve()
        }
    }
    , Dz = t => {
        const e = t.getProvider("app").getImmediate()
            , n = pc(e, IP).getImmediate();
        return {
            getId: () => Rz(n),
            getToken: r => Mz(n, r)
        }
    }
    ;
function Bz() {
    Yi(new ai(IP, Nz, "PUBLIC")),
        Yi(new ai(Oz, Dz, "PRIVATE"))
}
Bz();
kr(uP, Sx);
kr(uP, Sx, "esm2017");
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Nm = "analytics"
    , Fz = "firebase_id"
    , $z = "origin"
    , Uz = 60 * 1e3
    , Vz = "https://firebase.googleapis.com/v1alpha/projects/-/apps/{app-id}/webConfig"
    , Ix = "https://www.googletagmanager.com/gtag/js";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Rs = new Ov("@firebase/analytics");
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Gz = {
    "already-exists": "A Firebase Analytics instance with the appId {$id}  already exists. Only one Firebase Analytics instance can be created for each appId.",
    "already-initialized": "initializeAnalytics() cannot be called again with different options than those it was initially called with. It can be called again with the same options to return the existing instance, or getAnalytics() can be used to get a reference to the already-initialized instance.",
    "already-initialized-settings": "Firebase Analytics has already been initialized.settings() must be called before initializing any Analytics instanceor it will have no effect.",
    "interop-component-reg-failed": "Firebase Analytics Interop Component failed to instantiate: {$reason}",
    "invalid-analytics-context": "Firebase Analytics is not supported in this environment. Wrap initialization of analytics in analytics.isSupported() to prevent initialization in unsupported environments. Details: {$errorInfo}",
    "indexeddb-unavailable": "IndexedDB unavailable or restricted in this environment. Wrap initialization of analytics in analytics.isSupported() to prevent initialization in unsupported environments. Details: {$errorInfo}",
    "fetch-throttle": "The config fetch request timed out while in an exponential backoff state. Unix timestamp in milliseconds when fetch request throttling ends: {$throttleEndTimeMillis}.",
    "config-fetch-failed": "Dynamic config fetch failed: [{$httpStatus}] {$responseMessage}",
    "no-api-key": 'The "apiKey" field is empty in the local Firebase config. Firebase Analytics requires this field tocontain a valid API key.',
    "no-app-id": 'The "appId" field is empty in the local Firebase config. Firebase Analytics requires this field tocontain a valid app ID.',
    "no-client-id": 'The "client_id" field is empty.',
    "invalid-gtag-resource": "Trusted Types detected an invalid gtag resource: {$gtagURL}."
}
    , cr = new fc("analytics", "Analytics", Gz);
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Hz(t) {
    if (!t.startsWith(Ix)) {
        const e = cr.create("invalid-gtag-resource", {
            gtagURL: t
        });
        return Rs.warn(e.message),
            ""
    }
    return t
}
function AP(t) {
    return Promise.all(t.map(e => e.catch(n => n)))
}
function Wz(t, e) {
    let n;
    return window.trustedTypes && (n = window.trustedTypes.createPolicy(t, e)),
        n
}
function Yz(t, e) {
    const n = Wz("firebase-js-sdk-policy", {
        createScriptURL: Hz
    })
        , s = document.createElement("script")
        , r = `${Ix}?l=${t}&id=${e}`;
    s.src = n ? n == null ? void 0 : n.createScriptURL(r) : r,
        s.async = !0,
        document.head.appendChild(s)
}
function Xz(t) {
    let e = [];
    return Array.isArray(window[t]) ? e = window[t] : window[t] = e,
        e
}
async function jz(t, e, n, s, r, i) {
    const o = s[r];
    try {
        if (o)
            await e[o];
        else {
            const a = (await AP(n)).find(c => c.measurementId === r);
            a && await e[a.appId]
        }
    } catch (l) {
        Rs.error(l)
    }
    t("config", r, i)
}
async function zz(t, e, n, s, r) {
    try {
        let i = [];
        if (r && r.send_to) {
            let o = r.send_to;
            Array.isArray(o) || (o = [o]);
            const l = await AP(n);
            for (const a of o) {
                const c = l.find(h => h.measurementId === a)
                    , u = c && e[c.appId];
                if (u)
                    i.push(u);
                else {
                    i = [];
                    break
                }
            }
        }
        i.length === 0 && (i = Object.values(e)),
            await Promise.all(i),
            t("event", s, r || {})
    } catch (i) {
        Rs.error(i)
    }
}
function qz(t, e, n, s) {
    async function r(i, ...o) {
        try {
            if (i === "event") {
                const [l, a] = o;
                await zz(t, e, n, l, a)
            } else if (i === "config") {
                const [l, a] = o;
                await jz(t, e, n, s, l, a)
            } else if (i === "consent") {
                const [l, a] = o;
                t("consent", l, a)
            } else if (i === "get") {
                const [l, a, c] = o;
                t("get", l, a, c)
            } else if (i === "set") {
                const [l] = o;
                t("set", l)
            } else
                t(i, ...o)
        } catch (l) {
            Rs.error(l)
        }
    }
    return r
}
function Kz(t, e, n, s, r) {
    let i = function (...o) {
        window[s].push(arguments)
    };
    return window[r] && typeof window[r] == "function" && (i = window[r]),
        window[r] = qz(i, t, e, n),
    {
        gtagCore: i,
        wrappedGtag: window[r]
    }
}
function Jz(t) {
    const e = window.document.getElementsByTagName("script");
    for (const n of Object.values(e))
        if (n.src && n.src.includes(Ix) && n.src.includes(t))
            return n;
    return null
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Zz = 30
    , Qz = 1e3;
class eq {
    constructor(e = {}, n = Qz) {
        this.throttleMetadata = e,
            this.intervalMillis = n
    }
    getThrottleMetadata(e) {
        return this.throttleMetadata[e]
    }
    setThrottleMetadata(e, n) {
        this.throttleMetadata[e] = n
    }
    deleteThrottleMetadata(e) {
        delete this.throttleMetadata[e]
    }
}
const kP = new eq;
function tq(t) {
    return new Headers({
        Accept: "application/json",
        "x-goog-api-key": t
    })
}
async function nq(t) {
    var e;
    const { appId: n, apiKey: s } = t
        , r = {
            method: "GET",
            headers: tq(s)
        }
        , i = Vz.replace("{app-id}", n)
        , o = await fetch(i, r);
    if (o.status !== 200 && o.status !== 304) {
        let l = "";
        try {
            const a = await o.json();
            !((e = a.error) === null || e === void 0) && e.message && (l = a.error.message)
        } catch { }
        throw cr.create("config-fetch-failed", {
            httpStatus: o.status,
            responseMessage: l
        })
    }
    return o.json()
}
async function sq(t, e = kP, n) {
    const { appId: s, apiKey: r, measurementId: i } = t.options;
    if (!s)
        throw cr.create("no-app-id");
    if (!r) {
        if (i)
            return {
                measurementId: i,
                appId: s
            };
        throw cr.create("no-api-key")
    }
    const o = e.getThrottleMetadata(s) || {
        backoffCount: 0,
        throttleEndTimeMillis: Date.now()
    }
        , l = new oq;
    return setTimeout(async () => {
        l.abort()
    }
        , Uz),
        RP({
            appId: s,
            apiKey: r,
            measurementId: i
        }, o, l, e)
}
async function RP(t, { throttleEndTimeMillis: e, backoffCount: n }, s, r = kP) {
    var i;
    const { appId: o, measurementId: l } = t;
    try {
        await rq(s, e)
    } catch (a) {
        if (l)
            return Rs.warn(`Timed out fetching this Firebase app's measurement ID from the server. Falling back to the measurement ID ${l} provided in the "measurementId" field in the local Firebase config. [${a == null ? void 0 : a.message}]`),
            {
                appId: o,
                measurementId: l
            };
        throw a
    }
    try {
        const a = await nq(t);
        return r.deleteThrottleMetadata(o),
            a
    } catch (a) {
        const c = a;
        if (!iq(c)) {
            if (r.deleteThrottleMetadata(o),
                l)
                return Rs.warn(`Failed to fetch this Firebase app's measurement ID from the server. Falling back to the measurement ID ${l} provided in the "measurementId" field in the local Firebase config. [${c == null ? void 0 : c.message}]`),
                {
                    appId: o,
                    measurementId: l
                };
            throw a
        }
        const u = Number((i = c == null ? void 0 : c.customData) === null || i === void 0 ? void 0 : i.httpStatus) === 503 ? LE(n, r.intervalMillis, Zz) : LE(n, r.intervalMillis)
            , h = {
                throttleEndTimeMillis: Date.now() + u,
                backoffCount: n + 1
            };
        return r.setThrottleMetadata(o, h),
            Rs.debug(`Calling attemptFetch again in ${u} millis`),
            RP(t, h, s, r)
    }
}
function rq(t, e) {
    return new Promise((n, s) => {
        const r = Math.max(e - Date.now(), 0)
            , i = setTimeout(n, r);
        t.addEventListener(() => {
            clearTimeout(i),
                s(cr.create("fetch-throttle", {
                    throttleEndTimeMillis: e
                }))
        }
        )
    }
    )
}
function iq(t) {
    if (!(t instanceof fi) || !t.customData)
        return !1;
    const e = Number(t.customData.httpStatus);
    return e === 429 || e === 500 || e === 503 || e === 504
}
class oq {
    constructor() {
        this.listeners = []
    }
    addEventListener(e) {
        this.listeners.push(e)
    }
    abort() {
        this.listeners.forEach(e => e())
    }
}
async function aq(t, e, n, s, r) {
    if (r && r.global) {
        t("event", n, s);
        return
    } else {
        const i = await e
            , o = Object.assign(Object.assign({}, s), {
                send_to: i
            });
        t("event", n, o)
    }
}
async function lq(t, e, n, s) {
    {
        const r = await e;
        t("config", r, {
            update: !0,
            user_id: n
        })
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function cq() {
    if (ck())
        try {
            await uk()
        } catch (t) {
            return Rs.warn(cr.create("indexeddb-unavailable", {
                errorInfo: t == null ? void 0 : t.toString()
            }).message),
                !1
        }
    else
        return Rs.warn(cr.create("indexeddb-unavailable", {
            errorInfo: "IndexedDB is not available in this environment."
        }).message),
            !1;
    return !0
}
async function uq(t, e, n, s, r, i, o) {
    var l;
    const a = sq(t);
    a.then(f => {
        n[f.measurementId] = f.appId,
            t.options.measurementId && f.measurementId !== t.options.measurementId && Rs.warn(`The measurement ID in the local Firebase config (${t.options.measurementId}) does not match the measurement ID fetched from the server (${f.measurementId}). To ensure analytics events are always sent to the correct Analytics property, update the measurement ID field in the local config or remove it from the local config.`)
    }
    ).catch(f => Rs.error(f)),
        e.push(a);
    const c = cq().then(f => {
        if (f)
            return s.getId()
    }
    )
        , [u, h] = await Promise.all([a, c]);
    Jz(i) || Yz(i, u.measurementId),
        r("js", new Date);
    const d = (l = o == null ? void 0 : o.config) !== null && l !== void 0 ? l : {};
    return d[$z] = "firebase",
        d.update = !0,
        h != null && (d[Fz] = h),
        r("config", u.measurementId, d),
        u.measurementId
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class hq {
    constructor(e) {
        this.app = e
    }
    _delete() {
        return delete mu[this.app.options.appId],
            Promise.resolve()
    }
}
let mu = {}
    , n2 = [];
const s2 = {};
let B0 = "dataLayer", dq = "gtag", r2, Ax, i2 = !1;
function fq() {
    const t = [];
    if (lk() && t.push("This is a browser extension environment."),
        hD() || t.push("Cookies are not available."),
        t.length > 0) {
        const e = t.map((s, r) => `(${r + 1}) ${s}`).join(" ")
            , n = cr.create("invalid-analytics-context", {
                errorInfo: e
            });
        Rs.warn(n.message)
    }
}
function pq(t, e, n) {
    fq();
    const s = t.options.appId;
    if (!s)
        throw cr.create("no-app-id");
    if (!t.options.apiKey)
        if (t.options.measurementId)
            Rs.warn(`The "apiKey" field is empty in the local Firebase config. This is needed to fetch the latest measurement ID for this Firebase app. Falling back to the measurement ID ${t.options.measurementId} provided in the "measurementId" field in the local Firebase config.`);
        else
            throw cr.create("no-api-key");
    if (mu[s] != null)
        throw cr.create("already-exists", {
            id: s
        });
    if (!i2) {
        Xz(B0);
        const { wrappedGtag: i, gtagCore: o } = Kz(mu, n2, s2, B0, dq);
        Ax = i,
            r2 = o,
            i2 = !0
    }
    return mu[s] = uq(t, n2, s2, e, r2, B0, n),
        new hq(t)
}
function mq(t = Dv()) {
    t = Dr(t);
    const e = pc(t, Nm);
    return e.isInitialized() ? e.getImmediate() : gq(t)
}
function gq(t, e = {}) {
    const n = pc(t, Nm);
    if (n.isInitialized()) {
        const r = n.getImmediate();
        if (yd(e, n.getOptions()))
            return r;
        throw cr.create("already-initialized")
    }
    return n.initialize({
        options: e
    })
}
function _q(t, e, n) {
    t = Dr(t),
        lq(Ax, mu[t.app.options.appId], e).catch(s => Rs.error(s))
}
function ra(t, e, n, s) {
    t = Dr(t),
        aq(Ax, mu[t.app.options.appId], e, n, s).catch(r => Rs.error(r))
}
const o2 = "@firebase/analytics"
    , a2 = "0.10.7";
function yq() {
    Yi(new ai(Nm, (e, { options: n }) => {
        const s = e.getProvider("app").getImmediate()
            , r = e.getProvider("installations-internal").getImmediate();
        return pq(s, r, n)
    }
        , "PUBLIC")),
        Yi(new ai("analytics-internal", t, "PRIVATE")),
        kr(o2, a2),
        kr(o2, a2, "esm2017");
    function t(e) {
        try {
            const n = e.getProvider(Nm).getImmediate();
            return {
                logEvent: (s, r, i) => ra(n, s, r, i)
            }
        } catch (n) {
            throw cr.create("interop-component-reg-failed", {
                reason: n
            })
        }
    }
}
yq();
const Fn = Ds("analytics", {
    state: () => ({
        analytics: null
    }),
    actions: {
        initializeAnalytics(t) {
            this.analytics = mq(t)
        },
        setUserId(t) {
            _q(this.analytics, t)
        },
        earn(t, e = "coin") {
            ra(this.analytics, "earn_virtual_currency", {
                virtual_currency_name: e,
                value: t
            })
        },
        spend(t, e, n = "coin") {
            ra(this.analytics, "spend_virtual_currency", {
                virtual_currency_name: n,
                value: t,
                item_name: e
            })
        },
        beginOnboarding() {
            ra(this.analytics, "tutorial_begin")
        },
        finishOnboarding() {
            ra(this.analytics, "tutorial_complete")
        },
        levelUp(t, e) {
            ra(this.analytics, "level_up", {
                level: e,
                character: t
            })
        },
        share(t) {
            ra(this.analytics, "share", {
                method: "Telegram",
                content_type: t
            })
        },
        logEvent(t, e = null) {
            ra(this.analytics, t, e)
        }
    }
});
var ns = (t => (t.PROFIT = "profit",
    t.ENERGY = "energy",
    t))(ns || {});
const Xs = Ds("boosts", {
    state: () => ({
        config: {},
        showBoostsOverlay: !1,
        ownedBoosts: {
            profit: {
                common: 0,
                epic: 0,
                legendary: 0,
                rare: 0
            },
            energy: {
                common: 0,
                epic: 0,
                legendary: 0,
                rare: 0
            }
        }
    }),
    getters: {
        profitBoosts(t) {
            return Object.entries(t.config.profit).map(([e, n]) => ({
                ...n,
                type: "profit",
                tier: e,
                amount: t.ownedBoosts.profit[e]
            })).sort((e, n) => e.bonus - n.bonus)
        },
        energyBoosts(t) {
            return Object.entries(t.config.energy).map(([e, n]) => ({
                ...n,
                type: "energy",
                tier: e,
                amount: t.ownedBoosts.energy[e]
            })).sort((e, n) => e.bonus - n.bonus)
        },
        getBoost: t => (e, n) => {
            var s;
            return (s = t.config[e]) == null ? void 0 : s[n]
        }
        ,
        getEnergyBoostsWithStatus(t) {
            const { t: e } = gt();
            return n => t.energyBoosts.map(s => {
                let r = !1
                    , i = "";
                return s.amount ? n && n.tier !== s.tier && (r = !0,
                    i = e("boosts.disabled_reason.another_boost_active")) : (r = !0,
                        i = e("boosts.disabled_reason.no_boost_amount")),
                {
                    ...s,
                    startTime: n && n.tier === s.tier ? n.timestamp : 0,
                    endTime: n && n.tier === s.tier ? n.end_timestamp : 0,
                    isDisabled: r,
                    disabledReason: i
                }
            }
            )
        },
        getProfitBoostsWithStatus(t) {
            const { t: e } = gt();
            return n => t.profitBoosts.map(s => {
                let r = !1
                    , i = "";
                return s.amount ? n && n.tier !== s.tier ? (r = !0,
                    i = e("boosts.disabled_reason.another_boost_active")) : n && n.tier === s.tier && n.end_timestamp + s.duration > Bo() + s.max_duration && (r = !0,
                        i = e("boosts.disabled_reason.max_duration_reached")) : (r = !0,
                            i = e("boosts.disabled_reason.no_boost_amount")),
                {
                    ...s,
                    startTime: n && n.tier === s.tier ? n.timestamp : 0,
                    endTime: n && n.tier === s.tier ? n.end_timestamp : 0,
                    isDisabled: r,
                    disabledReason: i
                }
            }
            )
        }
    },
    actions: {
        setConfig(t) {
            this.config = t
        },
        setOwnedBoosts(t) {
            this.ownedBoosts = t
        },
        decrementOwnedBoost(t) {
            this.ownedBoosts[t.type][t.tier]--
        },
        async consumeBoost(t, e) {
            const n = Ye();
            this.decrementOwnedBoost(t),
                await Ls({
                    action: async () => Bn(n.telegramAppFunctions, "consume_boost_call")({
                        type: t.type,
                        tier: t.tier,
                        girl_id: e
                    }),
                    onSuccess: s => {
                        n.setUserData(s.data.user),
                            Fn().logEvent("consume_boost", {
                                type: t.type,
                                tier: t.tier
                            }),
                            mi().showSuccessToast("toast_messages.consume_boost")
                    }
                })
        },
        setShowBoostsOverlay(t) {
            this.showBoostsOverlay = t
        }
    }
})
    , id = (t, e) => {
        const n = e ?? Bo();
        return !!t && t.end_timestamp > n
    }
    , bq = (t, e, n) => {
        const s = DM(t, 0)
            , r = id(t.boosts[ns.PROFIT]) ? t.boosts[ns.PROFIT] : null
            , i = s * 3600
            , o = r && e ? e[r.tier].bonus : 1
            , l = n ? n + 1 : 1
            , a = i * o * l
            , c = a - i;
        return {
            perHour: Math.round(a),
            basePerHour: Math.round(i),
            bonusPerHour: Math.round(c)
        }
    }
    , g_ = async (t, e) => {
        var r;
        const n = Ye();
        n.setShowLoadingOverlay(!0);
        const s = await Ls({
            action: async () => Bn(n.telegramAppFunctions, "create_invoice_link_call")({
                item_type: t,
                item_id: e,
                env: "prod"
            }),
            onSuccess: () => { }
            ,
            onError: i => {
                console.error("Error in GetInvoice:", i.message)
            }
        });
        return n.setShowLoadingOverlay(!1),
            (r = s.data) == null ? void 0 : r.invoice_link
    }
    , Fo = Ds("slots", {
        state: () => ({
            isBuySlotModalVisible: !1,
            currentSlots: 0,
            slotsConfig: null
        }),
        getters: {
            unlockPrice(t) {
                var e;
                return t.hasMaxSlots ? null : ((e = t.slotsConfig) == null ? void 0 : e.slotPrices[t.currentSlots + 1]) ?? 0
            },
            hasMaxSlots(t) {
                var e;
                return t.currentSlots === ((e = t.slotsConfig) == null ? void 0 : e.maxSlotsNumber)
            }
        },
        actions: {
            showBuySlotModal() {
                this.slotsConfig && this.currentSlots < this.slotsConfig.maxSlotsNumber && (this.isBuySlotModalVisible = !0)
            },
            hideBuySlotModal() {
                this.isBuySlotModalVisible = !1
            },
            setCurrentSlots(t) {
                this.currentSlots = t
            },
            setSlotsConfig(t) {
                this.slotsConfig = t
            },
            async unlockSlot() {
                const t = await g_("girl_slot");
                try {
                    window.Telegram.WebApp.openInvoice(t, e => {
                        e === "paid" && (this.currentSlots++,
                            this.hideBuySlotModal(),
                            Fn().logEvent("unlock_slot", {
                                slot_number: this.currentSlots
                            }),
                            mi().showSuccessToast("toast_messages.unlock_slot"))
                    }
                    )
                } catch (e) {
                    console.error("Error opening Chips invoice link:", t, e)
                }
            }
        }
    })
    , si = Ds("timer", {
        state: () => ({
            currentTime: Date.now(),
            cooldowns: {}
        }),
        getters: {
            unixTime() {
                return Bo(this.currentTime)
            }
        },
        actions: {
            startGlobalTimer() {
                this._interval || (this._interval = setInterval(() => {
                    this.currentTime = Date.now(),
                        this.updateCooldowns()
                }
                    , 1e3))
            },
            stopGlobalTimer() {
                this._interval && (clearInterval(this._interval),
                    this._interval = null)
            },
            updateCooldowns() {
                Object.keys(this.cooldowns).forEach(t => {
                    const e = this.cooldowns[t];
                    e.endTime <= this.currentTime ? (e.isActive = !1,
                        delete this.cooldowns[t]) : e.remainingTime = Math.max(Math.floor(e.endTime - this.currentTime), 0)
                }
                )
            },
            addCooldown(t, e) {
                Object.keys(this.cooldowns).length === 0 && this.startGlobalTimer(),
                    this.cooldowns[t] = {
                        isActive: !0,
                        endTime: e,
                        remainingTime: Math.max(Math.floor(e - this.currentTime), 0)
                    }
            },
            getRemainingTime(t) {
                var e;
                return ((e = this.cooldowns[t]) == null ? void 0 : e.remainingTime) || 0
            },
            getUnixRemainingTime(t) {
                return Bo(this.getRemainingTime(t))
            },
            removeCooldown(t) {
                delete this.cooldowns[t],
                    Object.keys(this.cooldowns).length === 0 && this.stopGlobalTimer()
            }
        }
    })
    , ls = Ds("girls", {
        state: () => ({
            data: [],
            selectedGirlId: null
        }),
        getters: {
            slots() {
                return Fo().currentSlots
            },
            maxSlots() {
                var e;
                return ((e = Fo().slotsConfig) == null ? void 0 : e.maxSlotsNumber) || 0
            },
            girls(t) {
                const e = Ye()
                    , n = Xs();
                return t.data.filter(s => By[s.skin]).map(s => {
                    const r = By[s.skin]
                        , i = DM(s, e.profitBonus)
                        , o = eX(s, e.capacityBonus)
                        , l = bq(s, n.config.profit, e.profitBonus);
                    return {
                        ...s,
                        ...o,
                        ...l,
                        path: r.path,
                        poses: r.poses,
                        posesNum: Object.keys(r.poses).length,
                        activePose: s.active_pose,
                        rate: i
                    }
                }
                )
            },
            selectedGirlBoosts(t) {
                const e = Xs()
                    , n = si()
                    , s = t.getGirlById(t.selectedGirlId);
                return Object.entries((s == null ? void 0 : s.boosts) || {}).filter(([, r]) => id(r, n.unixTime)).map(([r, i]) => ({
                    ...i,
                    ...e.getBoost(r, i.tier),
                    type: r
                }))
            },
            energyBoostsForSelectedGirl(t) {
                const e = Xs()
                    , n = si()
                    , s = t.getGirlById(t.selectedGirlId)
                    , r = id(s.boosts[ns.ENERGY], n.unixTime) ? s.boosts[ns.ENERGY] : null;
                return e.getEnergyBoostsWithStatus(r)
            },
            profitBoostsForSelectedGirl(t) {
                const e = Xs()
                    , n = si()
                    , s = t.getGirlById(t.selectedGirlId)
                    , r = id(s.boosts[ns.PROFIT], n.unixTime) ? s.boosts[ns.PROFIT] : null;
                return e.getProfitBoostsWithStatus(r)
            },
            getGirlById: t => e => t.girls.find(n => n.id === e),
            selectedGirl(t) {
                return t.getGirlById(t.selectedGirlId)
            },
            getGirlBySlot: t => e => t.girls.find(n => n.slot === e),
            girlsInSlots(t) {
                var e;
                return (e = t.girls) == null ? void 0 : e.filter(n => n.slot != null).sort((n, s) => n.slot - s.slot)
            },
            emptySlots(t) {
                var e;
                return Math.max(t.slots - ((e = t.girlsInSlots) == null ? void 0 : e.length), 0)
            },
            lockedSlots(t) {
                return Math.max(t.maxSlots - t.slots, 0)
            },
            slotsByGirlIndexMap(t) {
                const e = Object.assign({}, Array(t.maxSlots).fill(null));
                return t.data.forEach((n, s) => {
                    n.slot !== null && (e[n.slot] = s)
                }
                ),
                    e
            }
        },
        actions: {
            setSlots(t) {
                this.slots = t
            },
            setGirls(t) {
                this.data = t
            },
            setSelectedGirlId(t) {
                this.selectedGirlId = t
            },
            equipGirl(t) {
                let e = this.girlsInSlots.length;
                if (this.emptySlots === 0) {
                    e = 0;
                    const n = this.girlsInSlots[e];
                    this.updateGirl(n == null ? void 0 : n.id, {
                        slot: null
                    }),
                        this.selectedGirlId === (n == null ? void 0 : n.id) && this.updateSelectedGirlId(t)
                }
                this.updateGirl(t, {
                    slot: e
                }),
                    this.selectedGirlId == null && this.updateSelectedGirlId(t)
            },
            unequipGirl(t) {
                var n, s;
                const e = (n = this.getGirlById(t)) == null ? void 0 : n.slot;
                this.updateGirl(t, {
                    slot: null
                }),
                    this.data = this.data.map(r => r.slot !== null && r.slot > e ? {
                        ...r,
                        slot: r.slot - 1
                    } : r),
                    this.selectedGirlId === t && this.updateSelectedGirlId((s = this.girlsInSlots[0]) == null ? void 0 : s.id)
            },
            removeEnergyBoostCooldown(t) {
                const e = this.getGirlById(t)
                    , n = {
                        ...(e == null ? void 0 : e.boosts) || {}
                    };
                delete n[ns.ENERGY],
                    this.updateGirl(t, {
                        boosts: n
                    })
            },
            updateGirl(t, e) {
                this.data = this.data.map(n => n.id === t ? {
                    ...n,
                    ...e
                } : n)
            },
            async updateGirlRequest(t, e) {
                const n = Ye()
                    , s = [...this.data];
                this.updateGirl(t, e),
                    await Ls({
                        action: async () => Bn(n.telegramAppFunctions, "update_girl_call")({
                            girl: {
                                id: t,
                                ...e
                            }
                        }),
                        onError: () => {
                            this.data = s
                        }
                    })
            },
            updateSelectedGirlId(t) {
                const e = Ye();
                return this.setSelectedGirlId(t),
                    Ls({
                        action: async () => Bn(e.telegramAppFunctions, "update_selected_girl_id_call")({
                            selected_girl_id: t
                        })
                    })
            }
        }
    })
    , F0 = (t, e, n = !1) => {
        if (e <= 0)
            return 0;
        const s = t.starting_effect_base * e + t.starting_effect_base * e / 11;
        return t.effect_type == "percentage" && !n ? Math.round(s * 100) / 100 : s
    }
    , js = {
        EN: "en",
        KP: "kp",
        RU: "ru"
    }
    , vq = t => t.replace(/_([a-z])/g, (e, n) => n.toUpperCase())
    , _o = t => Array.isArray(t) ? t.map(e => _o(e)) : t !== null && typeof t == "object" ? Object.entries(t).reduce((e, [n, s]) => (e[vq(n)] = _o(s),
        e), {}) : t
    , Qf = {
        COIN: Uu.COIN,
        STAR: Uu.STAR,
        REFERRAL: "referral",
        STARTER: "starter"
    }
    , ji = Ds("lootboxes", {
        state: () => ({
            ownedTypes: {},
            newLootboxes: {},
            lootboxes: {}
        }),
        getters: {
            ownedLootboxes(t) {
                return t.allLootboxes.flatMap(e => {
                    const n = t.ownedTypes[e.type] || 0
                        , s = t.newLootboxes[e.type] || 0;
                    return Array.from({
                        length: n
                    }, (r, i) => ({
                        ...e,
                        isNew: i < s
                    }))
                }
                ).map(e => ({
                    ...e,
                    disabled: !1
                }))
            },
            baseLootboxes() {
                const t = Ye();
                return Object.values(this.lootboxes).filter(e => e.group === Qf.COIN).sort((e, n) => e.price - n.price).map(e => ({
                    ...e,
                    disabled: t.balance < e.price
                }))
            },
            vipLootboxes() {
                return Object.values(this.lootboxes).filter(t => t.group === Qf.STAR).sort((t, e) => t.price - e.price)
            },
            referralLootboxes() {
                return Object.values(this.lootboxes).filter(t => t.group === Qf.REFERRAL)
            },
            starterLootboxes() {
                return Object.values(this.lootboxes).filter(t => t.group === Qf.STARTER)
            },
            allLootboxes(t) {
                return [...t.starterLootboxes, ...t.baseLootboxes, ...t.vipLootboxes, ...t.referralLootboxes]
            },
            getLootboxByType(t) {
                return e => t.allLootboxes.find(n => n.type === e)
            },
            hasNewLootboxes(t) {
                return Object.values(t.newLootboxes).some(e => e > 0)
            }
        },
        actions: {
            setOwned(t) {
                const e = {
                    ...this.ownedTypes
                };
                if (this.ownedTypes = t,
                    Object.keys(e).length !== 0 && Object.keys(t).length > 0) {
                    const n = {};
                    Object.keys(t).forEach(s => {
                        t[s] !== e[s] && (n[s] = t[s] - (e[s] || 0))
                    }
                    ),
                        this.applyNewLootboxes(n)
                }
            },
            setLootboxes(t) {
                const e = {};
                for (const n in t)
                    if (t.hasOwnProperty(n)) {
                        const s = _o(t[n]);
                        Array.isArray(s.drops) && s.drops.forEach(r => {
                            r.type === "girl" && r.girl && (r.girl.path = By[r.girl.skin].path)
                        }
                        ),
                            s.image = `/shop/lootbox-${s.type}.webp`,
                            e[n] = s
                    }
                this.lootboxes = e
            },
            incrementLootbox(t) {
                this.ownedTypes[t] === void 0 && (this.ownedTypes[t] = 0),
                    this.ownedTypes[t] += 1
            },
            decrementLootbox(t) {
                this.ownedTypes[t] -= 1
            },
            async purchaseLootbox(t) {
                const e = Ye();
                this.incrementLootbox(t),
                    await Ls({
                        action: async () => Bn(e.telegramAppFunctions, "purchase_lootbox_call")({
                            type: t
                        }),
                        onSuccess: n => {
                            e.setUserData(n.data.user)
                        }
                    })
            },
            async openLootbox(t) {
                var s, r;
                const e = Ye();
                this.decrementLootbox(t);
                const n = await Ls({
                    action: async () => Bn(e.telegramAppFunctions, "open_lootbox_call")({
                        type: t
                    }),
                    onSuccess: i => {
                        e.setUserData(i.data.user)
                    }
                });
                return (r = (s = n == null ? void 0 : n.data) == null ? void 0 : s.items) == null ? void 0 : r.flatMap(i => {
                    if (i.type === "coins")
                        return i;
                    const o = i.amount || 1;
                    return Array.from({
                        length: o
                    }, () => {
                        const { amount: l, ...a } = i;
                        return a
                    }
                    )
                }
                )
            },
            applyNewLootboxes(t) {
                Object.keys(t).forEach(e => {
                    this.newLootboxes[e] || (this.newLootboxes[e] = 0),
                        this.newLootboxes[e] += t[e]
                }
                )
            },
            decrementNewLootboxes(t) {
                this.newLootboxes[t]--
            },
            resetNewLootboxes() {
                this.newLootboxes = {}
            }
        }
    })
    , kx = Ds("referral", {
        state: () => ({
            invitedUsers: [],
            invitedByUsername: null,
            currentUserId: null,
            isLoading: !1,
            bonus: {
                coins: 0,
                standardLootboxes: 0,
                bonusStandardLootboxes: 0
            }
        }),
        actions: {
            setBonus(t, e, n) {
                this.bonus = {
                    coins: parseInt(t),
                    standardLootboxes: parseInt(e),
                    bonusStandardLootboxes: parseInt(n)
                }
            },
            async fetchReferralData() {
                const t = await Ye();
                this.isLoading = !0;
                const { data: e } = await Ls({
                    action: async () => Bn(t.telegramAppFunctions, "fetch_referral_data_call")()
                });
                (e == null ? void 0 : e.invited_users.length) > 0 && (this.invitedUsers = _o(e.invited_users)),
                    e != null && e.referral_bonus && this.setBonus(e.referral_bonus.coins, e.referral_bonus.standard_lootboxes, e.referral_bonus.premium_lootboxes),
                    this.invitedByUsername = e == null ? void 0 : e.invited_by_username,
                    this.currentUserId = e == null ? void 0 : e.current_user_id,
                    this.isLoading = !1
            },
            async claimRewards() {
                const t = await Ye()
                    , { data: e } = await Ls({
                        action: async () => Bn(t.telegramAppFunctions, "claim_referral_rewards_call")()
                    });
                e != null && e.user && t.setUserData(e.user)
            }
        }
    })
    , Ye = Ds("global", {
        state: () => ({
            isDevMode: !1,
            balance: 0,
            baseSlapPower: 25,
            realBalance: null,
            isBalanceAnimated: !1,
            energyLeftAmount: null,
            energyMaxAmount: 1e4,
            energyLeftIncrementAmount: 100,
            globalBackground: null,
            routeBackground: null,
            globalAnimation: null,
            userData: {},
            userId: null,
            webApp: null,
            telegramApp: null,
            telegramAppFunctions: null,
            isTelegramInited: !1,
            mainMenuHasNotification: !1,
            leftBalance: null,
            errorModal: {
                isVisible: !1
            },
            modal: {
                isVisible: !1,
                hasConfirmation: !1,
                message: "",
                callback: null,
                image: null,
                closeLabel: null,
                confirmLabel: null
            },
            intervalForBalance: null,
            isNewUser: !1,
            upgradeCards: [],
            collections: [],
            currentLocale: js.EN,
            gifts: {},
            ui: {
                showLoadingOverlay: !1
            },
            isGiftActivated: !1
        }),
        getters: {
            balanceFormatted: t => {
                if (t.balance === null)
                    return "";
                let e = t.balance.toString().replace(/\B(?=(\d{3})+(?!\d))/g, " ");
                return e = e.split(".")[0],
                    e
            }
            ,
            upgradeCardsGroupedBySection: t => {
                var n;
                const e = ((n = t.upgradeCardsWithData) == null ? void 0 : n.reduce((s, r) => (s[r.section] || (s[r.section] = []),
                    s[r.section].push(r),
                    s), {})) || {};
                return Object.keys(e).map(s => ({
                    id: s,
                    cards: e[s]
                }))
            }
            ,
            myCards: t => t == null ? void 0 : t.upgradeCardsWithData.filter(e => e.level),
            upgradeCardsWithData: t => {
                var n;
                const e = ((n = t.userData) == null ? void 0 : n.cards) || {};
                return t.upgradeCards.map(s => {
                    var c, u, h, d, f, p;
                    const r = ((c = e[s.id]) == null ? void 0 : c.level) || 0
                        , i = F0(s, r)
                        , o = r > 0 ? Math.round(s.starting_price * Math.pow(s.price_multiplier, r)) : s.starting_price
                        , l = Math.floor((F0(s, r + 1, !0) - F0(s, r, !0)) * 100);
                    let a = !1;
                    if ((u = s.dependency) != null && u.card_id && ((h = s.dependency) != null && h.min_level)) {
                        const m = e[s.dependency.card_id];
                        a = !m || m.level < s.dependency.min_level
                    }
                    return {
                        id: s.id,
                        type: s.type,
                        section: s.section,
                        maxLevel: s.max_level,
                        effectType: s.effect_type,
                        level: r,
                        price: o,
                        profit: i,
                        nextLevelProfit: l,
                        name: s.id,
                        isLocked: a,
                        requiredCardId: (d = s.dependency) == null ? void 0 : d.card_id,
                        requiredCardLevel: (f = s.dependency) == null ? void 0 : f.min_level,
                        lastUpgradeTime: (p = e[s.id]) == null ? void 0 : p.upgraded_at,
                        cooldownEndTime: QY(s, e[s.id])
                    }
                }
                )
            }
            ,
            capacityBonus: t => t.upgradeCardsWithData.filter(e => e.level > 0 && e.type === "Slap_cap_up").reduce((e, n) => e + n.profit, 0),
            profitBonus: t => t.upgradeCardsWithData.filter(e => e.level > 0 && e.type === "Slap_hr_up").reduce((e, n) => e + n.profit, 0),
            slapBonus: t => 1 + t.upgradeCardsWithData.filter(e => e.level > 0 && e.type === "Slap_tap_up").reduce((e, n) => e + n.profit, 0),
            slapPower: t => Math.floor(t.baseSlapPower * t.slapBonus),
            isShareRewardActive: t => {
                const { last_reset: n, count: s, max_shares_per_day: r } = t.userData.shares || {
                    count: 0,
                    max_shares_per_day: 10
                };
                return Date.now() - n > 864e5 && (t.userData.shares.count = 0,
                    t.userData.shares.last_reset = Date.now()),
                    s <= r
            }
            ,
            getWheelUserData: t => e => {
                var n, s;
                return (s = (n = t.userData) == null ? void 0 : n.fortune_wheels) == null ? void 0 : s[e]
            }
        },
        actions: {
            setIsNewUser(t) {
                this.isNewUser = t
            },
            setChangedBalance(t, e) {
                const n = t > 0;
                let s = e || this.balance;
                const r = 1e3;
                let i = 0
                    , o = 10;
                this.targetValue = s - t,
                    this.intervalForBalance && (clearInterval(this.intervalForBalance),
                        this.intervalForBalance = null),
                    this.isBalanceAnimated = !0;
                const l = Math.abs(s - this.targetValue);
                i = r / Math.max(l, 1),
                    l > 2e6 ? o = 1e5 : l > 2e5 ? o = 1e4 : l > 2e4 ? o = 1e3 : l > 2e3 && (o = 100),
                    this.intervalForBalance = setInterval(() => {
                        n && s > this.targetValue ? (this.setBalance(s - o),
                            s -= o) : !n && s < this.targetValue ? (this.setBalance(s + o),
                                s += o) : (this.setBalance(this.targetValue),
                                    clearInterval(this.intervalForBalance),
                                    this.intervalForBalance = null),
                            this.targetValue === this.realBalance && (this.isBalanceAnimated = !1)
                    }
                        , i)
            },
            showErrorModal() {
                this.errorModal.isVisible = !0
            },
            closeErrorModal() {
                this.errorModal.isVisible = !1
            },
            showModal(t, e, n, s, r) {
                this.modal.isVisible = !0,
                    this.modal.hasConfirmation = !!n,
                    this.modal.message = t,
                    this.modal.callback = e,
                    this.modal.image = s,
                    r && (this.modal.confirmLabel = r.confirmLabel,
                        this.modal.cancelLabel = r.cancelLabel)
            },
            closeModal(t = !1) {
                this.modal.isVisible = !1,
                    this.modal.hasConfirmation = !1,
                    this.modal.message = "",
                    this.modal.image = "",
                    this.modal.confirmLabel = null,
                    this.modal.cancelLabel = null,
                    typeof this.modal.callback == "function" && (this.modal.callback(t),
                        this.modal.callback = null)
            },
            formattedNumber(t) {
                return t ? t.toString().replace(/\B(?=(\d{3})+(?!\d))/g, " ") : ""
            },
            setMainMenuHasNotification(t) {
                this.mainMenuHasNotification = t
            },
            setTelegramInit(t) {
                this.isTelegramInited = t
            },
            setApp(t) {
                this.telegramApp = t
            },
            setAppFunctions(t) {
                this.telegramAppFunctions = t
            },
            setShowLoadingOverlay(t) {
                this.ui.showLoadingOverlay = t
            },
            setUserData({ balance: t, girls: e, slots: n, selected_girl_id: s, lootboxes: r, boosts: i, referral: o, ...l }) {
                if (this.isBalanceAnimated && this.intervalForBalance && clearInterval(this.intervalForBalance),
                    this.setBalance(t),
                    this.userData = {
                        balance: t,
                        ...l
                    },
                    e !== void 0) {
                    const c = ls();
                    c.setSelectedGirlId(s),
                        c.setGirls(e || [])
                }
                Fo().setCurrentSlots(n),
                    r !== void 0 && ji().setOwned(r),
                    i !== void 0 && Xs().setOwnedBoosts(i),
                    o !== void 0 && kx().setBonus(o.bonus_coins, o.bonus_standard_lootboxes, o.bonus_premium_lootboxes)
            },
            setUpgradeCards(t) {
                this.upgradeCards = t
            },
            setGlobalBackground(t) {
                this.globalBackground = t
            },
            setRouteBackground(t) {
                this.routeBackground = t
            },
            setGlobalAnimation(t) {
                this.globalAnimation = t
            },
            setIsDevMode(t) {
                this.isDevMode = t
            },
            setBalance(t) {
                this.balance = t
            },
            setCollections(t) {
                this.collections = t
            },
            setGifts(t) {
                this.gifts = t
            },
            incrementBalance() {
                this.balance += this.energyLeftIncrementAmount
            },
            setEnergyLeftAmount(t) {
                this.energyLeftAmount = Math.round(Math.min(this.energyMaxAmount, t))
            },
            decrementEnergyLeftAmount() {
                !this.energyLeftAmount && this.energyLeftAmount < this.energyLeftIncrementAmount || (this.energyLeftAmount -= this.energyLeftIncrementAmount)
            },
            async upgradeCard(t) {
                const e = {
                    ...this.userData
                }
                    , n = this.upgradeCardsWithData.find(r => r.id === t)
                    , s = {
                        ...this.userData.cards || {},
                        [t]: {
                            ...n,
                            level: ((n == null ? void 0 : n.level) || 0) + 1,
                            upgraded_at: Bo(Date.now())
                        }
                    };
                this.balance -= n.price,
                    this.userData = {
                        ...this.userData,
                        cards: s
                    },
                    await Ls({
                        action: async () => Bn(this.telegramAppFunctions, "upgrade_card_call")({
                            card: {
                                id: t
                            }
                        }),
                        onError: () => {
                            this.userData = e
                        }
                        ,
                        onSuccess: r => {
                            this.setUserData(r.data.user),
                                mi().showSuccessToast("toast_messages.upgrade_card")
                        }
                    })
            },
            decrementGifts(t) {
                this.userData.gifts[t] -= 1
            },
            setCurrentLocale(t) {
                this.currentLocale = t
            },
            setWheelUserData(t, e) {
                this.userData.fortune_wheels[t] = e
            },
            setUserId(t) {
                this.userId = t
            },
            incrementUserSlots() {
                this.userData.slots++
            },
            setIsGiftActivated(t) {
                this.isGiftActivated = t
            }
        }
    })
    , { initData: xq, initDataUnsafe: wq, version: Sq, platform: Eq, isVersionAtLeast: MP, sendData: Tq, close: Cq } = Telegram.WebApp
    , PP = ke(!1)
    , Iq = (...t) => {
        Telegram.WebApp.ready(...t),
            PP.value = !0
    }
    , LP = t => Telegram.WebApp.platform === t
    , OP = LP("unknown")
    , Aq = {
        ClosingConfirmation: "6.2",
        CloudStorage: "6.9",
        RequestWriteAccess: "6.9",
        RequestContact: "6.9",
        SettingsButton: "7.0",
        BiometricManager: "7.2",
        DisableVerticalSwipes: "7.7"
    }
    , kq = t => MP(Aq[t])
    , Rq = !OP && Telegram.WebApp.initData === "";
function NP() {
    return {
        initData: xq,
        initDataUnsafe: wq,
        version: Sq,
        platform: Eq,
        isVersionAtLeast: MP,
        onEvent: (t, e, n = {
            manual: !1
        }) => {
            const { manual: s } = n
                , r = () => {
                    Telegram.WebApp.onEvent(t, e)
                }
                , i = () => {
                    Telegram.WebApp.offEvent(t, e)
                }
                ;
            return s ? r() : (Or(r),
                Qd(i)),
            {
                off: i
            }
        }
        ,
        sendData: Tq,
        ready: Iq,
        close: Cq,
        isReady: lu(PP),
        isPlatform: LP,
        isPlatformUnknown: OP,
        isFeatureSupported: kq,
        canSendData: Rq
    }
}
ke(Telegram.WebApp.BackButton.isVisible);
Telegram.WebApp.BiometricManager;
ke(Telegram.WebApp.BiometricManager.isInited);
ke(Telegram.WebApp.BiometricManager.isBiometricAvailable);
ke(Telegram.WebApp.BiometricManager.biometricType);
ke(Telegram.WebApp.BiometricManager.isAccessRequested);
ke(Telegram.WebApp.BiometricManager.isAccessGranted);
ke(Telegram.WebApp.BiometricManager.isAccessGranted);
ke(Telegram.WebApp.BiometricManager.deviceId);
Telegram.WebApp;
ke(Telegram.WebApp.isClosingConfirmationEnabled);
Telegram.WebApp.CloudStorage;
Telegram.WebApp.HapticFeedback;
ke(Telegram.WebApp.MainButton.text);
ke(Telegram.WebApp.MainButton.color);
ke(Telegram.WebApp.MainButton.textColor);
ke(Telegram.WebApp.MainButton.isVisible);
ke(Telegram.WebApp.MainButton.isActive);
ke(Telegram.WebApp.MainButton.isProgressVisible);
Telegram.WebApp;
Telegram.WebApp;
Telegram.WebApp;
Telegram.WebApp;
NP();
ke(Telegram.WebApp.SettingsButton.isVisible);
ke(Telegram.WebApp.colorScheme);
ke(Telegram.WebApp.themeParams);
ke(Telegram.WebApp.headerColor);
ke(Telegram.WebApp.backgroundColor);
const DP = ke(Telegram.WebApp.isExpanded)
    , BP = ke(Telegram.WebApp.viewportHeight)
    , FP = ke(Telegram.WebApp.viewportStableHeight)
    , $P = ke(Telegram.WebApp.isVerticalSwipesEnabled);
function __() {
    DP.value = Telegram.WebApp.isExpanded,
        BP.value = Telegram.WebApp.viewportHeight,
        FP.value = Telegram.WebApp.viewportStableHeight,
        $P.value = Telegram.WebApp.isVerticalSwipesEnabled
}
function Mq(...t) {
    Telegram.WebApp.expand(...t),
        __()
}
const l2 = (...t) => {
    Telegram.WebApp.enableVerticalSwipes(...t),
        __()
}
    , c2 = (...t) => {
        Telegram.WebApp.disableVerticalSwipes(...t),
            __()
    }
    ;
function Pq() {
    const { onEvent: t } = NP()
        , e = (n, s) => t("viewportChanged", n, s);
    return e(__),
    {
        isExpanded: lu(DP),
        viewportHeight: lu(BP),
        viewportStableHeight: lu(FP),
        expand: Mq,
        onViewportChanged: e,
        isVerticalSwipesEnabled: ve({
            get() {
                return $P.value
            },
            set(n) {
                n ? l2() : c2()
            }
        }),
        enableVerticalSwipes: l2,
        disableVerticalSwipes: c2
    }
}
var Lq = "firebase"
    , Oq = "10.12.5";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
kr(Lq, Oq, "app");
function Rx(t, e) {
    var n = {};
    for (var s in t)
        Object.prototype.hasOwnProperty.call(t, s) && e.indexOf(s) < 0 && (n[s] = t[s]);
    if (t != null && typeof Object.getOwnPropertySymbols == "function")
        for (var r = 0, s = Object.getOwnPropertySymbols(t); r < s.length; r++)
            e.indexOf(s[r]) < 0 && Object.prototype.propertyIsEnumerable.call(t, s[r]) && (n[s[r]] = t[s[r]]);
    return n
}
function UP() {
    return {
        "dependent-sdk-initialized-before-auth": "Another Firebase SDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other Firebase SDK."
    }
}
const Nq = UP
    , VP = new fc("auth", "Firebase", UP());
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Dm = new Ov("@firebase/auth");
function Dq(t, ...e) {
    Dm.logLevel <= $t.WARN && Dm.warn(`Auth (${sf}): ${t}`, ...e)
}
function Hp(t, ...e) {
    Dm.logLevel <= $t.ERROR && Dm.error(`Auth (${sf}): ${t}`, ...e)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function $o(t, ...e) {
    throw Mx(t, ...e)
}
function Ui(t, ...e) {
    return Mx(t, ...e)
}
function GP(t, e, n) {
    const s = Object.assign(Object.assign({}, Nq()), {
        [e]: n
    });
    return new fc("auth", "Firebase", s).create(e, {
        appName: t.name
    })
}
function $a(t) {
    return GP(t, "operation-not-supported-in-this-environment", "Operations that alter the current user are not supported in conjunction with FirebaseServerApp")
}
function Mx(t, ...e) {
    if (typeof t != "string") {
        const n = e[0]
            , s = [...e.slice(1)];
        return s[0] && (s[0].appName = t.name),
            t._errorFactory.create(n, ...s)
    }
    return VP.create(t, ...e)
}
function Ze(t, e, ...n) {
    if (!t)
        throw Mx(e, ...n)
}
function yo(t) {
    const e = "INTERNAL ASSERTION FAILED: " + t;
    throw Hp(e),
    new Error(e)
}
function Uo(t, e) {
    t || yo(e)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function zy() {
    var t;
    return typeof self < "u" && ((t = self.location) === null || t === void 0 ? void 0 : t.href) || ""
}
function Bq() {
    return u2() === "http:" || u2() === "https:"
}
function u2() {
    var t;
    return typeof self < "u" && ((t = self.location) === null || t === void 0 ? void 0 : t.protocol) || null
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Fq() {
    return typeof navigator < "u" && navigator && "onLine" in navigator && typeof navigator.onLine == "boolean" && (Bq() || lk() || "connection" in navigator) ? navigator.onLine : !0
}
function $q() {
    if (typeof navigator > "u")
        return null;
    const t = navigator;
    return t.languages && t.languages[0] || t.language || null
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ff {
    constructor(e, n) {
        this.shortDelay = e,
            this.longDelay = n,
            Uo(n > e, "Short delay should be less than long delay!"),
            this.isMobile = lD() || cD()
    }
    get() {
        return Fq() ? this.isMobile ? this.longDelay : this.shortDelay : Math.min(5e3, this.shortDelay)
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Px(t, e) {
    Uo(t.emulator, "Emulator should always be set here");
    const { url: n } = t.emulator;
    return e ? `${n}${e.startsWith("/") ? e.slice(1) : e}` : n
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class HP {
    static initialize(e, n, s) {
        this.fetchImpl = e,
            n && (this.headersImpl = n),
            s && (this.responseImpl = s)
    }
    static fetch() {
        if (this.fetchImpl)
            return this.fetchImpl;
        if (typeof self < "u" && "fetch" in self)
            return self.fetch;
        if (typeof globalThis < "u" && globalThis.fetch)
            return globalThis.fetch;
        if (typeof fetch < "u")
            return fetch;
        yo("Could not find fetch implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill")
    }
    static headers() {
        if (this.headersImpl)
            return this.headersImpl;
        if (typeof self < "u" && "Headers" in self)
            return self.Headers;
        if (typeof globalThis < "u" && globalThis.Headers)
            return globalThis.Headers;
        if (typeof Headers < "u")
            return Headers;
        yo("Could not find Headers implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill")
    }
    static response() {
        if (this.responseImpl)
            return this.responseImpl;
        if (typeof self < "u" && "Response" in self)
            return self.Response;
        if (typeof globalThis < "u" && globalThis.Response)
            return globalThis.Response;
        if (typeof Response < "u")
            return Response;
        yo("Could not find Response implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill")
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Uq = {
    CREDENTIAL_MISMATCH: "custom-token-mismatch",
    MISSING_CUSTOM_TOKEN: "internal-error",
    INVALID_IDENTIFIER: "invalid-email",
    MISSING_CONTINUE_URI: "internal-error",
    INVALID_PASSWORD: "wrong-password",
    MISSING_PASSWORD: "missing-password",
    INVALID_LOGIN_CREDENTIALS: "invalid-credential",
    EMAIL_EXISTS: "email-already-in-use",
    PASSWORD_LOGIN_DISABLED: "operation-not-allowed",
    INVALID_IDP_RESPONSE: "invalid-credential",
    INVALID_PENDING_TOKEN: "invalid-credential",
    FEDERATED_USER_ID_ALREADY_LINKED: "credential-already-in-use",
    MISSING_REQ_TYPE: "internal-error",
    EMAIL_NOT_FOUND: "user-not-found",
    RESET_PASSWORD_EXCEED_LIMIT: "too-many-requests",
    EXPIRED_OOB_CODE: "expired-action-code",
    INVALID_OOB_CODE: "invalid-action-code",
    MISSING_OOB_CODE: "internal-error",
    CREDENTIAL_TOO_OLD_LOGIN_AGAIN: "requires-recent-login",
    INVALID_ID_TOKEN: "invalid-user-token",
    TOKEN_EXPIRED: "user-token-expired",
    USER_NOT_FOUND: "user-token-expired",
    TOO_MANY_ATTEMPTS_TRY_LATER: "too-many-requests",
    PASSWORD_DOES_NOT_MEET_REQUIREMENTS: "password-does-not-meet-requirements",
    INVALID_CODE: "invalid-verification-code",
    INVALID_SESSION_INFO: "invalid-verification-id",
    INVALID_TEMPORARY_PROOF: "invalid-credential",
    MISSING_SESSION_INFO: "missing-verification-id",
    SESSION_EXPIRED: "code-expired",
    MISSING_ANDROID_PACKAGE_NAME: "missing-android-pkg-name",
    UNAUTHORIZED_DOMAIN: "unauthorized-continue-uri",
    INVALID_OAUTH_CLIENT_ID: "invalid-oauth-client-id",
    ADMIN_ONLY_OPERATION: "admin-restricted-operation",
    INVALID_MFA_PENDING_CREDENTIAL: "invalid-multi-factor-session",
    MFA_ENROLLMENT_NOT_FOUND: "multi-factor-info-not-found",
    MISSING_MFA_ENROLLMENT_ID: "missing-multi-factor-info",
    MISSING_MFA_PENDING_CREDENTIAL: "missing-multi-factor-session",
    SECOND_FACTOR_EXISTS: "second-factor-already-in-use",
    SECOND_FACTOR_LIMIT_EXCEEDED: "maximum-second-factor-count-exceeded",
    BLOCKING_FUNCTION_ERROR_RESPONSE: "internal-error",
    RECAPTCHA_NOT_ENABLED: "recaptcha-not-enabled",
    MISSING_RECAPTCHA_TOKEN: "missing-recaptcha-token",
    INVALID_RECAPTCHA_TOKEN: "invalid-recaptcha-token",
    INVALID_RECAPTCHA_ACTION: "invalid-recaptcha-action",
    MISSING_CLIENT_TYPE: "missing-client-type",
    MISSING_RECAPTCHA_VERSION: "missing-recaptcha-version",
    INVALID_RECAPTCHA_VERSION: "invalid-recaptcha-version",
    INVALID_REQ_TYPE: "invalid-req-type"
};
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Vq = new ff(3e4, 6e4);
function y_(t, e) {
    return t.tenantId && !e.tenantId ? Object.assign(Object.assign({}, e), {
        tenantId: t.tenantId
    }) : e
}
async function lh(t, e, n, s, r = {}) {
    return WP(t, r, async () => {
        let i = {}
            , o = {};
        s && (e === "GET" ? o = s : i = {
            body: JSON.stringify(s)
        });
        const l = nf(Object.assign({
            key: t.config.apiKey
        }, o)).slice(1)
            , a = await t._getAdditionalHeaders();
        return a["Content-Type"] = "application/json",
            t.languageCode && (a["X-Firebase-Locale"] = t.languageCode),
            HP.fetch()(XP(t, t.config.apiHost, n, l), Object.assign({
                method: e,
                headers: a,
                referrerPolicy: "no-referrer"
            }, i))
    }
    )
}
async function WP(t, e, n) {
    t._canInitEmulator = !1;
    const s = Object.assign(Object.assign({}, Uq), e);
    try {
        const r = new Gq(t)
            , i = await Promise.race([n(), r.promise]);
        r.clearNetworkTimeout();
        const o = await i.json();
        if ("needConfirmation" in o)
            throw ep(t, "account-exists-with-different-credential", o);
        if (i.ok && !("errorMessage" in o))
            return o;
        {
            const l = i.ok ? o.errorMessage : o.error.message
                , [a, c] = l.split(" : ");
            if (a === "FEDERATED_USER_ID_ALREADY_LINKED")
                throw ep(t, "credential-already-in-use", o);
            if (a === "EMAIL_EXISTS")
                throw ep(t, "email-already-in-use", o);
            if (a === "USER_DISABLED")
                throw ep(t, "user-disabled", o);
            const u = s[a] || a.toLowerCase().replace(/[_\s]+/g, "-");
            if (c)
                throw GP(t, u, c);
            $o(t, u)
        }
    } catch (r) {
        if (r instanceof fi)
            throw r;
        $o(t, "network-request-failed", {
            message: String(r)
        })
    }
}
async function YP(t, e, n, s, r = {}) {
    const i = await lh(t, e, n, s, r);
    return "mfaPendingCredential" in i && $o(t, "multi-factor-auth-required", {
        _serverResponse: i
    }),
        i
}
function XP(t, e, n, s) {
    const r = `${e}${n}?${s}`;
    return t.config.emulator ? Px(t.config, r) : `${t.config.apiScheme}://${r}`
}
class Gq {
    constructor(e) {
        this.auth = e,
            this.timer = null,
            this.promise = new Promise((n, s) => {
                this.timer = setTimeout(() => s(Ui(this.auth, "network-request-failed")), Vq.get())
            }
            )
    }
    clearNetworkTimeout() {
        clearTimeout(this.timer)
    }
}
function ep(t, e, n) {
    const s = {
        appName: t.name
    };
    n.email && (s.email = n.email),
        n.phoneNumber && (s.phoneNumber = n.phoneNumber);
    const r = Ui(t, e, s);
    return r.customData._tokenResponse = n,
        r
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function Hq(t, e) {
    return lh(t, "POST", "/v1/accounts:delete", e)
}
async function jP(t, e) {
    return lh(t, "POST", "/v1/accounts:lookup", e)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function od(t) {
    if (t)
        try {
            const e = new Date(Number(t));
            if (!isNaN(e.getTime()))
                return e.toUTCString()
        } catch { }
}
async function Wq(t, e = !1) {
    const n = Dr(t)
        , s = await n.getIdToken(e)
        , r = Lx(s);
    Ze(r && r.exp && r.auth_time && r.iat, n.auth, "internal-error");
    const i = typeof r.firebase == "object" ? r.firebase : void 0
        , o = i == null ? void 0 : i.sign_in_provider;
    return {
        claims: r,
        token: s,
        authTime: od($0(r.auth_time)),
        issuedAtTime: od($0(r.iat)),
        expirationTime: od($0(r.exp)),
        signInProvider: o || null,
        signInSecondFactor: (i == null ? void 0 : i.sign_in_second_factor) || null
    }
}
function $0(t) {
    return Number(t) * 1e3
}
function Lx(t) {
    const [e, n, s] = t.split(".");
    if (e === void 0 || n === void 0 || s === void 0)
        return Hp("JWT malformed, contained fewer than 3 sections"),
            null;
    try {
        const r = rk(n);
        return r ? JSON.parse(r) : (Hp("Failed to decode base64 JWT payload"),
            null)
    } catch (r) {
        return Hp("Caught error parsing JWT payload as JSON", r == null ? void 0 : r.toString()),
            null
    }
}
function h2(t) {
    const e = Lx(t);
    return Ze(e, "internal-error"),
        Ze(typeof e.exp < "u", "internal-error"),
        Ze(typeof e.iat < "u", "internal-error"),
        Number(e.exp) - Number(e.iat)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function Rd(t, e, n = !1) {
    if (n)
        return e;
    try {
        return await e
    } catch (s) {
        throw s instanceof fi && Yq(s) && t.auth.currentUser === t && await t.auth.signOut(),
        s
    }
}
function Yq({ code: t }) {
    return t === "auth/user-disabled" || t === "auth/user-token-expired"
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Xq {
    constructor(e) {
        this.user = e,
            this.isRunning = !1,
            this.timerId = null,
            this.errorBackoff = 3e4
    }
    _start() {
        this.isRunning || (this.isRunning = !0,
            this.schedule())
    }
    _stop() {
        this.isRunning && (this.isRunning = !1,
            this.timerId !== null && clearTimeout(this.timerId))
    }
    getInterval(e) {
        var n;
        if (e) {
            const s = this.errorBackoff;
            return this.errorBackoff = Math.min(this.errorBackoff * 2, 96e4),
                s
        } else {
            this.errorBackoff = 3e4;
            const r = ((n = this.user.stsTokenManager.expirationTime) !== null && n !== void 0 ? n : 0) - Date.now() - 3e5;
            return Math.max(0, r)
        }
    }
    schedule(e = !1) {
        if (!this.isRunning)
            return;
        const n = this.getInterval(e);
        this.timerId = setTimeout(async () => {
            await this.iteration()
        }
            , n)
    }
    async iteration() {
        try {
            await this.user.getIdToken(!0)
        } catch (e) {
            (e == null ? void 0 : e.code) === "auth/network-request-failed" && this.schedule(!0);
            return
        }
        this.schedule()
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class qy {
    constructor(e, n) {
        this.createdAt = e,
            this.lastLoginAt = n,
            this._initializeTime()
    }
    _initializeTime() {
        this.lastSignInTime = od(this.lastLoginAt),
            this.creationTime = od(this.createdAt)
    }
    _copy(e) {
        this.createdAt = e.createdAt,
            this.lastLoginAt = e.lastLoginAt,
            this._initializeTime()
    }
    toJSON() {
        return {
            createdAt: this.createdAt,
            lastLoginAt: this.lastLoginAt
        }
    }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function Bm(t) {
    var e;
    const n = t.auth
        , s = await t.getIdToken()
        , r = await Rd(t, jP(n, {
            idToken: s
        }));
    Ze(r == null ? void 0 : r.users.length, n, "internal-error");
    const i = r.users[0];
    t._notifyReloadListener(i);
    const o = !((e = i.providerUserInfo) === null || e === void 0) && e.length ? zP(i.providerUserInfo) : []
        , l = zq(t.providerData, o)
        , a = t.isAnonymous
        , c = !(t.email && i.passwordHash) && !(l != null && l.length)
        , u = a ? c : !1
        , h = {
            uid: i.localId,
            displayName: i.displayName || null,
            photoURL: i.photoUrl || null,
            email: i.email || null,
            emailVerified: i.emailVerified || !1,
            phoneNumber: i.phoneNumber || null,
            tenantId: i.tenantId || null,
            providerData: l,
            metadata: new qy(i.createdAt, i.lastLoginAt),
            isAnonymous: u
        };
    Object.assign(t, h)
}
async function jq(t) {
    const e = Dr(t);
    await Bm(e),
        await e.auth._persistUserIfCurrent(e),
        e.auth._notifyListenersIfCurrent(e)
}
function zq(t, e) {
    return [...t.filter(s => !e.some(r => r.providerId === s.providerId)), ...e]
}
function zP(t) {
    return t.map(e => {
        var { providerId: n } = e
            , s = Rx(e, ["providerId"]);
        return {
            providerId: n,
            uid: s.rawId || "",
            displayName: s.displayName || null,
            email: s.email || null,
            phoneNumber: s.phoneNumber || null,
            photoURL: s.photoUrl || null
        }
    }
    )
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function qq(t, e) {
    const n = await WP(t, {}, async () => {
        const s = nf({
            grant_type: "refresh_token",
            refresh_token: e
        }).slice(1)
            , { tokenApiHost: r, apiKey: i } = t.config
            , o = XP(t, r, "/v1/token", `key=${i}`)
            , l = await t._getAdditionalHeaders();
        return l["Content-Type"] = "application/x-www-form-urlencoded",
            HP.fetch()(o, {
                method: "POST",
                headers: l,
                body: s
            })
    }
    );
    return {
        accessToken: n.access_token,
        expiresIn: n.expires_in,
        refreshToken: n.refresh_token
    }
}
async function Kq(t, e) {
    return lh(t, "POST", "/v2/accounts:revokeToken", y_(t, e))
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class gu {
    constructor() {
        this.refreshToken = null,
            this.accessToken = null,
            this.expirationTime = null
    }
    get isExpired() {
        return !this.expirationTime || Date.now() > this.expirationTime - 3e4
    }
    updateFromServerResponse(e) {
        Ze(e.idToken, "internal-error"),
            Ze(typeof e.idToken < "u", "internal-error"),
            Ze(typeof e.refreshToken < "u", "internal-error");
        const n = "expiresIn" in e && typeof e.expiresIn < "u" ? Number(e.expiresIn) : h2(e.idToken);
        this.updateTokensAndExpiration(e.idToken, e.refreshToken, n)
    }
    updateFromIdToken(e) {
        Ze(e.length !== 0, "internal-error");
        const n = h2(e);
        this.updateTokensAndExpiration(e, null, n)
    }
    async getToken(e, n = !1) {
        return !n && this.accessToken && !this.isExpired ? this.accessToken : (Ze(this.refreshToken, e, "user-token-expired"),
            this.refreshToken ? (await this.refresh(e, this.refreshToken),
                this.accessToken) : null)
    }
    clearRefreshToken() {
        this.refreshToken = null
    }
    async refresh(e, n) {
        const { accessToken: s, refreshToken: r, expiresIn: i } = await qq(e, n);
        this.updateTokensAndExpiration(s, r, Number(i))
    }
    updateTokensAndExpiration(e, n, s) {
        this.refreshToken = n || null,
            this.accessToken = e || null,
            this.expirationTime = Date.now() + s * 1e3
    }
    static fromJSON(e, n) {
        const { refreshToken: s, accessToken: r, expirationTime: i } = n
            , o = new gu;
        return s && (Ze(typeof s == "string", "internal-error", {
            appName: e
        }),
            o.refreshToken = s),
            r && (Ze(typeof r == "string", "internal-error", {
                appName: e
            }),
                o.accessToken = r),
            i && (Ze(typeof i == "number", "internal-error", {
                appName: e
            }),
                o.expirationTime = i),
            o
    }
    toJSON() {
        return {
            refreshToken: this.refreshToken,
            accessToken: this.accessToken,
            expirationTime: this.expirationTime
        }
    }
    _assign(e) {
        this.accessToken = e.accessToken,
            this.refreshToken = e.refreshToken,
            this.expirationTime = e.expirationTime
    }
    _clone() {
        return Object.assign(new gu, this.toJSON())
    }
    _performRefresh() {
        return yo("not implemented")
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Qo(t, e) {
    Ze(typeof t == "string" || typeof t > "u", "internal-error", {
        appName: e
    })
}
class bo {
    constructor(e) {
        var { uid: n, auth: s, stsTokenManager: r } = e
            , i = Rx(e, ["uid", "auth", "stsTokenManager"]);
        this.providerId = "firebase",
            this.proactiveRefresh = new Xq(this),
            this.reloadUserInfo = null,
            this.reloadListener = null,
            this.uid = n,
            this.auth = s,
            this.stsTokenManager = r,
            this.accessToken = r.accessToken,
            this.displayName = i.displayName || null,
            this.email = i.email || null,
            this.emailVerified = i.emailVerified || !1,
            this.phoneNumber = i.phoneNumber || null,
            this.photoURL = i.photoURL || null,
            this.isAnonymous = i.isAnonymous || !1,
            this.tenantId = i.tenantId || null,
            this.providerData = i.providerData ? [...i.providerData] : [],
            this.metadata = new qy(i.createdAt || void 0, i.lastLoginAt || void 0)
    }
    async getIdToken(e) {
        const n = await Rd(this, this.stsTokenManager.getToken(this.auth, e));
        return Ze(n, this.auth, "internal-error"),
            this.accessToken !== n && (this.accessToken = n,
                await this.auth._persistUserIfCurrent(this),
                this.auth._notifyListenersIfCurrent(this)),
            n
    }
    getIdTokenResult(e) {
        return Wq(this, e)
    }
    reload() {
        return jq(this)
    }
    _assign(e) {
        this !== e && (Ze(this.uid === e.uid, this.auth, "internal-error"),
            this.displayName = e.displayName,
            this.photoURL = e.photoURL,
            this.email = e.email,
            this.emailVerified = e.emailVerified,
            this.phoneNumber = e.phoneNumber,
            this.isAnonymous = e.isAnonymous,
            this.tenantId = e.tenantId,
            this.providerData = e.providerData.map(n => Object.assign({}, n)),
            this.metadata._copy(e.metadata),
            this.stsTokenManager._assign(e.stsTokenManager))
    }
    _clone(e) {
        const n = new bo(Object.assign(Object.assign({}, this), {
            auth: e,
            stsTokenManager: this.stsTokenManager._clone()
        }));
        return n.metadata._copy(this.metadata),
            n
    }
    _onReload(e) {
        Ze(!this.reloadListener, this.auth, "internal-error"),
            this.reloadListener = e,
            this.reloadUserInfo && (this._notifyReloadListener(this.reloadUserInfo),
                this.reloadUserInfo = null)
    }
    _notifyReloadListener(e) {
        this.reloadListener ? this.reloadListener(e) : this.reloadUserInfo = e
    }
    _startProactiveRefresh() {
        this.proactiveRefresh._start()
    }
    _stopProactiveRefresh() {
        this.proactiveRefresh._stop()
    }
    async _updateTokensIfNecessary(e, n = !1) {
        let s = !1;
        e.idToken && e.idToken !== this.stsTokenManager.accessToken && (this.stsTokenManager.updateFromServerResponse(e),
            s = !0),
            n && await Bm(this),
            await this.auth._persistUserIfCurrent(this),
            s && this.auth._notifyListenersIfCurrent(this)
    }
    async delete() {
        if (go(this.auth.app))
            return Promise.reject($a(this.auth));
        const e = await this.getIdToken();
        return await Rd(this, Hq(this.auth, {
            idToken: e
        })),
            this.stsTokenManager.clearRefreshToken(),
            this.auth.signOut()
    }
    toJSON() {
        return Object.assign(Object.assign({
            uid: this.uid,
            email: this.email || void 0,
            emailVerified: this.emailVerified,
            displayName: this.displayName || void 0,
            isAnonymous: this.isAnonymous,
            photoURL: this.photoURL || void 0,
            phoneNumber: this.phoneNumber || void 0,
            tenantId: this.tenantId || void 0,
            providerData: this.providerData.map(e => Object.assign({}, e)),
            stsTokenManager: this.stsTokenManager.toJSON(),
            _redirectEventId: this._redirectEventId
        }, this.metadata.toJSON()), {
            apiKey: this.auth.config.apiKey,
            appName: this.auth.name
        })
    }
    get refreshToken() {
        return this.stsTokenManager.refreshToken || ""
    }
    static _fromJSON(e, n) {
        var s, r, i, o, l, a, c, u;
        const h = (s = n.displayName) !== null && s !== void 0 ? s : void 0
            , d = (r = n.email) !== null && r !== void 0 ? r : void 0
            , f = (i = n.phoneNumber) !== null && i !== void 0 ? i : void 0
            , p = (o = n.photoURL) !== null && o !== void 0 ? o : void 0
            , m = (l = n.tenantId) !== null && l !== void 0 ? l : void 0
            , g = (a = n._redirectEventId) !== null && a !== void 0 ? a : void 0
            , b = (c = n.createdAt) !== null && c !== void 0 ? c : void 0
            , v = (u = n.lastLoginAt) !== null && u !== void 0 ? u : void 0
            , { uid: _, emailVerified: y, isAnonymous: x, providerData: w, stsTokenManager: S } = n;
        Ze(_ && S, e, "internal-error");
        const E = gu.fromJSON(this.name, S);
        Ze(typeof _ == "string", e, "internal-error"),
            Qo(h, e.name),
            Qo(d, e.name),
            Ze(typeof y == "boolean", e, "internal-error"),
            Ze(typeof x == "boolean", e, "internal-error"),
            Qo(f, e.name),
            Qo(p, e.name),
            Qo(m, e.name),
            Qo(g, e.name),
            Qo(b, e.name),
            Qo(v, e.name);
        const C = new bo({
            uid: _,
            auth: e,
            email: d,
            emailVerified: y,
            displayName: h,
            isAnonymous: x,
            photoURL: p,
            phoneNumber: f,
            tenantId: m,
            stsTokenManager: E,
            createdAt: b,
            lastLoginAt: v
        });
        return w && Array.isArray(w) && (C.providerData = w.map(I => Object.assign({}, I))),
            g && (C._redirectEventId = g),
            C
    }
    static async _fromIdTokenResponse(e, n, s = !1) {
        const r = new gu;
        r.updateFromServerResponse(n);
        const i = new bo({
            uid: n.localId,
            auth: e,
            stsTokenManager: r,
            isAnonymous: s
        });
        return await Bm(i),
            i
    }
    static async _fromGetAccountInfoResponse(e, n, s) {
        const r = n.users[0];
        Ze(r.localId !== void 0, "internal-error");
        const i = r.providerUserInfo !== void 0 ? zP(r.providerUserInfo) : []
            , o = !(r.email && r.passwordHash) && !(i != null && i.length)
            , l = new gu;
        l.updateFromIdToken(s);
        const a = new bo({
            uid: r.localId,
            auth: e,
            stsTokenManager: l,
            isAnonymous: o
        })
            , c = {
                uid: r.localId,
                displayName: r.displayName || null,
                photoURL: r.photoUrl || null,
                email: r.email || null,
                emailVerified: r.emailVerified || !1,
                phoneNumber: r.phoneNumber || null,
                tenantId: r.tenantId || null,
                providerData: i,
                metadata: new qy(r.createdAt, r.lastLoginAt),
                isAnonymous: !(r.email && r.passwordHash) && !(i != null && i.length)
            };
        return Object.assign(a, c),
            a
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const d2 = new Map;
function vo(t) {
    Uo(t instanceof Function, "Expected a class definition");
    let e = d2.get(t);
    return e ? (Uo(e instanceof t, "Instance stored in cache mismatched with class"),
        e) : (e = new t,
            d2.set(t, e),
            e)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class qP {
    constructor() {
        this.type = "NONE",
            this.storage = {}
    }
    async _isAvailable() {
        return !0
    }
    async _set(e, n) {
        this.storage[e] = n
    }
    async _get(e) {
        const n = this.storage[e];
        return n === void 0 ? null : n
    }
    async _remove(e) {
        delete this.storage[e]
    }
    _addListener(e, n) { }
    _removeListener(e, n) { }
}
qP.type = "NONE";
const f2 = qP;
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Wp(t, e, n) {
    return `firebase:${t}:${e}:${n}`
}
class _u {
    constructor(e, n, s) {
        this.persistence = e,
            this.auth = n,
            this.userKey = s;
        const { config: r, name: i } = this.auth;
        this.fullUserKey = Wp(this.userKey, r.apiKey, i),
            this.fullPersistenceKey = Wp("persistence", r.apiKey, i),
            this.boundEventHandler = n._onStorageEvent.bind(n),
            this.persistence._addListener(this.fullUserKey, this.boundEventHandler)
    }
    setCurrentUser(e) {
        return this.persistence._set(this.fullUserKey, e.toJSON())
    }
    async getCurrentUser() {
        const e = await this.persistence._get(this.fullUserKey);
        return e ? bo._fromJSON(this.auth, e) : null
    }
    removeCurrentUser() {
        return this.persistence._remove(this.fullUserKey)
    }
    savePersistenceForRedirect() {
        return this.persistence._set(this.fullPersistenceKey, this.persistence.type)
    }
    async setPersistence(e) {
        if (this.persistence === e)
            return;
        const n = await this.getCurrentUser();
        if (await this.removeCurrentUser(),
            this.persistence = e,
            n)
            return this.setCurrentUser(n)
    }
    delete() {
        this.persistence._removeListener(this.fullUserKey, this.boundEventHandler)
    }
    static async create(e, n, s = "authUser") {
        if (!n.length)
            return new _u(vo(f2), e, s);
        const r = (await Promise.all(n.map(async c => {
            if (await c._isAvailable())
                return c
        }
        ))).filter(c => c);
        let i = r[0] || vo(f2);
        const o = Wp(s, e.config.apiKey, e.name);
        let l = null;
        for (const c of n)
            try {
                const u = await c._get(o);
                if (u) {
                    const h = bo._fromJSON(e, u);
                    c !== i && (l = h),
                        i = c;
                    break
                }
            } catch { }
        const a = r.filter(c => c._shouldAllowMigration);
        return !i._shouldAllowMigration || !a.length ? new _u(i, e, s) : (i = a[0],
            l && await i._set(o, l.toJSON()),
            await Promise.all(n.map(async c => {
                if (c !== i)
                    try {
                        await c._remove(o)
                    } catch { }
            }
            )),
            new _u(i, e, s))
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function p2(t) {
    const e = t.toLowerCase();
    if (e.includes("opera/") || e.includes("opr/") || e.includes("opios/"))
        return "Opera";
    if (ZP(e))
        return "IEMobile";
    if (e.includes("msie") || e.includes("trident/"))
        return "IE";
    if (e.includes("edge/"))
        return "Edge";
    if (KP(e))
        return "Firefox";
    if (e.includes("silk/"))
        return "Silk";
    if (e4(e))
        return "Blackberry";
    if (t4(e))
        return "Webos";
    if (Ox(e))
        return "Safari";
    if ((e.includes("chrome/") || JP(e)) && !e.includes("edge/"))
        return "Chrome";
    if (QP(e))
        return "Android";
    {
        const n = /([a-zA-Z\d\.]+)\/[a-zA-Z\d\.]*$/
            , s = t.match(n);
        if ((s == null ? void 0 : s.length) === 2)
            return s[1]
    }
    return "Other"
}
function KP(t = ms()) {
    return /firefox\//i.test(t)
}
function Ox(t = ms()) {
    const e = t.toLowerCase();
    return e.includes("safari/") && !e.includes("chrome/") && !e.includes("crios/") && !e.includes("android")
}
function JP(t = ms()) {
    return /crios\//i.test(t)
}
function ZP(t = ms()) {
    return /iemobile/i.test(t)
}
function QP(t = ms()) {
    return /android/i.test(t)
}
function e4(t = ms()) {
    return /blackberry/i.test(t)
}
function t4(t = ms()) {
    return /webos/i.test(t)
}
function b_(t = ms()) {
    return /iphone|ipad|ipod/i.test(t) || /macintosh/i.test(t) && /mobile/i.test(t)
}
function Jq(t = ms()) {
    var e;
    return b_(t) && !!(!((e = window.navigator) === null || e === void 0) && e.standalone)
}
function Zq() {
    return uD() && document.documentMode === 10
}
function n4(t = ms()) {
    return b_(t) || QP(t) || t4(t) || e4(t) || /windows phone/i.test(t) || ZP(t)
}
function Qq() {
    try {
        return !!(window && window !== window.top)
    } catch {
        return !1
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function s4(t, e = []) {
    let n;
    switch (t) {
        case "Browser":
            n = p2(ms());
            break;
        case "Worker":
            n = `${p2(ms())}-${t}`;
            break;
        default:
            n = t
    }
    const s = e.length ? e.join(",") : "FirebaseCore-web";
    return `${n}/JsCore/${sf}/${s}`
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class eK {
    constructor(e) {
        this.auth = e,
            this.queue = []
    }
    pushCallback(e, n) {
        const s = i => new Promise((o, l) => {
            try {
                const a = e(i);
                o(a)
            } catch (a) {
                l(a)
            }
        }
        );
        s.onAbort = n,
            this.queue.push(s);
        const r = this.queue.length - 1;
        return () => {
            this.queue[r] = () => Promise.resolve()
        }
    }
    async runMiddleware(e) {
        if (this.auth.currentUser === e)
            return;
        const n = [];
        try {
            for (const s of this.queue)
                await s(e),
                    s.onAbort && n.push(s.onAbort)
        } catch (s) {
            n.reverse();
            for (const r of n)
                try {
                    r()
                } catch { }
            throw this.auth._errorFactory.create("login-blocked", {
                originalMessage: s == null ? void 0 : s.message
            })
        }
    }
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function tK(t, e = {}) {
    return lh(t, "GET", "/v2/passwordPolicy", y_(t, e))
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const nK = 6;
class sK {
    constructor(e) {
        var n, s, r, i;
        const o = e.customStrengthOptions;
        this.customStrengthOptions = {},
            this.customStrengthOptions.minPasswordLength = (n = o.minPasswordLength) !== null && n !== void 0 ? n : nK,
            o.maxPasswordLength && (this.customStrengthOptions.maxPasswordLength = o.maxPasswordLength),
            o.containsLowercaseCharacter !== void 0 && (this.customStrengthOptions.containsLowercaseLetter = o.containsLowercaseCharacter),
            o.containsUppercaseCharacter !== void 0 && (this.customStrengthOptions.containsUppercaseLetter = o.containsUppercaseCharacter),
            o.containsNumericCharacter !== void 0 && (this.customStrengthOptions.containsNumericCharacter = o.containsNumericCharacter),
            o.containsNonAlphanumericCharacter !== void 0 && (this.customStrengthOptions.containsNonAlphanumericCharacter = o.containsNonAlphanumericCharacter),
            this.enforcementState = e.enforcementState,
            this.enforcementState === "ENFORCEMENT_STATE_UNSPECIFIED" && (this.enforcementState = "OFF"),
            this.allowedNonAlphanumericCharacters = (r = (s = e.allowedNonAlphanumericCharacters) === null || s === void 0 ? void 0 : s.join("")) !== null && r !== void 0 ? r : "",
            this.forceUpgradeOnSignin = (i = e.forceUpgradeOnSignin) !== null && i !== void 0 ? i : !1,
            this.schemaVersion = e.schemaVersion
    }
    validatePassword(e) {
        var n, s, r, i, o, l;
        const a = {
            isValid: !0,
            passwordPolicy: this
        };
        return this.validatePasswordLengthOptions(e, a),
            this.validatePasswordCharacterOptions(e, a),
            a.isValid && (a.isValid = (n = a.meetsMinPasswordLength) !== null && n !== void 0 ? n : !0),
            a.isValid && (a.isValid = (s = a.meetsMaxPasswordLength) !== null && s !== void 0 ? s : !0),
            a.isValid && (a.isValid = (r = a.containsLowercaseLetter) !== null && r !== void 0 ? r : !0),
            a.isValid && (a.isValid = (i = a.containsUppercaseLetter) !== null && i !== void 0 ? i : !0),
            a.isValid && (a.isValid = (o = a.containsNumericCharacter) !== null && o !== void 0 ? o : !0),
            a.isValid && (a.isValid = (l = a.containsNonAlphanumericCharacter) !== null && l !== void 0 ? l : !0),
            a
    }
    validatePasswordLengthOptions(e, n) {
        const s = this.customStrengthOptions.minPasswordLength
            , r = this.customStrengthOptions.maxPasswordLength;
        s && (n.meetsMinPasswordLength = e.length >= s),
            r && (n.meetsMaxPasswordLength = e.length <= r)
    }
    validatePasswordCharacterOptions(e, n) {
        this.updatePasswordCharacterOptionsStatuses(n, !1, !1, !1, !1);
        let s;
        for (let r = 0; r < e.length; r++)
            s = e.charAt(r),
                this.updatePasswordCharacterOptionsStatuses(n, s >= "a" && s <= "z", s >= "A" && s <= "Z", s >= "0" && s <= "9", this.allowedNonAlphanumericCharacters.includes(s))
    }
    updatePasswordCharacterOptionsStatuses(e, n, s, r, i) {
        this.customStrengthOptions.containsLowercaseLetter && (e.containsLowercaseLetter || (e.containsLowercaseLetter = n)),
            this.customStrengthOptions.containsUppercaseLetter && (e.containsUppercaseLetter || (e.containsUppercaseLetter = s)),
            this.customStrengthOptions.containsNumericCharacter && (e.containsNumericCharacter || (e.containsNumericCharacter = r)),
            this.customStrengthOptions.containsNonAlphanumericCharacter && (e.containsNonAlphanumericCharacter || (e.containsNonAlphanumericCharacter = i))
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class rK {
    constructor(e, n, s, r) {
        this.app = e,
            this.heartbeatServiceProvider = n,
            this.appCheckServiceProvider = s,
            this.config = r,
            this.currentUser = null,
            this.emulatorConfig = null,
            this.operations = Promise.resolve(),
            this.authStateSubscription = new m2(this),
            this.idTokenSubscription = new m2(this),
            this.beforeStateQueue = new eK(this),
            this.redirectUser = null,
            this.isProactiveRefreshEnabled = !1,
            this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION = 1,
            this._canInitEmulator = !0,
            this._isInitialized = !1,
            this._deleted = !1,
            this._initializationPromise = null,
            this._popupRedirectResolver = null,
            this._errorFactory = VP,
            this._agentRecaptchaConfig = null,
            this._tenantRecaptchaConfigs = {},
            this._projectPasswordPolicy = null,
            this._tenantPasswordPolicies = {},
            this.lastNotifiedUid = void 0,
            this.languageCode = null,
            this.tenantId = null,
            this.settings = {
                appVerificationDisabledForTesting: !1
            },
            this.frameworks = [],
            this.name = e.name,
            this.clientVersion = r.sdkClientVersion
    }
    _initializeWithPersistence(e, n) {
        return n && (this._popupRedirectResolver = vo(n)),
            this._initializationPromise = this.queue(async () => {
                var s, r;
                if (!this._deleted && (this.persistenceManager = await _u.create(this, e),
                    !this._deleted)) {
                    if (!((s = this._popupRedirectResolver) === null || s === void 0) && s._shouldInitProactively)
                        try {
                            await this._popupRedirectResolver._initialize(this)
                        } catch { }
                    await this.initializeCurrentUser(n),
                        this.lastNotifiedUid = ((r = this.currentUser) === null || r === void 0 ? void 0 : r.uid) || null,
                        !this._deleted && (this._isInitialized = !0)
                }
            }
            ),
            this._initializationPromise
    }
    async _onStorageEvent() {
        if (this._deleted)
            return;
        const e = await this.assertedPersistence.getCurrentUser();
        if (!(!this.currentUser && !e)) {
            if (this.currentUser && e && this.currentUser.uid === e.uid) {
                this._currentUser._assign(e),
                    await this.currentUser.getIdToken();
                return
            }
            await this._updateCurrentUser(e, !0)
        }
    }
    async initializeCurrentUserFromIdToken(e) {
        try {
            const n = await jP(this, {
                idToken: e
            })
                , s = await bo._fromGetAccountInfoResponse(this, n, e);
            await this.directlySetCurrentUser(s)
        } catch (n) {
            console.warn("FirebaseServerApp could not login user with provided authIdToken: ", n),
                await this.directlySetCurrentUser(null)
        }
    }
    async initializeCurrentUser(e) {
        var n;
        if (go(this.app)) {
            const o = this.app.settings.authIdToken;
            return o ? new Promise(l => {
                setTimeout(() => this.initializeCurrentUserFromIdToken(o).then(l, l))
            }
            ) : this.directlySetCurrentUser(null)
        }
        const s = await this.assertedPersistence.getCurrentUser();
        let r = s
            , i = !1;
        if (e && this.config.authDomain) {
            await this.getOrInitRedirectPersistenceManager();
            const o = (n = this.redirectUser) === null || n === void 0 ? void 0 : n._redirectEventId
                , l = r == null ? void 0 : r._redirectEventId
                , a = await this.tryRedirectSignIn(e);
            (!o || o === l) && (a != null && a.user) && (r = a.user,
                i = !0)
        }
        if (!r)
            return this.directlySetCurrentUser(null);
        if (!r._redirectEventId) {
            if (i)
                try {
                    await this.beforeStateQueue.runMiddleware(r)
                } catch (o) {
                    r = s,
                        this._popupRedirectResolver._overrideRedirectResult(this, () => Promise.reject(o))
                }
            return r ? this.reloadAndSetCurrentUserOrClear(r) : this.directlySetCurrentUser(null)
        }
        return Ze(this._popupRedirectResolver, this, "argument-error"),
            await this.getOrInitRedirectPersistenceManager(),
            this.redirectUser && this.redirectUser._redirectEventId === r._redirectEventId ? this.directlySetCurrentUser(r) : this.reloadAndSetCurrentUserOrClear(r)
    }
    async tryRedirectSignIn(e) {
        let n = null;
        try {
            n = await this._popupRedirectResolver._completeRedirectFn(this, e, !0)
        } catch {
            await this._setRedirectUser(null)
        }
        return n
    }
    async reloadAndSetCurrentUserOrClear(e) {
        try {
            await Bm(e)
        } catch (n) {
            if ((n == null ? void 0 : n.code) !== "auth/network-request-failed")
                return this.directlySetCurrentUser(null)
        }
        return this.directlySetCurrentUser(e)
    }
    useDeviceLanguage() {
        this.languageCode = $q()
    }
    async _delete() {
        this._deleted = !0
    }
    async updateCurrentUser(e) {
        if (go(this.app))
            return Promise.reject($a(this));
        const n = e ? Dr(e) : null;
        return n && Ze(n.auth.config.apiKey === this.config.apiKey, this, "invalid-user-token"),
            this._updateCurrentUser(n && n._clone(this))
    }
    async _updateCurrentUser(e, n = !1) {
        if (!this._deleted)
            return e && Ze(this.tenantId === e.tenantId, this, "tenant-id-mismatch"),
                n || await this.beforeStateQueue.runMiddleware(e),
                this.queue(async () => {
                    await this.directlySetCurrentUser(e),
                        this.notifyAuthListeners()
                }
                )
    }
    async signOut() {
        return go(this.app) ? Promise.reject($a(this)) : (await this.beforeStateQueue.runMiddleware(null),
            (this.redirectPersistenceManager || this._popupRedirectResolver) && await this._setRedirectUser(null),
            this._updateCurrentUser(null, !0))
    }
    setPersistence(e) {
        return go(this.app) ? Promise.reject($a(this)) : this.queue(async () => {
            await this.assertedPersistence.setPersistence(vo(e))
        }
        )
    }
    _getRecaptchaConfig() {
        return this.tenantId == null ? this._agentRecaptchaConfig : this._tenantRecaptchaConfigs[this.tenantId]
    }
    async validatePassword(e) {
        this._getPasswordPolicyInternal() || await this._updatePasswordPolicy();
        const n = this._getPasswordPolicyInternal();
        return n.schemaVersion !== this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION ? Promise.reject(this._errorFactory.create("unsupported-password-policy-schema-version", {})) : n.validatePassword(e)
    }
    _getPasswordPolicyInternal() {
        return this.tenantId === null ? this._projectPasswordPolicy : this._tenantPasswordPolicies[this.tenantId]
    }
    async _updatePasswordPolicy() {
        const e = await tK(this)
            , n = new sK(e);
        this.tenantId === null ? this._projectPasswordPolicy = n : this._tenantPasswordPolicies[this.tenantId] = n
    }
    _getPersistence() {
        return this.assertedPersistence.persistence.type
    }
    _updateErrorMap(e) {
        this._errorFactory = new fc("auth", "Firebase", e())
    }
    onAuthStateChanged(e, n, s) {
        return this.registerStateListener(this.authStateSubscription, e, n, s)
    }
    beforeAuthStateChanged(e, n) {
        return this.beforeStateQueue.pushCallback(e, n)
    }
    onIdTokenChanged(e, n, s) {
        return this.registerStateListener(this.idTokenSubscription, e, n, s)
    }
    authStateReady() {
        return new Promise((e, n) => {
            if (this.currentUser)
                e();
            else {
                const s = this.onAuthStateChanged(() => {
                    s(),
                        e()
                }
                    , n)
            }
        }
        )
    }
    async revokeAccessToken(e) {
        if (this.currentUser) {
            const n = await this.currentUser.getIdToken()
                , s = {
                    providerId: "apple.com",
                    tokenType: "ACCESS_TOKEN",
                    token: e,
                    idToken: n
                };
            this.tenantId != null && (s.tenantId = this.tenantId),
                await Kq(this, s)
        }
    }
    toJSON() {
        var e;
        return {
            apiKey: this.config.apiKey,
            authDomain: this.config.authDomain,
            appName: this.name,
            currentUser: (e = this._currentUser) === null || e === void 0 ? void 0 : e.toJSON()
        }
    }
    async _setRedirectUser(e, n) {
        const s = await this.getOrInitRedirectPersistenceManager(n);
        return e === null ? s.removeCurrentUser() : s.setCurrentUser(e)
    }
    async getOrInitRedirectPersistenceManager(e) {
        if (!this.redirectPersistenceManager) {
            const n = e && vo(e) || this._popupRedirectResolver;
            Ze(n, this, "argument-error"),
                this.redirectPersistenceManager = await _u.create(this, [vo(n._redirectPersistence)], "redirectUser"),
                this.redirectUser = await this.redirectPersistenceManager.getCurrentUser()
        }
        return this.redirectPersistenceManager
    }
    async _redirectUserForId(e) {
        var n, s;
        return this._isInitialized && await this.queue(async () => { }
        ),
            ((n = this._currentUser) === null || n === void 0 ? void 0 : n._redirectEventId) === e ? this._currentUser : ((s = this.redirectUser) === null || s === void 0 ? void 0 : s._redirectEventId) === e ? this.redirectUser : null
    }
    async _persistUserIfCurrent(e) {
        if (e === this.currentUser)
            return this.queue(async () => this.directlySetCurrentUser(e))
    }
    _notifyListenersIfCurrent(e) {
        e === this.currentUser && this.notifyAuthListeners()
    }
    _key() {
        return `${this.config.authDomain}:${this.config.apiKey}:${this.name}`
    }
    _startProactiveRefresh() {
        this.isProactiveRefreshEnabled = !0,
            this.currentUser && this._currentUser._startProactiveRefresh()
    }
    _stopProactiveRefresh() {
        this.isProactiveRefreshEnabled = !1,
            this.currentUser && this._currentUser._stopProactiveRefresh()
    }
    get _currentUser() {
        return this.currentUser
    }
    notifyAuthListeners() {
        var e, n;
        if (!this._isInitialized)
            return;
        this.idTokenSubscription.next(this.currentUser);
        const s = (n = (e = this.currentUser) === null || e === void 0 ? void 0 : e.uid) !== null && n !== void 0 ? n : null;
        this.lastNotifiedUid !== s && (this.lastNotifiedUid = s,
            this.authStateSubscription.next(this.currentUser))
    }
    registerStateListener(e, n, s, r) {
        if (this._deleted)
            return () => { }
                ;
        const i = typeof n == "function" ? n : n.next.bind(n);
        let o = !1;
        const l = this._isInitialized ? Promise.resolve() : this._initializationPromise;
        if (Ze(l, this, "internal-error"),
            l.then(() => {
                o || i(this.currentUser)
            }
            ),
            typeof n == "function") {
            const a = e.addObserver(n, s, r);
            return () => {
                o = !0,
                    a()
            }
        } else {
            const a = e.addObserver(n);
            return () => {
                o = !0,
                    a()
            }
        }
    }
    async directlySetCurrentUser(e) {
        this.currentUser && this.currentUser !== e && this._currentUser._stopProactiveRefresh(),
            e && this.isProactiveRefreshEnabled && e._startProactiveRefresh(),
            this.currentUser = e,
            e ? await this.assertedPersistence.setCurrentUser(e) : await this.assertedPersistence.removeCurrentUser()
    }
    queue(e) {
        return this.operations = this.operations.then(e, e),
            this.operations
    }
    get assertedPersistence() {
        return Ze(this.persistenceManager, this, "internal-error"),
            this.persistenceManager
    }
    _logFramework(e) {
        !e || this.frameworks.includes(e) || (this.frameworks.push(e),
            this.frameworks.sort(),
            this.clientVersion = s4(this.config.clientPlatform, this._getFrameworks()))
    }
    _getFrameworks() {
        return this.frameworks
    }
    async _getAdditionalHeaders() {
        var e;
        const n = {
            "X-Client-Version": this.clientVersion
        };
        this.app.options.appId && (n["X-Firebase-gmpid"] = this.app.options.appId);
        const s = await ((e = this.heartbeatServiceProvider.getImmediate({
            optional: !0
        })) === null || e === void 0 ? void 0 : e.getHeartbeatsHeader());
        s && (n["X-Firebase-Client"] = s);
        const r = await this._getAppCheckToken();
        return r && (n["X-Firebase-AppCheck"] = r),
            n
    }
    async _getAppCheckToken() {
        var e;
        const n = await ((e = this.appCheckServiceProvider.getImmediate({
            optional: !0
        })) === null || e === void 0 ? void 0 : e.getToken());
        return n != null && n.error && Dq(`Error while retrieving App Check token: ${n.error}`),
            n == null ? void 0 : n.token
    }
}
function v_(t) {
    return Dr(t)
}
class m2 {
    constructor(e) {
        this.auth = e,
            this.observer = null,
            this.addObserver = gD(n => this.observer = n)
    }
    get next() {
        return Ze(this.observer, this.auth, "internal-error"),
            this.observer.next.bind(this.observer)
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let Nx = {
    async loadJS() {
        throw new Error("Unable to load external scripts")
    },
    recaptchaV2Script: "",
    recaptchaEnterpriseScript: "",
    gapiScript: ""
};
function iK(t) {
    Nx = t
}
function oK(t) {
    return Nx.loadJS(t)
}
function aK() {
    return Nx.gapiScript
}
function lK(t) {
    return `__${t}${Math.floor(Math.random() * 1e6)}`
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function cK(t, e) {
    const n = pc(t, "auth");
    if (n.isInitialized()) {
        const r = n.getImmediate()
            , i = n.getOptions();
        if (yd(i, e ?? {}))
            return r;
        $o(r, "already-initialized")
    }
    return n.initialize({
        options: e
    })
}
function uK(t, e) {
    const n = (e == null ? void 0 : e.persistence) || []
        , s = (Array.isArray(n) ? n : [n]).map(vo);
    e != null && e.errorMap && t._updateErrorMap(e.errorMap),
        t._initializeWithPersistence(s, e == null ? void 0 : e.popupRedirectResolver)
}
function hK(t, e, n) {
    const s = v_(t);
    Ze(s._canInitEmulator, s, "emulator-config-failed"),
        Ze(/^https?:\/\//.test(e), s, "invalid-emulator-scheme");
    const r = !1
        , i = r4(e)
        , { host: o, port: l } = dK(e)
        , a = l === null ? "" : `:${l}`;
    s.config.emulator = {
        url: `${i}//${o}${a}/`
    },
        s.settings.appVerificationDisabledForTesting = !0,
        s.emulatorConfig = Object.freeze({
            host: o,
            port: l,
            protocol: i.replace(":", ""),
            options: Object.freeze({
                disableWarnings: r
            })
        }),
        fK()
}
function r4(t) {
    const e = t.indexOf(":");
    return e < 0 ? "" : t.substr(0, e + 1)
}
function dK(t) {
    const e = r4(t)
        , n = /(\/\/)?([^?#/]+)/.exec(t.substr(e.length));
    if (!n)
        return {
            host: "",
            port: null
        };
    const s = n[2].split("@").pop() || ""
        , r = /^(\[[^\]]+\])(:|$)/.exec(s);
    if (r) {
        const i = r[1];
        return {
            host: i,
            port: g2(s.substr(i.length + 1))
        }
    } else {
        const [i, o] = s.split(":");
        return {
            host: i,
            port: g2(o)
        }
    }
}
function g2(t) {
    if (!t)
        return null;
    const e = Number(t);
    return isNaN(e) ? null : e
}
function fK() {
    function t() {
        const e = document.createElement("p")
            , n = e.style;
        e.innerText = "Running in emulator mode. Do not use with production credentials.",
            n.position = "fixed",
            n.width = "100%",
            n.backgroundColor = "#ffffff",
            n.border = ".1em solid #000000",
            n.color = "#b50000",
            n.bottom = "0px",
            n.left = "0px",
            n.margin = "0px",
            n.zIndex = "10000",
            n.textAlign = "center",
            e.classList.add("firebase-emulator-warning"),
            document.body.appendChild(e)
    }
    typeof console < "u" && typeof console.info == "function" && console.info("WARNING: You are using the Auth Emulator, which is intended for local testing only.  Do not use with production credentials."),
        typeof window < "u" && typeof document < "u" && (document.readyState === "loading" ? window.addEventListener("DOMContentLoaded", t) : t())
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class i4 {
    constructor(e, n) {
        this.providerId = e,
            this.signInMethod = n
    }
    toJSON() {
        return yo("not implemented")
    }
    _getIdTokenResponse(e) {
        return yo("not implemented")
    }
    _linkToIdToken(e, n) {
        return yo("not implemented")
    }
    _getReauthenticationResolver(e) {
        return yo("not implemented")
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function yu(t, e) {
    return YP(t, "POST", "/v1/accounts:signInWithIdp", y_(t, e))
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const pK = "http://localhost";
class sc extends i4 {
    constructor() {
        super(...arguments),
            this.pendingToken = null
    }
    static _fromParams(e) {
        const n = new sc(e.providerId, e.signInMethod);
        return e.idToken || e.accessToken ? (e.idToken && (n.idToken = e.idToken),
            e.accessToken && (n.accessToken = e.accessToken),
            e.nonce && !e.pendingToken && (n.nonce = e.nonce),
            e.pendingToken && (n.pendingToken = e.pendingToken)) : e.oauthToken && e.oauthTokenSecret ? (n.accessToken = e.oauthToken,
                n.secret = e.oauthTokenSecret) : $o("argument-error"),
            n
    }
    toJSON() {
        return {
            idToken: this.idToken,
            accessToken: this.accessToken,
            secret: this.secret,
            nonce: this.nonce,
            pendingToken: this.pendingToken,
            providerId: this.providerId,
            signInMethod: this.signInMethod
        }
    }
    static fromJSON(e) {
        const n = typeof e == "string" ? JSON.parse(e) : e
            , { providerId: s, signInMethod: r } = n
            , i = Rx(n, ["providerId", "signInMethod"]);
        if (!s || !r)
            return null;
        const o = new sc(s, r);
        return o.idToken = i.idToken || void 0,
            o.accessToken = i.accessToken || void 0,
            o.secret = i.secret,
            o.nonce = i.nonce,
            o.pendingToken = i.pendingToken || null,
            o
    }
    _getIdTokenResponse(e) {
        const n = this.buildRequest();
        return yu(e, n)
    }
    _linkToIdToken(e, n) {
        const s = this.buildRequest();
        return s.idToken = n,
            yu(e, s)
    }
    _getReauthenticationResolver(e) {
        const n = this.buildRequest();
        return n.autoCreate = !1,
            yu(e, n)
    }
    buildRequest() {
        const e = {
            requestUri: pK,
            returnSecureToken: !0
        };
        if (this.pendingToken)
            e.pendingToken = this.pendingToken;
        else {
            const n = {};
            this.idToken && (n.id_token = this.idToken),
                this.accessToken && (n.access_token = this.accessToken),
                this.secret && (n.oauth_token_secret = this.secret),
                n.providerId = this.providerId,
                this.nonce && !this.pendingToken && (n.nonce = this.nonce),
                e.postBody = nf(n)
        }
        return e
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class o4 {
    constructor(e) {
        this.providerId = e,
            this.defaultLanguageCode = null,
            this.customParameters = {}
    }
    setDefaultLanguage(e) {
        this.defaultLanguageCode = e
    }
    setCustomParameters(e) {
        return this.customParameters = e,
            this
    }
    getCustomParameters() {
        return this.customParameters
    }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class pf extends o4 {
    constructor() {
        super(...arguments),
            this.scopes = []
    }
    addScope(e) {
        return this.scopes.includes(e) || this.scopes.push(e),
            this
    }
    getScopes() {
        return [...this.scopes]
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ea extends pf {
    constructor() {
        super("facebook.com")
    }
    static credential(e) {
        return sc._fromParams({
            providerId: Ea.PROVIDER_ID,
            signInMethod: Ea.FACEBOOK_SIGN_IN_METHOD,
            accessToken: e
        })
    }
    static credentialFromResult(e) {
        return Ea.credentialFromTaggedObject(e)
    }
    static credentialFromError(e) {
        return Ea.credentialFromTaggedObject(e.customData || {})
    }
    static credentialFromTaggedObject({ _tokenResponse: e }) {
        if (!e || !("oauthAccessToken" in e) || !e.oauthAccessToken)
            return null;
        try {
            return Ea.credential(e.oauthAccessToken)
        } catch {
            return null
        }
    }
}
Ea.FACEBOOK_SIGN_IN_METHOD = "facebook.com";
Ea.PROVIDER_ID = "facebook.com";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ta extends pf {
    constructor() {
        super("google.com"),
            this.addScope("profile")
    }
    static credential(e, n) {
        return sc._fromParams({
            providerId: Ta.PROVIDER_ID,
            signInMethod: Ta.GOOGLE_SIGN_IN_METHOD,
            idToken: e,
            accessToken: n
        })
    }
    static credentialFromResult(e) {
        return Ta.credentialFromTaggedObject(e)
    }
    static credentialFromError(e) {
        return Ta.credentialFromTaggedObject(e.customData || {})
    }
    static credentialFromTaggedObject({ _tokenResponse: e }) {
        if (!e)
            return null;
        const { oauthIdToken: n, oauthAccessToken: s } = e;
        if (!n && !s)
            return null;
        try {
            return Ta.credential(n, s)
        } catch {
            return null
        }
    }
}
Ta.GOOGLE_SIGN_IN_METHOD = "google.com";
Ta.PROVIDER_ID = "google.com";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ca extends pf {
    constructor() {
        super("github.com")
    }
    static credential(e) {
        return sc._fromParams({
            providerId: Ca.PROVIDER_ID,
            signInMethod: Ca.GITHUB_SIGN_IN_METHOD,
            accessToken: e
        })
    }
    static credentialFromResult(e) {
        return Ca.credentialFromTaggedObject(e)
    }
    static credentialFromError(e) {
        return Ca.credentialFromTaggedObject(e.customData || {})
    }
    static credentialFromTaggedObject({ _tokenResponse: e }) {
        if (!e || !("oauthAccessToken" in e) || !e.oauthAccessToken)
            return null;
        try {
            return Ca.credential(e.oauthAccessToken)
        } catch {
            return null
        }
    }
}
Ca.GITHUB_SIGN_IN_METHOD = "github.com";
Ca.PROVIDER_ID = "github.com";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ia extends pf {
    constructor() {
        super("twitter.com")
    }
    static credential(e, n) {
        return sc._fromParams({
            providerId: Ia.PROVIDER_ID,
            signInMethod: Ia.TWITTER_SIGN_IN_METHOD,
            oauthToken: e,
            oauthTokenSecret: n
        })
    }
    static credentialFromResult(e) {
        return Ia.credentialFromTaggedObject(e)
    }
    static credentialFromError(e) {
        return Ia.credentialFromTaggedObject(e.customData || {})
    }
    static credentialFromTaggedObject({ _tokenResponse: e }) {
        if (!e)
            return null;
        const { oauthAccessToken: n, oauthTokenSecret: s } = e;
        if (!n || !s)
            return null;
        try {
            return Ia.credential(n, s)
        } catch {
            return null
        }
    }
}
Ia.TWITTER_SIGN_IN_METHOD = "twitter.com";
Ia.PROVIDER_ID = "twitter.com";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class rc {
    constructor(e) {
        this.user = e.user,
            this.providerId = e.providerId,
            this._tokenResponse = e._tokenResponse,
            this.operationType = e.operationType
    }
    static async _fromIdTokenResponse(e, n, s, r = !1) {
        const i = await bo._fromIdTokenResponse(e, s, r)
            , o = _2(s);
        return new rc({
            user: i,
            providerId: o,
            _tokenResponse: s,
            operationType: n
        })
    }
    static async _forOperation(e, n, s) {
        await e._updateTokensIfNecessary(s, !0);
        const r = _2(s);
        return new rc({
            user: e,
            providerId: r,
            _tokenResponse: s,
            operationType: n
        })
    }
}
function _2(t) {
    return t.providerId ? t.providerId : "phoneNumber" in t ? "phone" : null
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Fm extends fi {
    constructor(e, n, s, r) {
        var i;
        super(n.code, n.message),
            this.operationType = s,
            this.user = r,
            Object.setPrototypeOf(this, Fm.prototype),
            this.customData = {
                appName: e.name,
                tenantId: (i = e.tenantId) !== null && i !== void 0 ? i : void 0,
                _serverResponse: n.customData._serverResponse,
                operationType: s
            }
    }
    static _fromErrorAndOperation(e, n, s, r) {
        return new Fm(e, n, s, r)
    }
}
function a4(t, e, n, s) {
    return (e === "reauthenticate" ? n._getReauthenticationResolver(t) : n._getIdTokenResponse(t)).catch(i => {
        throw i.code === "auth/multi-factor-auth-required" ? Fm._fromErrorAndOperation(t, i, e, s) : i
    }
    )
}
async function mK(t, e, n = !1) {
    const s = await Rd(t, e._linkToIdToken(t.auth, await t.getIdToken()), n);
    return rc._forOperation(t, "link", s)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function gK(t, e, n = !1) {
    const { auth: s } = t;
    if (go(s.app))
        return Promise.reject($a(s));
    const r = "reauthenticate";
    try {
        const i = await Rd(t, a4(s, r, e, t), n);
        Ze(i.idToken, s, "internal-error");
        const o = Lx(i.idToken);
        Ze(o, s, "internal-error");
        const { sub: l } = o;
        return Ze(t.uid === l, s, "user-mismatch"),
            rc._forOperation(t, r, i)
    } catch (i) {
        throw (i == null ? void 0 : i.code) === "auth/user-not-found" && $o(s, "user-mismatch"),
        i
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function _K(t, e, n = !1) {
    if (go(t.app))
        return Promise.reject($a(t));
    const s = "signIn"
        , r = await a4(t, s, e)
        , i = await rc._fromIdTokenResponse(t, s, r);
    return n || await t._updateCurrentUser(i.user),
        i
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function yK(t, e) {
    return YP(t, "POST", "/v1/accounts:signInWithCustomToken", y_(t, e))
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function bK(t, e) {
    if (go(t.app))
        return Promise.reject($a(t));
    const n = v_(t)
        , s = await yK(n, {
            token: e,
            returnSecureToken: !0
        })
        , r = await rc._fromIdTokenResponse(n, "signIn", s);
    return await n._updateCurrentUser(r.user),
        r
}
function vK(t, e, n, s) {
    return Dr(t).onIdTokenChanged(e, n, s)
}
function xK(t, e, n) {
    return Dr(t).beforeAuthStateChanged(e, n)
}
const $m = "__sak";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class l4 {
    constructor(e, n) {
        this.storageRetriever = e,
            this.type = n
    }
    _isAvailable() {
        try {
            return this.storage ? (this.storage.setItem($m, "1"),
                this.storage.removeItem($m),
                Promise.resolve(!0)) : Promise.resolve(!1)
        } catch {
            return Promise.resolve(!1)
        }
    }
    _set(e, n) {
        return this.storage.setItem(e, JSON.stringify(n)),
            Promise.resolve()
    }
    _get(e) {
        const n = this.storage.getItem(e);
        return Promise.resolve(n ? JSON.parse(n) : null)
    }
    _remove(e) {
        return this.storage.removeItem(e),
            Promise.resolve()
    }
    get storage() {
        return this.storageRetriever()
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function wK() {
    const t = ms();
    return Ox(t) || b_(t)
}
const SK = 1e3
    , EK = 10;
class c4 extends l4 {
    constructor() {
        super(() => window.localStorage, "LOCAL"),
            this.boundEventHandler = (e, n) => this.onStorageEvent(e, n),
            this.listeners = {},
            this.localCache = {},
            this.pollTimer = null,
            this.safariLocalStorageNotSynced = wK() && Qq(),
            this.fallbackToPolling = n4(),
            this._shouldAllowMigration = !0
    }
    forAllChangedKeys(e) {
        for (const n of Object.keys(this.listeners)) {
            const s = this.storage.getItem(n)
                , r = this.localCache[n];
            s !== r && e(n, r, s)
        }
    }
    onStorageEvent(e, n = !1) {
        if (!e.key) {
            this.forAllChangedKeys((o, l, a) => {
                this.notifyListeners(o, a)
            }
            );
            return
        }
        const s = e.key;
        if (n ? this.detachListener() : this.stopPolling(),
            this.safariLocalStorageNotSynced) {
            const o = this.storage.getItem(s);
            if (e.newValue !== o)
                e.newValue !== null ? this.storage.setItem(s, e.newValue) : this.storage.removeItem(s);
            else if (this.localCache[s] === e.newValue && !n)
                return
        }
        const r = () => {
            const o = this.storage.getItem(s);
            !n && this.localCache[s] === o || this.notifyListeners(s, o)
        }
            , i = this.storage.getItem(s);
        Zq() && i !== e.newValue && e.newValue !== e.oldValue ? setTimeout(r, EK) : r()
    }
    notifyListeners(e, n) {
        this.localCache[e] = n;
        const s = this.listeners[e];
        if (s)
            for (const r of Array.from(s))
                r(n && JSON.parse(n))
    }
    startPolling() {
        this.stopPolling(),
            this.pollTimer = setInterval(() => {
                this.forAllChangedKeys((e, n, s) => {
                    this.onStorageEvent(new StorageEvent("storage", {
                        key: e,
                        oldValue: n,
                        newValue: s
                    }), !0)
                }
                )
            }
                , SK)
    }
    stopPolling() {
        this.pollTimer && (clearInterval(this.pollTimer),
            this.pollTimer = null)
    }
    attachListener() {
        window.addEventListener("storage", this.boundEventHandler)
    }
    detachListener() {
        window.removeEventListener("storage", this.boundEventHandler)
    }
    _addListener(e, n) {
        Object.keys(this.listeners).length === 0 && (this.fallbackToPolling ? this.startPolling() : this.attachListener()),
            this.listeners[e] || (this.listeners[e] = new Set,
                this.localCache[e] = this.storage.getItem(e)),
            this.listeners[e].add(n)
    }
    _removeListener(e, n) {
        this.listeners[e] && (this.listeners[e].delete(n),
            this.listeners[e].size === 0 && delete this.listeners[e]),
            Object.keys(this.listeners).length === 0 && (this.detachListener(),
                this.stopPolling())
    }
    async _set(e, n) {
        await super._set(e, n),
            this.localCache[e] = JSON.stringify(n)
    }
    async _get(e) {
        const n = await super._get(e);
        return this.localCache[e] = JSON.stringify(n),
            n
    }
    async _remove(e) {
        await super._remove(e),
            delete this.localCache[e]
    }
}
c4.type = "LOCAL";
const TK = c4;
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class u4 extends l4 {
    constructor() {
        super(() => window.sessionStorage, "SESSION")
    }
    _addListener(e, n) { }
    _removeListener(e, n) { }
}
u4.type = "SESSION";
const h4 = u4;
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function CK(t) {
    return Promise.all(t.map(async e => {
        try {
            return {
                fulfilled: !0,
                value: await e
            }
        } catch (n) {
            return {
                fulfilled: !1,
                reason: n
            }
        }
    }
    ))
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class x_ {
    constructor(e) {
        this.eventTarget = e,
            this.handlersMap = {},
            this.boundEventHandler = this.handleEvent.bind(this)
    }
    static _getInstance(e) {
        const n = this.receivers.find(r => r.isListeningto(e));
        if (n)
            return n;
        const s = new x_(e);
        return this.receivers.push(s),
            s
    }
    isListeningto(e) {
        return this.eventTarget === e
    }
    async handleEvent(e) {
        const n = e
            , { eventId: s, eventType: r, data: i } = n.data
            , o = this.handlersMap[r];
        if (!(o != null && o.size))
            return;
        n.ports[0].postMessage({
            status: "ack",
            eventId: s,
            eventType: r
        });
        const l = Array.from(o).map(async c => c(n.origin, i))
            , a = await CK(l);
        n.ports[0].postMessage({
            status: "done",
            eventId: s,
            eventType: r,
            response: a
        })
    }
    _subscribe(e, n) {
        Object.keys(this.handlersMap).length === 0 && this.eventTarget.addEventListener("message", this.boundEventHandler),
            this.handlersMap[e] || (this.handlersMap[e] = new Set),
            this.handlersMap[e].add(n)
    }
    _unsubscribe(e, n) {
        this.handlersMap[e] && n && this.handlersMap[e].delete(n),
            (!n || this.handlersMap[e].size === 0) && delete this.handlersMap[e],
            Object.keys(this.handlersMap).length === 0 && this.eventTarget.removeEventListener("message", this.boundEventHandler)
    }
}
x_.receivers = [];
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Dx(t = "", e = 10) {
    let n = "";
    for (let s = 0; s < e; s++)
        n += Math.floor(Math.random() * 10);
    return t + n
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class IK {
    constructor(e) {
        this.target = e,
            this.handlers = new Set
    }
    removeMessageHandler(e) {
        e.messageChannel && (e.messageChannel.port1.removeEventListener("message", e.onMessage),
            e.messageChannel.port1.close()),
            this.handlers.delete(e)
    }
    async _send(e, n, s = 50) {
        const r = typeof MessageChannel < "u" ? new MessageChannel : null;
        if (!r)
            throw new Error("connection_unavailable");
        let i, o;
        return new Promise((l, a) => {
            const c = Dx("", 20);
            r.port1.start();
            const u = setTimeout(() => {
                a(new Error("unsupported_event"))
            }
                , s);
            o = {
                messageChannel: r,
                onMessage(h) {
                    const d = h;
                    if (d.data.eventId === c)
                        switch (d.data.status) {
                            case "ack":
                                clearTimeout(u),
                                    i = setTimeout(() => {
                                        a(new Error("timeout"))
                                    }
                                        , 3e3);
                                break;
                            case "done":
                                clearTimeout(i),
                                    l(d.data.response);
                                break;
                            default:
                                clearTimeout(u),
                                    clearTimeout(i),
                                    a(new Error("invalid_response"));
                                break
                        }
                }
            },
                this.handlers.add(o),
                r.port1.addEventListener("message", o.onMessage),
                this.target.postMessage({
                    eventType: e,
                    eventId: c,
                    data: n
                }, [r.port2])
        }
        ).finally(() => {
            o && this.removeMessageHandler(o)
        }
        )
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Vi() {
    return window
}
function AK(t) {
    Vi().location.href = t
}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function d4() {
    return typeof Vi().WorkerGlobalScope < "u" && typeof Vi().importScripts == "function"
}
async function kK() {
    if (!(navigator != null && navigator.serviceWorker))
        return null;
    try {
        return (await navigator.serviceWorker.ready).active
    } catch {
        return null
    }
}
function RK() {
    var t;
    return ((t = navigator == null ? void 0 : navigator.serviceWorker) === null || t === void 0 ? void 0 : t.controller) || null
}
function MK() {
    return d4() ? self : null
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const f4 = "firebaseLocalStorageDb"
    , PK = 1
    , Um = "firebaseLocalStorage"
    , p4 = "fbase_key";
class mf {
    constructor(e) {
        this.request = e
    }
    toPromise() {
        return new Promise((e, n) => {
            this.request.addEventListener("success", () => {
                e(this.request.result)
            }
            ),
                this.request.addEventListener("error", () => {
                    n(this.request.error)
                }
                )
        }
        )
    }
}
function w_(t, e) {
    return t.transaction([Um], e ? "readwrite" : "readonly").objectStore(Um)
}
function LK() {
    const t = indexedDB.deleteDatabase(f4);
    return new mf(t).toPromise()
}
function Ky() {
    const t = indexedDB.open(f4, PK);
    return new Promise((e, n) => {
        t.addEventListener("error", () => {
            n(t.error)
        }
        ),
            t.addEventListener("upgradeneeded", () => {
                const s = t.result;
                try {
                    s.createObjectStore(Um, {
                        keyPath: p4
                    })
                } catch (r) {
                    n(r)
                }
            }
            ),
            t.addEventListener("success", async () => {
                const s = t.result;
                s.objectStoreNames.contains(Um) ? e(s) : (s.close(),
                    await LK(),
                    e(await Ky()))
            }
            )
    }
    )
}
async function y2(t, e, n) {
    const s = w_(t, !0).put({
        [p4]: e,
        value: n
    });
    return new mf(s).toPromise()
}
async function OK(t, e) {
    const n = w_(t, !1).get(e)
        , s = await new mf(n).toPromise();
    return s === void 0 ? null : s.value
}
function b2(t, e) {
    const n = w_(t, !0).delete(e);
    return new mf(n).toPromise()
}
const NK = 800
    , DK = 3;
class m4 {
    constructor() {
        this.type = "LOCAL",
            this._shouldAllowMigration = !0,
            this.listeners = {},
            this.localCache = {},
            this.pollTimer = null,
            this.pendingWrites = 0,
            this.receiver = null,
            this.sender = null,
            this.serviceWorkerReceiverAvailable = !1,
            this.activeServiceWorker = null,
            this._workerInitializationPromise = this.initializeServiceWorkerMessaging().then(() => { }
                , () => { }
            )
    }
    async _openDb() {
        return this.db ? this.db : (this.db = await Ky(),
            this.db)
    }
    async _withRetries(e) {
        let n = 0;
        for (; ;)
            try {
                const s = await this._openDb();
                return await e(s)
            } catch (s) {
                if (n++ > DK)
                    throw s;
                this.db && (this.db.close(),
                    this.db = void 0)
            }
    }
    async initializeServiceWorkerMessaging() {
        return d4() ? this.initializeReceiver() : this.initializeSender()
    }
    async initializeReceiver() {
        this.receiver = x_._getInstance(MK()),
            this.receiver._subscribe("keyChanged", async (e, n) => ({
                keyProcessed: (await this._poll()).includes(n.key)
            })),
            this.receiver._subscribe("ping", async (e, n) => ["keyChanged"])
    }
    async initializeSender() {
        var e, n;
        if (this.activeServiceWorker = await kK(),
            !this.activeServiceWorker)
            return;
        this.sender = new IK(this.activeServiceWorker);
        const s = await this.sender._send("ping", {}, 800);
        s && !((e = s[0]) === null || e === void 0) && e.fulfilled && !((n = s[0]) === null || n === void 0) && n.value.includes("keyChanged") && (this.serviceWorkerReceiverAvailable = !0)
    }
    async notifyServiceWorker(e) {
        if (!(!this.sender || !this.activeServiceWorker || RK() !== this.activeServiceWorker))
            try {
                await this.sender._send("keyChanged", {
                    key: e
                }, this.serviceWorkerReceiverAvailable ? 800 : 50)
            } catch { }
    }
    async _isAvailable() {
        try {
            if (!indexedDB)
                return !1;
            const e = await Ky();
            return await y2(e, $m, "1"),
                await b2(e, $m),
                !0
        } catch { }
        return !1
    }
    async _withPendingWrite(e) {
        this.pendingWrites++;
        try {
            await e()
        } finally {
            this.pendingWrites--
        }
    }
    async _set(e, n) {
        return this._withPendingWrite(async () => (await this._withRetries(s => y2(s, e, n)),
            this.localCache[e] = n,
            this.notifyServiceWorker(e)))
    }
    async _get(e) {
        const n = await this._withRetries(s => OK(s, e));
        return this.localCache[e] = n,
            n
    }
    async _remove(e) {
        return this._withPendingWrite(async () => (await this._withRetries(n => b2(n, e)),
            delete this.localCache[e],
            this.notifyServiceWorker(e)))
    }
    async _poll() {
        const e = await this._withRetries(r => {
            const i = w_(r, !1).getAll();
            return new mf(i).toPromise()
        }
        );
        if (!e)
            return [];
        if (this.pendingWrites !== 0)
            return [];
        const n = []
            , s = new Set;
        if (e.length !== 0)
            for (const { fbase_key: r, value: i } of e)
                s.add(r),
                    JSON.stringify(this.localCache[r]) !== JSON.stringify(i) && (this.notifyListeners(r, i),
                        n.push(r));
        for (const r of Object.keys(this.localCache))
            this.localCache[r] && !s.has(r) && (this.notifyListeners(r, null),
                n.push(r));
        return n
    }
    notifyListeners(e, n) {
        this.localCache[e] = n;
        const s = this.listeners[e];
        if (s)
            for (const r of Array.from(s))
                r(n)
    }
    startPolling() {
        this.stopPolling(),
            this.pollTimer = setInterval(async () => this._poll(), NK)
    }
    stopPolling() {
        this.pollTimer && (clearInterval(this.pollTimer),
            this.pollTimer = null)
    }
    _addListener(e, n) {
        Object.keys(this.listeners).length === 0 && this.startPolling(),
            this.listeners[e] || (this.listeners[e] = new Set,
                this._get(e)),
            this.listeners[e].add(n)
    }
    _removeListener(e, n) {
        this.listeners[e] && (this.listeners[e].delete(n),
            this.listeners[e].size === 0 && delete this.listeners[e]),
            Object.keys(this.listeners).length === 0 && this.stopPolling()
    }
}
m4.type = "LOCAL";
const BK = m4;
new ff(3e4, 6e4);
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function FK(t, e) {
    return e ? vo(e) : (Ze(t._popupRedirectResolver, t, "argument-error"),
        t._popupRedirectResolver)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Bx extends i4 {
    constructor(e) {
        super("custom", "custom"),
            this.params = e
    }
    _getIdTokenResponse(e) {
        return yu(e, this._buildIdpRequest())
    }
    _linkToIdToken(e, n) {
        return yu(e, this._buildIdpRequest(n))
    }
    _getReauthenticationResolver(e) {
        return yu(e, this._buildIdpRequest())
    }
    _buildIdpRequest(e) {
        const n = {
            requestUri: this.params.requestUri,
            sessionId: this.params.sessionId,
            postBody: this.params.postBody,
            tenantId: this.params.tenantId,
            pendingToken: this.params.pendingToken,
            returnSecureToken: !0,
            returnIdpCredential: !0
        };
        return e && (n.idToken = e),
            n
    }
}
function $K(t) {
    return _K(t.auth, new Bx(t), t.bypassAuthState)
}
function UK(t) {
    const { auth: e, user: n } = t;
    return Ze(n, e, "internal-error"),
        gK(n, new Bx(t), t.bypassAuthState)
}
async function VK(t) {
    const { auth: e, user: n } = t;
    return Ze(n, e, "internal-error"),
        mK(n, new Bx(t), t.bypassAuthState)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class g4 {
    constructor(e, n, s, r, i = !1) {
        this.auth = e,
            this.resolver = s,
            this.user = r,
            this.bypassAuthState = i,
            this.pendingPromise = null,
            this.eventManager = null,
            this.filter = Array.isArray(n) ? n : [n]
    }
    execute() {
        return new Promise(async (e, n) => {
            this.pendingPromise = {
                resolve: e,
                reject: n
            };
            try {
                this.eventManager = await this.resolver._initialize(this.auth),
                    await this.onExecution(),
                    this.eventManager.registerConsumer(this)
            } catch (s) {
                this.reject(s)
            }
        }
        )
    }
    async onAuthEvent(e) {
        const { urlResponse: n, sessionId: s, postBody: r, tenantId: i, error: o, type: l } = e;
        if (o) {
            this.reject(o);
            return
        }
        const a = {
            auth: this.auth,
            requestUri: n,
            sessionId: s,
            tenantId: i || void 0,
            postBody: r || void 0,
            user: this.user,
            bypassAuthState: this.bypassAuthState
        };
        try {
            this.resolve(await this.getIdpTask(l)(a))
        } catch (c) {
            this.reject(c)
        }
    }
    onError(e) {
        this.reject(e)
    }
    getIdpTask(e) {
        switch (e) {
            case "signInViaPopup":
            case "signInViaRedirect":
                return $K;
            case "linkViaPopup":
            case "linkViaRedirect":
                return VK;
            case "reauthViaPopup":
            case "reauthViaRedirect":
                return UK;
            default:
                $o(this.auth, "internal-error")
        }
    }
    resolve(e) {
        Uo(this.pendingPromise, "Pending promise was never set"),
            this.pendingPromise.resolve(e),
            this.unregisterAndCleanUp()
    }
    reject(e) {
        Uo(this.pendingPromise, "Pending promise was never set"),
            this.pendingPromise.reject(e),
            this.unregisterAndCleanUp()
    }
    unregisterAndCleanUp() {
        this.eventManager && this.eventManager.unregisterConsumer(this),
            this.pendingPromise = null,
            this.cleanUp()
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const GK = new ff(2e3, 1e4);
class tu extends g4 {
    constructor(e, n, s, r, i) {
        super(e, n, r, i),
            this.provider = s,
            this.authWindow = null,
            this.pollId = null,
            tu.currentPopupAction && tu.currentPopupAction.cancel(),
            tu.currentPopupAction = this
    }
    async executeNotNull() {
        const e = await this.execute();
        return Ze(e, this.auth, "internal-error"),
            e
    }
    async onExecution() {
        Uo(this.filter.length === 1, "Popup operations only handle one event");
        const e = Dx();
        this.authWindow = await this.resolver._openPopup(this.auth, this.provider, this.filter[0], e),
            this.authWindow.associatedEvent = e,
            this.resolver._originValidation(this.auth).catch(n => {
                this.reject(n)
            }
            ),
            this.resolver._isIframeWebStorageSupported(this.auth, n => {
                n || this.reject(Ui(this.auth, "web-storage-unsupported"))
            }
            ),
            this.pollUserCancellation()
    }
    get eventId() {
        var e;
        return ((e = this.authWindow) === null || e === void 0 ? void 0 : e.associatedEvent) || null
    }
    cancel() {
        this.reject(Ui(this.auth, "cancelled-popup-request"))
    }
    cleanUp() {
        this.authWindow && this.authWindow.close(),
            this.pollId && window.clearTimeout(this.pollId),
            this.authWindow = null,
            this.pollId = null,
            tu.currentPopupAction = null
    }
    pollUserCancellation() {
        const e = () => {
            var n, s;
            if (!((s = (n = this.authWindow) === null || n === void 0 ? void 0 : n.window) === null || s === void 0) && s.closed) {
                this.pollId = window.setTimeout(() => {
                    this.pollId = null,
                        this.reject(Ui(this.auth, "popup-closed-by-user"))
                }
                    , 8e3);
                return
            }
            this.pollId = window.setTimeout(e, GK.get())
        }
            ;
        e()
    }
}
tu.currentPopupAction = null;
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const HK = "pendingRedirect"
    , Yp = new Map;
class WK extends g4 {
    constructor(e, n, s = !1) {
        super(e, ["signInViaRedirect", "linkViaRedirect", "reauthViaRedirect", "unknown"], n, void 0, s),
            this.eventId = null
    }
    async execute() {
        let e = Yp.get(this.auth._key());
        if (!e) {
            try {
                const s = await YK(this.resolver, this.auth) ? await super.execute() : null;
                e = () => Promise.resolve(s)
            } catch (n) {
                e = () => Promise.reject(n)
            }
            Yp.set(this.auth._key(), e)
        }
        return this.bypassAuthState || Yp.set(this.auth._key(), () => Promise.resolve(null)),
            e()
    }
    async onAuthEvent(e) {
        if (e.type === "signInViaRedirect")
            return super.onAuthEvent(e);
        if (e.type === "unknown") {
            this.resolve(null);
            return
        }
        if (e.eventId) {
            const n = await this.auth._redirectUserForId(e.eventId);
            if (n)
                return this.user = n,
                    super.onAuthEvent(e);
            this.resolve(null)
        }
    }
    async onExecution() { }
    cleanUp() { }
}
async function YK(t, e) {
    const n = zK(e)
        , s = jK(t);
    if (!await s._isAvailable())
        return !1;
    const r = await s._get(n) === "true";
    return await s._remove(n),
        r
}
function XK(t, e) {
    Yp.set(t._key(), e)
}
function jK(t) {
    return vo(t._redirectPersistence)
}
function zK(t) {
    return Wp(HK, t.config.apiKey, t.name)
}
async function qK(t, e, n = !1) {
    if (go(t.app))
        return Promise.reject($a(t));
    const s = v_(t)
        , r = FK(s, e)
        , o = await new WK(s, r, n).execute();
    return o && !n && (delete o.user._redirectEventId,
        await s._persistUserIfCurrent(o.user),
        await s._setRedirectUser(null, e)),
        o
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const KK = 10 * 60 * 1e3;
class JK {
    constructor(e) {
        this.auth = e,
            this.cachedEventUids = new Set,
            this.consumers = new Set,
            this.queuedRedirectEvent = null,
            this.hasHandledPotentialRedirect = !1,
            this.lastProcessedEventTime = Date.now()
    }
    registerConsumer(e) {
        this.consumers.add(e),
            this.queuedRedirectEvent && this.isEventForConsumer(this.queuedRedirectEvent, e) && (this.sendToConsumer(this.queuedRedirectEvent, e),
                this.saveEventToCache(this.queuedRedirectEvent),
                this.queuedRedirectEvent = null)
    }
    unregisterConsumer(e) {
        this.consumers.delete(e)
    }
    onEvent(e) {
        if (this.hasEventBeenHandled(e))
            return !1;
        let n = !1;
        return this.consumers.forEach(s => {
            this.isEventForConsumer(e, s) && (n = !0,
                this.sendToConsumer(e, s),
                this.saveEventToCache(e))
        }
        ),
            this.hasHandledPotentialRedirect || !ZK(e) || (this.hasHandledPotentialRedirect = !0,
                n || (this.queuedRedirectEvent = e,
                    n = !0)),
            n
    }
    sendToConsumer(e, n) {
        var s;
        if (e.error && !_4(e)) {
            const r = ((s = e.error.code) === null || s === void 0 ? void 0 : s.split("auth/")[1]) || "internal-error";
            n.onError(Ui(this.auth, r))
        } else
            n.onAuthEvent(e)
    }
    isEventForConsumer(e, n) {
        const s = n.eventId === null || !!e.eventId && e.eventId === n.eventId;
        return n.filter.includes(e.type) && s
    }
    hasEventBeenHandled(e) {
        return Date.now() - this.lastProcessedEventTime >= KK && this.cachedEventUids.clear(),
            this.cachedEventUids.has(v2(e))
    }
    saveEventToCache(e) {
        this.cachedEventUids.add(v2(e)),
            this.lastProcessedEventTime = Date.now()
    }
}
function v2(t) {
    return [t.type, t.eventId, t.sessionId, t.tenantId].filter(e => e).join("-")
}
function _4({ type: t, error: e }) {
    return t === "unknown" && (e == null ? void 0 : e.code) === "auth/no-auth-event"
}
function ZK(t) {
    switch (t.type) {
        case "signInViaRedirect":
        case "linkViaRedirect":
        case "reauthViaRedirect":
            return !0;
        case "unknown":
            return _4(t);
        default:
            return !1
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function QK(t, e = {}) {
    return lh(t, "GET", "/v1/projects", e)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const eJ = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/
    , tJ = /^https?/;
async function nJ(t) {
    if (t.config.emulator)
        return;
    const { authorizedDomains: e } = await QK(t);
    for (const n of e)
        try {
            if (sJ(n))
                return
        } catch { }
    $o(t, "unauthorized-domain")
}
function sJ(t) {
    const e = zy()
        , { protocol: n, hostname: s } = new URL(e);
    if (t.startsWith("chrome-extension://")) {
        const o = new URL(t);
        return o.hostname === "" && s === "" ? n === "chrome-extension:" && t.replace("chrome-extension://", "") === e.replace("chrome-extension://", "") : n === "chrome-extension:" && o.hostname === s
    }
    if (!tJ.test(n))
        return !1;
    if (eJ.test(t))
        return s === t;
    const r = t.replace(/\./g, "\\.");
    return new RegExp("^(.+\\." + r + "|" + r + ")$", "i").test(s)
}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const rJ = new ff(3e4, 6e4);
function x2() {
    const t = Vi().___jsl;
    if (t != null && t.H) {
        for (const e of Object.keys(t.H))
            if (t.H[e].r = t.H[e].r || [],
                t.H[e].L = t.H[e].L || [],
                t.H[e].r = [...t.H[e].L],
                t.CP)
                for (let n = 0; n < t.CP.length; n++)
                    t.CP[n] = null
    }
}
function iJ(t) {
    return new Promise((e, n) => {
        var s, r, i;
        function o() {
            x2(),
                gapi.load("gapi.iframes", {
                    callback: () => {
                        e(gapi.iframes.getContext())
                    }
                    ,
                    ontimeout: () => {
                        x2(),
                            n(Ui(t, "network-request-failed"))
                    }
                    ,
                    timeout: rJ.get()
                })
        }
        if (!((r = (s = Vi().gapi) === null || s === void 0 ? void 0 : s.iframes) === null || r === void 0) && r.Iframe)
            e(gapi.iframes.getContext());
        else if (!((i = Vi().gapi) === null || i === void 0) && i.load)
            o();
        else {
            const l = lK("iframefcb");
            return Vi()[l] = () => {
                gapi.load ? o() : n(Ui(t, "network-request-failed"))
            }
                ,
                oK(`${aK()}?onload=${l}`).catch(a => n(a))
        }
    }
    ).catch(e => {
        throw Xp = null,
        e
    }
    )
}
let Xp = null;
function oJ(t) {
    return Xp = Xp || iJ(t),
        Xp
}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const aJ = new ff(5e3, 15e3)
    , lJ = "__/auth/iframe"
    , cJ = "emulator/auth/iframe"
    , uJ = {
        style: {
            position: "absolute",
            top: "-100px",
            width: "1px",
            height: "1px"
        },
        "aria-hidden": "true",
        tabindex: "-1"
    }
    , hJ = new Map([["identitytoolkit.googleapis.com", "p"], ["staging-identitytoolkit.sandbox.googleapis.com", "s"], ["test-identitytoolkit.sandbox.googleapis.com", "t"]]);
function dJ(t) {
    const e = t.config;
    Ze(e.authDomain, t, "auth-domain-config-required");
    const n = e.emulator ? Px(e, cJ) : `https://${t.config.authDomain}/${lJ}`
        , s = {
            apiKey: e.apiKey,
            appName: t.name,
            v: sf
        }
        , r = hJ.get(t.config.apiHost);
    r && (s.eid = r);
    const i = t._getFrameworks();
    return i.length && (s.fw = i.join(",")),
        `${n}?${nf(s).slice(1)}`
}
async function fJ(t) {
    const e = await oJ(t)
        , n = Vi().gapi;
    return Ze(n, t, "internal-error"),
        e.open({
            where: document.body,
            url: dJ(t),
            messageHandlersFilter: n.iframes.CROSS_ORIGIN_IFRAMES_FILTER,
            attributes: uJ,
            dontclear: !0
        }, s => new Promise(async (r, i) => {
            await s.restyle({
                setHideOnLeave: !1
            });
            const o = Ui(t, "network-request-failed")
                , l = Vi().setTimeout(() => {
                    i(o)
                }
                    , aJ.get());
            function a() {
                Vi().clearTimeout(l),
                    r(s)
            }
            s.ping(a).then(a, () => {
                i(o)
            }
            )
        }
        ))
}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const pJ = {
    location: "yes",
    resizable: "yes",
    statusbar: "yes",
    toolbar: "no"
}
    , mJ = 500
    , gJ = 600
    , _J = "_blank"
    , yJ = "http://localhost";
class w2 {
    constructor(e) {
        this.window = e,
            this.associatedEvent = null
    }
    close() {
        if (this.window)
            try {
                this.window.close()
            } catch { }
    }
}
function bJ(t, e, n, s = mJ, r = gJ) {
    const i = Math.max((window.screen.availHeight - r) / 2, 0).toString()
        , o = Math.max((window.screen.availWidth - s) / 2, 0).toString();
    let l = "";
    const a = Object.assign(Object.assign({}, pJ), {
        width: s.toString(),
        height: r.toString(),
        top: i,
        left: o
    })
        , c = ms().toLowerCase();
    n && (l = JP(c) ? _J : n),
        KP(c) && (e = e || yJ,
            a.scrollbars = "yes");
    const u = Object.entries(a).reduce((d, [f, p]) => `${d}${f}=${p},`, "");
    if (Jq(c) && l !== "_self")
        return vJ(e || "", l),
            new w2(null);
    const h = window.open(e || "", l, u);
    Ze(h, t, "popup-blocked");
    try {
        h.focus()
    } catch { }
    return new w2(h)
}
function vJ(t, e) {
    const n = document.createElement("a");
    n.href = t,
        n.target = e;
    const s = document.createEvent("MouseEvent");
    s.initMouseEvent("click", !0, !0, window, 1, 0, 0, 0, 0, !1, !1, !1, !1, 1, null),
        n.dispatchEvent(s)
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const xJ = "__/auth/handler"
    , wJ = "emulator/auth/handler"
    , SJ = encodeURIComponent("fac");
async function S2(t, e, n, s, r, i) {
    Ze(t.config.authDomain, t, "auth-domain-config-required"),
        Ze(t.config.apiKey, t, "invalid-api-key");
    const o = {
        apiKey: t.config.apiKey,
        appName: t.name,
        authType: n,
        redirectUrl: s,
        v: sf,
        eventId: r
    };
    if (e instanceof o4) {
        e.setDefaultLanguage(t.languageCode),
            o.providerId = e.providerId || "",
            mD(e.getCustomParameters()) || (o.customParameters = JSON.stringify(e.getCustomParameters()));
        for (const [u, h] of Object.entries({}))
            o[u] = h
    }
    if (e instanceof pf) {
        const u = e.getScopes().filter(h => h !== "");
        u.length > 0 && (o.scopes = u.join(","))
    }
    t.tenantId && (o.tid = t.tenantId);
    const l = o;
    for (const u of Object.keys(l))
        l[u] === void 0 && delete l[u];
    const a = await t._getAppCheckToken()
        , c = a ? `#${SJ}=${encodeURIComponent(a)}` : "";
    return `${EJ(t)}?${nf(l).slice(1)}${c}`
}
function EJ({ config: t }) {
    return t.emulator ? Px(t, wJ) : `https://${t.authDomain}/${xJ}`
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const U0 = "webStorageSupport";
class TJ {
    constructor() {
        this.eventManagers = {},
            this.iframes = {},
            this.originValidationPromises = {},
            this._redirectPersistence = h4,
            this._completeRedirectFn = qK,
            this._overrideRedirectResult = XK
    }
    async _openPopup(e, n, s, r) {
        var i;
        Uo((i = this.eventManagers[e._key()]) === null || i === void 0 ? void 0 : i.manager, "_initialize() not called before _openPopup()");
        const o = await S2(e, n, s, zy(), r);
        return bJ(e, o, Dx())
    }
    async _openRedirect(e, n, s, r) {
        await this._originValidation(e);
        const i = await S2(e, n, s, zy(), r);
        return AK(i),
            new Promise(() => { }
            )
    }
    _initialize(e) {
        const n = e._key();
        if (this.eventManagers[n]) {
            const { manager: r, promise: i } = this.eventManagers[n];
            return r ? Promise.resolve(r) : (Uo(i, "If manager is not set, promise should be"),
                i)
        }
        const s = this.initAndGetManager(e);
        return this.eventManagers[n] = {
            promise: s
        },
            s.catch(() => {
                delete this.eventManagers[n]
            }
            ),
            s
    }
    async initAndGetManager(e) {
        const n = await fJ(e)
            , s = new JK(e);
        return n.register("authEvent", r => (Ze(r == null ? void 0 : r.authEvent, e, "invalid-auth-event"),
        {
            status: s.onEvent(r.authEvent) ? "ACK" : "ERROR"
        }), gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER),
            this.eventManagers[e._key()] = {
                manager: s
            },
            this.iframes[e._key()] = n,
            s
    }
    _isIframeWebStorageSupported(e, n) {
        this.iframes[e._key()].send(U0, {
            type: U0
        }, r => {
            var i;
            const o = (i = r == null ? void 0 : r[0]) === null || i === void 0 ? void 0 : i[U0];
            o !== void 0 && n(!!o),
                $o(e, "internal-error")
        }
            , gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER)
    }
    _originValidation(e) {
        const n = e._key();
        return this.originValidationPromises[n] || (this.originValidationPromises[n] = nJ(e)),
            this.originValidationPromises[n]
    }
    get _shouldInitProactively() {
        return n4() || Ox() || b_()
    }
}
const CJ = TJ;
var E2 = "@firebase/auth"
    , T2 = "1.7.6";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class IJ {
    constructor(e) {
        this.auth = e,
            this.internalListeners = new Map
    }
    getUid() {
        var e;
        return this.assertAuthConfigured(),
            ((e = this.auth.currentUser) === null || e === void 0 ? void 0 : e.uid) || null
    }
    async getToken(e) {
        return this.assertAuthConfigured(),
            await this.auth._initializationPromise,
            this.auth.currentUser ? {
                accessToken: await this.auth.currentUser.getIdToken(e)
            } : null
    }
    addAuthTokenListener(e) {
        if (this.assertAuthConfigured(),
            this.internalListeners.has(e))
            return;
        const n = this.auth.onIdTokenChanged(s => {
            e((s == null ? void 0 : s.stsTokenManager.accessToken) || null)
        }
        );
        this.internalListeners.set(e, n),
            this.updateProactiveRefresh()
    }
    removeAuthTokenListener(e) {
        this.assertAuthConfigured();
        const n = this.internalListeners.get(e);
        n && (this.internalListeners.delete(e),
            n(),
            this.updateProactiveRefresh())
    }
    assertAuthConfigured() {
        Ze(this.auth._initializationPromise, "dependent-sdk-initialized-before-auth")
    }
    updateProactiveRefresh() {
        this.internalListeners.size > 0 ? this.auth._startProactiveRefresh() : this.auth._stopProactiveRefresh()
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function AJ(t) {
    switch (t) {
        case "Node":
            return "node";
        case "ReactNative":
            return "rn";
        case "Worker":
            return "webworker";
        case "Cordova":
            return "cordova";
        case "WebExtension":
            return "web-extension";
        default:
            return
    }
}
function kJ(t) {
    Yi(new ai("auth", (e, { options: n }) => {
        const s = e.getProvider("app").getImmediate()
            , r = e.getProvider("heartbeat")
            , i = e.getProvider("app-check-internal")
            , { apiKey: o, authDomain: l } = s.options;
        Ze(o && !o.includes(":"), "invalid-api-key", {
            appName: s.name
        });
        const a = {
            apiKey: o,
            authDomain: l,
            clientPlatform: t,
            apiHost: "identitytoolkit.googleapis.com",
            tokenApiHost: "securetoken.googleapis.com",
            apiScheme: "https",
            sdkClientVersion: s4(t)
        }
            , c = new rK(s, r, i, a);
        return uK(c, n),
            c
    }
        , "PUBLIC").setInstantiationMode("EXPLICIT").setInstanceCreatedCallback((e, n, s) => {
            e.getProvider("auth-internal").initialize()
        }
        )),
        Yi(new ai("auth-internal", e => {
            const n = v_(e.getProvider("auth").getImmediate());
            return (s => new IJ(s))(n)
        }
            , "PRIVATE").setInstantiationMode("EXPLICIT")),
        kr(E2, T2, AJ(t)),
        kr(E2, T2, "esm2017")
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const RJ = 5 * 60
    , MJ = ak("authIdTokenMaxAge") || RJ;
let C2 = null;
const PJ = t => async e => {
    const n = e && await e.getIdTokenResult()
        , s = n && (new Date().getTime() - Date.parse(n.issuedAtTime)) / 1e3;
    if (s && s > MJ)
        return;
    const r = n == null ? void 0 : n.token;
    C2 !== r && (C2 = r,
        await fetch(t, {
            method: r ? "POST" : "DELETE",
            headers: r ? {
                Authorization: `Bearer ${r}`
            } : {}
        }))
}
    ;
function LJ(t = Dv()) {
    const e = pc(t, "auth");
    if (e.isInitialized())
        return e.getImmediate();
    const n = cK(t, {
        popupRedirectResolver: CJ,
        persistence: [BK, TK, h4]
    })
        , s = ak("authTokenSyncURL");
    if (s && typeof isSecureContext == "boolean" && isSecureContext) {
        const i = new URL(s, location.origin);
        if (location.origin === i.origin) {
            const o = PJ(i.toString());
            xK(n, o, () => o(n.currentUser)),
                vK(n, l => o(l))
        }
    }
    const r = ik("auth");
    return r && hK(n, `http://${r}`),
        n
}
function OJ() {
    var t, e;
    return (e = (t = document.getElementsByTagName("head")) === null || t === void 0 ? void 0 : t[0]) !== null && e !== void 0 ? e : document
}
iK({
    loadJS(t) {
        return new Promise((e, n) => {
            const s = document.createElement("script");
            s.setAttribute("src", t),
                s.onload = e,
                s.onerror = r => {
                    const i = Ui("internal-error");
                    i.customData = r,
                        n(i)
                }
                ,
                s.type = "text/javascript",
                s.charset = "UTF-8",
                OJ().appendChild(s)
        }
        )
    },
    gapiScript: "https://apis.google.com/js/api.js",
    recaptchaV2Script: "https://www.google.com/recaptcha/api.js",
    recaptchaEnterpriseScript: "https://www.google.com/recaptcha/enterprise.js?render="
});
kJ("Browser");
const _e = (t, e) => {
    const n = t.__vccOpts || t;
    for (const [s, r] of e)
        n[s] = r;
    return n
}
    , NJ = {
        computed: {
            globalStore() {
                return Ye()
            },
            closeLabel() {
                return this.globalStore.modal.closeLabel || (this.globalStore.modal.hasConfirmation ? this.$t("modal.cancel") : this.$t("modal.close"))
            },
            confirmLabel() {
                return this.globalStore.modal.confirmLabel || "OK"
            }
        },
        methods: {
            onClickOutside(t) {
                t.preventDefault(),
                    t.stopPropagation(),
                    setTimeout(() => {
                        this.globalStore.closeModal(!1)
                    }
                        , 100)
            }
        }
    }
    , DJ = {
        key: 0,
        class: "slap-modal"
    }
    , BJ = {
        class: "slap-modal__inner"
    }
    , FJ = {
        key: 0,
        class: "slap-modal__image"
    }
    , $J = ["src"]
    , UJ = {
        class: "slap-modal__text"
    }
    , VJ = {
        class: "slap-modal__buttons"
    };
function GJ(t, e, n, s, r, i) {
    const o = mr("click-away");
    return i.globalStore.modal.isVisible ? (A(),
        N("div", DJ, [vn((A(),
            N("div", BJ, [i.globalStore.modal.image ? (A(),
                N("div", FJ, [T("img", {
                    class: "w-[120px] h-[120px]",
                    src: i.globalStore.modal.image,
                    alt: ""
                }, null, 8, $J)])) : te("", !0), T("div", UJ, $(i.globalStore.modal.message), 1), T("div", VJ, [T("button", {
                    class: "slap-modal__button slap-modal__button--close",
                    onClick: e[0] || (e[0] = l => i.globalStore.closeModal(!1))
                }, $(i.closeLabel), 1), i.globalStore.modal.hasConfirmation ? (A(),
                    N("button", {
                        key: 0,
                        class: "slap-modal__button slap-modal__button--confirm",
                        onClick: e[1] || (e[1] = l => i.globalStore.closeModal(!0))
                    }, $(i.confirmLabel), 1)) : te("", !0)])])), [[o, i.onClickOutside]])])) : te("", !0)
}
const HJ = _e(NJ, [["render", GJ], ["__scopeId", "data-v-dd3354eb"]])
    , WJ = {}
    , YJ = {
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }
    , XJ = T("path", {
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        d: "M4.50159 4.43971C4.85072 4.08592 5.42056 4.08214 5.77435 4.43128L11.9997 10.5747L18.2251 4.43128C18.5788 4.08214 19.1487 4.08592 19.4978 4.43971C19.847 4.7935 19.8432 5.36334 19.4894 5.71247L13.281 11.8391L19.4894 17.9657C19.8432 18.3148 19.847 18.8847 19.4978 19.2385C19.1487 19.5923 18.5788 19.596 18.2251 19.2469L11.9997 13.1035L5.77435 19.2469C5.42056 19.596 4.85072 19.5923 4.50159 19.2385C4.15245 18.8847 4.15623 18.3148 4.51002 17.9657L10.7184 11.8391L4.51002 5.71247C4.15623 5.36334 4.15245 4.7935 4.50159 4.43971Z",
        fill: "white",
        "fill-opacity": "0.24"
    }, null, -1)
    , jJ = [XJ];
function zJ(t, e) {
    return A(),
        N("svg", YJ, jJ)
}
const S_ = _e(WJ, [["render", zJ]])
    , qJ = {
        class: "sl-popup"
    }
    , KJ = {
        key: 0,
        class: "sl-popup__body bg-[#0f0b1c] border-2 border-white/[.06] overflow-x-hidden overflow-y-auto"
    }
    , JJ = {
        __name: "Popup",
        props: {
            isVisible: {
                type: Boolean,
                default: !1
            },
            customBackgroundClass: {
                type: String,
                required: !1
            },
            click: Function
        },
        emits: ["close"],
        setup(t, { emit: e }) {
            const n = e
                , s = () => {
                    n("close")
                }
                ;
            return (r, i) => (A(),
                N("div", qJ, [G(is, {
                    name: "fade"
                }, {
                    default: Ce(() => [t.isVisible ? (A(),
                        N("div", {
                            key: 0,
                            class: "fixed inset-0 bg-black/70 z-[99]",
                            onClick: s
                        })) : te("", !0)]),
                    _: 1
                }), G(is, {
                    name: "popup"
                }, {
                    default: Ce(() => [t.isVisible ? (A(),
                        N("div", KJ, [T("div", {
                            class: "absolute top-0 right-0 w-10 p-2",
                            onClick: s
                        }, [G(S_)]), rs(r.$slots, "default", {}, void 0, !0)])) : te("", !0)]),
                    _: 3
                })]))
        }
    }
    , il = _e(JJ, [["__scopeId", "data-v-60aff868"]])
    , ZJ = {}
    , QJ = {
        width: "25",
        height: "24",
        viewBox: "0 0 25 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }
    , eZ = T("path", {
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        d: "M16.2071 3.79289C15.8166 3.40237 15.1834 3.40237 14.7929 3.79289L7.29289 11.2929C6.90237 11.6834 6.90237 12.3166 7.29289 12.7071L14.7929 20.2071C15.1834 20.5976 15.8166 20.5976 16.2071 20.2071C16.5976 19.8166 16.5976 19.1834 16.2071 18.7929L9.41421 12L16.2071 5.20711C16.5976 4.81658 16.5976 4.18342 16.2071 3.79289Z",
        fill: "white"
    }, null, -1)
    , tZ = [eZ];
function nZ(t, e) {
    return A(),
        N("svg", QJ, tZ)
}
const Fx = _e(ZJ, [["render", nZ]])
    , sZ = {}
    , rZ = {
        class: "w-[10vw] text-white"
    }
    , iZ = Nr('<svg class="m-auto w-full h-full" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><circle cx="50" cy="50" r="45" fill="none" stroke-width="10" stroke-linecap="round"></circle><circle cx="50" cy="50" r="45" fill="none" stroke="currentColor" stroke-width="10" stroke-linecap="round" stroke-dasharray="282.6" stroke-dashoffset="282.6" transform="rotate(-90 50 50)"><animateTransform attributeName="transform" type="rotate" from="-90 50 50" to="270 50 50" dur="2s" repeatCount="indefinite"></animateTransform><animate attributeName="stroke-dashoffset" from="282.6" to="0" dur="2s" repeatCount="indefinite"></animate></circle></svg>', 1)
    , oZ = [iZ];
function aZ(t, e) {
    return A(),
        N("div", rZ, oZ)
}
const ol = _e(sZ, [["render", aZ]])
    , lZ = ["disabled"];
var y4 = (t => (t.PRIMARY = "primary",
    t.SECONDARY = "secondary",
    t.SUCCESS = "success",
    t.ERROR = "error",
    t.ACCENT = "accent",
    t.DARK = "dark",
    t))(y4 || {});
const Lr = Qa({
    __name: "ButtonPrimary",
    props: {
        type: {
            type: String,
            default: "primary",
            validator: t => Object.values(y4).includes(t)
        },
        size: {
            type: String,
            default: "m",
            validator: t => ["m", "l"].includes(t)
        },
        disabled: Boolean,
        isLoading: Boolean
    },
    setup(t) {
        return (e, n) => (A(),
            N("button", {
                class: Te(["px-4 py-2 justify-center items-center inline-flex overflow-hidden rounded-lg disabled:text-[#ffffff3d] text-white w-full", {
                    "bg-[linear-gradient(97deg,#00A1DC_5.51%,#00E23A_94.49%)] active:bg-[linear-gradient(0deg,#00000033_0%,#00000033_100%),linear-gradient(97deg,#02A88D_5.51%,#3EBB6D_94.49%)]": t.type === "success" && !t.disabled,
                    "bg-[linear-gradient(97deg,#FE105C_5.51%,#E41414_94.49%)] active:bg-[linear-gradient(0deg,#00000033_0%,#00000033_100%),linear-gradient(79deg,#FE105C_0%,#E41414_58.17%)]": t.type === "error" && !t.disabled,
                    "bg-[linear-gradient(90deg,#29D5FB_0%,#0E47D8_100%)] active:bg-[linear-gradient(0deg,#00000033_0%,#00000033_100%),linear-gradient(11deg,#29D5FB_0%,#0E47D8_92.17%)]": t.type === "primary",
                    "bg-[linear-gradient(90deg,#DC69E9_0%,#00BDF9_100%)] active:bg-[linear-gradient(0deg,#00000033_0%,#00000033_100%),linear-gradient(70deg,#DC69E9_0%,#00BDF9_63.43%)]": t.type === "secondary",
                    "bg-[linear-gradient(90deg,#FFB52E_0%,#DF279B_100%)] active:bg-[linear-gradient(0deg,#00000033_0%,#00000033_100%),linear-gradient(70deg,#FFB52E_0%,#DF279B_63.43%)]": t.type === "accent",
                    "bg-white/[6%] border border-white/[6%] backdrop-blur-sm active:border-white/[12%]": t.type === "dark",
                    "h-[60px] text-xl font-semibold": t.size === "l",
                    "h-[52px] text-base font-bold": t.size === "m",
                    "text-white/20 cursor-not-allowed bg-gray-primary transition-transform duration-200 ease-out active:-translate-x-[0.5rem]": t.disabled
                }]),
                disabled: t.disabled
            }, [t.isLoading ? (A(),
                fe(ol, {
                    key: 0,
                    class: "!w-[2.125rem] !h-[2.125rem] !text-white"
                })) : rs(e.$slots, "default", {
                    key: 1
                })], 10, lZ))
    }
})
    , cZ = {
        name: "Overlay",
        components: {
            Loader: ol,
            IconArrowLeft: Fx,
            IconClose: S_,
            ButtonPrimary: Lr
        },
        props: {
            bodyClass: String,
            closeButtonClass: String,
            isVisible: {
                type: Boolean,
                default: !1
            },
            isCloseDisabled: Boolean,
            isConfirmDisabled: Boolean,
            backButtonText: String,
            confirmButtonText: String,
            hideCloseIcon: Boolean,
            close: Function,
            confirm: Function,
            showCloseButton: Boolean,
            showConfirmButton: Boolean,
            isLoading: Boolean,
            headerCustomClass: Number
        },
        computed: {
            backButton() {
                return this.backButtonText || this.$t("common.back")
            },
            confirmButton() {
                return this.confirmButtonText || this.$t("common.confirm")
            }
        },
        data() {
            return {
                isClosing: !1
            }
        },
        methods: {
            animationClose() {
                return new Promise(t => {
                    this.isClosing = !0,
                        setTimeout(() => {
                            t(),
                                this.isClosing = !1
                        }
                            , 300)
                }
                )
            },
            onClose() {
                this.animationClose().then(() => this.$emit("close"))
            },
            async handleConfirm() {
                await this.confirm(),
                    await this.animationClose(),
                    this.$emit("close")
            }
        }
    }
    , uZ = {
        key: 0,
        class: "flex-col justify-center items-center flex"
    }
    , hZ = {
        key: 0,
        class: "fixed z-20 flex inset-x-4 bottom-5 gap-2"
    };
function dZ(t, e, n, s, r, i) {
    const o = q("IconClose")
        , l = q("IconArrowLeft")
        , a = q("ButtonPrimary");
    return n.isVisible ? (A(),
        fe(Hg, {
            key: 0,
            to: "body"
        }, [n.isVisible ? (A(),
            N("div", {
                key: 0,
                class: Te(["sl-overlay fixed inset-0 bg-black z-50 overflow-hidden", t.$attrs.class, {
                    "animate-slideOut": r.isClosing,
                    "animate-slideIn": !r.isClosing
                }])
            }, [T("div", {
                class: Te(["max-h-[calc(100%-90px)] h-full flex flex-col justify-between", {
                    "max-h-full": !n.showCloseButton && !n.showConfirmButton
                }, n.bodyClass])
            }, [T("div", {
                class: Te(["flex justify-center items-center p-4 relative", [n.headerCustomClass]])
            }, [t.$slots.header ? (A(),
                N("div", uZ, [rs(t.$slots, "header", {}, void 0, !0)])) : te("", !0), n.hideCloseIcon ? te("", !0) : (A(),
                    N("button", {
                        key: 1,
                        class: Te(["absolute right-4 p-2 w-10", n.closeButtonClass]),
                        onClick: e[0] || (e[0] = (...c) => i.onClose && i.onClose(...c))
                    }, [G(o)], 2))], 2), rs(t.$slots, "default", {}, void 0, !0)], 2), n.showCloseButton || n.showConfirmButton ? (A(),
                        N("div", hZ, [n.showCloseButton ? (A(),
                            fe(a, {
                                key: 0,
                                type: "dark",
                                size: "l",
                                onClick: i.onClose,
                                disabled: n.isCloseDisabled || n.isLoading
                            }, {
                                default: Ce(() => [G(l, {
                                    class: "mr-1"
                                }), Fe(" " + $(i.backButton), 1)]),
                                _: 1
                            }, 8, ["onClick", "disabled"])) : te("", !0), n.showConfirmButton ? (A(),
                                fe(a, {
                                    key: 1,
                                    type: "success",
                                    size: "l",
                                    onClick: i.handleConfirm,
                                    isLoading: n.isLoading,
                                    disabled: n.isConfirmDisabled || n.isLoading
                                }, {
                                    default: Ce(() => [Fe($(i.confirmButton), 1)]),
                                    _: 1
                                }, 8, ["onClick", "isLoading", "disabled"])) : te("", !0)])) : te("", !0)], 2)) : te("", !0)])) : te("", !0)
}
const ch = _e(cZ, [["render", dZ], ["__scopeId", "data-v-59619ae2"]])
    , fZ = {}
    , pZ = {
        viewBox: "0 0 80 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }
    , mZ = Nr('<path d="M36.5371 10.99C38.0772 8.32598 41.9228 8.32596 43.4629 10.9899L73.5301 62.998C75.0717 65.6646 73.1474 69 70.0671 69H9.93286C6.85262 69 4.92825 65.6647 6.46991 62.998L36.5371 10.99Z" fill="url(#paint0_linear_3188_3717)"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M37.0003 27C35.8017 27 34.8723 28.047 35.0144 29.2371L37.0628 46.3915C37.2405 47.8796 38.5026 49 40.0013 49C41.5 49 42.7621 47.8796 42.9398 46.3915L44.9882 29.2371C45.1303 28.047 44.2009 27 43.0023 27H37.0003ZM39.8489 51C38.1921 51 36.8489 52.3431 36.8489 54C36.8489 55.6569 38.1921 57 39.8489 57H40.1538C41.8106 57 43.1538 55.6569 43.1538 54C43.1538 52.3431 41.8106 51 40.1538 51H39.8489Z" fill="white"></path><defs><linearGradient id="paint0_linear_3188_3717" x1="3" y1="69" x2="66.3314" y2="-4.22691" gradientUnits="userSpaceOnUse"><stop stop-color="#DD1C0A"></stop><stop offset="1" stop-color="#FF5B70"></stop></linearGradient></defs>', 3)
    , gZ = [mZ];
function _Z(t, e) {
    return A(),
        N("svg", pZ, gZ)
}
const b4 = _e(fZ, [["render", _Z]])
    , yZ = {
        top: "180deg",
        right: "90deg",
        bottom: "0deg",
        left: "270deg"
    }
    , $x = (t, e = "right") => ({
        background: `linear-gradient(${yZ[e]}, ${Vu[t].start}, ${Vu[t].end})`
    })
    , gr = {
        __name: "Glow",
        props: {
            blur: {
                type: String,
                default: "40"
            },
            height: {
                type: String,
                default: "40%"
            },
            width: {
                type: String,
                default: "65%"
            },
            position: {
                type: String,
                default: "top",
                validator: t => ["top", "right", "bottom", "left", "center"].includes(t)
            },
            tier: {
                type: String,
                required: !0,
                validator: t => ["common", "rare", "epic", "legendary"].includes(t)
            }
        },
        setup(t) {
            const e = t
                , n = ve(() => ({
                    ...$x(e.tier, e.position),
                    height: e.height,
                    width: e.width,
                    filter: `blur(${e.blur}px)`
                }));
            return (s, r) => (A(),
                N("div", {
                    class: Te(["absolute inset-0 w-full h-full flex overflow-hidden", {
                        "justify-center items-start": t.position === "top",
                        "justify-center items-end": t.position === "bottom",
                        "justify-start items-center": t.position === "left",
                        "justify-end items-center": t.position === "right",
                        "justify-center items-center": t.position === "center"
                    }])
                }, [T("div", {
                    class: Te(["rounded-full", {
                        "-translate-y-1/2": t.position === "top",
                        "translate-y-1/2": t.position === "bottom",
                        "-translate-x-1/2": t.position === "left",
                        "translate-x-1/2": t.position === "right"
                    }]),
                    style: Wt(n.value)
                }, null, 6)], 2))
        }
    }
    , bZ = {
        name: "FlipCard",
        props: {
            rotate: Number
        }
    }
    , vZ = {
        class: "relative w-full h-full perspective"
    }
    , xZ = {
        class: "front-face absolute w-full h-full backface-hidden"
    }
    , wZ = {
        class: "back-face absolute w-full h-full backface-hidden transform"
    };
function SZ(t, e, n, s, r, i) {
    return A(),
        N("div", vZ, [T("div", {
            class: "grid w-full h-full transition-transform duration-500 transform-style-3d will-change-transform",
            style: Wt({
                transform: `rotateY(${n.rotate}deg)`
            })
        }, [T("div", xZ, [rs(t.$slots, "front", {}, void 0, !0)]), T("div", wZ, [rs(t.$slots, "back", {}, void 0, !0)])], 4)])
}
const EZ = _e(bZ, [["render", SZ], ["__scopeId", "data-v-d2f16094"]])
    , TZ = "/shop/card-back-common.webp"
    , CZ = {
        name: "CardCover",
        props: {
            tier: {
                type: String,
                default: "common",
                validator: t => ["common", "rare", "epic", "legendary"].includes(t)
            }
        }
    }
    , IZ = {
        class: "relative w-full h-full rounded-lg border bg-black/60 border-white/5"
    }
    , AZ = T("img", {
        class: "absolute w-full h-full object-cover rounded-lg",
        src: TZ,
        alt: "Card Background"
    }, null, -1)
    , kZ = [AZ];
function RZ(t, e, n, s, r, i) {
    return A(),
        N("div", IZ, kZ)
}
const MZ = _e(CZ, [["render", RZ]])
    , ur = (t = "light") => {
        var n, s;
        const e = (s = (n = window.Telegram) == null ? void 0 : n.WebApp) == null ? void 0 : s.HapticFeedback;
        e ? ["success", "error"].includes(t) ? e.notificationOccurred(t) : e.impactOccurred(t) : console.warn("HapticFeedback is not available.")
    }
    ;
function uh({ active: t = !0, onSwipe: e, onSwipeEnd: n, onPressEnd: s }) {
    const r = ke(!1)
        , i = ke(!1)
        , o = ke(null)
        , l = ke(null)
        , a = ke(0)
        , c = p => {
            var _;
            const m = (_ = p.touches) != null && _.length ? p.touches[0] : p
                , g = m.clientX - o.value
                , b = m.clientY - l.value
                , v = performance.now() - a.value;
            return {
                deltaX: g,
                deltaY: b,
                deltaTime: v,
                clientX: m.clientX,
                clientY: m.clientY
            }
        }
        , u = p => {
            const m = p.touches ? p.touches[0] : p;
            o.value = m.clientX,
                l.value = m.clientY,
                r.value = !1,
                i.value = !0,
                a.value = performance.now(),
                ur("light")
        }
        , h = p => {
            if (!i.value)
                return;
            const m = c(p);
            (Math.abs(m.deltaX) > 10 || Math.abs(m.deltaY) > 10) && (r.value = !0,
                e == null || e({
                    startX: o,
                    startY: l,
                    ...m
                }))
        }
        , d = p => {
            r.value ? (n == null || n(p),
                ur("light")) : i && (s == null || s(p)),
                f(),
                o.value = null,
                l.value = null
        }
        , f = () => {
            i.value && (i.value = !1,
                r.value = !1)
        }
        ;
    return t ? {
        isPressed: i,
        handlePressStart: u,
        handleMove: h,
        handlePressEnd: d,
        handlePressCancel: f
    } : {}
}
const PZ = 50
    , tp = 200
    , Ux = 500
    , v4 = 10
    , x4 = 20
    , V0 = (t, e = {}) => ({
        transform: "scale(1.55)",
        zIndex: t.length,
        transitionDuration: `${Ux}ms`,
        ...e
    })
    , LZ = (t, e, n, s = {}) => ({
        transform: `translateX(-${window.innerWidth / 2 - x4}px) translateX(50%) translateX(${t * v4}px)`,
        zIndex: n.length + (t - e),
        transitionDuration: `${Ux}ms`,
        ...s
    })
    , I2 = (t, e, n, s = {}) => ({
        transform: `translateX(${window.innerWidth / 2 - x4}px) translateX(-50%) translateX(-${(n.length - t - 1) * v4}px)`,
        zIndex: n.length - (t - e),
        transitionDuration: `${Ux}ms`,
        ...s
    })
    , OZ = (t, e) => {
        let n = ke(!1);
        const s = ke((e == null ? void 0 : e.startIndex) != null ? e.startIndex : -1)
            , r = ke(e != null && e.showAllCardsOnStart ? new Set(Array.from({
                length: t.value.length
            }, (f, p) => p)) : new Set)
            , i = ke(t.value.map((f, p) => V0(t.value, {
                zIndex: t.value.length - p,
                transitionDelay: `${(t.value.length - p - 1) * tp}ms`
            })))
            , o = () => {
                s.value = (e == null ? void 0 : e.startIndex) ?? -1,
                    r.value = e != null && e.showAllCardsOnStart ? new Set(Array.from({
                        length: t.value.length
                    }, (f, p) => p)) : new Set,
                    a()
            }
            , l = () => {
                o(),
                    i.value = t.value.map((f, p) => p === 0 ? V0(t.value, {
                        transitionDelay: `${(t.value.length - p - 1) * tp}ms`
                    }) : I2(p, s.value, t.value, {
                        transitionDelay: `${(t.value.length - p - 1) * tp}ms`
                    })),
                    e != null && e.skipInitialAnimation || setTimeout(() => {
                        s.value = 0
                    }
                        , (t.value.length - 1) * tp)
            }
            , a = () => {
                const f = [];
                t.value.forEach((p, m) => {
                    const g = m - s.value;
                    g < 0 ? f[m] = LZ(m, s.value, t.value) : g > 0 ? f[m] = I2(m, s.value, t.value) : f[m] = V0(t.value)
                }
                ),
                    i.value = f
            }
            , { handlePressStart: c, handleMove: u, handlePressEnd: h } = uh({
                onSwipe: ({ deltaX: f, deltaTime: p }) => {
                    n.value || Math.abs(f) > PZ && (f < 0 && s.value < t.value.length - 1 ? (s.value += 1,
                        n.value = !0) : f > 0 && s.value > 0 && (s.value -= 1,
                            n.value = !0))
                }
                ,
                onSwipeEnd: () => n.value = !1,
                onPressEnd: () => {
                    s.value < t.value.length - 1 && (s.value += 1,
                        n.value = !0)
                }
            })
            , d = f => r.value.has(f) ? 180 : 0;
        return Ln(s, (f, p) => {
            r.value.add(f),
                !(p === -1 && f === 0) && a()
        }
        ),
            e != null && e.skipInitialAnimation && a(),
        {
            currentIndex: s,
            calculatedStyles: i,
            openedCards: r,
            initializeCardAnimation: l,
            handlePressStart: c,
            handleMove: u,
            handlePressEnd: h,
            getCardRotation: d
        }
    }
    , Xt = (t, e = !1) => t < 1e4 || e ? t.toString().replace(/\B(?=(\d{3})+(?!\d))/g, " ") : t < 1e5 ? `${(t / 1e3).toFixed(1)}k` : t < 1e6 ? `${Math.floor(t / 1e3)}k` : t < 1e7 ? `${(t / 1e6).toFixed(2)}m` : t < 1e8 ? `${(t / 1e6).toFixed(1)}m` : `${Math.floor(t / 1e6)}m`
    , NZ = {
        name: "CoinCard",
        props: {
            amount: Number
        },
        setup() {
            const { t } = gt();
            return {
                t,
                formattingPrice: Xt
            }
        }
    }
    , DZ = {
        class: "relative w-full h-full items-center justify-center flex flex-col rounded-lg border border-[#3d2216] bg-gradient-to-t from-black to-coin overflow-hidden"
    }
    , BZ = {
        key: 0,
        class: "flex flex-col items-center gap-2 p-2"
    }
    , FZ = {
        class: "font-semibold text-coin text-lg"
    }
    , $Z = {
        class: "text-white/60 text-xxs"
    };
function UZ(t, e, n, s, r, i) {
    const o = q("IconCoin");
    return A(),
        N("div", DZ, [G(o, {
            class: "w-full"
        }), n.amount ? (A(),
            N("div", BZ, [T("div", FZ, " + " + $(s.formattingPrice(n.amount)), 1), T("p", $Z, $(s.t("lootbox_popup.slapcoins")), 1)])) : te("", !0)])
}
const w4 = _e(NZ, [["render", UZ]])
    , VZ = {}
    , GZ = {
        width: "125",
        height: "202",
        viewBox: "0 0 125 202",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }
    , HZ = T("path", {
        d: "M102.042 0H127.203L22.3644 202H-2.79688L102.042 0Z",
        fill: "url(#paint0_linear_6073_18386)"
    }, null, -1)
    , WZ = T("defs", null, [T("linearGradient", {
        id: "paint0_linear_6073_18386",
        x1: "62.2031",
        y1: "0",
        x2: "62.2031",
        y2: "202",
        gradientUnits: "userSpaceOnUse"
    }, [T("stop", {
        "stop-color": "white",
        "stop-opacity": "0.12"
    }), T("stop", {
        offset: "1",
        "stop-color": "white",
        "stop-opacity": "0.08"
    })])], -1)
    , YZ = [HZ, WZ];
function XZ(t, e) {
    return A(),
        N("svg", GZ, YZ)
}
const Vx = _e(VZ, [["render", XZ]])
    , jZ = {
        key: 0,
        class: "absolute inset-0 z-100 overflow-hidden will-change-transform pointer-events-none"
    }
    , zZ = {
        __name: "Blik",
        props: {
            isBlikActive: {
                type: Boolean,
                required: !1,
                default: !1
            },
            hasInterval: {
                type: Boolean,
                required: !1,
                default: !1
            }
        },
        setup(t) {
            const e = t
                , n = ke(!1)
                , s = ke(null);
            return Ln(() => e.isBlikActive, r => {
                n.value = r
            }
            ),
                Or(() => {
                    e.hasInterval && (s.value = setInterval(() => {
                        n.value = !0,
                            setTimeout(() => {
                                n.value = !1
                            }
                                , _C.duration)
                    }
                        , _C.interval))
                }
                ),
                Gg(() => {
                    e.hasInterval && s.value && clearInterval(s.value)
                }
                ),
                (r, i) => n.value ? (A(),
                    N("div", jZ, [G(Vx, {
                        class: "w-full h-auto animate-blik"
                    })])) : te("", !0)
        }
    }
    , Ki = _e(zZ, [["__scopeId", "data-v-8399a1c6"]])
    , qZ = {
        key: 0,
        class: "absolute inset-0 bg-black/50 rounded-l z-20"
    }
    , KZ = {
        key: 1,
        class: "absolute z-20 top-2 left-1/2 -translate-x-1/2 rounded-lg bg-black/60 px-2 py-0.5 text-xs font-semibold text-center text-white leading-none"
    }
    , JZ = ["src"]
    , ZZ = {
        class: "z-10 flex items-center justify-center grow"
    }
    , QZ = {
        class: "relative z-10 flex flex-col gap-1"
    }
    , eQ = {
        class: "flex items-center justify-center gap-1 pb-0.5 text-white text-xs font-bold tracking-tight"
    }
    , Gx = {
        __name: "BoostCard",
        props: {
            isDisabled: {
                type: Boolean,
                default: !1
            },
            dimmed: {
                type: Boolean,
                default: !1
            },
            disabledReason: {
                type: String,
                default: ""
            },
            amount: {
                type: Number,
                default: 0
            },
            hideAmount: {
                type: Boolean,
                default: !1
            },
            clickable: {
                type: Boolean,
                default: !0
            },
            tier: {
                type: String,
                required: !0,
                validator: t => ["common", "rare", "epic", "legendary"].includes(t)
            }
        },
        emits: ["click"],
        setup(t, { emit: e }) {
            const n = t
                , s = e
                , r = ke(!1)
                , i = mi()
                , o = () => {
                    r.value = !0,
                        setTimeout(() => {
                            r.value = !1
                        }
                            , 180)
                }
                , { isPressed: l, handlePressStart: a, handleMove: c, handlePressEnd: u, handlePressCancel: h } = uh({
                    active: n.clickable,
                    onPressEnd: () => {
                        n.isDisabled ? (ur("error"),
                            n.disabledReason && i.showErrorToast(n.disabledReason, 1e3)) : (o(),
                                s("click"),
                                ur("medium"))
                    }
                });
            return (d, f) => {
                const p = mr("bounce");
                return vn((A(),
                    N("div", {
                        class: Te(["flex flex-col aspect-[124/192] relative w-full h-full justify-end items-stretch rounded-lg transition transform overflow-hidden p-2 pb-3 border border-white/5 bg-black cursor-pointer", {
                            "scale-95 bg-white/[.13]": de(l) && !t.isDisabled
                        }]),
                        onPointerdown: f[0] || (f[0] = (...m) => de(a) && de(a)(...m)),
                        onPointerup: f[1] || (f[1] = (...m) => de(u) && de(u)(...m)),
                        onPointermove: f[2] || (f[2] = (...m) => de(c) && de(c)(...m)),
                        onPointercancel: f[3] || (f[3] = (...m) => de(h) && de(h)(...m))
                    }, [G(gr, {
                        tier: t.tier
                    }, null, 8, ["tier"]), G(Ki, {
                        tier: t.tier,
                        isBlikActive: r.value
                    }, null, 8, ["tier", "isBlikActive"]), t.dimmed || t.isDisabled ? (A(),
                        N("div", qZ)) : te("", !0), t.hideAmount ? te("", !0) : (A(),
                            N("span", KZ, $(t.amount), 1)), T("img", {
                                src: `/icons/icon-type-${t.tier}.svg`,
                                alt: "",
                                class: "absolute top-2 left-2 w-4 h-4 z-20"
                            }, null, 8, JZ), T("div", ZZ, [rs(d.$slots, "image")]), T("div", QZ, [T("div", eQ, [rs(d.$slots, "info")]), rs(d.$slots, "button")]), rs(d.$slots, "default")], 34)), [[p, {
                                enabled: !1,
                                startAnimation: de(l) && t.isDisabled
                            }]])
            }
        }
    }
    , S4 = "/icons/icon-coin.webp"
    , tQ = {}
    , nQ = {
        src: S4,
        alt: "Coin Image"
    };
function sQ(t, e) {
    return A(),
        N("img", nQ)
}
const dn = _e(tQ, [["render", sQ]])
    , rQ = {
        viewBox: "0 0 21 20",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }
    , iQ = ["fill"]
    , oQ = ["id"]
    , aQ = ["stop-color"]
    , lQ = ["stop-color"]
    , vc = {
        __name: "IconStars",
        props: {
            id: {
                type: String,
                default: "paint0_linear_2200_782"
            },
            firstColor: {
                type: String,
                default: "#FFDF7E"
            },
            secondColor: {
                type: String,
                default: "#FEA80C"
            }
        },
        setup(t) {
            return (e, n) => (A(),
                N("svg", rQ, [T("path", {
                    d: "M9.51829 1.25002C9.88134 0.383328 11.1187 0.383326 11.4817 1.25002L13.4057 5.843C13.5801 6.25948 13.9743 6.54359 14.4264 6.57957L19.4202 6.9771C20.3639 7.05221 20.744 8.2198 20.0271 8.82954L16.2223 12.0657C15.8776 12.3589 15.7267 12.8193 15.8322 13.2582L16.9946 18.0969C17.2135 19.0078 16.2147 19.732 15.406 19.2416L11.1306 16.6487C10.7434 16.4139 10.2566 16.4139 9.86941 16.6487L5.59397 19.2416C4.78532 19.732 3.78654 19.0078 4.00538 18.0969L4.52799 15.9215C4.83683 14.6359 5.7023 13.5512 6.89288 12.9583L10.9705 10.9276C11.3502 10.7385 11.1596 10.1733 10.7476 10.2387L5.96896 10.9973C4.66063 11.205 3.32657 10.8314 2.32068 9.9759L0.972885 8.82954C0.255997 8.2198 0.636092 7.05221 1.57977 6.9771L6.57363 6.57957C7.02566 6.54359 7.41988 6.25948 7.59434 5.843L9.51829 1.25002Z",
                    fill: `url(#${t.id})`,
                    stroke: "#BA7000",
                    "stroke-width": "0.2"
                }, null, 8, iQ), T("defs", null, [T("linearGradient", {
                    id: t.id,
                    x1: "0.5",
                    y1: "1",
                    x2: "20.5",
                    y2: "20",
                    gradientUnits: "userSpaceOnUse"
                }, [T("stop", {
                    "stop-color": t.firstColor
                }, null, 8, aQ), T("stop", {
                    offset: 1,
                    "stop-color": t.secondColor
                }, null, 8, lQ)], 8, oQ)])]))
        }
    }
    , cQ = {}
    , uQ = {
        width: "17",
        height: "16",
        viewBox: "0 0 17 16",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }
    , hQ = Nr('<g id="Play"><path id="Rectangle 8344104" d="M3.5 2.74104C3.5 1.96925 4.33721 1.48838 5.00387 1.87726L14.0192 7.13622C14.6807 7.5221 14.6807 8.4779 14.0192 8.86378L5.00387 14.1227C4.33721 14.5116 3.5 14.0308 3.5 13.259V2.74104Z" fill="url(#paint0_linear_8636_27856)"></path></g><defs><linearGradient id="paint0_linear_8636_27856" x1="3.5" y1="15" x2="17.3353" y2="3.14118" gradientUnits="userSpaceOnUse"><stop stop-color="#DD0A6F"></stop><stop offset="1" stop-color="#FF5B70"></stop></linearGradient></defs>', 2)
    , dQ = [hQ];
function fQ(t, e) {
    return A(),
        N("svg", uQ, dQ)
}
const pQ = _e(cQ, [["render", fQ]])
    , mQ = {
        class: "px-2 py-[3px] bg-white/[.06] active:bg-white/[.12] [@media(hover:hover)]:hover:bg-white/[.12] rounded-3xl border border-white/[.04] w-full relative backdrop-blur-sm active:scale-90 transition-transform duration-100 ease-in-out"
    }
    , ic = {
        __name: "BuyButton",
        props: {
            label: {
                type: String,
                required: !0
            },
            icon: {
                type: String,
                default: null,
                validator: t => ["coin", "play", "star"].includes(t)
            },
            disabled: Boolean,
            isLoading: Boolean
        },
        setup(t) {
            const e = {
                coin: dn,
                star: vc,
                play: pQ
            }
                , n = t
                , s = n.icon && e[n.icon];
            return (r, i) => (A(),
                N("button", mQ, [T("div", {
                    class: Te(["flex justify-center items-center text-white font-semibold leading-tight gap-1", {
                        "opacity-30": t.disabled
                    }])
                }, [t.isLoading ? (A(),
                    fe(ol, {
                        key: 0,
                        class: "!w-4 !h-4 !text-white"
                    })) : (A(),
                        N(Ie, {
                            key: 1
                        }, [(A(),
                            fe(Kl(de(s)), {
                                class: "w-4 h-4"
                            })), T("span", null, $(t.label), 1)], 64))], 2)]))
        }
    }
    , gQ = {}
    , _Q = {
        width: "17",
        height: "16",
        viewBox: "0 0 17 16",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }
    , yQ = Nr('<g id="Energy Icon"><path id="Subtract" fill-rule="evenodd" clip-rule="evenodd" d="M5.30039 0.8C5.30039 0.358203 5.65859 0 6.10039 0H10.9004C11.3422 0 11.7004 0.358203 11.7004 0.8V1.6H13.3004C13.7422 1.6 14.1004 1.9582 14.1004 2.4V15.2C14.1004 15.6418 13.7422 16 13.3004 16H3.70039C3.25859 16 2.90039 15.6418 2.90039 15.2V2.4C2.90039 2.19062 2.98086 2 3.1127 1.85703C3.25879 1.69883 3.46797 1.6 3.70039 1.6H5.30039V0.8ZM9.22979 2.52031V6.97021L12.359 6.33908C12.4615 6.31841 12.5379 6.43331 12.4809 6.52237L7.98808 13.5452C7.92398 13.6454 7.77099 13.5992 7.77099 13.4797V9.02979L4.64181 9.66092C4.53932 9.68159 4.46287 9.56669 4.51985 9.47763L9.01271 2.45482C9.0768 2.35464 9.22979 2.40079 9.22979 2.52031Z" fill="url(#paint0_linear_9184_41261)"></path></g><defs><linearGradient id="paint0_linear_9184_41261" x1="2.90039" y1="16" x2="17.9339" y2="5.47651" gradientUnits="userSpaceOnUse"><stop stop-color="#32B70D"></stop><stop offset="1" stop-color="#1BFFAF"></stop></linearGradient></defs>', 2)
    , bQ = [yQ];
function vQ(t, e) {
    return A(),
        N("svg", _Q, bQ)
}
const E4 = _e(gQ, [["render", vQ]])
    , xQ = {
        width: "30",
        height: "42",
        viewBox: "0 0 30 42",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }
    , wQ = ["fill"]
    , SQ = ["id"]
    , EQ = ["stop-color"]
    , TQ = ["stop-color"]
    , Hx = {
        __name: "IconEnergy",
        props: {
            tier: {
                type: String,
                required: !0,
                validator(t) {
                    return ["common", "rare", "epic", "legendary"].includes(t)
                }
            }
        },
        setup(t) {
            return (e, n) => (A(),
                N("svg", xQ, [T("path", {
                    "fill-rule": "evenodd",
                    "clip-rule": "evenodd",
                    d: "M17.7352 17.1383V0.451163C17.7352 0.00297215 17.1615 -0.170106 16.9212 0.205576L0.0729619 26.5411C-0.140701 26.8751 0.146002 27.3059 0.53032 27.2284L12.2648 24.8617V41.5488C12.2648 41.997 12.8385 42.1701 13.0788 41.7944L29.927 15.4589C30.1407 15.1249 29.854 14.6941 29.4697 14.7716L17.7352 17.1383Z",
                    fill: `url(#paint0_linear_${t.tier})`
                }, null, 8, wQ), T("defs", null, [T("linearGradient", {
                    id: `paint0_linear_${t.tier}`,
                    x1: "-3.36944e-07",
                    y1: "42",
                    x2: "40.6023",
                    y2: "17.7565",
                    gradientUnits: "userSpaceOnUse"
                }, [T("stop", {
                    "stop-color": de(Vu)[t.tier].start
                }, null, 8, EQ), T("stop", {
                    offset: "1",
                    "stop-color": de(Vu)[t.tier].end
                }, null, 8, TQ)], 8, SQ)])]))
        }
    }
    , CQ = {
        xmlns: "http://www.w3.org/2000/svg",
        width: "100",
        height: "100",
        viewBox: "0 0 100 100",
        fill: "none"
    }
    , IQ = ["id"]
    , AQ = ["stop-color"]
    , kQ = ["stop-color"]
    , RQ = T("circle", {
        cx: "50",
        cy: "50",
        r: "48",
        stroke: "black",
        "stroke-opacity": "0.2",
        "stroke-width": "4"
    }, null, -1)
    , MQ = ["stroke", "stroke-dasharray", "stroke-dashoffset"]
    , T4 = {
        __name: "IconTimer",
        props: {
            percentage: {
                type: Number,
                required: !0,
                validator(t) {
                    return t >= 0 && t <= 100
                }
            },
            color: {
                type: String,
                default: "green",
                validator(t) {
                    return ["green", "pink", "orange", "common", "rare", "epic", "legendary"].includes(t)
                }
            }
        },
        setup(t) {
            const e = {
                green: {
                    start: "#32B70D",
                    end: "#1BFFAF"
                },
                pink: {
                    start: "#DD0A6F",
                    end: "#FF5B70"
                },
                orange: {
                    start: "#FF9500",
                    end: "#FFD237"
                },
                ...Vu
            }
                , n = t
                , s = ve(() => 2 * Math.PI * 47)
                , r = ve(() => s.value * (1 - n.percentage / 100));
            return (i, o) => (A(),
                N("svg", CQ, [T("defs", null, [T("linearGradient", {
                    id: t.color,
                    x1: "2",
                    y1: "50",
                    x2: "50",
                    y2: "2",
                    gradientUnits: "userSpaceOnUse"
                }, [T("stop", {
                    "stop-color": e[t.color].start
                }, null, 8, AQ), T("stop", {
                    offset: "1",
                    "stop-color": e[t.color].end
                }, null, 8, kQ)], 8, IQ)]), RQ, T("circle", {
                    class: "[transition:stroke-dashoffset_1s_linear]",
                    cx: "50",
                    cy: "50",
                    r: "48",
                    stroke: `url(#${t.color})`,
                    "stroke-linecap": "round",
                    "stroke-width": "4",
                    fill: "none",
                    "stroke-dasharray": s.value,
                    "stroke-dashoffset": r.value,
                    transform: "rotate(-90 50 50)"
                }, null, 8, MQ)]))
        }
    }
    , PQ = {
        key: 0,
        class: "block text-white/60 text-xxs leading-3"
    }
    , LQ = {
        class: "block font-semibold leading-tight text-white"
    }
    , C4 = {
        __name: "CountdownTimer",
        props: {
            startUnixTime: {
                type: Number,
                required: !0
            },
            endUnixTime: {
                type: Number,
                required: !0
            },
            cooldownColor: {
                type: String,
                default: "green",
                validator(t) {
                    return ["green", "pink", "orange", "common", "rare", "epic", "legendary"].includes(t)
                }
            },
            viewType: {
                type: Number,
                required: !1,
                default: hs.VERTICAL,
                validator(t) {
                    return [hs.VERTICAL, hs.HORIZONTAL, hs.COMPACT].includes(t)
                }
            }
        },
        setup(t) {
            const { t: e } = gt()
                , n = t
                , s = si()
                , r = ve(() => Math.max(n.endUnixTime - s.unixTime, 0))
                , i = ve(() => {
                    const l = Math.floor(r.value / 3600)
                        , a = Math.floor(r.value % 3600 / 60)
                        , c = r.value % 60;
                    return n.viewType === hs.COMPACT ? l > 0 ? `${l}${e("hours_short")} ${a}${e("minutes_short")}` : `${a}${e("minutes_short")} ${c}${e("seconds_short")}` : `${l.toString().padStart(2, "0")}:${a.toString().padStart(2, "0")}:${c.toString().padStart(2, "0")}`
                }
                )
                , o = ve(() => r.value >= n.endUnixTime ? 0 : Math.max(Math.floor(r.value / (n.endUnixTime - n.startUnixTime) * 100), 0));
            return (l, a) => r.value >= 0 ? (A(),
                N("div", {
                    key: 0,
                    class: Te(["absolute p-2 flex items-center gap-2", {
                        "flex-col": t.viewType !== de(hs).HORIZONTAL,
                        "flex-row-reverse": t.viewType === de(hs).HORIZONTAL
                    }])
                }, [G(T4, {
                    class: Te({
                        "min-w-[4.25rem] w-full aspect-square h-auto": t.viewType === de(hs).COMPACT,
                        "w-full h-auto": t.viewType === de(hs).VERTICAL,
                        "h-full w-auto": t.viewType === de(hs).HORIZONTAL
                    }),
                    percentage: o.value,
                    color: t.cooldownColor
                }, null, 8, ["class", "percentage", "color"]), T("div", {
                    class: Te(["text-center", {
                        "absolute top-1/2 -translate-y-1/2 z-10": t.viewType !== de(hs).HORIZONTAL
                    }])
                }, [t.viewType !== de(hs).COMPACT ? (A(),
                    N("span", PQ, $(l.$t("cooldown_available")), 1)) : te("", !0), T("span", LQ, $(i.value), 1)], 2)], 2)) : te("", !0)
        }
    }
    , OQ = {
        class: "flex flex-col items-center gap-1"
    }
    , NQ = {
        key: 0,
        class: "text-white/80 text-xs font-normal capitalize text-center"
    }
    , DQ = {
        class: "flex items-center gap-0.5 text-coin"
    }
    , Wx = {
        __name: "EnergyBoostCard",
        props: {
            amount: {
                type: Number,
                default: 0
            },
            isDisabled: {
                type: Boolean,
                default: !1
            },
            tier: {
                type: String,
                required: !0,
                validator: t => ["common", "rare", "epic", "legendary"].includes(t)
            },
            startTime: {
                type: Number,
                default: 0
            },
            endTime: {
                type: Number,
                default: 0
            },
            showName: {
                type: Boolean,
                default: !1
            },
            showButton: {
                type: Boolean,
                default: !0
            },
            hideAmount: {
                type: Boolean,
                default: !1
            },
            clickable: {
                type: Boolean,
                default: !0
            }
        },
        emits: ["click"],
        setup(t, { emit: e }) {
            const n = t
                , s = e
                , { t: r } = gt()
                , i = ls()
                , o = si()
                , l = Xs()
                , a = ve(() => Math.max(n.endTime - o.unixTime, 0))
                , c = ve(() => l.getBoost(ns.ENERGY, n.tier, o.unixTime))
                , u = ve(() => Math.ceil(a.value / 60))
                , h = ve(() => {
                    var m;
                    return Math.round((((m = c.value) == null ? void 0 : m.bonus) - 1) * 100)
                }
                )
                , d = ve(() => a.value > 0)
                , f = () => {
                    !n.clickable || n.isDisabled && !d.value || (d.value ? p() : s("click"))
                }
                , p = async () => {
                    const m = await g_("energy_boost_reset_cooldown", i.selectedGirlId);
                    window.Telegram.WebApp.openInvoice(m, g => {
                        g === "paid" && i.removeEnergyBoostCooldown(i.selectedGirlId)
                    }
                    )
                }
                ;
            return (m, g) => (A(),
                fe(Gx, {
                    tier: t.tier,
                    amount: t.amount,
                    hideAmount: t.hideAmount,
                    clickable: t.clickable,
                    isDisabled: t.isDisabled && !d.value,
                    dimmed: d.value,
                    label: de(r)("boosts.energy_boost"),
                    onClick: f
                }, C3({
                    image: Ce(() => [G(Hx, {
                        class: "w-3/4 h-auto aspect-square",
                        tier: t.tier
                    }, null, 8, ["tier"])]),
                    info: Ce(() => [T("div", OQ, [t.showName ? (A(),
                        N("div", NQ, $(de(r)("boosts.energy_boost")), 1)) : te("", !0), T("div", DQ, [G(E4, {
                            class: "w-4 h-4"
                        }), T("span", null, "+" + $(h.value) + "%", 1)])])]),
                    _: 2
                }, [!d.value && t.showButton ? {
                    name: "button",
                    fn: Ce(() => [G(ic, {
                        class: "pointer-events-none",
                        label: de(r)("boosts.apply_button")
                    }, null, 8, ["label"])]),
                    key: "0"
                } : void 0, d.value ? {
                    name: "default",
                    fn: Ce(() => [d.value ? (A(),
                        fe(C4, {
                            key: 0,
                            class: "z-30 w-full h-1/2 absolute top-6 left-1/2 -translate-x-1/2",
                            startUnixTime: t.startTime,
                            endUnixTime: t.endTime,
                            viewType: de(hs).COMPACT,
                            cooldownColor: t.tier
                        }, null, 8, ["startUnixTime", "endUnixTime", "viewType", "cooldownColor"])) : te("", !0), G(ic, {
                            class: "mt-1 z-30 pointer-events-none",
                            label: de(Xt)(u.value, !0),
                            icon: "star"
                        }, null, 8, ["label"])]),
                    key: "1"
                } : void 0]), 1032, ["tier", "amount", "hideAmount", "clickable", "isDisabled", "dimmed", "label"]))
        }
    }
    , BQ = {
        class: "w-full h-auto",
        width: "40",
        height: "40",
        viewBox: "0 0 40 40",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }
    , FQ = ["id"]
    , $Q = ["stop-color"]
    , UQ = ["stop-color"]
    , VQ = {
        id: "IconLvl"
    }
    , GQ = ["fill"]
    , Yx = {
        __name: "IconLevelUp",
        props: {
            tier: {
                type: String,
                default: "common",
                validator: t => ["common", "rare", "epic", "legendary"].includes(t)
            }
        },
        setup(t) {
            const e = t
                , n = ve(() => Vu[e.tier])
                , s = ve(() => `gradient-${e.tier}`)
                , r = ve(() => `url(#${s.value})`);
            return (i, o) => (A(),
                N("svg", BQ, [T("defs", null, [T("linearGradient", {
                    id: s.value,
                    x1: "2",
                    y1: "39",
                    x2: "40.8754",
                    y2: "3.11502",
                    gradientUnits: "userSpaceOnUse"
                }, [T("stop", {
                    "stop-color": n.value.start
                }, null, 8, $Q), T("stop", {
                    offset: 1,
                    "stop-color": n.value.end
                }, null, 8, UQ)], 8, FQ)]), T("g", VQ, [T("path", {
                    id: "Vector",
                    "fill-rule": "evenodd",
                    "clip-rule": "evenodd",
                    d: "M20.8924 0.389042C20.4085 -0.129682 19.5915 -0.12968 19.1076 0.389044L2.33553 18.3687C1.59944 19.1578 2.15394 20.4527 3.22796 20.4527H10.1958V29.1081C10.1958 29.791 10.7445 30.3446 11.4213 30.3446H28.5787C29.2555 30.3446 29.8042 29.791 29.8042 29.1081V20.4527H36.772C37.8461 20.4527 38.4006 19.1578 37.6645 18.3687L20.8924 0.389042ZM10.1958 34.054C10.1958 33.3712 10.7445 32.8176 11.4213 32.8176H28.5787C29.2555 32.8176 29.8042 33.3712 29.8042 34.054V37.7635C29.8042 38.4464 29.2555 39 28.5787 39H11.4213C10.7445 39 10.1958 38.4464 10.1958 37.7635V34.054Z",
                    fill: r.value
                }, null, 8, GQ)])]))
        }
    }
    , HQ = {
        name: "GiftCard",
        components: {
            IconLevelUp: Yx,
            Glow: gr
        },
        props: {
            tier: {
                type: String,
                required: !0,
                validator: t => ["common", "rare", "epic", "legendary"].includes(t)
            }
        },
        setup(t) {
            const { t: e } = gt()
                , n = Ye().gifts[t.tier];
            return {
                t: e,
                exp: n
            }
        }
    }
    , WQ = {
        class: "relative w-full h-full items-center justify-center flex flex-col rounded-lg border border-white/5 bg-black overflow-hidden"
    }
    , YQ = {
        class: "flex flex-col items-center gap-1 p-2"
    }
    , XQ = {
        class: "font-semibold text-coin text-base"
    }
    , jQ = {
        class: "text-white/60 text-xxs uppercase"
    };
function zQ(t, e, n, s, r, i) {
    const o = q("Glow")
        , l = q("IconLevelUp");
    return A(),
        N("div", WQ, [G(o, {
            tier: n.tier
        }, null, 8, ["tier"]), G(l, {
            class: "z-10",
            tier: n.tier
        }, null, 8, ["tier"]), T("div", YQ, [T("div", XQ, "+" + $(s.exp), 1), T("p", jQ, $(s.t("lootbox_popup.exp")), 1)])])
}
const I4 = _e(HQ, [["render", zQ]])
    , qQ = {
        name: "LvlProgress",
        props: {
            currentLevel: {
                type: Number,
                required: !0
            },
            animateToLevel: {
                type: Number
            },
            maxLevel: {
                type: Number,
                required: !0
            },
            label: {
                type: String
            }
        },
        computed: {
            progressWidth() {
                return `${(this.animateToLevel || this.currentLevel) / this.maxLevel * 100}%`
            }
        }
    }
    , KQ = {
        class: "flex items-center text-white/60 text-xxs leading-3"
    }
    , JQ = {
        class: "flex-1 mx-2 h-1 bg-gray-700 rounded-full relative overflow-hidden"
    }
    , ZQ = {
        class: "text-white"
    };
function QQ(t, e, n, s, r, i) {
    return A(),
        N("div", KQ, [T("span", null, $(n.label || t.$t("level")), 1), T("div", JQ, [T("div", {
            class: "absolute top-0 left-0 h-full bg-gradient-to-r from-orange-500 to-green-500 transition-all duration-200",
            style: Wt({
                width: i.progressWidth
            })
        }, null, 4)]), T("span", ZQ, $(n.currentLevel) + " / " + $(n.maxLevel), 1)])
}
const A4 = _e(qQ, [["render", QQ]])
    , eee = {
        name: "GirlCard",
        components: {
            Glow: gr,
            Blik: Ki,
            LvlProgress: A4,
            IconCoin: dn
        },
        props: {
            id: {
                type: String
            },
            girl: {
                type: Object,
                required: !1
            },
            isBlikActive: Boolean,
            maxLevel: {
                type: Number,
                default: 99
            }
        },
        setup(t, { emit: e }) {
            const n = ls();
            return {
                girl: t.id != null ? n.getGirlById(t.id) : t.girl,
                onPressStart() {
                    e("pressStart")
                },
                onPressEnd() {
                    e("pressEnd")
                },
                onPressCancel() {
                    e("pressCancel")
                }
            }
        }
    }
    , tee = ["src"]
    , nee = ["src"]
    , see = {
        class: "absolute flex flex-col gap-1 bottom-0 inset-x-0 p-2 z-20 text-white text-sm bg-gradient-to-t from-black to-transparent"
    }
    , ree = {
        class: "font-semibold capitalize leading-none text-xs"
    }
    , iee = {
        class: "text-white/60 capitalize text-xxs leading-none"
    }
    , oee = {
        key: 0,
        class: "flex items-center text-coin text-xxs font-semibold leading-none"
    };
function aee(t, e, n, s, r, i) {
    const o = q("Blik")
        , l = q("Glow")
        , a = q("IconCoin")
        , c = q("LvlProgress");
    return A(),
        N("div", {
            class: "relative p-2 w-full h-full flex flex-col items-center rounded-lg border border-white/5 bg-black overflow-hidden",
            onMousedown: e[0] || (e[0] = (...u) => s.onPressStart && s.onPressStart(...u)),
            onMouseup: e[1] || (e[1] = (...u) => s.onPressEnd && s.onPressEnd(...u)),
            onMouseleave: e[2] || (e[2] = (...u) => s.onPressCancel && s.onPressCancel(...u)),
            onTouchstart: e[3] || (e[3] = (...u) => s.onPressStart && s.onPressStart(...u)),
            onTouchend: e[4] || (e[4] = (...u) => s.onPressEnd && s.onPressEnd(...u))
        }, [G(o, {
            isBlikActive: n.isBlikActive
        }, null, 8, ["isBlikActive"]), G(l, {
            tier: s.girl.tier,
            blur: "24"
        }, null, 8, ["tier"]), T("img", {
            class: "absolute w-4 h-4 z-10 top-2 left-2",
            src: `/icons/icon-type-${s.girl.tier}.svg`,
            alt: "Tier Icon"
        }, null, 8, tee), T("img", {
            src: s.girl.path,
            alt: "Girl",
            class: "object-top object-cover w-full h-full z-10"
        }, null, 8, nee), T("div", see, [T("h3", ree, $(t.$t(`girls.names.${s.girl.name}`)), 1), T("p", iee, $(t.$t(`girls.collections.${s.girl.collection}`)), 1), s.girl.id !== -1 ? (A(),
            N("div", oee, [G(a, {
                class: "w-4 h-4 mr-1"
            }), T("span", null, $(s.girl.balance) + " / " + $(s.girl.capacity), 1)])) : te("", !0), G(c, {
                class: "text-xxs",
                "max-level": n.maxLevel,
                "current-level": s.girl.level
            }, null, 8, ["max-level", "current-level"])])], 32)
}
const k4 = _e(eee, [["render", aee]])
    , lee = {}
    , cee = {
        viewBox: "0 0 16 16",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }
    , uee = T("path", {
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        d: "M14.4 8C14.4 11.5346 11.5346 14.4 8 14.4C4.46538 14.4 1.6 11.5346 1.6 8C1.6 4.46538 4.46538 1.6 8 1.6C11.5346 1.6 14.4 4.46538 14.4 8ZM16 8C16 12.4183 12.4183 16 8 16C3.58172 16 0 12.4183 0 8C0 3.58172 3.58172 0 8 0C12.4183 0 16 3.58172 16 8ZM8.8 4C8.8 3.55817 8.44183 3.2 8 3.2C7.55817 3.2 7.2 3.55817 7.2 4V8.8C7.2 9.15718 7.43678 9.47109 7.78022 9.56922L10.5802 10.3692C11.0051 10.4906 11.4478 10.2446 11.5692 9.81978C11.6906 9.39495 11.4446 8.95216 11.0198 8.83078L8.8 8.19656V4Z",
        fill: "white"
    }, null, -1)
    , hee = [uee];
function dee(t, e) {
    return A(),
        N("svg", cee, hee)
}
const Xx = _e(lee, [["render", dee]])
    , fee = ["src"]
    , pee = {
        class: "flex flex-col gap-1 items-center"
    }
    , mee = {
        key: 0,
        class: "text-white/80 text-xs font-normal capitalize"
    }
    , gee = {
        class: "flex justify-center gap-1"
    }
    , _ee = {
        class: "flex items-center gap-0.5"
    }
    , yee = {
        class: "flex items-center gap-0.5 text-coin"
    }
    , jx = {
        __name: "ProfitBoostCard",
        props: {
            amount: {
                type: Number,
                default: 0
            },
            isDisabled: {
                type: Boolean,
                default: !1
            },
            tier: {
                type: String,
                required: !0,
                validator: t => ["common", "rare", "epic", "legendary"].includes(t)
            },
            showName: {
                type: Boolean,
                default: !1
            },
            showButton: {
                type: Boolean,
                default: !0
            },
            hideAmount: {
                type: Boolean,
                default: !1
            },
            clickable: {
                type: Boolean,
                default: !0
            }
        },
        setup(t) {
            const e = t
                , { t: n } = gt()
                , r = Xs().getBoost(ns.PROFIT, e.tier)
                , i = ve(() => Math.round(((r == null ? void 0 : r.bonus) - 1) * 100))
                , o = ve(() => {
                    const l = Math.floor((r == null ? void 0 : r.duration) / 3600)
                        , a = Math.floor((r == null ? void 0 : r.duration) % l / 60)
                        , c = a > 0 ? `${a}${n("minutes_short")}` : "";
                    return `${l > 0 ? `${l}${n("hours_short")}` : ""} ${c}`
                }
                );
            return (l, a) => {
                const c = q("IconCoin");
                return A(),
                    fe(Gx, {
                        tier: t.tier,
                        isDisabled: t.isDisabled,
                        amount: t.amount,
                        clickable: t.clickable,
                        hideAmount: t.hideAmount,
                        label: de(n)("boosts.profit_boost")
                    }, C3({
                        image: Ce(() => [T("img", {
                            src: `/boosts/boost-${t.tier}.webp`,
                            alt: "Profit Boost",
                            class: "object-contain object-[0_10px]"
                        }, null, 8, fee)]),
                        info: Ce(() => [T("div", pee, [t.showName ? (A(),
                            N("div", mee, $(de(n)("boosts.profit_boost")), 1)) : te("", !0), T("div", gee, [T("div", _ee, [G(Xx, {
                                class: "w-4 h-4 p-0.5"
                            }), T("span", null, $(o.value), 1)]), T("div", yee, [G(c, {
                                class: "w-4 h-4"
                            }), T("span", null, "+" + $(i.value) + "%", 1)])])])]),
                        _: 2
                    }, [t.showButton ? {
                        name: "button",
                        fn: Ce(() => [G(ic, {
                            class: "pointer-events-none",
                            label: de(n)("boosts.apply_button")
                        }, null, 8, ["label"])]),
                        key: "0"
                    } : void 0]), 1032, ["tier", "isDisabled", "amount", "clickable", "hideAmount", "label"])
            }
        }
    }
    , bee = {
        __name: "LootboxCard",
        props: {
            item: {
                type: Object,
                required: !0
            },
            isBlikActive: {
                type: Boolean,
                default: !1,
                required: !1
            }
        },
        setup(t) {
            return (e, n) => (A(),
                N(Ie, null, [t.item.type === "gift" ? (A(),
                    fe(I4, {
                        key: 0,
                        tier: t.item.tier
                    }, null, 8, ["tier"])) : te("", !0), t.item.type === "coins" ? (A(),
                        fe(w4, {
                            key: 1,
                            amount: t.item.amount
                        }, null, 8, ["amount"])) : te("", !0), t.item.type === "girl" ? (A(),
                            fe(k4, {
                                key: 2,
                                id: t.item.girl_id,
                                girl: t.item.girl,
                                isBlikActive: t.isBlikActive
                            }, null, 8, ["id", "girl", "isBlikActive"])) : te("", !0), t.item.type === "energy_boost" ? (A(),
                                fe(Wx, {
                                    key: 3,
                                    tier: t.item.tier,
                                    clickable: !1,
                                    showName: !0,
                                    showButton: !1,
                                    hideAmount: !t.item.amount || t.item.amount <= 1,
                                    amount: t.item.amount
                                }, null, 8, ["tier", "hideAmount", "amount"])) : te("", !0), t.item.type === "profit_boost" ? (A(),
                                    fe(jx, {
                                        key: 4,
                                        tier: t.item.tier,
                                        clickable: !1,
                                        showName: !0,
                                        showButton: !1,
                                        hideAmount: !t.item.amount || t.item.amount <= 1,
                                        amount: t.item.amount
                                    }, null, 8, ["tier", "hideAmount", "amount"])) : te("", !0)], 64))
        }
    }
    , vee = {
        name: "LootboxCards",
        components: {
            LootboxCard: bee,
            CardCover: MZ,
            FlipCard: EZ
        },
        props: {
            items: {
                type: Array,
                required: !0
            },
            startAnimation: {
                type: Boolean,
                default: !1
            },
            playToEndAnimation: {
                type: Boolean,
                default: !1
            },
            showAllCardsOnStart: {
                type: Boolean,
                default: !1
            },
            startIndex: {
                type: Number,
                default: -1
            },
            skipInitialAnimation: {
                type: Boolean,
                default: !1
            }
        },
        emits: ["openedCardsCount", "currentIndexChanged"],
        slots: {
            cards: {
                type: Object,
                required: !1
            }
        },
        setup(t, { emit: e }) {
            const n = ve(() => t.items)
                , { currentIndex: s, initializeCardAnimation: r, openedCards: i, calculatedStyles: o, handlePressStart: l, handleMove: a, handlePressEnd: c, getCardRotation: u } = OZ(n, {
                    showAllCardsOnStart: t.showAllCardsOnStart,
                    startIndex: t.startIndex,
                    skipInitialAnimation: t.skipInitialAnimation
                });
            return Ln([() => t.startAnimation, () => t.items], ([h, d]) => {
                h && d.length && r()
            }
            ),
                Ln(() => t.playToEndAnimation, () => {
                    if (t.playToEndAnimation) {
                        let h = s.value + 1;
                        const d = setInterval(() => {
                            if (h >= t.items.length) {
                                clearInterval(d);
                                return
                            }
                            s.value = h,
                                h++
                        }
                            , 500)
                    }
                }
                ),
                Ln(() => i.value.size, () => {
                    e("openedCardsCount", i.value.size)
                }
                ),
                Ln(s, () => {
                    e("currentIndexChanged", s)
                }
                ),
                Or(() => {
                    t.startAnimation && t.items.length && r()
                }
                ),
            {
                currentIndex: s,
                calculatedStyles: o,
                getCardRotation: u,
                handlePressStart: l,
                handleMove: a,
                handlePressEnd: c
            }
        }
    };
function xee(t, e, n, s, r, i) {
    const o = q("CardCover")
        , l = q("LootboxCard")
        , a = q("FlipCard");
    return A(),
        N("div", {
            class: "relative w-full flex items-center h-[300px] justify-center",
            onPointerdown: e[0] || (e[0] = ni((...c) => s.handlePressStart && s.handlePressStart(...c), ["prevent"])),
            onPointermove: e[1] || (e[1] = ni((...c) => s.handleMove && s.handleMove(...c), ["prevent"])),
            onPointerup: e[2] || (e[2] = ni((...c) => s.handlePressEnd && s.handlePressEnd(...c), ["prevent"]))
        }, [(A(!0),
            N(Ie, null, mt(n.items, (c, u) => (A(),
                fe(a, {
                    key: `${c.type}-${u}-${c.amount}-${c.lootbox_type}-${c.tier}`,
                    class: "!absolute !w-[124px] !h-[192px] aspect-[124/192] scale-[1.55] duration-500 transition-[transform] ease-in-out will-change-[transform]",
                    style: Wt(s.calculatedStyles[u]),
                    rotate: s.getCardRotation(u)
                }, {
                    front: Ce(() => [G(o, {
                        tier: c.tier
                    }, null, 8, ["tier"])]),
                    back: Ce(() => [G(l, {
                        item: c,
                        isBlikActive: u === s.currentIndex
                    }, null, 8, ["item", "isBlikActive"]), rs(t.$slots, "cards", {
                        item: c,
                        isBlikActive: u === s.currentIndex
                    })]),
                    _: 2
                }, 1032, ["style", "rotate"]))), 128))], 32)
}
const R4 = _e(vee, [["render", xee]])
    , wee = () => {
        const t = new Date
            , e = new Date(Date.UTC(t.getUTCFullYear(), t.getUTCMonth(), t.getUTCDate()));
        return Bo(e.getTime())
    }
    , See = () => {
        const t = new Date
            , e = new Date(Date.UTC(t.getUTCFullYear(), t.getUTCMonth(), t.getUTCDate() + 1));
        return Bo(e.getTime())
    }
    , gf = Ds("dailyClaims", {
        state: () => ({
            _dailyClaims: [],
            dayStreak: 0,
            lastRewardTimestamp: 0,
            ui: {
                showPopup: !1
            }
        }),
        getters: {
            dailyClaims(t) {
                return t._dailyClaims.map(e => ({
                    ...e,
                    done: e.day <= t.dayStreak
                }))
            },
            currentDailyClaim(t) {
                var r;
                if (!((r = t.dailyClaims) != null && r.length))
                    return;
                const e = wee()
                    , n = See();
                let s;
                return t.lastRewardTimestamp !== 0 && t.lastRewardTimestamp >= e && t.lastRewardTimestamp < n ? s = t.dailyClaims[t.dayStreak - 1] : s = t.dailyClaims[t.dayStreak],
                    s
            },
            isCurrentDailyClaimAvailable(t) {
                var e;
                return ((e = t.currentDailyClaim) == null ? void 0 : e.done) === !1
            }
        },
        actions: {
            setDailyClaims(t, e, n) {
                this._dailyClaims = Object.values(t),
                    this.dayStreak = e,
                    this.lastRewardTimestamp = n
            },
            closeDailyRewardPopup() {
                this.ui.showPopup = !1
            },
            showDailyRewardPopup() {
                this.ui.showPopup = !0
            },
            async claimDailyReward() {
                const t = Ye();
                await Ls({
                    action: async () => Bn(t.telegramAppFunctions, "claim_daily_reward_call")(),
                    onError: () => { }
                    ,
                    onSuccess: e => {
                        var n, s;
                        this.dayStreak = (n = e.data.user.daily_claims) == null ? void 0 : n.day,
                            this.lastRewardTimestamp = (s = e.data.user.daily_claims) == null ? void 0 : s.timestamp,
                            t.setUserData(e.data.user)
                    }
                })
            }
        }
    });
/*!
  * vue-router v4.4.0
  * (c) 2024 Eduardo San Martin Morote
  * @license MIT
  */
const $c = typeof document < "u";
function Eee(t) {
    return t.__esModule || t[Symbol.toStringTag] === "Module"
}
const Ot = Object.assign;
function G0(t, e) {
    const n = {};
    for (const s in e) {
        const r = e[s];
        n[s] = li(r) ? r.map(t) : t(r)
    }
    return n
}
const ad = () => { }
    , li = Array.isArray
    , M4 = /#/g
    , Tee = /&/g
    , Cee = /\//g
    , Iee = /=/g
    , Aee = /\?/g
    , P4 = /\+/g
    , kee = /%5B/g
    , Ree = /%5D/g
    , L4 = /%5E/g
    , Mee = /%60/g
    , O4 = /%7B/g
    , Pee = /%7C/g
    , N4 = /%7D/g
    , Lee = /%20/g;
function zx(t) {
    return encodeURI("" + t).replace(Pee, "|").replace(kee, "[").replace(Ree, "]")
}
function Oee(t) {
    return zx(t).replace(O4, "{").replace(N4, "}").replace(L4, "^")
}
function Jy(t) {
    return zx(t).replace(P4, "%2B").replace(Lee, "+").replace(M4, "%23").replace(Tee, "%26").replace(Mee, "`").replace(O4, "{").replace(N4, "}").replace(L4, "^")
}
function Nee(t) {
    return Jy(t).replace(Iee, "%3D")
}
function Dee(t) {
    return zx(t).replace(M4, "%23").replace(Aee, "%3F")
}
function Bee(t) {
    return t == null ? "" : Dee(t).replace(Cee, "%2F")
}
function Md(t) {
    try {
        return decodeURIComponent("" + t)
    } catch { }
    return "" + t
}
const Fee = /\/$/
    , $ee = t => t.replace(Fee, "");
function H0(t, e, n = "/") {
    let s, r = {}, i = "", o = "";
    const l = e.indexOf("#");
    let a = e.indexOf("?");
    return l < a && l >= 0 && (a = -1),
        a > -1 && (s = e.slice(0, a),
            i = e.slice(a + 1, l > -1 ? l : e.length),
            r = t(i)),
        l > -1 && (s = s || e.slice(0, l),
            o = e.slice(l, e.length)),
        s = Hee(s ?? e, n),
    {
        fullPath: s + (i && "?") + i + o,
        path: s,
        query: r,
        hash: Md(o)
    }
}
function Uee(t, e) {
    const n = e.query ? t(e.query) : "";
    return e.path + (n && "?") + n + (e.hash || "")
}
function A2(t, e) {
    return !e || !t.toLowerCase().startsWith(e.toLowerCase()) ? t : t.slice(e.length) || "/"
}
function Vee(t, e, n) {
    const s = e.matched.length - 1
        , r = n.matched.length - 1;
    return s > -1 && s === r && Yu(e.matched[s], n.matched[r]) && D4(e.params, n.params) && t(e.query) === t(n.query) && e.hash === n.hash
}
function Yu(t, e) {
    return (t.aliasOf || t) === (e.aliasOf || e)
}
function D4(t, e) {
    if (Object.keys(t).length !== Object.keys(e).length)
        return !1;
    for (const n in t)
        if (!Gee(t[n], e[n]))
            return !1;
    return !0
}
function Gee(t, e) {
    return li(t) ? k2(t, e) : li(e) ? k2(e, t) : t === e
}
function k2(t, e) {
    return li(e) ? t.length === e.length && t.every((n, s) => n === e[s]) : t.length === 1 && t[0] === e
}
function Hee(t, e) {
    if (t.startsWith("/"))
        return t;
    if (!t)
        return e;
    const n = e.split("/")
        , s = t.split("/")
        , r = s[s.length - 1];
    (r === ".." || r === ".") && s.push("");
    let i = n.length - 1, o, l;
    for (o = 0; o < s.length; o++)
        if (l = s[o],
            l !== ".")
            if (l === "..")
                i > 1 && i--;
            else
                break;
    return n.slice(0, i).join("/") + "/" + s.slice(o).join("/")
}
const ea = {
    path: "/",
    name: void 0,
    params: {},
    query: {},
    hash: "",
    fullPath: "/",
    matched: [],
    meta: {},
    redirectedFrom: void 0
};
var Pd;
(function (t) {
    t.pop = "pop",
        t.push = "push"
}
)(Pd || (Pd = {}));
var ld;
(function (t) {
    t.back = "back",
        t.forward = "forward",
        t.unknown = ""
}
)(ld || (ld = {}));
function Wee(t) {
    if (!t)
        if ($c) {
            const e = document.querySelector("base");
            t = e && e.getAttribute("href") || "/",
                t = t.replace(/^\w+:\/\/[^\/]+/, "")
        } else
            t = "/";
    return t[0] !== "/" && t[0] !== "#" && (t = "/" + t),
        $ee(t)
}
const Yee = /^[^#]+#/;
function Xee(t, e) {
    return t.replace(Yee, "#") + e
}
function jee(t, e) {
    const n = document.documentElement.getBoundingClientRect()
        , s = t.getBoundingClientRect();
    return {
        behavior: e.behavior,
        left: s.left - n.left - (e.left || 0),
        top: s.top - n.top - (e.top || 0)
    }
}
const E_ = () => ({
    left: window.scrollX,
    top: window.scrollY
});
function zee(t) {
    let e;
    if ("el" in t) {
        const n = t.el
            , s = typeof n == "string" && n.startsWith("#")
            , r = typeof n == "string" ? s ? document.getElementById(n.slice(1)) : document.querySelector(n) : n;
        if (!r)
            return;
        e = jee(r, t)
    } else
        e = t;
    "scrollBehavior" in document.documentElement.style ? window.scrollTo(e) : window.scrollTo(e.left != null ? e.left : window.scrollX, e.top != null ? e.top : window.scrollY)
}
function R2(t, e) {
    return (history.state ? history.state.position - e : -1) + t
}
const Zy = new Map;
function qee(t, e) {
    Zy.set(t, e)
}
function Kee(t) {
    const e = Zy.get(t);
    return Zy.delete(t),
        e
}
let Jee = () => location.protocol + "//" + location.host;
function B4(t, e) {
    const { pathname: n, search: s, hash: r } = e
        , i = t.indexOf("#");
    if (i > -1) {
        let l = r.includes(t.slice(i)) ? t.slice(i).length : 1
            , a = r.slice(l);
        return a[0] !== "/" && (a = "/" + a),
            A2(a, "")
    }
    return A2(n, t) + s + r
}
function Zee(t, e, n, s) {
    let r = []
        , i = []
        , o = null;
    const l = ({ state: d }) => {
        const f = B4(t, location)
            , p = n.value
            , m = e.value;
        let g = 0;
        if (d) {
            if (n.value = f,
                e.value = d,
                o && o === p) {
                o = null;
                return
            }
            g = m ? d.position - m.position : 0
        } else
            s(f);
        r.forEach(b => {
            b(n.value, p, {
                delta: g,
                type: Pd.pop,
                direction: g ? g > 0 ? ld.forward : ld.back : ld.unknown
            })
        }
        )
    }
        ;
    function a() {
        o = n.value
    }
    function c(d) {
        r.push(d);
        const f = () => {
            const p = r.indexOf(d);
            p > -1 && r.splice(p, 1)
        }
            ;
        return i.push(f),
            f
    }
    function u() {
        const { history: d } = window;
        d.state && d.replaceState(Ot({}, d.state, {
            scroll: E_()
        }), "")
    }
    function h() {
        for (const d of i)
            d();
        i = [],
            window.removeEventListener("popstate", l),
            window.removeEventListener("beforeunload", u)
    }
    return window.addEventListener("popstate", l),
        window.addEventListener("beforeunload", u, {
            passive: !0
        }),
    {
        pauseListeners: a,
        listen: c,
        destroy: h
    }
}
function M2(t, e, n, s = !1, r = !1) {
    return {
        back: t,
        current: e,
        forward: n,
        replaced: s,
        position: window.history.length,
        scroll: r ? E_() : null
    }
}
function Qee(t) {
    const { history: e, location: n } = window
        , s = {
            value: B4(t, n)
        }
        , r = {
            value: e.state
        };
    r.value || i(s.value, {
        back: null,
        current: s.value,
        forward: null,
        position: e.length - 1,
        replaced: !0,
        scroll: null
    }, !0);
    function i(a, c, u) {
        const h = t.indexOf("#")
            , d = h > -1 ? (n.host && document.querySelector("base") ? t : t.slice(h)) + a : Jee() + t + a;
        try {
            e[u ? "replaceState" : "pushState"](c, "", d),
                r.value = c
        } catch (f) {
            console.error(f),
                n[u ? "replace" : "assign"](d)
        }
    }
    function o(a, c) {
        const u = Ot({}, e.state, M2(r.value.back, a, r.value.forward, !0), c, {
            position: r.value.position
        });
        i(a, u, !0),
            s.value = a
    }
    function l(a, c) {
        const u = Ot({}, r.value, e.state, {
            forward: a,
            scroll: E_()
        });
        i(u.current, u, !0);
        const h = Ot({}, M2(s.value, a, null), {
            position: u.position + 1
        }, c);
        i(a, h, !1),
            s.value = a
    }
    return {
        location: s,
        state: r,
        push: l,
        replace: o
    }
}
function ete(t) {
    t = Wee(t);
    const e = Qee(t)
        , n = Zee(t, e.state, e.location, e.replace);
    function s(i, o = !0) {
        o || n.pauseListeners(),
            history.go(i)
    }
    const r = Ot({
        location: "",
        base: t,
        go: s,
        createHref: Xee.bind(null, t)
    }, e, n);
    return Object.defineProperty(r, "location", {
        enumerable: !0,
        get: () => e.location.value
    }),
        Object.defineProperty(r, "state", {
            enumerable: !0,
            get: () => e.state.value
        }),
        r
}
function tte(t) {
    return typeof t == "string" || t && typeof t == "object"
}
function F4(t) {
    return typeof t == "string" || typeof t == "symbol"
}
const $4 = Symbol("");
var P2;
(function (t) {
    t[t.aborted = 4] = "aborted",
        t[t.cancelled = 8] = "cancelled",
        t[t.duplicated = 16] = "duplicated"
}
)(P2 || (P2 = {}));
function Xu(t, e) {
    return Ot(new Error, {
        type: t,
        [$4]: !0
    }, e)
}
function to(t, e) {
    return t instanceof Error && $4 in t && (e == null || !!(t.type & e))
}
const L2 = "[^/]+?"
    , nte = {
        sensitive: !1,
        strict: !1,
        start: !0,
        end: !0
    }
    , ste = /[.+*?^${}()[\]/\\]/g;
function rte(t, e) {
    const n = Ot({}, nte, e)
        , s = [];
    let r = n.start ? "^" : "";
    const i = [];
    for (const c of t) {
        const u = c.length ? [] : [90];
        n.strict && !c.length && (r += "/");
        for (let h = 0; h < c.length; h++) {
            const d = c[h];
            let f = 40 + (n.sensitive ? .25 : 0);
            if (d.type === 0)
                h || (r += "/"),
                    r += d.value.replace(ste, "\\$&"),
                    f += 40;
            else if (d.type === 1) {
                const { value: p, repeatable: m, optional: g, regexp: b } = d;
                i.push({
                    name: p,
                    repeatable: m,
                    optional: g
                });
                const v = b || L2;
                if (v !== L2) {
                    f += 10;
                    try {
                        new RegExp(`(${v})`)
                    } catch (y) {
                        throw new Error(`Invalid custom RegExp for param "${p}" (${v}): ` + y.message)
                    }
                }
                let _ = m ? `((?:${v})(?:/(?:${v}))*)` : `(${v})`;
                h || (_ = g && c.length < 2 ? `(?:/${_})` : "/" + _),
                    g && (_ += "?"),
                    r += _,
                    f += 20,
                    g && (f += -8),
                    m && (f += -20),
                    v === ".*" && (f += -50)
            }
            u.push(f)
        }
        s.push(u)
    }
    if (n.strict && n.end) {
        const c = s.length - 1;
        s[c][s[c].length - 1] += .7000000000000001
    }
    n.strict || (r += "/?"),
        n.end ? r += "$" : n.strict && (r += "(?:/|$)");
    const o = new RegExp(r, n.sensitive ? "" : "i");
    function l(c) {
        const u = c.match(o)
            , h = {};
        if (!u)
            return null;
        for (let d = 1; d < u.length; d++) {
            const f = u[d] || ""
                , p = i[d - 1];
            h[p.name] = f && p.repeatable ? f.split("/") : f
        }
        return h
    }
    function a(c) {
        let u = ""
            , h = !1;
        for (const d of t) {
            (!h || !u.endsWith("/")) && (u += "/"),
                h = !1;
            for (const f of d)
                if (f.type === 0)
                    u += f.value;
                else if (f.type === 1) {
                    const { value: p, repeatable: m, optional: g } = f
                        , b = p in c ? c[p] : "";
                    if (li(b) && !m)
                        throw new Error(`Provided param "${p}" is an array but it is not repeatable (* or + modifiers)`);
                    const v = li(b) ? b.join("/") : b;
                    if (!v)
                        if (g)
                            d.length < 2 && (u.endsWith("/") ? u = u.slice(0, -1) : h = !0);
                        else
                            throw new Error(`Missing required param "${p}"`);
                    u += v
                }
        }
        return u || "/"
    }
    return {
        re: o,
        score: s,
        keys: i,
        parse: l,
        stringify: a
    }
}
function ite(t, e) {
    let n = 0;
    for (; n < t.length && n < e.length;) {
        const s = e[n] - t[n];
        if (s)
            return s;
        n++
    }
    return t.length < e.length ? t.length === 1 && t[0] === 80 ? -1 : 1 : t.length > e.length ? e.length === 1 && e[0] === 80 ? 1 : -1 : 0
}
function U4(t, e) {
    let n = 0;
    const s = t.score
        , r = e.score;
    for (; n < s.length && n < r.length;) {
        const i = ite(s[n], r[n]);
        if (i)
            return i;
        n++
    }
    if (Math.abs(r.length - s.length) === 1) {
        if (O2(s))
            return 1;
        if (O2(r))
            return -1
    }
    return r.length - s.length
}
function O2(t) {
    const e = t[t.length - 1];
    return t.length > 0 && e[e.length - 1] < 0
}
const ote = {
    type: 0,
    value: ""
}
    , ate = /[a-zA-Z0-9_]/;
function lte(t) {
    if (!t)
        return [[]];
    if (t === "/")
        return [[ote]];
    if (!t.startsWith("/"))
        throw new Error(`Invalid path "${t}"`);
    function e(f) {
        throw new Error(`ERR (${n})/"${c}": ${f}`)
    }
    let n = 0
        , s = n;
    const r = [];
    let i;
    function o() {
        i && r.push(i),
            i = []
    }
    let l = 0, a, c = "", u = "";
    function h() {
        c && (n === 0 ? i.push({
            type: 0,
            value: c
        }) : n === 1 || n === 2 || n === 3 ? (i.length > 1 && (a === "*" || a === "+") && e(`A repeatable param (${c}) must be alone in its segment. eg: '/:ids+.`),
            i.push({
                type: 1,
                value: c,
                regexp: u,
                repeatable: a === "*" || a === "+",
                optional: a === "*" || a === "?"
            })) : e("Invalid state to consume buffer"),
            c = "")
    }
    function d() {
        c += a
    }
    for (; l < t.length;) {
        if (a = t[l++],
            a === "\\" && n !== 2) {
            s = n,
                n = 4;
            continue
        }
        switch (n) {
            case 0:
                a === "/" ? (c && h(),
                    o()) : a === ":" ? (h(),
                        n = 1) : d();
                break;
            case 4:
                d(),
                    n = s;
                break;
            case 1:
                a === "(" ? n = 2 : ate.test(a) ? d() : (h(),
                    n = 0,
                    a !== "*" && a !== "?" && a !== "+" && l--);
                break;
            case 2:
                a === ")" ? u[u.length - 1] == "\\" ? u = u.slice(0, -1) + a : n = 3 : u += a;
                break;
            case 3:
                h(),
                    n = 0,
                    a !== "*" && a !== "?" && a !== "+" && l--,
                    u = "";
                break;
            default:
                e("Unknown state");
                break
        }
    }
    return n === 2 && e(`Unfinished custom RegExp for param "${c}"`),
        h(),
        o(),
        r
}
function cte(t, e, n) {
    const s = rte(lte(t.path), n)
        , r = Ot(s, {
            record: t,
            parent: e,
            children: [],
            alias: []
        });
    return e && !r.record.aliasOf == !e.record.aliasOf && e.children.push(r),
        r
}
function ute(t, e) {
    const n = []
        , s = new Map;
    e = B2({
        strict: !1,
        end: !0,
        sensitive: !1
    }, e);
    function r(h) {
        return s.get(h)
    }
    function i(h, d, f) {
        const p = !f
            , m = hte(h);
        m.aliasOf = f && f.record;
        const g = B2(e, h)
            , b = [m];
        if ("alias" in h) {
            const y = typeof h.alias == "string" ? [h.alias] : h.alias;
            for (const x of y)
                b.push(Ot({}, m, {
                    components: f ? f.record.components : m.components,
                    path: x,
                    aliasOf: f ? f.record : m
                }))
        }
        let v, _;
        for (const y of b) {
            const { path: x } = y;
            if (d && x[0] !== "/") {
                const w = d.record.path
                    , S = w[w.length - 1] === "/" ? "" : "/";
                y.path = d.record.path + (x && S + x)
            }
            if (v = cte(y, d, g),
                f ? f.alias.push(v) : (_ = _ || v,
                    _ !== v && _.alias.push(v),
                    p && h.name && !D2(v) && o(h.name)),
                V4(v) && a(v),
                m.children) {
                const w = m.children;
                for (let S = 0; S < w.length; S++)
                    i(w[S], v, f && f.children[S])
            }
            f = f || v
        }
        return _ ? () => {
            o(_)
        }
            : ad
    }
    function o(h) {
        if (F4(h)) {
            const d = s.get(h);
            d && (s.delete(h),
                n.splice(n.indexOf(d), 1),
                d.children.forEach(o),
                d.alias.forEach(o))
        } else {
            const d = n.indexOf(h);
            d > -1 && (n.splice(d, 1),
                h.record.name && s.delete(h.record.name),
                h.children.forEach(o),
                h.alias.forEach(o))
        }
    }
    function l() {
        return n
    }
    function a(h) {
        const d = pte(h, n);
        n.splice(d, 0, h),
            h.record.name && !D2(h) && s.set(h.record.name, h)
    }
    function c(h, d) {
        let f, p = {}, m, g;
        if ("name" in h && h.name) {
            if (f = s.get(h.name),
                !f)
                throw Xu(1, {
                    location: h
                });
            g = f.record.name,
                p = Ot(N2(d.params, f.keys.filter(_ => !_.optional).concat(f.parent ? f.parent.keys.filter(_ => _.optional) : []).map(_ => _.name)), h.params && N2(h.params, f.keys.map(_ => _.name))),
                m = f.stringify(p)
        } else if (h.path != null)
            m = h.path,
                f = n.find(_ => _.re.test(m)),
                f && (p = f.parse(m),
                    g = f.record.name);
        else {
            if (f = d.name ? s.get(d.name) : n.find(_ => _.re.test(d.path)),
                !f)
                throw Xu(1, {
                    location: h,
                    currentLocation: d
                });
            g = f.record.name,
                p = Ot({}, d.params, h.params),
                m = f.stringify(p)
        }
        const b = [];
        let v = f;
        for (; v;)
            b.unshift(v.record),
                v = v.parent;
        return {
            name: g,
            path: m,
            params: p,
            matched: b,
            meta: fte(b)
        }
    }
    t.forEach(h => i(h));
    function u() {
        n.length = 0,
            s.clear()
    }
    return {
        addRoute: i,
        resolve: c,
        removeRoute: o,
        clearRoutes: u,
        getRoutes: l,
        getRecordMatcher: r
    }
}
function N2(t, e) {
    const n = {};
    for (const s of e)
        s in t && (n[s] = t[s]);
    return n
}
function hte(t) {
    return {
        path: t.path,
        redirect: t.redirect,
        name: t.name,
        meta: t.meta || {},
        aliasOf: void 0,
        beforeEnter: t.beforeEnter,
        props: dte(t),
        children: t.children || [],
        instances: {},
        leaveGuards: new Set,
        updateGuards: new Set,
        enterCallbacks: {},
        components: "components" in t ? t.components || null : t.component && {
            default: t.component
        }
    }
}
function dte(t) {
    const e = {}
        , n = t.props || !1;
    if ("component" in t)
        e.default = n;
    else
        for (const s in t.components)
            e[s] = typeof n == "object" ? n[s] : n;
    return e
}
function D2(t) {
    for (; t;) {
        if (t.record.aliasOf)
            return !0;
        t = t.parent
    }
    return !1
}
function fte(t) {
    return t.reduce((e, n) => Ot(e, n.meta), {})
}
function B2(t, e) {
    const n = {};
    for (const s in t)
        n[s] = s in e ? e[s] : t[s];
    return n
}
function pte(t, e) {
    let n = 0
        , s = e.length;
    for (; n !== s;) {
        const i = n + s >> 1;
        U4(t, e[i]) < 0 ? s = i : n = i + 1
    }
    const r = mte(t);
    return r && (s = e.lastIndexOf(r, s - 1)),
        s
}
function mte(t) {
    let e = t;
    for (; e = e.parent;)
        if (V4(e) && U4(t, e) === 0)
            return e
}
function V4({ record: t }) {
    return !!(t.name || t.components && Object.keys(t.components).length || t.redirect)
}
function gte(t) {
    const e = {};
    if (t === "" || t === "?")
        return e;
    const s = (t[0] === "?" ? t.slice(1) : t).split("&");
    for (let r = 0; r < s.length; ++r) {
        const i = s[r].replace(P4, " ")
            , o = i.indexOf("=")
            , l = Md(o < 0 ? i : i.slice(0, o))
            , a = o < 0 ? null : Md(i.slice(o + 1));
        if (l in e) {
            let c = e[l];
            li(c) || (c = e[l] = [c]),
                c.push(a)
        } else
            e[l] = a
    }
    return e
}
function F2(t) {
    let e = "";
    for (let n in t) {
        const s = t[n];
        if (n = Nee(n),
            s == null) {
            s !== void 0 && (e += (e.length ? "&" : "") + n);
            continue
        }
        (li(s) ? s.map(i => i && Jy(i)) : [s && Jy(s)]).forEach(i => {
            i !== void 0 && (e += (e.length ? "&" : "") + n,
                i != null && (e += "=" + i))
        }
        )
    }
    return e
}
function _te(t) {
    const e = {};
    for (const n in t) {
        const s = t[n];
        s !== void 0 && (e[n] = li(s) ? s.map(r => r == null ? null : "" + r) : s == null ? s : "" + s)
    }
    return e
}
const yte = Symbol("")
    , $2 = Symbol("")
    , T_ = Symbol("")
    , G4 = Symbol("")
    , Qy = Symbol("");
function Ih() {
    let t = [];
    function e(s) {
        return t.push(s),
            () => {
                const r = t.indexOf(s);
                r > -1 && t.splice(r, 1)
            }
    }
    function n() {
        t = []
    }
    return {
        add: e,
        list: () => t.slice(),
        reset: n
    }
}
function va(t, e, n, s, r, i = o => o()) {
    const o = s && (s.enterCallbacks[r] = s.enterCallbacks[r] || []);
    return () => new Promise((l, a) => {
        const c = d => {
            d === !1 ? a(Xu(4, {
                from: n,
                to: e
            })) : d instanceof Error ? a(d) : tte(d) ? a(Xu(2, {
                from: e,
                to: d
            })) : (o && s.enterCallbacks[r] === o && typeof d == "function" && o.push(d),
                l())
        }
            , u = i(() => t.call(s && s.instances[r], e, n, c));
        let h = Promise.resolve(u);
        t.length < 3 && (h = h.then(c)),
            h.catch(d => a(d))
    }
    )
}
function W0(t, e, n, s, r = i => i()) {
    const i = [];
    for (const o of t)
        for (const l in o.components) {
            let a = o.components[l];
            if (!(e !== "beforeRouteEnter" && !o.instances[l]))
                if (bte(a)) {
                    const u = (a.__vccOpts || a)[e];
                    u && i.push(va(u, n, s, o, l, r))
                } else {
                    let c = a();
                    i.push(() => c.then(u => {
                        if (!u)
                            return Promise.reject(new Error(`Couldn't resolve component "${l}" at "${o.path}"`));
                        const h = Eee(u) ? u.default : u;
                        o.components[l] = h;
                        const f = (h.__vccOpts || h)[e];
                        return f && va(f, n, s, o, l, r)()
                    }
                    ))
                }
        }
    return i
}
function bte(t) {
    return typeof t == "object" || "displayName" in t || "props" in t || "__vccOpts" in t
}
function U2(t) {
    const e = Ar(T_)
        , n = Ar(G4)
        , s = ve(() => {
            const a = de(t.to);
            return e.resolve(a)
        }
        )
        , r = ve(() => {
            const { matched: a } = s.value
                , { length: c } = a
                , u = a[c - 1]
                , h = n.matched;
            if (!u || !h.length)
                return -1;
            const d = h.findIndex(Yu.bind(null, u));
            if (d > -1)
                return d;
            const f = V2(a[c - 2]);
            return c > 1 && V2(u) === f && h[h.length - 1].path !== f ? h.findIndex(Yu.bind(null, a[c - 2])) : d
        }
        )
        , i = ve(() => r.value > -1 && Ste(n.params, s.value.params))
        , o = ve(() => r.value > -1 && r.value === n.matched.length - 1 && D4(n.params, s.value.params));
    function l(a = {}) {
        return wte(a) ? e[de(t.replace) ? "replace" : "push"](de(t.to)).catch(ad) : Promise.resolve()
    }
    return {
        route: s,
        href: ve(() => s.value.href),
        isActive: i,
        isExactActive: o,
        navigate: l
    }
}
const vte = Qa({
    name: "RouterLink",
    compatConfig: {
        MODE: 3
    },
    props: {
        to: {
            type: [String, Object],
            required: !0
        },
        replace: Boolean,
        activeClass: String,
        exactActiveClass: String,
        custom: Boolean,
        ariaCurrentValue: {
            type: String,
            default: "page"
        }
    },
    useLink: U2,
    setup(t, { slots: e }) {
        const n = Qu(U2(t))
            , { options: s } = Ar(T_)
            , r = ve(() => ({
                [G2(t.activeClass, s.linkActiveClass, "router-link-active")]: n.isActive,
                [G2(t.exactActiveClass, s.linkExactActiveClass, "router-link-exact-active")]: n.isExactActive
            }));
        return () => {
            const i = e.default && e.default(n);
            return t.custom ? i : Wi("a", {
                "aria-current": n.isExactActive ? t.ariaCurrentValue : null,
                href: n.href,
                onClick: n.navigate,
                class: r.value
            }, i)
        }
    }
})
    , xte = vte;
function wte(t) {
    if (!(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey) && !t.defaultPrevented && !(t.button !== void 0 && t.button !== 0)) {
        if (t.currentTarget && t.currentTarget.getAttribute) {
            const e = t.currentTarget.getAttribute("target");
            if (/\b_blank\b/i.test(e))
                return
        }
        return t.preventDefault && t.preventDefault(),
            !0
    }
}
function Ste(t, e) {
    for (const n in e) {
        const s = e[n]
            , r = t[n];
        if (typeof s == "string") {
            if (s !== r)
                return !1
        } else if (!li(r) || r.length !== s.length || s.some((i, o) => i !== r[o]))
            return !1
    }
    return !0
}
function V2(t) {
    return t ? t.aliasOf ? t.aliasOf.path : t.path : ""
}
const G2 = (t, e, n) => t ?? e ?? n
    , Ete = Qa({
        name: "RouterView",
        inheritAttrs: !1,
        props: {
            name: {
                type: String,
                default: "default"
            },
            route: Object
        },
        compatConfig: {
            MODE: 3
        },
        setup(t, { attrs: e, slots: n }) {
            const s = Ar(Qy)
                , r = ve(() => t.route || s.value)
                , i = Ar($2, 0)
                , o = ve(() => {
                    let c = de(i);
                    const { matched: u } = r.value;
                    let h;
                    for (; (h = u[c]) && !h.components;)
                        c++;
                    return c
                }
                )
                , l = ve(() => r.value.matched[o.value]);
            Rp($2, ve(() => o.value + 1)),
                Rp(yte, l),
                Rp(Qy, r);
            const a = ke();
            return Ln(() => [a.value, l.value, t.name], ([c, u, h], [d, f, p]) => {
                u && (u.instances[h] = c,
                    f && f !== u && c && c === d && (u.leaveGuards.size || (u.leaveGuards = f.leaveGuards),
                        u.updateGuards.size || (u.updateGuards = f.updateGuards))),
                    c && u && (!f || !Yu(u, f) || !d) && (u.enterCallbacks[h] || []).forEach(m => m(c))
            }
                , {
                    flush: "post"
                }),
                () => {
                    const c = r.value
                        , u = t.name
                        , h = l.value
                        , d = h && h.components[u];
                    if (!d)
                        return H2(n.default, {
                            Component: d,
                            route: c
                        });
                    const f = h.props[u]
                        , p = f ? f === !0 ? c.params : typeof f == "function" ? f(c) : f : null
                        , g = Wi(d, Ot({}, p, e, {
                            onVnodeUnmounted: b => {
                                b.component.isUnmounted && (h.instances[u] = null)
                            }
                            ,
                            ref: a
                        }));
                    return H2(n.default, {
                        Component: g,
                        route: c
                    }) || g
                }
        }
    });
function H2(t, e) {
    if (!t)
        return null;
    const n = t(e);
    return n.length === 1 ? n[0] : n
}
const Tte = Ete;
function Cte(t) {
    const e = ute(t.routes, t)
        , n = t.parseQuery || gte
        , s = t.stringifyQuery || F2
        , r = t.history
        , i = Ih()
        , o = Ih()
        , l = Ih()
        , a = Sv(ea);
    let c = ea;
    $c && t.scrollBehavior && "scrollRestoration" in history && (history.scrollRestoration = "manual");
    const u = G0.bind(null, K => "" + K)
        , h = G0.bind(null, Bee)
        , d = G0.bind(null, Md);
    function f(K, ge) {
        let he, be;
        return F4(K) ? (he = e.getRecordMatcher(K),
            be = ge) : be = K,
            e.addRoute(be, he)
    }
    function p(K) {
        const ge = e.getRecordMatcher(K);
        ge && e.removeRoute(ge)
    }
    function m() {
        return e.getRoutes().map(K => K.record)
    }
    function g(K) {
        return !!e.getRecordMatcher(K)
    }
    function b(K, ge) {
        if (ge = Ot({}, ge || a.value),
            typeof K == "string") {
            const M = H0(n, K, ge.path)
                , X = e.resolve({
                    path: M.path
                }, ge)
                , ae = r.createHref(M.fullPath);
            return Ot(M, X, {
                params: d(X.params),
                hash: Md(M.hash),
                redirectedFrom: void 0,
                href: ae
            })
        }
        let he;
        if (K.path != null)
            he = Ot({}, K, {
                path: H0(n, K.path, ge.path).path
            });
        else {
            const M = Ot({}, K.params);
            for (const X in M)
                M[X] == null && delete M[X];
            he = Ot({}, K, {
                params: h(M)
            }),
                ge.params = h(ge.params)
        }
        const be = e.resolve(he, ge)
            , Pe = K.hash || "";
        be.params = u(d(be.params));
        const De = Uee(s, Ot({}, K, {
            hash: Oee(Pe),
            path: be.path
        }))
            , D = r.createHref(De);
        return Ot({
            fullPath: De,
            hash: Pe,
            query: s === F2 ? _te(K.query) : K.query || {}
        }, be, {
            redirectedFrom: void 0,
            href: D
        })
    }
    function v(K) {
        return typeof K == "string" ? H0(n, K, a.value.path) : Ot({}, K)
    }
    function _(K, ge) {
        if (c !== K)
            return Xu(8, {
                from: ge,
                to: K
            })
    }
    function y(K) {
        return S(K)
    }
    function x(K) {
        return y(Ot(v(K), {
            replace: !0
        }))
    }
    function w(K) {
        const ge = K.matched[K.matched.length - 1];
        if (ge && ge.redirect) {
            const { redirect: he } = ge;
            let be = typeof he == "function" ? he(K) : he;
            return typeof be == "string" && (be = be.includes("?") || be.includes("#") ? be = v(be) : {
                path: be
            },
                be.params = {}),
                Ot({
                    query: K.query,
                    hash: K.hash,
                    params: be.path != null ? {} : K.params
                }, be)
        }
    }
    function S(K, ge) {
        const he = c = b(K)
            , be = a.value
            , Pe = K.state
            , De = K.force
            , D = K.replace === !0
            , M = w(he);
        if (M)
            return S(Ot(v(M), {
                state: typeof M == "object" ? Ot({}, Pe, M.state) : Pe,
                force: De,
                replace: D
            }), ge || he);
        const X = he;
        X.redirectedFrom = ge;
        let ae;
        return !De && Vee(s, be, he) && (ae = Xu(16, {
            to: X,
            from: be
        }),
            Y(be, be, !0, !1)),
            (ae ? Promise.resolve(ae) : I(X, be)).catch(ie => to(ie) ? to(ie, 2) ? ie : J(ie) : z(ie, X, be)).then(ie => {
                if (ie) {
                    if (to(ie, 2))
                        return S(Ot({
                            replace: D
                        }, v(ie.to), {
                            state: typeof ie.to == "object" ? Ot({}, Pe, ie.to.state) : Pe,
                            force: De
                        }), ge || X)
                } else
                    ie = k(X, be, !0, D, Pe);
                return L(X, be, ie),
                    ie
            }
            )
    }
    function E(K, ge) {
        const he = _(K, ge);
        return he ? Promise.reject(he) : Promise.resolve()
    }
    function C(K) {
        const ge = ce.values().next().value;
        return ge && typeof ge.runWithContext == "function" ? ge.runWithContext(K) : K()
    }
    function I(K, ge) {
        let he;
        const [be, Pe, De] = Ite(K, ge);
        he = W0(be.reverse(), "beforeRouteLeave", K, ge);
        for (const M of be)
            M.leaveGuards.forEach(X => {
                he.push(va(X, K, ge))
            }
            );
        const D = E.bind(null, K, ge);
        return he.push(D),
            we(he).then(() => {
                he = [];
                for (const M of i.list())
                    he.push(va(M, K, ge));
                return he.push(D),
                    we(he)
            }
            ).then(() => {
                he = W0(Pe, "beforeRouteUpdate", K, ge);
                for (const M of Pe)
                    M.updateGuards.forEach(X => {
                        he.push(va(X, K, ge))
                    }
                    );
                return he.push(D),
                    we(he)
            }
            ).then(() => {
                he = [];
                for (const M of De)
                    if (M.beforeEnter)
                        if (li(M.beforeEnter))
                            for (const X of M.beforeEnter)
                                he.push(va(X, K, ge));
                        else
                            he.push(va(M.beforeEnter, K, ge));
                return he.push(D),
                    we(he)
            }
            ).then(() => (K.matched.forEach(M => M.enterCallbacks = {}),
                he = W0(De, "beforeRouteEnter", K, ge, C),
                he.push(D),
                we(he))).then(() => {
                    he = [];
                    for (const M of o.list())
                        he.push(va(M, K, ge));
                    return he.push(D),
                        we(he)
                }
                ).catch(M => to(M, 8) ? M : Promise.reject(M))
    }
    function L(K, ge, he) {
        l.list().forEach(be => C(() => be(K, ge, he)))
    }
    function k(K, ge, he, be, Pe) {
        const De = _(K, ge);
        if (De)
            return De;
        const D = ge === ea
            , M = $c ? history.state : {};
        he && (be || D ? r.replace(K.fullPath, Ot({
            scroll: D && M && M.scroll
        }, Pe)) : r.push(K.fullPath, Pe)),
            a.value = K,
            Y(K, ge, he, D),
            J()
    }
    let R;
    function U() {
        R || (R = r.listen((K, ge, he) => {
            if (!ue.listening)
                return;
            const be = b(K)
                , Pe = w(be);
            if (Pe) {
                S(Ot(Pe, {
                    replace: !0
                }), be).catch(ad);
                return
            }
            c = be;
            const De = a.value;
            $c && qee(R2(De.fullPath, he.delta), E_()),
                I(be, De).catch(D => to(D, 12) ? D : to(D, 2) ? (S(D.to, be).then(M => {
                    to(M, 20) && !he.delta && he.type === Pd.pop && r.go(-1, !1)
                }
                ).catch(ad),
                    Promise.reject()) : (he.delta && r.go(-he.delta, !1),
                        z(D, be, De))).then(D => {
                            D = D || k(be, De, !1),
                                D && (he.delta && !to(D, 8) ? r.go(-he.delta, !1) : he.type === Pd.pop && to(D, 20) && r.go(-1, !1)),
                                L(be, De, D)
                        }
                        ).catch(ad)
        }
        ))
    }
    let W = Ih(), H = Ih(), j;
    function z(K, ge, he) {
        J(K);
        const be = H.list();
        return be.length ? be.forEach(Pe => Pe(K, ge, he)) : console.error(K),
            Promise.reject(K)
    }
    function ee() {
        return j && a.value !== ea ? Promise.resolve() : new Promise((K, ge) => {
            W.add([K, ge])
        }
        )
    }
    function J(K) {
        return j || (j = !K,
            U(),
            W.list().forEach(([ge, he]) => K ? he(K) : ge()),
            W.reset()),
            K
    }
    function Y(K, ge, he, be) {
        const { scrollBehavior: Pe } = t;
        if (!$c || !Pe)
            return Promise.resolve();
        const De = !he && Kee(R2(K.fullPath, 0)) || (be || !he) && history.state && history.state.scroll || null;
        return Zd().then(() => Pe(K, ge, De)).then(D => D && zee(D)).catch(D => z(D, K, ge))
    }
    const ne = K => r.go(K);
    let oe;
    const ce = new Set
        , ue = {
            currentRoute: a,
            listening: !0,
            addRoute: f,
            removeRoute: p,
            clearRoutes: e.clearRoutes,
            hasRoute: g,
            getRoutes: m,
            resolve: b,
            options: t,
            push: y,
            replace: x,
            go: ne,
            back: () => ne(-1),
            forward: () => ne(1),
            beforeEach: i.add,
            beforeResolve: o.add,
            afterEach: l.add,
            onError: H.add,
            isReady: ee,
            install(K) {
                const ge = this;
                K.component("RouterLink", xte),
                    K.component("RouterView", Tte),
                    K.config.globalProperties.$router = ge,
                    Object.defineProperty(K.config.globalProperties, "$route", {
                        enumerable: !0,
                        get: () => de(a)
                    }),
                    $c && !oe && a.value === ea && (oe = !0,
                        y(r.location).catch(Pe => { }
                        ));
                const he = {};
                for (const Pe in ea)
                    Object.defineProperty(he, Pe, {
                        get: () => a.value[Pe],
                        enumerable: !0
                    });
                K.provide(T_, ge),
                    K.provide(G4, c3(he)),
                    K.provide(Qy, a);
                const be = K.unmount;
                ce.add(K),
                    K.unmount = function () {
                        ce.delete(K),
                            ce.size < 1 && (c = ea,
                                R && R(),
                                R = null,
                                a.value = ea,
                                oe = !1,
                                j = !1),
                            be()
                    }
            }
        };
    function we(K) {
        return K.reduce((ge, he) => ge.then(() => C(he)), Promise.resolve())
    }
    return ue
}
function Ite(t, e) {
    const n = []
        , s = []
        , r = []
        , i = Math.max(e.matched.length, t.matched.length);
    for (let o = 0; o < i; o++) {
        const l = e.matched[o];
        l && (t.matched.find(c => Yu(c, l)) ? s.push(l) : n.push(l));
        const a = t.matched[o];
        a && (e.matched.find(c => Yu(c, a)) || r.push(a))
    }
    return [n, s, r]
}
function Ld() {
    return Ar(T_)
}
const Ate = {}
    , kte = {
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }
    , Rte = T("path", {
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        d: "M12 21.1667C6.93739 21.1667 2.83333 17.0626 2.83333 12C2.83333 6.93739 6.93739 2.83333 12 2.83333C17.0626 2.83333 21.1667 6.93739 21.1667 12C21.1667 17.0626 17.0626 21.1667 12 21.1667ZM1 12C1 5.92487 5.92487 1 12 1C18.0751 1 23 5.92487 23 12C23 18.0751 18.0751 23 12 23C5.92487 23 1 18.0751 1 12ZM10.8841 13.4039L10.8922 13.9997H12.5927V13.5454C12.5927 13.2872 12.6309 13.0662 12.7072 12.8825C12.7889 12.6939 12.9279 12.5176 13.1241 12.3538C13.3203 12.1849 13.5928 12.0062 13.9417 11.8175C14.4867 11.5246 14.9091 11.1721 15.2088 10.76C15.5141 10.3429 15.6667 9.84891 15.6667 9.27793V9.26303C15.6667 8.73178 15.5141 8.2601 15.2088 7.848C14.9091 7.43094 14.4867 7.10325 13.9417 6.86493C13.4021 6.62164 12.7699 6.5 12.045 6.5C11.2601 6.5 10.5952 6.63157 10.0502 6.89472C9.50514 7.1529 9.08819 7.5079 8.79933 7.95972C8.51592 8.40657 8.36059 8.90803 8.33333 9.46412V9.47901L10.0256 9.47156L10.042 9.46412C10.0638 9.14139 10.1564 8.86087 10.32 8.62255C10.4835 8.37926 10.7042 8.19307 10.9822 8.06398C11.2601 7.93489 11.5871 7.87035 11.9632 7.87035C12.3338 7.87035 12.6554 7.93489 12.9279 8.06398C13.2059 8.18811 13.4184 8.3594 13.5656 8.57786C13.7182 8.79632 13.7945 9.04706 13.7945 9.33006V9.34496C13.7945 9.59321 13.7509 9.81415 13.6637 10.0078C13.5819 10.2014 13.443 10.3826 13.2467 10.5515C13.0505 10.7153 12.7889 10.8891 12.4619 11.0728C12.0913 11.2763 11.7861 11.4923 11.5463 11.7207C11.3065 11.9441 11.132 12.1924 11.023 12.4655C10.9195 12.7385 10.8732 13.0513 10.8841 13.4039ZM10.9249 17.1947C11.1593 17.3982 11.4645 17.5 11.8406 17.5C12.2221 17.5 12.5273 17.3982 12.7562 17.1947C12.9851 16.9911 13.0996 16.723 13.0996 16.3903C13.0996 16.0527 12.9851 15.7821 12.7562 15.5785C12.5273 15.37 12.2221 15.2657 11.8406 15.2657C11.4645 15.2657 11.1593 15.37 10.9249 15.5785C10.6906 15.7821 10.5734 16.0527 10.5734 16.3903C10.5734 16.723 10.6906 16.9911 10.9249 17.1947Z"
    }, null, -1)
    , Mte = [Rte];
function Pte(t, e) {
    return A(),
        N("svg", kte, Mte)
}
const Lte = _e(Ate, [["render", Pte]])
    , Ote = {}
    , Nte = {
        width: "16",
        height: "16",
        viewBox: "0 0 16 16",
        xmlns: "http://www.w3.org/2000/svg"
    }
    , Dte = Nr('<rect opacity="0.6" x="0.666656" y="6" width="14.6667" height="9.33333" rx="1" fill="url(#paint0_linear_6295_21408)"></rect><path fill-rule="evenodd" clip-rule="evenodd" d="M6 4C6.73638 4 7.33333 3.40305 7.33333 2.66667C7.33333 1.93029 6.73638 1.33333 6 1.33333C5.26362 1.33333 4.66667 1.93029 4.66667 2.66667C4.66667 3.40305 5.26362 4 6 4ZM8 0.902785C7.51137 0.34917 6.79646 0 6 0C4.52724 0 3.33333 1.19391 3.33333 2.66667C3.33333 3.15238 3.46319 3.60777 3.69009 4H0.666667C0.298477 4 0 4.29848 0 4.66667V7.33333C0 7.70152 0.298477 8 0.666667 8H6.66667V15.3333C6.66667 15.7015 6.96514 16 7.33333 16H8.66667C9.03486 16 9.33333 15.7015 9.33333 15.3333V8H15.3333C15.7015 8 16 7.70152 16 7.33333V4.66667C16 4.29848 15.7015 4 15.3333 4H12.3099C12.5368 3.60777 12.6667 3.15238 12.6667 2.66667C12.6667 1.19391 11.4728 0 10 0C9.20354 0 8.48863 0.34917 8 0.902785ZM8.66667 2.66667C8.66667 1.93029 9.26362 1.33333 10 1.33333C10.7364 1.33333 11.3333 1.93029 11.3333 2.66667C11.3333 3.40305 10.7364 4 10 4C9.26362 4 8.66667 3.40305 8.66667 2.66667Z" fill="url(#paint1_linear_6295_21408)"></path><defs><linearGradient id="paint0_linear_6295_21408" x1="0.666657" y1="15.3333" x2="9.12156" y2="2.04706" gradientUnits="userSpaceOnUse"><stop stop-color="#DD0A6F"></stop><stop offset="1" stop-color="#FF5B70"></stop></linearGradient><linearGradient id="paint1_linear_6295_21408" x1="1.31958e-07" y1="16" x2="16" y2="1.31958e-07" gradientUnits="userSpaceOnUse"><stop stop-color="#DD0A6F"></stop><stop offset="1" stop-color="#FF5B70"></stop></linearGradient></defs>', 3)
    , Bte = [Dte];
function Fte(t, e) {
    return A(),
        N("svg", Nte, Bte)
}
const $te = _e(Ote, [["render", Fte]])
    , Ute = {}
    , Vte = {
        width: "20",
        height: "20",
        viewBox: "0 0 20 20",
        xmlns: "http://www.w3.org/2000/svg"
    }
    , Gte = T("path", {
        d: "M10 19.6004C8.68336 19.6004 7.44169 19.3504 6.27502 18.8504C5.10836 18.3504 4.08752 17.6629 3.21252 16.7879C2.33752 15.9129 1.65002 14.8921 1.15002 13.7254C0.650024 12.5587 0.400024 11.3171 0.400024 10.0004C0.400024 8.66706 0.650024 7.42122 1.15002 6.26289C1.65002 5.10456 2.33752 4.08789 3.21252 3.21289C4.08752 2.33789 5.10836 1.65039 6.27502 1.15039C7.44169 0.650391 8.68336 0.400391 10 0.400391C11.3334 0.400391 12.5792 0.650391 13.7375 1.15039C14.8959 1.65039 15.9125 2.33789 16.7875 3.21289C17.6625 4.08789 18.35 5.10456 18.85 6.26289C19.35 7.42122 19.6 8.66706 19.6 10.0004C19.6 11.3171 19.35 12.5587 18.85 13.7254C18.35 14.8921 17.6625 15.9129 16.7875 16.7879C15.9125 17.6629 14.8959 18.3504 13.7375 18.8504C12.5792 19.3504 11.3334 19.6004 10 19.6004ZM10 17.7254C10.2834 17.4421 10.5667 16.9129 10.85 16.1379C11.1334 15.3629 11.35 14.5171 11.5 13.6004H8.50002C8.65002 14.5171 8.86669 15.3629 9.15002 16.1379C9.43336 16.9129 9.71669 17.4421 10 17.7254ZM7.72502 17.4754C7.49169 16.9754 7.28752 16.4004 7.11252 15.7504C6.93752 15.1004 6.79169 14.3837 6.67502 13.6004H3.10002C3.58336 14.5504 4.22502 15.3629 5.02502 16.0379C5.82502 16.7129 6.72502 17.1921 7.72502 17.4754ZM12.275 17.4754C13.275 17.1921 14.175 16.7129 14.975 16.0379C15.775 15.3629 16.4167 14.5504 16.9 13.6004H13.325C13.2084 14.3837 13.0625 15.1004 12.8875 15.7504C12.7125 16.4004 12.5084 16.9754 12.275 17.4754ZM2.42502 11.8004H6.45002C6.41669 11.4837 6.39586 11.1712 6.38752 10.8629C6.37919 10.5546 6.37502 10.2504 6.37502 9.95039C6.37502 9.65039 6.37919 9.35456 6.38752 9.06289C6.39586 8.77122 6.41669 8.48372 6.45002 8.20039H2.42502C2.34169 8.51706 2.28336 8.82122 2.25002 9.11289C2.21669 9.40456 2.20002 9.70039 2.20002 10.0004C2.20002 10.3004 2.21669 10.5962 2.25002 10.8879C2.28336 11.1796 2.34169 11.4837 2.42502 11.8004ZM8.27502 11.8004H11.725C11.7584 11.4671 11.7792 11.1546 11.7875 10.8629C11.7959 10.5712 11.8 10.2837 11.8 10.0004C11.8 9.71706 11.7959 9.42539 11.7875 9.12539C11.7792 8.82539 11.7584 8.51706 11.725 8.20039H8.27502C8.24169 8.51706 8.22086 8.82539 8.21252 9.12539C8.20419 9.42539 8.20002 9.71706 8.20002 10.0004C8.20002 10.2837 8.20419 10.5754 8.21252 10.8754C8.22086 11.1754 8.24169 11.4837 8.27502 11.8004ZM13.55 11.8004H17.575C17.6584 11.4837 17.7167 11.1796 17.75 10.8879C17.7834 10.5962 17.8 10.3004 17.8 10.0004C17.8 9.70039 17.7834 9.40039 17.75 9.10039C17.7167 8.80039 17.6584 8.50039 17.575 8.20039H13.55C13.5834 8.51706 13.6042 8.82956 13.6125 9.13789C13.6209 9.44622 13.625 9.75039 13.625 10.0504C13.625 10.3504 13.6209 10.6462 13.6125 10.9379C13.6042 11.2296 13.5834 11.5171 13.55 11.8004ZM13.325 6.40039H16.9C16.4167 5.45039 15.775 4.63789 14.975 3.96289C14.175 3.28789 13.275 2.80872 12.275 2.52539C12.5084 3.02539 12.7125 3.60039 12.8875 4.25039C13.0625 4.90039 13.2084 5.61706 13.325 6.40039ZM8.50002 6.40039H11.5C11.35 5.48372 11.1334 4.63789 10.85 3.86289C10.5667 3.08789 10.2834 2.55872 10 2.27539C9.71669 2.55872 9.43336 3.08789 9.15002 3.86289C8.86669 4.63789 8.65002 5.48372 8.50002 6.40039ZM3.10002 6.40039H6.67502C6.79169 5.61706 6.93752 4.90039 7.11252 4.25039C7.28752 3.60039 7.49169 3.02539 7.72502 2.52539C6.72502 2.80872 5.82502 3.28789 5.02502 3.96289C4.22502 4.63789 3.58336 5.45039 3.10002 6.40039Z"
    }, null, -1)
    , Hte = [Gte];
function Wte(t, e) {
    return A(),
        N("svg", Vte, Hte)
}
const Yte = _e(Ute, [["render", Wte]])
    , Xte = {}
    , jte = {
        width: "12",
        height: "12",
        viewBox: "0 0 12 12",
        xmlns: "http://www.w3.org/2000/svg"
    }
    , zte = T("path", {
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        d: "M1.29289 3.29289C1.68342 2.90237 2.31658 2.90237 2.70711 3.29289L6 6.58579L9.29289 3.29289C9.68342 2.90237 10.3166 2.90237 10.7071 3.29289C11.0976 3.68342 11.0976 4.31658 10.7071 4.70711L6.70711 8.70711C6.31658 9.09763 5.68342 9.09763 5.29289 8.70711L1.29289 4.70711C0.902369 4.31658 0.902369 3.68342 1.29289 3.29289Z"
    }, null, -1)
    , qte = [zte];
function Kte(t, e) {
    return A(),
        N("svg", jte, qte)
}
const Jte = _e(Xte, [["render", Kte]])
    , Zte = {
        name: "LanguagePicker",
        components: {
            IconChevronDown: Jte,
            IconLanguage: Yte
        },
        data() {
            return {
                isOpen: !1,
                options: [{
                    label: js.EN,
                    value: js.EN,
                    icon: "/countryFlags/Property 1=united kingdom.svg"
                }, {
                    label: js.RU,
                    value: js.RU,
                    icon: "/countryFlags/Property 1=russia.svg"
                }]
            }
        },
        methods: {
            toggleDropdown() {
                this.isOpen = !this.isOpen
            },
            selectOption(t) {
                var e, n;
                this.globalStore.setCurrentLocale(t);
                try {
                    (n = (e = window.Telegram) == null ? void 0 : e.WebApp) != null && n.CloudStorage && window.Telegram.WebApp.CloudStorage.setItem(OM.CURRENT_LOCALE, t)
                } catch { }
                this.isOpen = !1
            }
        },
        setup() {
            return {
                globalStore: Ye()
            }
        }
    }
    , Qte = {
        class: "relative inline-block text-left"
    }
    , ene = {
        class: "rounded-full bg-white/[.12] p-[3px] border border-white/[.12]"
    }
    , tne = {
        class: "uppercase"
    }
    , nne = {
        class: "absolute z-[12] right-0 w-[86px] origin-top-right bg-black border-x border-b border-white/[.12] rounded-b-lg shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none"
    }
    , sne = ["onClick"]
    , rne = {
        class: "w-4 h-4 mr-0.5"
    }
    , ine = ["src"];
function one(t, e, n, s, r, i) {
    const o = q("IconLanguage")
        , l = q("IconChevronDown")
        , a = mr("click-away");
    return A(),
        N("div", Qte, [T("button", {
            onClick: e[0] || (e[0] = (...c) => i.toggleDropdown && i.toggleDropdown(...c)),
            class: Te(["flex items-center space-x-1 px-2 py-0.5 w-[86px] border-x border-t focus:outline-none text-white/[.6] font-semibold group", [r.isOpen && "bg-black rounded-t-lg border-white/[.12]", !r.isOpen && "border-transparent"]])
        }, [T("span", ene, [G(o, {
            class: "fill-white/[.6] group-hover:fill-white"
        })]), T("span", tne, $(s.globalStore.currentLocale), 1), G(l, {
            class: "fill-white/[.6]"
        })], 2), vn((A(),
            N("div", nne, [T("div", null, [(A(!0),
                N(Ie, null, mt(r.options, c => (A(),
                    N("button", {
                        key: c.label,
                        onClick: u => i.selectOption(c.value),
                        class: "flex items-center w-full px-4 py-1 text-sm text-white/[.80] uppercase hover:bg-white/[.12] hover:text-white last:rounded-b-lg hover:font-semibold"
                    }, [T("span", rne, [T("img", {
                        src: c.icon,
                        alt: "",
                        class: "w-full h-full"
                    }, null, 8, ine)]), Fe(" " + $(c.label), 1)], 8, sne))), 128))])])), [[Ru, r.isOpen], [a, () => r.isOpen = !1]])])
}
const ane = _e(Zte, [["render", one], ["__scopeId", "data-v-cd48df7f"]])
    , lne = {
        name: "Header",
        components: {
            LanguagePicker: ane,
            Blik: Ki,
            IconAirdrop2: $te,
            IconQuestion: Lte,
            IconCoin: dn
        },
        data() {
            return {
                globalStore: Ye()
            }
        },
        computed: {
            balance() {
                return Xt(this.globalStore.balance)
            }
        }
    }
    , cne = {
        class: "py-2.5 px-4 w-full inline-flex items-center justify-between relative"
    }
    , une = {
        class: "w-1/3"
    }
    , hne = {
        class: "w-1/3 inline-flex gap-2 text-2xl font-semibold text-coin"
    }
    , dne = {
        class: "mw-1/3"
    };
function fne(t, e, n, s, r, i) {
    const o = q("LanguagePicker")
        , l = q("IconCoin")
        , a = q("IconAirdrop2")
        , c = q("Blik")
        , u = q("router-link");
    return A(),
        N("header", cne, [T("div", une, [G(o)]), T("div", hne, [G(l, {
            class: "w-8 h-8"
        }), T("span", null, $(i.balance), 1)]), T("div", dne, [G(u, {
            to: "/airdrop",
            class: "flex flex-row items-center gap-1 text-white font-semibold py-1.5 px-4 border border-white/5 rounded-3xl bg-white/[.06] active:scale-90 transform transition-transform duration-150"
        }, {
            default: Ce(() => [G(a), Fe(" " + $(t.$t("header.airdrop_button")) + " ", 1), G(c, {
                hasInterval: !0
            })]),
            _: 1
        })])])
}
const oc = _e(lne, [["render", fne]])
    , pne = {}
    , mne = {
        width: "29",
        height: "28",
        viewBox: "0 0 29 28",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }
    , gne = T("path", {
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        d: "M8.94961 0.613281L22.2496 2.17798V25.8229L8.94961 27.3876V0.613281ZM10.3496 2.18764V25.8132L20.8496 24.5779V3.42293L10.3496 2.18764ZM1.59961 2.10044H6.84961C7.23621 2.10044 7.54961 2.41384 7.54961 2.80044C7.54961 3.18704 7.23621 3.50044 6.84961 3.50044H2.99961V25.2004C2.99961 25.587 2.68621 25.9004 2.29961 25.9004C1.91301 25.9004 1.59961 25.587 1.59961 25.2004V2.10044ZM25.3996 3.50044H24.3496C23.963 3.50044 23.6496 3.18704 23.6496 2.80044C23.6496 2.41384 23.963 2.10044 24.3496 2.10044H26.7996V25.2004C26.7996 25.587 26.4862 25.9004 26.0996 25.9004C25.713 25.9004 25.3996 25.587 25.3996 25.2004V3.50044ZM13.1496 15.4004C13.9228 15.4004 14.5496 14.7736 14.5496 14.0004C14.5496 13.2272 13.9228 12.6004 13.1496 12.6004C12.3764 12.6004 11.7496 13.2272 11.7496 14.0004C11.7496 14.7736 12.3764 15.4004 13.1496 15.4004Z"
    }, null, -1)
    , _ne = [gne];
function yne(t, e) {
    return A(),
        N("svg", mne, _ne)
}
const bne = _e(pne, [["render", yne]])
    , vne = {}
    , xne = {
        width: "29",
        height: "28",
        viewBox: "0 0 29 28",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }
    , wne = T("path", {
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        d: "M14.5986 0.700195C11.5058 0.700195 8.99865 3.2074 8.99865 6.3002V7.0002H7.32887C6.27995 7.0002 5.39189 7.77417 5.24857 8.81326L3.02788 24.9133C2.85382 26.1752 3.83431 27.3002 5.10818 27.3002H24.0891C25.363 27.3002 26.3435 26.1752 26.1694 24.9133L23.9487 8.81326C23.8054 7.77417 22.9173 7.0002 21.8684 7.0002H20.1986V6.3002C20.1986 3.2074 17.6914 0.700195 14.5986 0.700195ZM18.7986 8.4002V11.9002C18.7986 12.2868 19.112 12.6002 19.4986 12.6002C19.8852 12.6002 20.1986 12.2868 20.1986 11.9002V8.4002H21.8684C22.2181 8.4002 22.5141 8.65819 22.5619 9.00455L24.7825 25.1045C24.8406 25.5252 24.5137 25.9002 24.0891 25.9002H5.10818C4.68356 25.9002 4.35673 25.5252 4.41475 25.1046L6.63544 9.00455C6.68321 8.65819 6.97923 8.4002 7.32887 8.4002H8.99865V11.9002C8.99865 12.2868 9.31205 12.6002 9.69865 12.6002C10.0852 12.6002 10.3986 12.2868 10.3986 11.9002V8.4002H18.7986ZM18.7986 7.0002V6.3002C18.7986 3.9806 16.9182 2.1002 14.5986 2.1002C12.279 2.1002 10.3986 3.9806 10.3986 6.3002V7.0002H18.7986Z"
    }, null, -1)
    , Sne = [wne];
function Ene(t, e) {
    return A(),
        N("svg", xne, Sne)
}
const Tne = _e(vne, [["render", Ene]])
    , Cne = {}
    , Ine = {
        width: "29",
        height: "28",
        viewBox: "0 0 29 28",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }
    , Ane = T("path", {
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        d: "M13.4142 7.55537L13.2563 9.34465C13.0938 11.1871 11.5506 12.6001 9.701 12.6001C7.8514 12.6001 6.30824 11.1871 6.14567 9.34466L5.98779 7.55538C5.79548 5.37581 7.51297 3.5001 9.701 3.5001C11.889 3.5001 13.6065 5.37581 13.4142 7.55537ZM4.59321 7.67843C4.32867 4.68028 6.69121 2.1001 9.701 2.1001C12.7108 2.1001 15.0733 4.68027 14.8088 7.67842L14.6509 9.4677C14.5178 10.9767 13.7195 12.2788 12.5605 13.0952C15.553 14.1674 17.7898 16.8778 18.1356 20.2031L18.6402 25.7553C18.7261 26.5813 18.0782 27.3001 17.2477 27.3001H2.15405C1.32357 27.3001 0.675656 26.5813 0.761563 25.7553L1.26619 20.2031C1.61203 16.8777 3.84886 14.1673 6.84148 13.0951C5.6825 12.2787 4.88423 10.9767 4.75109 9.46771L4.59321 7.67843ZM16.7431 20.3479L17.2477 25.9001H2.15405L2.65868 20.3479C3.03384 16.7406 6.07416 14.0001 9.7009 14.0001C13.3276 14.0001 16.368 16.7406 16.7431 20.3479ZM23.6236 13.203L23.733 11.7804C23.8442 10.3346 22.7011 9.1001 21.251 9.1001C19.801 9.1001 18.6578 10.3346 18.769 11.7804L18.8785 13.203C18.9738 14.4428 20.0076 15.4001 21.251 15.4001C22.4944 15.4001 23.5282 14.4428 23.6236 13.203ZM21.251 7.7001C18.9855 7.7001 17.1994 9.62883 17.3732 11.8877L17.4826 13.3104C17.5613 14.3335 18.0423 15.2355 18.7634 15.866C18.5835 15.9361 18.4071 16.0136 18.2348 16.0982C18.4692 16.4992 18.6763 16.9187 18.8535 17.3542C19.5794 16.9987 20.3939 16.8001 21.2509 16.8001C24.0437 16.8001 26.3857 18.909 26.6773 21.6865L27.0462 25.9001H20.0481C20.0489 26.4072 19.9127 26.8863 19.6732 27.3001H27.1741C27.9368 27.3001 28.5316 26.6396 28.4519 25.881L28.0696 21.5403C27.7945 18.9202 26.0674 16.7735 23.7386 15.8661C24.4597 15.2355 24.9408 14.3335 25.0195 13.3104L25.1289 11.8877C25.3027 9.62883 23.5166 7.7001 21.251 7.7001Z"
    }, null, -1)
    , kne = [Ane];
function Rne(t, e) {
    return A(),
        N("svg", Ine, kne)
}
const Mne = _e(Cne, [["render", Rne]])
    , Pne = {}
    , Lne = {
        width: "29",
        height: "28",
        viewBox: "0 0 29 28",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }
    , One = T("path", {
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        d: "M15.3073 1.16344C15.2002 0.949404 14.94 0.862648 14.7259 0.969667L14.6066 1.02933C14.3926 1.13635 14.3058 1.39662 14.4128 1.61065C14.8311 2.44727 14.7691 3.44388 14.2503 4.22215C13.5925 5.20883 13.4653 6.44914 13.8938 7.54039C13.3715 7.81735 13.0156 8.36668 13.0156 8.99914V10.9995H8.66602C4.24774 10.9995 0.666016 14.5812 0.666016 18.9995C0.666016 23.4178 4.24774 26.9995 8.66602 26.9995H20.666C25.0843 26.9995 28.666 23.4178 28.666 18.9995C28.666 14.5812 25.0843 10.9995 20.666 10.9995H16.3156V8.99914C16.3156 8.17061 15.705 7.48471 14.9092 7.36699C14.5025 6.53481 14.5679 5.54851 15.0823 4.77685C15.8002 3.69999 15.8861 2.32103 15.3073 1.16344ZM15.0156 8.99914V10.9995H14.3156V8.99914C14.3156 8.80584 14.4723 8.64913 14.6656 8.64913C14.8589 8.64913 15.0156 8.80584 15.0156 8.99914ZM20.666 12.2995H8.66602C4.96571 12.2995 1.96602 15.2992 1.96602 18.9995C1.96602 22.6998 4.96571 25.6995 8.66602 25.6995H20.666C24.3663 25.6995 27.366 22.6998 27.366 18.9995C27.366 15.2992 24.3663 12.2995 20.666 12.2995ZM7.66602 15.9995C7.11373 15.9995 6.66602 16.4472 6.66602 16.9995V17.9995H5.66602C5.11373 17.9995 4.66602 18.4472 4.66602 18.9995C4.66602 19.5518 5.11373 19.9995 5.66602 19.9995H6.66602V20.9995C6.66602 21.5518 7.11373 21.9995 7.66602 21.9995C8.2183 21.9995 8.66602 21.5518 8.66602 20.9995V19.9995H9.66602C10.2183 19.9995 10.666 19.5518 10.666 18.9995C10.666 18.4472 10.2183 17.9995 9.66602 17.9995H8.66602V16.9995C8.66602 16.4472 8.2183 15.9995 7.66602 15.9995ZM19.7601 15.3749C20.2606 14.8744 21.0721 14.8744 21.5726 15.3749C22.0731 15.8754 22.0731 16.6869 21.5726 17.1874C21.0721 17.6879 20.2606 17.6879 19.7601 17.1874C19.2596 16.6869 19.2596 15.8754 19.7601 15.3749ZM22.4789 18.0936C22.9794 17.5932 23.7908 17.5932 24.2913 18.0936C24.7918 18.5941 24.7918 19.4056 24.2913 19.9061C23.7908 20.4066 22.9794 20.4066 22.4789 19.9061C21.9784 19.4056 21.9784 18.5941 22.4789 18.0936ZM21.5726 20.8124C21.0721 20.3119 20.2606 20.3119 19.7601 20.8124C19.2596 21.3129 19.2596 22.1244 19.7601 22.6249C20.2606 23.1254 21.0721 23.1254 21.5726 22.6249C22.0731 22.1244 22.0731 21.3129 21.5726 20.8124ZM17.0414 18.0936C17.5419 17.5932 18.3533 17.5932 18.8538 18.0936C19.3543 18.5941 19.3543 19.4056 18.8538 19.9061C18.3533 20.4066 17.5419 20.4066 17.0414 19.9061C16.5409 19.4056 16.5409 18.5941 17.0414 18.0936Z"
    }, null, -1)
    , Nne = [One];
function Dne(t, e) {
    return A(),
        N("svg", Lne, Nne)
}
const Bne = _e(Pne, [["render", Dne]])
    , Fne = {}
    , $ne = {
        width: "29",
        height: "28",
        viewBox: "0 0 29 28",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }
    , Une = T("path", {
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        d: "M10.1254 13.3991V19.8796H20.0981V13.3991H24.6764L15.1117 3.08687L5.547 13.3991H10.1254ZM21.4981 14.7991H26.0368C26.7364 14.7991 27.0976 13.9509 26.6182 13.4339L15.693 1.6549C15.3778 1.31507 14.8456 1.31507 14.5304 1.6549L3.60528 13.4339C3.1258 13.9509 3.487 14.7991 4.1866 14.7991H8.72536V20.4696C8.72536 20.9169 9.08277 21.2796 9.52366 21.2796H20.6998C21.1407 21.2796 21.4981 20.9169 21.4981 20.4696V14.7991ZM10.1254 24.2997V25.55H20.0981V24.2997H10.1254ZM9.52366 22.8997C9.08277 22.8997 8.72536 23.2624 8.72536 23.7098V26.14C8.72536 26.5873 9.08277 26.95 9.52366 26.95H20.6998C21.1407 26.95 21.4981 26.5873 21.4981 26.14V23.7098C21.4981 23.2624 21.1407 22.8997 20.6998 22.8997H9.52366Z"
    }, null, -1)
    , Vne = [Une];
function Gne(t, e) {
    return A(),
        N("svg", $ne, Vne)
}
const Hne = _e(Fne, [["render", Gne]])
    , Wne = {}
    , Yne = {
        width: "29",
        height: "28",
        viewBox: "0 0 29 28",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }
    , Xne = T("path", {
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        d: "M17.908 12.2028L23.0142 14.2671C23.3623 14.4078 23.7615 14.2717 23.9494 13.9481C24.1572 13.5903 24.0339 13.1327 23.674 12.9261L17.0484 9.12338C16.99 9.08987 16.9302 9.06148 16.8695 9.03804C16.774 8.88397 16.6488 8.75205 16.5029 8.64884C16.2797 8.49093 16.0081 8.40023 15.7201 8.40023H13.4804C13.1925 8.40023 12.9209 8.4909 12.6978 8.64876C12.5519 8.75192 12.4268 8.88377 12.3312 9.03776C12.2705 9.06118 12.2107 9.08957 12.1523 9.12308L5.52678 12.9258C5.16683 13.1324 5.0435 13.59 5.25132 13.9478C5.43923 14.2714 5.83844 14.4075 6.18657 14.2668L11.2926 12.2025L9.5149 17.8578C9.24323 18.722 9.8927 19.6002 10.8035 19.6002H11.2533C11.2549 19.6246 11.2572 19.6491 11.2602 19.6737L11.9132 25.0294C11.9738 25.5262 12.398 25.9 12.9015 25.9C13.4513 25.9 13.8971 25.4569 13.8971 24.9103V19.6002H15.3055V24.9103C15.3055 25.4569 15.7513 25.9 16.3011 25.9C16.8046 25.9 17.2288 25.5262 17.2894 25.0294L17.9424 19.6737C17.9454 19.6491 17.9477 19.6246 17.9493 19.6002H18.397C19.3078 19.6002 19.9573 18.722 19.6856 17.8578L17.908 12.2028ZM20.133 14.6124L21.0212 17.4379C21.4941 18.9424 20.6078 20.4524 19.2056 20.8805L18.6791 25.1988C18.5321 26.4045 17.5058 27.3 16.3011 27.3C15.639 27.3 15.0365 27.0308 14.6013 26.5942C14.1661 27.0308 13.5636 27.3 12.9015 27.3C11.6968 27.3 10.6705 26.4045 10.5235 25.1988L9.99707 20.8812C8.59361 20.454 7.70618 18.9431 8.17933 17.4379L9.06762 14.6121L6.7113 15.5647C5.72084 15.9652 4.58039 15.5802 4.04068 14.6509C3.44118 13.6187 3.80031 12.3026 4.82987 11.7116L11.4145 7.93233C11.4564 7.88478 11.4999 7.83876 11.5449 7.79434C10.8261 7.04215 10.3838 6.02409 10.3838 4.89995C10.3838 2.57258 12.2795 0.699951 14.6004 0.699951C16.9213 0.699951 18.8169 2.57258 18.8169 4.89995C18.8169 6.02416 18.3746 7.04227 17.6557 7.79448C17.7008 7.83896 17.7444 7.88506 17.7863 7.93269L24.3709 11.7119C25.4004 12.3029 25.7596 13.619 25.1601 14.6512C24.6204 15.5805 23.4799 15.9655 22.4894 15.565L20.133 14.6124ZM12.8301 7.07782C12.1919 6.5645 11.7838 5.7796 11.7838 4.89995C11.7838 3.35355 13.0449 2.09995 14.6004 2.09995C16.1559 2.09995 17.4169 3.35355 17.4169 4.89995C17.4169 5.77962 17.0089 6.56455 16.3707 7.07787C16.174 7.23609 15.9554 7.3685 15.7201 7.46993C15.3769 7.61791 14.9983 7.69994 14.6004 7.69994C14.2024 7.69994 13.8237 7.61787 13.4804 7.46982C13.2452 7.36839 13.0267 7.236 12.8301 7.07782Z"
    }, null, -1)
    , jne = [Xne];
function zne(t, e) {
    return A(),
        N("svg", Yne, jne)
}
const qne = _e(Wne, [["render", zne]])
    , Kne = {
        name: "NotificationDot"
    }
    , Jne = {
        class: "absolute w-2.5 h-2.5 rounded-full"
    };
function Zne(t, e, n, s, r, i) {
    return A(),
        N("div", Jne)
}
const Vm = _e(Kne, [["render", Zne]])
    , Qne = {
        class: "sl-footer"
    }
    , jo = {
        __name: "Footer",
        props: {
            energyLeftAmount: Number,
            energyMaxAmount: Number
        },
        setup(t) {
            const e = Ye()
                , n = ji();
            return (s, r) => {
                const i = q("router-link");
                return A(),
                    N("footer", Qne, [G(i, {
                        to: de(ft).MAIN,
                        class: "sl-footer__item sl-footer__item--home",
                        "active-class": "sl-footer__item--active",
                        exact: ""
                    }, {
                        default: Ce(() => [G(bne, {
                            class: "fill-current mb-1"
                        }), Fe(" " + $(s.$t("footer_links.home")) + " ", 1), de(e).mainMenuHasNotification ? (A(),
                            fe(Vm, {
                                key: 0,
                                class: "top-1 right-1 bg-red-600"
                            })) : te("", !0)]),
                        _: 1
                    }, 8, ["to"]), G(i, {
                        to: de(ft).GIRLS,
                        class: "sl-footer__item sl-footer__item--girls",
                        "active-class": "sl-footer__item--active",
                        exact: ""
                    }, {
                        default: Ce(() => [G(qne, {
                            class: "fill-current mb-1"
                        }), Fe(" " + $(s.$t("footer_links.my_girls")), 1)]),
                        _: 1
                    }, 8, ["to"]), G(i, {
                        to: de(ft).UPGRADE,
                        class: "sl-footer__item sl-footer__item--games",
                        "active-class": "sl-footer__item--active",
                        exact: ""
                    }, {
                        default: Ce(() => [G(Hne, {
                            class: "fill-current mb-1"
                        }), Fe(" " + $(s.$t("footer_links.upgrade")), 1)]),
                        _: 1
                    }, 8, ["to"]), G(i, {
                        to: de(ft).SHOP,
                        class: "sl-footer__item sl-footer__item--shop",
                        "active-class": "sl-footer__item--active",
                        exact: ""
                    }, {
                        default: Ce(() => [de(n).hasNewLootboxes ? (A(),
                            fe(Vm, {
                                key: 0,
                                class: "notification-dot"
                            })) : te("", !0), G(Tne, {
                                class: "fill-current mb-1"
                            }), Fe(" " + $(s.$t("footer_links.shop")), 1)]),
                        _: 1
                    }, 8, ["to"]), G(i, {
                        to: de(ft).REFERRAL,
                        class: "sl-footer__item sl-footer__item--earn",
                        "active-class": "sl-footer__item--active",
                        exact: ""
                    }, {
                        default: Ce(() => [G(Mne, {
                            class: "fill-current mb-1"
                        }), Fe(" " + $(s.$t("footer_links.referral")), 1)]),
                        _: 1
                    }, 8, ["to"]), G(i, {
                        to: de(ft).GAMES,
                        class: "sl-footer__item sl-footer__item--games",
                        "active-class": "sl-footer__item--active",
                        exact: ""
                    }, {
                        default: Ce(() => [G(Bne, {
                            class: "fill-current mb-1"
                        }), Fe(" " + $(s.$t("footer_links.games")), 1)]),
                        _: 1
                    }, 8, ["to"])])
            }
        }
    }
    , ese = {}
    , tse = {
        viewBox: "0 0 28 28",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }
    , nse = T("path", {
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        d: "M15 4H13V13H4V15H13V24H15V15H24V13H15V4Z",
        fill: "inherit"
    }, null, -1)
    , sse = [nse];
function rse(t, e) {
    return A(),
        N("svg", tse, sse)
}
const qx = _e(ese, [["render", rse]])
    , ise = {}
    , ose = {
        viewBox: "0 0 28 28",
        fill: "currentColor",
        xmlns: "http://www.w3.org/2000/svg"
    }
    , ase = T("path", {
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        d: "M18.6667 7.29167V9.33333H8.75V7.29167C8.75 4.55326 10.9699 2.33333 13.7083 2.33333C16.4467 2.33333 18.6667 4.55325 18.6667 7.29167ZM4.66667 27.4167H13.7083H22.75C23.3943 27.4167 23.9167 26.8943 23.9167 26.25V10.5C23.9167 9.85567 23.3943 9.33333 22.75 9.33333H21V7.29167C21 3.26459 17.7354 0 13.7083 0C9.68126 0 6.41667 3.26459 6.41667 7.29167V9.33333H4.66667C4.02233 9.33333 3.5 9.85567 3.5 10.5V26.25C3.5 26.8943 4.02233 27.4167 4.66667 27.4167ZM16.3333 16.9167C16.3333 17.7259 15.9214 18.4389 15.2957 18.8575L15.6368 20.9041C15.6961 21.2597 15.4219 21.5833 15.0614 21.5833H12.9386C12.5781 21.5833 12.3039 21.2597 12.3632 20.9041L12.7043 18.8575C12.0786 18.4389 11.6667 17.7259 11.6667 16.9167C11.6667 15.628 12.7113 14.5833 14 14.5833C15.2887 14.5833 16.3333 15.628 16.3333 16.9167Z",
        fill: "currentColor"
    }, null, -1)
    , lse = [ase];
function cse(t, e) {
    return A(),
        N("svg", ose, lse)
}
const C_ = _e(ise, [["render", cse]])
    , use = {
        class: "flex flex-col items-center justify-center rounded-lg shrink-0 p-1 bg-white/[.06] active:bg-white/[.12] h-[72px] relative active:scale-95 transition-transform duration-100 ease-in-out overflow-hidden"
    }
    , hse = {
        class: "flex-grow flex items-center justify-center"
    }
    , dse = {
        class: "text-white text-xxs bg-white/[.06] rounded-full py-0.5 px-2"
    }
    , fse = {
        __name: "UnlockSlotCard",
        setup(t) {
            return (e, n) => (A(),
                N("div", use, [G(Ki, {
                    hasInterval: !0
                }), T("div", hse, [G(C_, {
                    class: "w-6 h-6 text-white/[.6]"
                })]), T("div", dse, $(e.$t("unlock")), 1), G(gr, {
                    tier: "rare",
                    width: "100%",
                    height: "10%",
                    blur: "15",
                    position: "bottom"
                })]))
        }
    }
    , pse = {
        name: "SlapCollectionsFooter",
        props: {
            selectedSlotIndex: Number
        },
        components: {
            UnlockSlotCard: fse,
            IconPlus: qx,
            IconLock: C_
        },
        data() {
            return {
                girlsStore: ls(),
                slotsStore: Fo(),
                onboardingStore: _s()
            }
        },
        computed: {
            webApp() {
                return window.Telegram.WebApp
            },
            girls() {
                return this.girlsStore.girlsInSlots
            }
        },
        methods: {
            onUnlock() {
                this.slotsStore.showBuySlotModal()
            },
            onClickSlot(t) {
                this.$emit("click-on-index", t)
            }
        }
    }
    , mse = {
        class: "sl-collections-footer"
    }
    , gse = {
        ref: "container",
        class: "sl-collections-footer__list overflow-auto scrollbar-hide"
    }
    , _se = ["onClick"]
    , yse = {
        class: "h-[56px] overflow-hidden relative z-[1]"
    }
    , bse = ["src"]
    , vse = {
        class: "sl-collections-footer__list-item-info"
    }
    , xse = {
        class: "text-white font-semibold"
    }
    , wse = ["src"];
function Sse(t, e, n, s, r, i) {
    const o = q("IconPlus")
        , l = q("UnlockSlotCard");
    return A(),
        N("div", mse, [T("div", gse, [(A(!0),
            N(Ie, null, mt(i.girls, (a, c) => (A(),
                N("div", {
                    key: c,
                    class: Te(["sl-collections-footer__list-item sl-collections-footer__list-item--add flex items-center justify-center", [`sl-collections-footer__list-item--tier-${a.tier}`, {
                        "sl-collections-footer__list-item--selected": n.selectedSlotIndex === c
                    }]]),
                    onClick: u => i.onClickSlot(c)
                }, [T("div", yse, [T("img", {
                    class: "sl-collections-footer__list-item-pic",
                    src: a.path,
                    alt: ""
                }, null, 8, bse)]), T("div", vse, [Fe($(t.$t("level")) + " ", 1), T("span", xse, $(a.level), 1)]), T("img", {
                    class: "sl-collections-footer__list-item-type",
                    src: `/icons/icon-type-${a.tier}.svg`,
                    alt: ""
                }, null, 8, wse)], 10, _se))), 128)), r.girlsStore.emptySlots ? (A(),
                    N("div", {
                        key: 0,
                        class: "sl-collections-footer__list-item sl-collections-footer__list-item--add flex items-center justify-center",
                        onClick: e[0] || (e[0] = a => i.onClickSlot(i.girls.length))
                    }, [G(o, {
                        class: "w-[28px] fill-accent"
                    })])) : te("", !0), r.girlsStore.lockedSlots ? (A(),
                        fe(l, {
                            key: 1,
                            onClick: i.onUnlock,
                            class: Te({
                                "opacity-25 pointer-events-none": r.onboardingStore.isOnboardingInProgress
                            })
                        }, null, 8, ["onClick", "class"])) : te("", !0)], 512)])
}
const Ese = _e(pse, [["render", Sse], ["__scopeId", "data-v-8212747c"]])
    , Tse = {}
    , Cse = {
        width: "40",
        height: "40",
        viewBox: "0 0 40 40",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }
    , Ise = Nr('<rect x="6.33789" y="10.3789" width="24" height="16" rx="2" transform="rotate(-15 6.33789 10.3789)" fill="url(#paint0_linear_1910_18884)" fill-opacity="0.6"></rect><rect x="7.11523" y="13.2764" width="24" height="3" transform="rotate(-15 7.11523 13.2764)" fill="url(#paint1_linear_1910_18884)"></rect><path fill-rule="evenodd" clip-rule="evenodd" d="M8 14C6.89543 14 6 14.8954 6 16V32C6 33.1046 6.89543 34 8 34H32C33.1046 34 34 33.1046 34 32V27C35.1046 27 36 26.1046 36 25V23C36 21.8954 35.1046 21 34 21V16C34 14.8954 33.1046 14 32 14H8Z" fill="url(#paint2_linear_1910_18884)"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M8 14C6.89543 14 6 14.8954 6 16V32C6 33.1046 6.89543 34 8 34H32C33.1046 34 34 33.1046 34 32V27C35.1046 27 36 26.1046 36 25V23C36 21.8954 35.1046 21 34 21V16C34 14.8954 33.1046 14 32 14H8Z" fill="url(#paint3_linear_1910_18884)"></path><rect x="29" y="22" width="4" height="4" rx="2" fill="white"></rect><defs><linearGradient id="paint0_linear_1910_18884" x1="18.3379" y1="10.3789" x2="18.3379" y2="26.3789" gradientUnits="userSpaceOnUse"><stop stop-color="#FF9500"></stop><stop offset="1" stop-color="#FFD237"></stop></linearGradient><linearGradient id="paint1_linear_1910_18884" x1="19.1152" y1="13.2764" x2="19.1152" y2="16.2764" gradientUnits="userSpaceOnUse"><stop stop-color="#FF9500"></stop><stop offset="1" stop-color="#FFD237"></stop></linearGradient><linearGradient id="paint2_linear_1910_18884" x1="33.5" y1="21" x2="33.5" y2="27" gradientUnits="userSpaceOnUse"><stop stop-color="#FF9500"></stop><stop offset="1" stop-color="#FFD237"></stop></linearGradient><linearGradient id="paint3_linear_1910_18884" x1="21" y1="13" x2="21" y2="35" gradientUnits="userSpaceOnUse"><stop stop-color="#FF9500"></stop><stop offset="1" stop-color="#FFD237"></stop></linearGradient></defs>', 6)
    , Ase = [Ise];
function kse(t, e) {
    return A(),
        N("svg", Cse, Ase)
}
const Rse = _e(Tse, [["render", kse]])
    , Mse = {
        class: "text-white text-xxs font-semibold leading-3"
    }
    , Pse = {
        __name: "CountdownMini",
        props: {
            targetUnixTime: {
                type: Number,
                required: !0
            }
        },
        setup(t) {
            const e = t
                , { t: n } = gt()
                , s = si()
                , r = ve(() => s.unixTime)
                , i = ve(() => {
                    const o = e.targetUnixTime - r.value
                        , l = Math.floor(o / 3600)
                        , a = Math.floor(o % 3600 / 60)
                        , c = o % 60;
                    return l > 0 ? `${l}${n("hours_short")} ${a}${n("minutes_short")}` : `${a}${n("minutes_short")} ${c}${n("seconds_short")}`
                }
                );
            return (o, l) => (A(),
                N("div", Mse, $(i.value), 1))
        }
    }
    , Lse = {
        class: "flex gap-3 items-center"
    }
    , Ose = {
        class: "w-14 h-14 bg-white/5 rounded-full flex justify-center items-center relative"
    }
    , Nse = ["src"]
    , Dse = {
        __name: "ActiveBoostsStatus",
        setup(t) {
            const e = si()
                , n = ls()
                , s = ve(() => e.unixTime)
                , r = ve(() => n.selectedGirlBoosts)
                , i = o => {
                    const l = o.end_timestamp - s.value
                        , a = o.end_timestamp - o.timestamp;
                    return Math.max(Math.floor(l / a * 100), 0)
                }
                ;
            return (o, l) => (A(),
                N("div", Lse, [(A(!0),
                    N(Ie, null, mt(r.value, a => (A(),
                        N("div", {
                            key: `${a.type}_${a.tier}`,
                            class: "flex flex-col gap-1 items-center"
                        }, [T("div", Ose, [a.type === "profit" ? (A(),
                            N("img", {
                                key: 0,
                                src: `/boosts/boost-${a.tier}.webp`,
                                alt: "Profit Boost",
                                class: "object-contain w-12 h-12"
                            }, null, 8, Nse)) : a.type === "energy" ? (A(),
                                fe(Hx, {
                                    key: 1,
                                    class: "w-12 p-1.5 h-12",
                                    tier: a.tier
                                }, null, 8, ["tier"])) : te("", !0), G(T4, {
                                    class: "absolute left-0.5 top-0.5 w-[3.25rem] h-[3.25rem]",
                                    percentage: i(a),
                                    color: a.tier
                                }, null, 8, ["percentage", "color"])]), G(Pse, {
                                    targetUnixTime: a.end_timestamp
                                }, null, 8, ["targetUnixTime"])]))), 128))]))
        }
    }
    , Bse = {
        class: "fixed w-14 h-14 bg-white/[.04] p-2 rounded-lg z-[5] flex flex-col items-center justify-center [@media(hover:hover)]:hover:bg-white/10 active:bg-white/10"
    }
    , hh = {
        __name: "IconButton",
        props: {
            glow: {
                type: String,
                values: ["common", "rare", "epic", "legendary"]
            },
            showNotification: {
                type: Boolean,
                default: !1
            }
        },
        setup(t) {
            return (e, n) => (A(),
                N("div", Bse, [rs(e.$slots, "default"), t.glow ? (A(),
                    fe(gr, {
                        key: 0,
                        tier: t.glow,
                        position: "bottom",
                        height: "8%",
                        blur: "10"
                    }, null, 8, ["tier"])) : te("", !0), t.showNotification ? (A(),
                        fe(Vm, {
                            key: 1,
                            class: "top-1 right-1 bg-red-600"
                        })) : te("", !0)]))
        }
    }
    , Fse = {}
    , $se = {
        viewBox: "0 0 40 40",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }
    , Use = Nr('<path fill-rule="evenodd" clip-rule="evenodd" d="M21.0001 20.9375L34.4138 6.68537C35.0145 6.04719 34.562 5 33.6856 5H6.31449C5.43811 5 4.98565 6.04719 5.58628 6.68536L19.0001 20.9375V31L16.5001 33H13.0001C12.4478 33 12.0001 33.4477 12.0001 34C12.0001 34.5523 12.4478 35 13.0001 35H14.0001H19.0001H21.0001H26.0001H27.0001C27.5523 35 28.0001 34.5523 28.0001 34C28.0001 33.4477 27.5523 33 27.0001 33H23.5001L21.0001 31V20.9375Z" fill="url(#paint0_linear_3041_6524)" fill-opacity="0.6"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M8.55664 9.8411L9.0171 9.4136C12.3054 6.36064 17.3395 6.1943 20.8222 9.02353C24.1305 11.7111 28.8699 11.7111 32.1782 9.02353C32.2246 8.98589 32.2712 8.94878 32.3181 8.9122L20.7284 21.2262C20.3336 21.6457 19.6669 21.6457 19.272 21.2262L8.55664 9.8411Z" fill="url(#paint1_linear_3041_6523)"></path><defs><linearGradient id="paint0_linear_3041_6524" x1="20.0001" y1="5.00092" x2="20.0001" y2="35.001" gradientUnits="userSpaceOnUse"><stop stop-color="#FF5B70"></stop><stop offset="1" stop-color="#DD0A6F"></stop></linearGradient><linearGradient id="paint1_linear_3041_6523" x1="8.55664" y1="21.5408" x2="21.4943" y2="0.387772" gradientUnits="userSpaceOnUse"><stop stop-color="#DD0A6F"></stop><stop offset="1" stop-color="#FF5B70"></stop></linearGradient></defs>', 3)
    , Vse = [Use];
function Gse(t, e) {
    return A(),
        N("svg", $se, Vse)
}
const Hse = _e(Fse, [["render", Gse]])
    , Wse = {
        __name: "BoostButton",
        setup(t) {
            return (e, n) => (A(),
                fe(hh, {
                    glow: "epic"
                }, {
                    default: Ce(() => [G(Hse)]),
                    _: 1
                }))
        }
    }
    , Yse = {}
    , Xse = {
        width: "40",
        height: "40",
        viewBox: "0 0 40 40",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }
    , jse = T("path", {
        d: "M18.2493 30L27.666 20.5833L25.2493 18.1667L18.2077 25.2083L14.7077 21.7083L12.3327 24.0833L18.2493 30ZM9.99935 36.6667C9.08268 36.6667 8.29796 36.3403 7.64518 35.6875C6.9924 35.0347 6.66602 34.25 6.66602 33.3333V6.66666C6.66602 5.74999 6.9924 4.96527 7.64518 4.31249C8.29796 3.65972 9.08268 3.33333 9.99935 3.33333H23.3327L33.3327 13.3333V33.3333C33.3327 34.25 33.0063 35.0347 32.3535 35.6875C31.7007 36.3403 30.916 36.6667 29.9993 36.6667H9.99935ZM21.666 15H29.9993L21.666 6.66666V15Z",
        fill: "url(#paint0_linear_5107_37516)"
    }, null, -1)
    , zse = T("defs", null, [T("linearGradient", {
        id: "paint0_linear_5107_37516",
        x1: "6.66602",
        y1: "36.6667",
        x2: "39.1863",
        y2: "10.6504",
        gradientUnits: "userSpaceOnUse"
    }, [T("stop", {
        "stop-color": "#FF9500"
    }), T("stop", {
        offset: "1",
        "stop-color": "#FFD237"
    })])], -1)
    , qse = [jse, zse];
function Kse(t, e) {
    return A(),
        N("svg", Xse, qse)
}
const Jse = _e(Yse, [["render", Kse]])
    , _f = Ds("itemsTasks", {
        state: () => ({
            mediaTasks: []
        }),
        getters: {
            getTaskById(t) {
                return e => t.mediaTasks.find(n => n.id === e)
            },
            hasUnfinishedTask(t) {
                return t.mediaTasks.some(e => !e.done && !e.disabled)
            }
        },
        actions: {
            setMediaTasks(t, e) {
                this.mediaTasks = t.map(n => ({
                    ...n,
                    isExternalLink: n.is_external_link,
                    done: (e == null ? void 0 : e.includes(n.id)) || !1
                }))
            },
            setMediaTaskIsDone(t) {
                this.mediaTasks = this.mediaTasks.map(e => ({
                    ...e,
                    done: t === e.id ? !0 : e.done
                }))
            },
            setReadyToClaim(t) {
                this.mediaTasks = this.mediaTasks.map(e => ({
                    ...e,
                    isReadyToClaim: t === e.id ? !0 : e.isReadyToClaim
                }))
            },
            completeMediaTask(t) {
                const e = this.getTaskById(t);
                if (!e || e.done)
                    return;
                const n = Ye()
                    , s = n.balance;
                return n.setChangedBalance(-e.reward, s),
                    this.setMediaTaskIsDone(t),
                    Ls({
                        action: async () => Bn(n.telegramAppFunctions, "complete_media_quest_call")({
                            quest: e.id
                        }),
                        onSuccess: r => {
                            n.setUserData(r.data.user);
                            const { showSuccessToast: i } = mi();
                            i("toast_messages.complete_media_quest")
                        }
                    })
            }
        }
    })
    , Zse = {
        __name: "TaskButton",
        setup(t) {
            const e = gf()
                , n = _f()
                , s = ve(() => {
                    var r;
                    return ((r = e.currentDailyClaim) == null ? void 0 : r.done) === !1 || n.hasUnfinishedTask
                }
                );
            return (r, i) => (A(),
                fe(hh, {
                    glow: "legendary",
                    showNotification: s.value
                }, {
                    default: Ce(() => [G(Jse)]),
                    _: 1
                }, 8, ["showNotification"]))
        }
    }
    , Qse = {}
    , ere = {
        viewBox: "0 0 40 40",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }
    , tre = T("path", {
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        d: "M16.1719 5.89435C16.1719 3.74356 17.9155 2 20.0662 2C22.217 2 23.9606 3.74356 23.9606 5.89435C23.9606 8.04514 22.217 9.7887 20.0662 9.7887C17.9155 9.7887 16.1719 8.04514 16.1719 5.89435ZM16.9288 11.6494C17.2629 11.1075 17.8595 10.7627 18.5177 10.7627H21.6145C22.2728 10.7627 22.8695 11.1077 23.2036 11.6498C23.2876 11.6824 23.3703 11.7219 23.4511 11.7685L32.612 17.0575C33.1097 17.3449 33.2802 17.9813 32.9928 18.479C32.733 18.929 32.1811 19.1183 31.6997 18.9226L24.6395 16.0514L27.0974 23.9166C27.4731 25.1186 26.5751 26.3401 25.3157 26.3401H24.6967C24.6944 26.374 24.6913 26.4081 24.6871 26.4423L23.7842 33.8912C23.7005 34.5823 23.1139 35.102 22.4177 35.102C21.6575 35.102 21.0412 34.4858 21.0412 33.7255V26.3401H19.0938L19.0938 33.7255C19.0938 34.4858 18.4775 35.102 17.7173 35.102C17.0211 35.102 16.4345 34.5823 16.3508 33.8912L15.4479 26.4423C15.4437 26.4081 15.4406 26.374 15.4383 26.3401H14.8164C13.5571 26.3401 12.6591 25.1186 13.0347 23.9166L15.4927 16.0511L8.43272 18.9222C7.95137 19.1179 7.3994 18.9285 7.13958 18.4785C6.85224 17.9808 7.02276 17.3444 7.52045 17.0571L16.6813 11.7681C16.7621 11.7215 16.8448 11.682 16.9288 11.6494ZM15 31L11 30L11.2598 31.0392C8.64294 31.7709 7 32.8265 7 34.0003C7 36.2094 12.8203 38.0003 20 38.0003C27.1797 38.0003 33 36.2094 33 34.0003C33 32.8265 31.3571 31.7709 28.7402 31.0392L29 30L25 31L28 34L28.2549 32.9803C28.374 33.014 28.4904 33.0484 28.6042 33.0834C29.602 33.3904 30.2955 33.7165 30.7157 34.0003C30.2955 34.284 29.602 34.6101 28.6042 34.9171C26.49 35.5677 23.4475 36.0003 20 36.0003C16.5525 36.0003 13.51 35.5677 11.3958 34.9171C10.398 34.6101 9.70454 34.284 9.28433 34.0003C9.70454 33.7165 10.398 33.3904 11.3958 33.0834C11.5096 33.0484 11.626 33.014 11.7451 32.9803L12 34L15 31Z",
        fill: "url(#paint0_linear_3009_3173)"
    }, null, -1)
    , nre = T("defs", null, [T("linearGradient", {
        id: "paint0_linear_3009_3173",
        x1: "7",
        y1: "38.0003",
        x2: "42.0659",
        y2: "16.7222",
        gradientUnits: "userSpaceOnUse"
    }, [T("stop", {
        "stop-color": "#0E47D8"
    }), T("stop", {
        offset: "1",
        "stop-color": "#29D5FB"
    })])], -1)
    , sre = [tre, nre];
function rre(t, e) {
    return A(),
        N("svg", ere, sre)
}
const ire = _e(Qse, [["render", rre]])
    , ore = {
        __name: "PoseButton",
        props: {
            highlighted: {
                type: Boolean,
                default: !1
            }
        },
        setup(t) {
            return (e, n) => (A(),
                fe(hh, {
                    glow: "rare",
                    class: Te({
                        "animate-glow-pulse": t.highlighted
                    })
                }, {
                    default: Ce(() => [G(ire)]),
                    _: 1
                }, 8, ["class"]))
        }
    }
    , are = ["width", "height"]
    , lre = T("circle", {
        cx: "50",
        cy: "50",
        r: "47",
        stroke: "#00000033",
        "stroke-width": "6",
        fill: "none"
    }, null, -1)
    , cre = ["stroke-dasharray", "stroke-dashoffset"]
    , ure = {
        __name: "ProgressCircle",
        props: {
            percentage: {
                type: Number,
                required: !0,
                validator(t) {
                    return t >= 0 && t <= 100
                }
            },
            size: {
                type: String,
                default: "100%"
            },
            level: {
                type: Number
            }
        },
        setup(t) {
            const e = t
                , n = ke(0)
                , s = ke(!0)
                , r = ve(() => 2 * Math.PI * 47)
                , i = ve(() => {
                    const l = n.value;
                    return r.value - l / 100 * r.value
                }
                )
                , o = async l => {
                    n.value = 100,
                        await new Promise(a => setTimeout(a, 300)),
                        s.value = !1,
                        n.value = 0,
                        await new Promise(a => setTimeout(a, 200)),
                        s.value = !0,
                        n.value = l
                }
                ;
            return Ln([() => e.percentage, () => e.level], ([l, a], [c, u]) => {
                u && a !== u ? o(l) : n.value = l
            }
                , {
                    immediate: !0
                }),
                (l, a) => (A(),
                    N("svg", {
                        class: "block m-auto max-w-full h-auto",
                        width: t.size,
                        height: t.size,
                        viewBox: "0 0 100 100"
                    }, [lre, T("circle", {
                        class: Te([s.value ? "[transition:stroke-dashoffset_0.3s_ease-in-out]" : ""]),
                        cx: "50",
                        cy: "50",
                        r: "47",
                        stroke: "#EC2E70",
                        "stroke-width": "6",
                        fill: "none",
                        "stroke-dasharray": r.value,
                        "stroke-dashoffset": i.value,
                        transform: "rotate(-90 50 50)"
                    }, null, 10, cre)], 8, are))
        }
    }
    , hre = {
        key: 0,
        class: "relative z-10"
    }
    , dre = {
        class: "slap-gifts__header"
    }
    , fre = {
        class: "slap-gifts__header-title"
    }
    , pre = {
        class: "slap-gifts__header-value"
    }
    , mre = {
        class: "slap-gifts__header-value-new"
    }
    , gre = {
        class: "slap-gifts__xp"
    }
    , _re = {
        class: "slap-gifts__xp-title"
    }
    , yre = {
        class: "slap-gifts__xp-value"
    }
    , bre = {
        key: 0,
        class: "slap-gifts z-30"
    }
    , vre = ["onPointerdown", "onPointerup"]
    , xre = ["src"]
    , wre = {
        key: 0,
        class: "slap-gifts__item-amount"
    }
    , Sre = {
        class: "slap-gifts__item-text text-nowrap text-white text-xs font-semibold text-center"
    }
    , Ere = {
        class: "slap-gifts__item-button"
    }
    , Tre = {
        __name: "Gifts",
        props: {
            isGiftActivated: {
                type: Boolean,
                required: !0
            }
        },
        emits: ["gift-used"],
        setup(t, { emit: e }) {
            const n = e
                , s = ke(null)
                , { t: r } = gt()
                , i = Ye()
                , o = ls()
                , l = ve(() => {
                    var f;
                    const d = (f = i.userData) == null ? void 0 : f.gifts;
                    return Object.entries(i.gifts).map(([p, m]) => ({
                        tier: p,
                        exp: m,
                        image: `/gifts/gift-tier-${p}.webp`,
                        amount: d[p]
                    })).sort((p, m) => p.exp - m.exp)
                }
                )
                , a = ve(() => {
                    const d = o.selectedGirl
                        , f = Wl[d.tier].next_level_experience
                        , p = Wl[d.tier].next_level_experience_inc
                        , m = Math.floor(f * Math.pow(p, d.level - 1));
                    return {
                        ...d,
                        disabled: d.level >= Wl[d.tier].max_level,
                        experienceLimit: m
                    }
                }
                )
                , c = ve(() => {
                    const d = Math.round(a.value.experience / a.value.experienceLimit * 100);
                    return Math.min(d + .2, 100)
                }
                )
                , u = d => {
                    s.value = d
                }
                , h = ({ tier: d, image: f, exp: p, amount: m }) => {
                    if (s.value = null,
                        !(!m || a.value.disabled))
                        try {
                            i.showModal(r("gifts.confirmation"), async g => {
                                if (g) {
                                    let b = 0
                                        , v = p;
                                    for (; v > 0 && !a.value.disabled;) {
                                        const x = Math.min(a.value.experienceLimit - a.value.experience, v);
                                        v -= x;
                                        const w = !!v;
                                        o.updateGirl(a.value.id, {
                                            experience: w ? 0 : a.value.experience + x,
                                            level: a.value.level + Number(w)
                                        }),
                                            w && b++
                                    }
                                    const _ = Fn();
                                    _.logEvent("gift_used", {
                                        tier: d
                                    }),
                                        b && (document.querySelector(".slap-gifts__header-value").classList.add("slap-gifts__header-value--up"),
                                            _.levelUp(a.value.id, b));
                                    try {
                                        i.decrementGifts(d)
                                    } catch (x) {
                                        console.error(x)
                                    }
                                    document.querySelector(".sl-layout__background").classList.remove("tier-common", "tier-rare", "tier-epic", "tier-legendary"),
                                        setTimeout(() => {
                                            document.querySelector(".sl-layout__background").classList.add(`tier-${d}`, "activated")
                                        }
                                            , 200),
                                        setTimeout(() => {
                                            document.querySelector(".sl-layout__background").classList.remove("activated"),
                                                document.querySelector(".slap-gifts__header-value").style.transition = "none",
                                                document.querySelector(".slap-gifts__header-value").classList.remove("slap-gifts__header-value--up")
                                        }
                                            , 700),
                                        setTimeout(() => {
                                            document.querySelector(".slap-gifts__header-value").style.transition = ""
                                        }
                                            , 800),
                                        n("gift-used");
                                    const y = Bn(i.telegramAppFunctions, "consume_gift_call");
                                    try {
                                        await y({
                                            tier: d,
                                            girl_id: a.value.id
                                        }).then(x => {
                                            i.setUserData(x.data.user)
                                        }
                                        )
                                    } catch (x) {
                                        console.error(x),
                                            i.isDevMode || i.showErrorModal()
                                    }
                                }
                            }
                                , !0, f)
                        } catch (g) {
                            console.error(g)
                        }
                }
                ;
            return (d, f) => {
                const p = mr("bounce");
                return A(),
                    N("div", null, [G(is, {
                        name: "fade"
                    }, {
                        default: Ce(() => [t.isGiftActivated ? (A(),
                            fe(ure, {
                                key: 0,
                                class: "slap-gifts__level",
                                percentage: c.value,
                                level: a.value.level
                            }, null, 8, ["percentage", "level"])) : te("", !0)]),
                        _: 1
                    }), G(is, {
                        name: "fade"
                    }, {
                        default: Ce(() => [t.isGiftActivated ? (A(),
                            N("div", hre, [T("div", dre, [T("div", fre, $(de(r)("gifts.leveling")), 1), T("div", pre, [Fe($(de(r)("common.level")) + " ", 1), T("span", null, $(a.value.level), 1), T("div", mre, [Fe($(de(r)("common.level")) + " ", 1), T("span", null, $(a.value.level), 1)])])]), T("div", gre, [T("div", _re, $(de(r)("lootbox_popup.exp")), 1), T("div", yre, $(Math.floor(a.value.experience)) + "/" + $(Math.floor(a.value.experienceLimit)), 1)])])) : te("", !0)]),
                        _: 1
                    }), G(is, {
                        name: "fade"
                    }, {
                        default: Ce(() => [t.isGiftActivated ? (A(),
                            N("div", bre, [(A(!0),
                                N(Ie, null, mt(l.value, m => vn((A(),
                                    N("div", {
                                        class: Te(["slap-gifts__item overflow-hidden bg-black cursor-pointer transition-transform duration-200", [`slap-gifts__item--tier-${m.tier}`, {
                                            "slap-gifts__item--not-active": !m.amount || a.value.disabled,
                                            "scale-95 bg-black/70": s.value === m.tier && m.amount
                                        }]]),
                                        key: m.tier,
                                        onPointerdown: g => u(m.tier),
                                        onPointerup: g => h(m)
                                    }, [G(gr, {
                                        tier: m.tier,
                                        height: "100%",
                                        blur: m.amount ? "25" : "35"
                                    }, null, 8, ["tier", "blur"]), T("img", {
                                        src: m.image,
                                        class: "slap-gifts__item-pic",
                                        alt: ""
                                    }, null, 8, xre), m.amount ? (A(),
                                        N("div", wre, $(m.amount), 1)) : te("", !0), T("div", Sre, " + " + $(de(Xt)(m.exp, !0)) + " " + $(de(r)("lootbox_popup.exp")), 1), T("div", Ere, $(de(r)("gifts.apply")), 1)], 42, vre)), [[p, {
                                            enabled: !1,
                                            startAnimation: s.value === m.tier && (!m.amount || a.value.disabled)
                                        }]])), 128))])) : te("", !0)]),
                        _: 1
                    })])
            }
        }
    }
    , Cre = _e(Tre, [["__scopeId", "data-v-d9543e39"]])
    , Ire = {}
    , Are = {
        viewBox: "0 0 40 40",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }
    , kre = T("path", {
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        d: "M39 13.9567C39 12.5759 37.8809 11.4567 36.5 11.4567L18.667 11.4567L20.2051 10.7976C20.7305 10.5725 21.208 10.2492 21.6123 9.84491L22.4092 9.04755C23.5635 7.89277 23.5635 6.0207 22.4092 4.86591C21.3281 3.78486 19.6006 3.70624 18.4258 4.68525L17.5 5.45673L11.376 7.61786C9.81641 8.16864 8.41797 9.09736 7.30469 10.3215L4.4541 13.4567L2 13.4567C1.44727 13.4567 1 13.9045 1 14.4567L0.999999 27.4567C0.999999 28.009 1.44726 28.4567 2 28.4567L4.41601 28.4567C5.1875 30.2224 6.94922 31.4567 9 31.4567L24.5 31.4567C25.8809 31.4567 27 30.3376 27 28.9567C27 27.5759 25.8809 26.4567 24.5 26.4567L26.5 26.4567C27.8809 26.4567 29 25.3376 29 23.9567C29 22.5759 27.8809 21.4567 26.5 21.4567L27.5 21.4567C28.8809 21.4567 30 20.3376 30 18.9567C30 17.5759 28.8809 16.4567 27.5 16.4567L36.5 16.4567C37.8809 16.4567 39 15.3376 39 13.9567Z",
        fill: "white",
        "fill-opacity": "1"
    }, null, -1)
    , Rre = [kre];
function Mre(t, e) {
    return A(),
        N("svg", Are, Rre)
}
const al = _e(Ire, [["render", Mre]])
    , Pre = {
        name: "SlapDailyHeader",
        methods: {
            formattingPrice: Xt
        },
        components: {
            IconCoin: dn
        },
        data() {
            return {
                globalStore: Ye()
            }
        }
    }
    , Lre = {
        class: "sl-daily-header"
    }
    , Ore = {
        class: "sl-daily-header__value"
    };
function Nre(t, e, n, s, r, i) {
    const o = q("IconCoin");
    return A(),
        N("header", Lre, [T("div", Ore, [G(o, {
            class: "w-[32px] mr-2"
        }), Fe(" " + $(i.formattingPrice(r.globalStore.balance)), 1)])])
}
const Dre = _e(Pre, [["render", Nre], ["__scopeId", "data-v-d2cfe971"]])
    , Bre = {}
    , Fre = {
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }
    , $re = T("path", {
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        d: "M7.29289 3.79289C7.68342 3.40237 8.31658 3.40237 8.70711 3.79289L16.2071 11.2929C16.5976 11.6834 16.5976 12.3166 16.2071 12.7071L8.70711 20.2071C8.31658 20.5976 7.68342 20.5976 7.29289 20.2071C6.90237 19.8166 6.90237 19.1834 7.29289 18.7929L14.0858 12L7.29289 5.20711C6.90237 4.81658 6.90237 4.18342 7.29289 3.79289Z",
        fill: "white",
        "fill-opacity": "0.24"
    }, null, -1)
    , Ure = [$re];
function Vre(t, e) {
    return A(),
        N("svg", Fre, Ure)
}
const H4 = _e(Bre, [["render", Vre]])
    , Gre = {}
    , Hre = {
        viewBox: "0 0 32 32",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }
    , Wre = T("rect", {
        width: "32",
        height: "32",
        rx: "16",
        fill: "#58B83E"
    }, null, -1)
    , Yre = T("path", {
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        d: "M25.274 8.98816C25.9087 9.63903 25.9087 10.6943 25.274 11.3452L13.899 23.0118C13.2644 23.6627 12.2356 23.6627 11.601 23.0118L6.72595 18.0118C6.09135 17.361 6.09135 16.3057 6.72595 15.6548C7.36055 15.0039 8.38945 15.0039 9.02405 15.6548L12.75 19.4763L22.976 8.98816C23.6106 8.33728 24.6394 8.33728 25.274 8.98816Z",
        fill: "white"
    }, null, -1)
    , Xre = [Wre, Yre];
function jre(t, e) {
    return A(),
        N("svg", Hre, Xre)
}
const xc = _e(Gre, [["render", jre]])
    , zre = ["src"]
    , qre = {
        class: "mr-auto"
    }
    , Kre = {
        class: "text-base leading-6 text-white last:mb-0 mb-1"
    }
    , Jre = {
        key: 0,
        class: "flex text-base leading-6 font-semibold text-white"
    }
    , Zre = {
        key: 1,
        class: "text-white"
    }
    , W4 = {
        __name: "DailyCard",
        props: {
            label: String,
            icon: String,
            reward: Number,
            disabled: Boolean,
            done: Boolean
        },
        setup(t) {
            return (e, n) => (A(),
                N("div", {
                    class: Te(["flex items-center p-2 px-4 rounded-lg bg-white/[.08] cursor-pointer transition-all duration-100 last:mb-0 hover:bg-white/[.12] active:bg-white/[.12]", [t.disabled && "pointer-events-none opacity-40"]])
                }, [t.icon ? (A(),
                    N("img", {
                        key: 0,
                        src: `/icons/icon-${t.icon}.webp`,
                        class: "mr-4 shrink-0 w-[52px] h-[52px]"
                    }, null, 8, zre)) : te("", !0), T("div", qre, [T("div", Kre, $(t.label), 1), t.reward ? (A(),
                        N("div", Jre, [G(dn, {
                            class: "mr-2 w-6 h-6"
                        }), Fe(" + " + $(de(Xt)(t.reward, !0)), 1)])) : te("", !0)]), t.disabled && !t.done ? (A(),
                            N("div", Zre, $(e.$t("common.soon")), 1)) : te("", !0), t.done ? (A(),
                                fe(xc, {
                                    key: 2,
                                    class: "shrink-0 w-6 h-6"
                                })) : (A(),
                                    fe(H4, {
                                        key: 3,
                                        class: "shrink-0 w-6 h-6"
                                    }))], 2))
        }
    }
    , Qre = {
        class: "flex flex-col gap-3 w-full items-center"
    }
    , eie = ["src"]
    , tie = {
        class: "text-white text-2xl font-bold text-center"
    }
    , nie = {
        class: "text-coin text-2xl font-semibold"
    }
    , sie = {
        __name: "MediaTasksPopup",
        props: {
            isVisible: Boolean,
            id: String
        },
        emits: ["close"],
        setup(t, { emit: e }) {
            const { t: n } = gt()
                , s = t
                , r = e
                , i = _f()
                , o = ve(() => i.getTaskById(s.id))
                , l = ke(!1)
                , a = () => {
                    o.value.link && (o.value.isExternalLink ? window.Telegram.WebApp.openLink(o.value.link) : window.Telegram.WebApp.openTelegramLink(o.value.link),
                        i.setReadyToClaim(o.value.id))
                }
                , c = async () => {
                    o.value.isLoading || (l.value = !0,
                        await i.completeMediaTask(o.value.id),
                        l.value = !1,
                        r("close"))
                }
                ;
            return (u, h) => (A(),
                fe(il, {
                    isVisible: t.isVisible,
                    onClose: h[0] || (h[0] = d => r("close"))
                }, {
                    default: Ce(() => [T("div", Qre, [T("img", {
                        src: `/icons/icon-${o.value.icon}.webp`,
                        alt: "Media Icon",
                        class: "w-20 h-20"
                    }, null, 8, eie), T("h4", tie, $(de(n)(`tasks.${o.value.id}.label`)), 1), G(Lr, {
                        class: "px-6 !w-auto !border-accent active:bg-accent/50",
                        type: "dark",
                        size: "m",
                        onClick: a,
                        disabled: o.value.isReadyToClaim
                    }, {
                        default: Ce(() => [Fe($(de(n)(`tasks.${o.value.id}.button`)), 1)]),
                        _: 1
                    }, 8, ["disabled"]), T("p", nie, [Fe(" + " + $(de(Xt)(o.value.reward, !0)) + " ", 1), o.value.done ? (A(),
                        fe(xc, {
                            key: 0,
                            class: "ml-2 inline-block shrink-0 w-6 h-6"
                        })) : te("", !0)]), G(Lr, {
                            class: "w-full",
                            type: "success",
                            disabled: !o.value.isReadyToClaim || o.value.done,
                            isLoading: l.value,
                            onClick: c,
                            size: "l"
                        }, {
                            default: Ce(() => [Fe($(de(n)("daily.reward_popup.button")), 1)]),
                            _: 1
                        }, 8, ["disabled", "isLoading"])])]),
                    _: 1
                }, 8, ["isVisible"]))
        }
    }
    , rie = {
        class: "flex flex-col gap-2"
    }
    , Y4 = {
        __name: "TasksList",
        props: {},
        setup(t) {
            const { t: e } = gt()
                , n = ke(!1)
                , s = ke(null)
                , r = _f()
                , i = ve(() => [...r.mediaTasks.filter(a => !a.done && !a.disabled), ...r.mediaTasks.filter(a => a.done && !a.disabled), ...r.mediaTasks.filter(a => a.disabled)])
                , o = a => {
                    s.value = a.id,
                        n.value = !0
                }
                , l = () => {
                    n.value = !1,
                        s.value = null
                }
                ;
            return (a, c) => (A(),
                N("div", rie, [(A(!0),
                    N(Ie, null, mt(i.value, u => (A(),
                        fe(W4, Ms({
                            key: u.id,
                            ref_for: !0
                        }, u, {
                            label: de(e)(`tasks.${u.id}.label`),
                            disabled: u.disabled || u.done,
                            onClick: h => o(u)
                        }), null, 16, ["label", "disabled", "onClick"]))), 128)), G(sie, {
                            isVisible: n.value,
                            onClose: l,
                            id: s.value
                        }, null, 8, ["isVisible", "id"])]))
        }
    }
    , iie = {
        name: "SlapDailyBody",
        data() {
            return {
                globalStore: Ye(),
                dailyClaimsStore: gf(),
                tasksStore: _f(),
                showDailyPopup: !1
            }
        },
        emits: ["dailyRewardClicked"],
        components: {
            TasksList: Y4,
            DailyCard: W4
        },
        computed: {
            currentDailyClaim() {
                return this.dailyClaimsStore.currentDailyClaim
            },
            hasTasks() {
                var t;
                return !!((t = this.tasksStore.mediaTasks) != null && t.length)
            }
        },
        methods: {
            showDailyRewardPopup() {
                this.dailyClaimsStore.showDailyRewardPopup(),
                    this.$emit("dailyRewardClicked")
            }
        }
    }
    , oie = {
        class: "sl-daily-body"
    }
    , aie = {
        class: "sl-daily-body__header"
    }
    , lie = {
        class: "sl-daily-body__group"
    }
    , cie = {
        class: "sl-daily-body__title"
    }
    , uie = {
        class: "sl-daily-body__items"
    }
    , hie = {
        key: 0,
        class: "sl-daily-body__group"
    }
    , die = {
        class: "sl-daily-body__title"
    };
function fie(t, e, n, s, r, i) {
    const o = q("IconCoin")
        , l = q("DailyCard")
        , a = q("TasksList");
    return A(),
        N("div", oie, [T("div", aie, [G(o, {
            class: "sl-daily-body__header__pic w-[128px]"
        })]), T("div", lie, [T("div", cie, $(t.$t("daily.body.daily_tasks_title")), 1), T("div", uie, [i.currentDailyClaim ? (A(),
            fe(l, {
                key: 0,
                icon: "calendar",
                done: i.currentDailyClaim.done,
                label: t.$t("daily.body.daily_reward"),
                onClick: i.showDailyRewardPopup
            }, null, 8, ["done", "label", "onClick"])) : te("", !0)])]), i.hasTasks ? (A(),
                N("div", hie, [T("div", die, $(t.$t("daily.body.tasks_list_title")), 1), G(a)])) : te("", !0)])
}
const pie = _e(iie, [["render", fie], ["__scopeId", "data-v-0427fc4a"]])
    , mie = Qa({
        components: {
            SlapDailyBody: pie,
            SlapDailyHeader: Dre,
            IconHand: al,
            Overlay: ch
        },
        data() {
            return {
                onboardingStore: _s(),
                dailyRewardPopupOpened: !1
            }
        },
        emits: ["ready"],
        methods: {
            onDailyRewardClicked() {
                this.onboardingStore.goToNextStep()
            }
        },
        props: {
            isVisible: {
                type: Boolean,
                default: !1
            },
            onClose: Function
        },
        mounted() {
            this.$emit("ready"),
                document.querySelector(".sl-layout").classList.add("before-h-454")
        },
        unmounted() {
            document.querySelector(".sl-layout").classList.remove("before-h-454")
        }
    })
    , gie = {
        class: "sl-daily-quest__content overflow-auto"
    };
function _ie(t, e, n, s, r, i) {
    const o = q("SlapDailyHeader")
        , l = q("IconHand")
        , a = q("SlapDailyBody")
        , c = q("Overlay");
    return A(),
        fe(c, {
            isVisible: t.isVisible,
            onClose: t.onClose,
            class: "sl-girl-card__bg flex flex-col",
            bodyClass: "grow justify-end flex flex-col",
            closeButtonClass: "bg-white/5 rounded-full"
        }, {
            header: Ce(() => [G(o)]),
            default: Ce(() => {
                var u;
                return [T("div", {
                    class: Te(["sl-daily-quest", [t.onboardingStore.isOnboardingInProgress && `sl-daily-quest--onboarding-step-${(u = t.onboardingStore.currentStep) == null ? void 0 : u.stepId}`]])
                }, [G(l, {
                    class: "sl-daily-quest__onboarding-hand"
                }), T("div", gie, [G(a, {
                    onDailyRewardClicked: t.onDailyRewardClicked
                }, null, 8, ["onDailyRewardClicked"])])], 2)]
            }
            ),
            _: 1
        }, 8, ["isVisible", "onClose"])
}
const yie = _e(mie, [["render", _ie], ["__scopeId", "data-v-2d485a45"]]);
var ut = (t => (t[t.Region = 0] = "Region",
    t[t.BoundingBox = 1] = "BoundingBox",
    t[t.Mesh = 2] = "Mesh",
    t[t.LinkedMesh = 3] = "LinkedMesh",
    t[t.Path = 4] = "Path",
    t[t.Point = 5] = "Point",
    t[t.Clipping = 6] = "Clipping",
    t))(ut || {});
class Gm {
    constructor(e, n = new Array, s = 0, r = new DataView(e.buffer)) {
        this.strings = n,
            this.index = s,
            this.buffer = r
    }
    readByte() {
        return this.buffer.getInt8(this.index++)
    }
    readUnsignedByte() {
        return this.buffer.getUint8(this.index++)
    }
    readShort() {
        const e = this.buffer.getInt16(this.index);
        return this.index += 2,
            e
    }
    readInt32() {
        const e = this.buffer.getInt32(this.index);
        return this.index += 4,
            e
    }
    readInt(e) {
        let n = this.readByte()
            , s = n & 127;
        return n & 128 && (n = this.readByte(),
            s |= (n & 127) << 7,
            n & 128 && (n = this.readByte(),
                s |= (n & 127) << 14,
                n & 128 && (n = this.readByte(),
                    s |= (n & 127) << 21,
                    n & 128 && (n = this.readByte(),
                        s |= (n & 127) << 28)))),
            e ? s : s >>> 1 ^ -(s & 1)
    }
    readStringRef() {
        const e = this.readInt(!0);
        return e == 0 ? null : this.strings[e - 1]
    }
    readString() {
        let e = this.readInt(!0);
        switch (e) {
            case 0:
                return null;
            case 1:
                return ""
        }
        e--;
        let n = "";
        for (let s = 0; s < e;) {
            const r = this.readUnsignedByte();
            switch (r >> 4) {
                case 12:
                case 13:
                    n += String.fromCharCode((r & 31) << 6 | this.readByte() & 63),
                        s += 2;
                    break;
                case 14:
                    n += String.fromCharCode((r & 15) << 12 | (this.readByte() & 63) << 6 | this.readByte() & 63),
                        s += 3;
                    break;
                default:
                    n += String.fromCharCode(r),
                        s++
            }
        }
        return n
    }
    readFloat() {
        const e = this.buffer.getFloat32(this.index);
        return this.index += 4,
            e
    }
    readBoolean() {
        return this.readByte() != 0
    }
}
var O = (t => (t[t.setup = 0] = "setup",
    t[t.first = 1] = "first",
    t[t.replace = 2] = "replace",
    t[t.add = 3] = "add",
    t))(O || {})
    , ct = (t => (t[t.mixIn = 0] = "mixIn",
        t[t.mixOut = 1] = "mixOut",
        t))(ct || {})
    , on = (t => (t[t.Fixed = 0] = "Fixed",
        t[t.Percent = 1] = "Percent",
        t))(on || {})
    , bn = (t => (t[t.Tangent = 0] = "Tangent",
        t[t.Chain = 1] = "Chain",
        t[t.ChainScale = 2] = "ChainScale",
        t))(bn || {})
    , Qe = (t => (t[t.Normal = 0] = "Normal",
        t[t.OnlyTranslation = 1] = "OnlyTranslation",
        t[t.NoRotationOrReflection = 2] = "NoRotationOrReflection",
        t[t.NoScale = 3] = "NoScale",
        t[t.NoScaleOrReflection = 4] = "NoScaleOrReflection",
        t))(Qe || {})
    , wc = (t => (t[t.WEBGL_LEGACY = 0] = "WEBGL_LEGACY",
        t[t.WEBGL = 1] = "WEBGL",
        t[t.WEBGL2 = 2] = "WEBGL2",
        t))(wc || {})
    , X4 = (t => (t[t.UNKNOWN = 0] = "UNKNOWN",
        t[t.WEBGL = 1] = "WEBGL",
        t[t.CANVAS = 2] = "CANVAS",
        t))(X4 || {})
    , eb = (t => (t[t.COLOR = 16384] = "COLOR",
        t[t.DEPTH = 256] = "DEPTH",
        t[t.STENCIL = 1024] = "STENCIL",
        t))(eb || {})
    , Oe = (t => (t[t.NORMAL = 0] = "NORMAL",
        t[t.ADD = 1] = "ADD",
        t[t.MULTIPLY = 2] = "MULTIPLY",
        t[t.SCREEN = 3] = "SCREEN",
        t[t.OVERLAY = 4] = "OVERLAY",
        t[t.DARKEN = 5] = "DARKEN",
        t[t.LIGHTEN = 6] = "LIGHTEN",
        t[t.COLOR_DODGE = 7] = "COLOR_DODGE",
        t[t.COLOR_BURN = 8] = "COLOR_BURN",
        t[t.HARD_LIGHT = 9] = "HARD_LIGHT",
        t[t.SOFT_LIGHT = 10] = "SOFT_LIGHT",
        t[t.DIFFERENCE = 11] = "DIFFERENCE",
        t[t.EXCLUSION = 12] = "EXCLUSION",
        t[t.HUE = 13] = "HUE",
        t[t.SATURATION = 14] = "SATURATION",
        t[t.COLOR = 15] = "COLOR",
        t[t.LUMINOSITY = 16] = "LUMINOSITY",
        t[t.NORMAL_NPM = 17] = "NORMAL_NPM",
        t[t.ADD_NPM = 18] = "ADD_NPM",
        t[t.SCREEN_NPM = 19] = "SCREEN_NPM",
        t[t.NONE = 20] = "NONE",
        t[t.SRC_OVER = 0] = "SRC_OVER",
        t[t.SRC_IN = 21] = "SRC_IN",
        t[t.SRC_OUT = 22] = "SRC_OUT",
        t[t.SRC_ATOP = 23] = "SRC_ATOP",
        t[t.DST_OVER = 24] = "DST_OVER",
        t[t.DST_IN = 25] = "DST_IN",
        t[t.DST_OUT = 26] = "DST_OUT",
        t[t.DST_ATOP = 27] = "DST_ATOP",
        t[t.ERASE = 26] = "ERASE",
        t[t.SUBTRACT = 28] = "SUBTRACT",
        t[t.XOR = 29] = "XOR",
        t))(Oe || {})
    , ti = (t => (t[t.POINTS = 0] = "POINTS",
        t[t.LINES = 1] = "LINES",
        t[t.LINE_LOOP = 2] = "LINE_LOOP",
        t[t.LINE_STRIP = 3] = "LINE_STRIP",
        t[t.TRIANGLES = 4] = "TRIANGLES",
        t[t.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP",
        t[t.TRIANGLE_FAN = 6] = "TRIANGLE_FAN",
        t))(ti || {})
    , Ee = (t => (t[t.RGBA = 6408] = "RGBA",
        t[t.RGB = 6407] = "RGB",
        t[t.RG = 33319] = "RG",
        t[t.RED = 6403] = "RED",
        t[t.RGBA_INTEGER = 36249] = "RGBA_INTEGER",
        t[t.RGB_INTEGER = 36248] = "RGB_INTEGER",
        t[t.RG_INTEGER = 33320] = "RG_INTEGER",
        t[t.RED_INTEGER = 36244] = "RED_INTEGER",
        t[t.ALPHA = 6406] = "ALPHA",
        t[t.LUMINANCE = 6409] = "LUMINANCE",
        t[t.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA",
        t[t.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT",
        t[t.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL",
        t))(Ee || {})
    , bu = (t => (t[t.TEXTURE_2D = 3553] = "TEXTURE_2D",
        t[t.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP",
        t[t.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY",
        t[t.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X",
        t[t.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X",
        t[t.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y",
        t[t.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y",
        t[t.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z",
        t[t.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z",
        t))(bu || {})
    , Ge = (t => (t[t.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE",
        t[t.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT",
        t[t.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5",
        t[t.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4",
        t[t.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1",
        t[t.UNSIGNED_INT = 5125] = "UNSIGNED_INT",
        t[t.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV",
        t[t.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV",
        t[t.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8",
        t[t.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV",
        t[t.BYTE = 5120] = "BYTE",
        t[t.SHORT = 5122] = "SHORT",
        t[t.INT = 5124] = "INT",
        t[t.FLOAT = 5126] = "FLOAT",
        t[t.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV",
        t[t.HALF_FLOAT = 36193] = "HALF_FLOAT",
        t))(Ge || {})
    , Ne = (t => (t[t.FLOAT = 0] = "FLOAT",
        t[t.INT = 1] = "INT",
        t[t.UINT = 2] = "UINT",
        t))(Ne || {})
    , ar = (t => (t[t.NEAREST = 0] = "NEAREST",
        t[t.LINEAR = 1] = "LINEAR",
        t))(ar || {})
    , Ua = (t => (t[t.CLAMP = 33071] = "CLAMP",
        t[t.REPEAT = 10497] = "REPEAT",
        t[t.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT",
        t))(Ua || {})
    , ci = (t => (t[t.OFF = 0] = "OFF",
        t[t.POW2 = 1] = "POW2",
        t[t.ON = 2] = "ON",
        t[t.ON_MANUAL = 3] = "ON_MANUAL",
        t))(ci || {})
    , Is = (t => (t[t.NPM = 0] = "NPM",
        t[t.UNPACK = 1] = "UNPACK",
        t[t.PMA = 2] = "PMA",
        t[t.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA",
        t[t.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD",
        t[t.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA",
        t))(Is || {})
    , Oi = (t => (t[t.NO = 0] = "NO",
        t[t.YES = 1] = "YES",
        t[t.AUTO = 2] = "AUTO",
        t[t.BLEND = 0] = "BLEND",
        t[t.CLEAR = 1] = "CLEAR",
        t[t.BLIT = 2] = "BLIT",
        t))(Oi || {})
    , Kx = (t => (t[t.AUTO = 0] = "AUTO",
        t[t.MANUAL = 1] = "MANUAL",
        t))(Kx || {})
    , Er = (t => (t.LOW = "lowp",
        t.MEDIUM = "mediump",
        t.HIGH = "highp",
        t))(Er || {})
    , An = (t => (t[t.NONE = 0] = "NONE",
        t[t.SCISSOR = 1] = "SCISSOR",
        t[t.STENCIL = 2] = "STENCIL",
        t[t.SPRITE = 3] = "SPRITE",
        t[t.COLOR = 4] = "COLOR",
        t))(An || {})
    , En = (t => (t[t.NONE = 0] = "NONE",
        t[t.LOW = 2] = "LOW",
        t[t.MEDIUM = 4] = "MEDIUM",
        t[t.HIGH = 8] = "HIGH",
        t))(En || {})
    , Gi = (t => (t[t.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER",
        t[t.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER",
        t[t.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER",
        t))(Gi || {});
const bie = {
    createCanvas: (t, e) => {
        const n = document.createElement("canvas");
        return n.width = t,
            n.height = e,
            n
    }
    ,
    getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
    getWebGLRenderingContext: () => WebGLRenderingContext,
    getNavigator: () => navigator,
    getBaseUrl: () => document.baseURI ?? window.location.href,
    getFontFaceSet: () => document.fonts,
    fetch: (t, e) => fetch(t, e),
    parseXML: t => new DOMParser().parseFromString(t, "text/xml")
}
    , Le = {
        ADAPTER: bie,
        RESOLUTION: 1,
        CREATE_IMAGE_BITMAP: !1,
        ROUND_PIXELS: !1
    };
var Y0 = /iPhone/i
    , W2 = /iPod/i
    , Y2 = /iPad/i
    , X2 = /\biOS-universal(?:.+)Mac\b/i
    , X0 = /\bAndroid(?:.+)Mobile\b/i
    , j2 = /Android/i
    , kc = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i
    , np = /Silk/i
    , no = /Windows Phone/i
    , z2 = /\bWindows(?:.+)ARM\b/i
    , q2 = /BlackBerry/i
    , K2 = /BB10/i
    , J2 = /Opera Mini/i
    , Z2 = /\b(CriOS|Chrome)(?:.+)Mobile/i
    , Q2 = /Mobile(?:.+)Firefox\b/i
    , eI = function (t) {
        return typeof t < "u" && t.platform === "MacIntel" && typeof t.maxTouchPoints == "number" && t.maxTouchPoints > 1 && typeof MSStream > "u"
    };
function vie(t) {
    return function (e) {
        return e.test(t)
    }
}
function tI(t) {
    var e = {
        userAgent: "",
        platform: "",
        maxTouchPoints: 0
    };
    !t && typeof navigator < "u" ? e = {
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        maxTouchPoints: navigator.maxTouchPoints || 0
    } : typeof t == "string" ? e.userAgent = t : t && t.userAgent && (e = {
        userAgent: t.userAgent,
        platform: t.platform,
        maxTouchPoints: t.maxTouchPoints || 0
    });
    var n = e.userAgent
        , s = n.split("[FBAN");
    typeof s[1] < "u" && (n = s[0]),
        s = n.split("Twitter"),
        typeof s[1] < "u" && (n = s[0]);
    var r = vie(n)
        , i = {
            apple: {
                phone: r(Y0) && !r(no),
                ipod: r(W2),
                tablet: !r(Y0) && (r(Y2) || eI(e)) && !r(no),
                universal: r(X2),
                device: (r(Y0) || r(W2) || r(Y2) || r(X2) || eI(e)) && !r(no)
            },
            amazon: {
                phone: r(kc),
                tablet: !r(kc) && r(np),
                device: r(kc) || r(np)
            },
            android: {
                phone: !r(no) && r(kc) || !r(no) && r(X0),
                tablet: !r(no) && !r(kc) && !r(X0) && (r(np) || r(j2)),
                device: !r(no) && (r(kc) || r(np) || r(X0) || r(j2)) || r(/\bokhttp\b/i)
            },
            windows: {
                phone: r(no),
                tablet: r(z2),
                device: r(no) || r(z2)
            },
            other: {
                blackberry: r(q2),
                blackberry10: r(K2),
                opera: r(J2),
                firefox: r(Q2),
                chrome: r(Z2),
                device: r(q2) || r(K2) || r(J2) || r(Q2) || r(Z2)
            },
            any: !1,
            phone: !1,
            tablet: !1
        };
    return i.any = i.apple.device || i.android.device || i.windows.device || i.other.device,
        i.phone = i.apple.phone || i.android.phone || i.windows.phone,
        i.tablet = i.apple.tablet || i.android.tablet || i.windows.tablet,
        i
}
const xie = tI.default ?? tI
    , xo = xie(globalThis.navigator);
Le.RETINA_PREFIX = /@([0-9\.]+)x/;
Le.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !1;
var j4 = {
    exports: {}
};
(function (t) {
    var e = Object.prototype.hasOwnProperty
        , n = "~";
    function s() { }
    Object.create && (s.prototype = Object.create(null),
        new s().__proto__ || (n = !1));
    function r(a, c, u) {
        this.fn = a,
            this.context = c,
            this.once = u || !1
    }
    function i(a, c, u, h, d) {
        if (typeof u != "function")
            throw new TypeError("The listener must be a function");
        var f = new r(u, h || a, d)
            , p = n ? n + c : c;
        return a._events[p] ? a._events[p].fn ? a._events[p] = [a._events[p], f] : a._events[p].push(f) : (a._events[p] = f,
            a._eventsCount++),
            a
    }
    function o(a, c) {
        --a._eventsCount === 0 ? a._events = new s : delete a._events[c]
    }
    function l() {
        this._events = new s,
            this._eventsCount = 0
    }
    l.prototype.eventNames = function () {
        var c = [], u, h;
        if (this._eventsCount === 0)
            return c;
        for (h in u = this._events)
            e.call(u, h) && c.push(n ? h.slice(1) : h);
        return Object.getOwnPropertySymbols ? c.concat(Object.getOwnPropertySymbols(u)) : c
    }
        ,
        l.prototype.listeners = function (c) {
            var u = n ? n + c : c
                , h = this._events[u];
            if (!h)
                return [];
            if (h.fn)
                return [h.fn];
            for (var d = 0, f = h.length, p = new Array(f); d < f; d++)
                p[d] = h[d].fn;
            return p
        }
        ,
        l.prototype.listenerCount = function (c) {
            var u = n ? n + c : c
                , h = this._events[u];
            return h ? h.fn ? 1 : h.length : 0
        }
        ,
        l.prototype.emit = function (c, u, h, d, f, p) {
            var m = n ? n + c : c;
            if (!this._events[m])
                return !1;
            var g = this._events[m], b = arguments.length, v, _;
            if (g.fn) {
                switch (g.once && this.removeListener(c, g.fn, void 0, !0),
                b) {
                    case 1:
                        return g.fn.call(g.context),
                            !0;
                    case 2:
                        return g.fn.call(g.context, u),
                            !0;
                    case 3:
                        return g.fn.call(g.context, u, h),
                            !0;
                    case 4:
                        return g.fn.call(g.context, u, h, d),
                            !0;
                    case 5:
                        return g.fn.call(g.context, u, h, d, f),
                            !0;
                    case 6:
                        return g.fn.call(g.context, u, h, d, f, p),
                            !0
                }
                for (_ = 1,
                    v = new Array(b - 1); _ < b; _++)
                    v[_ - 1] = arguments[_];
                g.fn.apply(g.context, v)
            } else {
                var y = g.length, x;
                for (_ = 0; _ < y; _++)
                    switch (g[_].once && this.removeListener(c, g[_].fn, void 0, !0),
                    b) {
                        case 1:
                            g[_].fn.call(g[_].context);
                            break;
                        case 2:
                            g[_].fn.call(g[_].context, u);
                            break;
                        case 3:
                            g[_].fn.call(g[_].context, u, h);
                            break;
                        case 4:
                            g[_].fn.call(g[_].context, u, h, d);
                            break;
                        default:
                            if (!v)
                                for (x = 1,
                                    v = new Array(b - 1); x < b; x++)
                                    v[x - 1] = arguments[x];
                            g[_].fn.apply(g[_].context, v)
                    }
            }
            return !0
        }
        ,
        l.prototype.on = function (c, u, h) {
            return i(this, c, u, h, !1)
        }
        ,
        l.prototype.once = function (c, u, h) {
            return i(this, c, u, h, !0)
        }
        ,
        l.prototype.removeListener = function (c, u, h, d) {
            var f = n ? n + c : c;
            if (!this._events[f])
                return this;
            if (!u)
                return o(this, f),
                    this;
            var p = this._events[f];
            if (p.fn)
                p.fn === u && (!d || p.once) && (!h || p.context === h) && o(this, f);
            else {
                for (var m = 0, g = [], b = p.length; m < b; m++)
                    (p[m].fn !== u || d && !p[m].once || h && p[m].context !== h) && g.push(p[m]);
                g.length ? this._events[f] = g.length === 1 ? g[0] : g : o(this, f)
            }
            return this
        }
        ,
        l.prototype.removeAllListeners = function (c) {
            var u;
            return c ? (u = n ? n + c : c,
                this._events[u] && o(this, u)) : (this._events = new s,
                    this._eventsCount = 0),
                this
        }
        ,
        l.prototype.off = l.prototype.removeListener,
        l.prototype.addListener = l.prototype.on,
        l.prefixed = n,
        l.EventEmitter = l,
        t.exports = l
}
)(j4);
var wie = j4.exports;
const yf = Fv(wie);
var Jx = {
    exports: {}
};
Jx.exports = I_;
Jx.exports.default = I_;
function I_(t, e, n) {
    n = n || 2;
    var s = e && e.length
        , r = s ? e[0] * n : t.length
        , i = z4(t, 0, r, n, !0)
        , o = [];
    if (!i || i.next === i.prev)
        return o;
    var l, a, c, u, h, d, f;
    if (s && (i = Iie(t, e, i, n)),
        t.length > 80 * n) {
        l = c = t[0],
            a = u = t[1];
        for (var p = n; p < r; p += n)
            h = t[p],
                d = t[p + 1],
                h < l && (l = h),
                d < a && (a = d),
                h > c && (c = h),
                d > u && (u = d);
        f = Math.max(c - l, u - a),
            f = f !== 0 ? 32767 / f : 0
    }
    return Od(i, o, n, l, a, f, 0),
        o
}
function z4(t, e, n, s, r) {
    var i, o;
    if (r === sb(t, e, n, s) > 0)
        for (i = e; i < n; i += s)
            o = nI(i, t[i], t[i + 1], o);
    else
        for (i = n - s; i >= e; i -= s)
            o = nI(i, t[i], t[i + 1], o);
    return o && A_(o, o.next) && (Dd(o),
        o = o.next),
        o
}
function ac(t, e) {
    if (!t)
        return t;
    e || (e = t);
    var n = t, s;
    do
        if (s = !1,
            !n.steiner && (A_(n, n.next) || rn(n.prev, n, n.next) === 0)) {
            if (Dd(n),
                n = e = n.prev,
                n === n.next)
                break;
            s = !0
        } else
            n = n.next;
    while (s || n !== e);
    return e
}
function Od(t, e, n, s, r, i, o) {
    if (t) {
        !o && i && Pie(t, s, r, i);
        for (var l = t, a, c; t.prev !== t.next;) {
            if (a = t.prev,
                c = t.next,
                i ? Eie(t, s, r, i) : Sie(t)) {
                e.push(a.i / n | 0),
                    e.push(t.i / n | 0),
                    e.push(c.i / n | 0),
                    Dd(t),
                    t = c.next,
                    l = c.next;
                continue
            }
            if (t = c,
                t === l) {
                o ? o === 1 ? (t = Tie(ac(t), e, n),
                    Od(t, e, n, s, r, i, 2)) : o === 2 && Cie(t, e, n, s, r, i) : Od(ac(t), e, n, s, r, i, 1);
                break
            }
        }
    }
}
function Sie(t) {
    var e = t.prev
        , n = t
        , s = t.next;
    if (rn(e, n, s) >= 0)
        return !1;
    for (var r = e.x, i = n.x, o = s.x, l = e.y, a = n.y, c = s.y, u = r < i ? r < o ? r : o : i < o ? i : o, h = l < a ? l < c ? l : c : a < c ? a : c, d = r > i ? r > o ? r : o : i > o ? i : o, f = l > a ? l > c ? l : c : a > c ? a : c, p = s.next; p !== e;) {
        if (p.x >= u && p.x <= d && p.y >= h && p.y <= f && nu(r, l, i, a, o, c, p.x, p.y) && rn(p.prev, p, p.next) >= 0)
            return !1;
        p = p.next
    }
    return !0
}
function Eie(t, e, n, s) {
    var r = t.prev
        , i = t
        , o = t.next;
    if (rn(r, i, o) >= 0)
        return !1;
    for (var l = r.x, a = i.x, c = o.x, u = r.y, h = i.y, d = o.y, f = l < a ? l < c ? l : c : a < c ? a : c, p = u < h ? u < d ? u : d : h < d ? h : d, m = l > a ? l > c ? l : c : a > c ? a : c, g = u > h ? u > d ? u : d : h > d ? h : d, b = tb(f, p, e, n, s), v = tb(m, g, e, n, s), _ = t.prevZ, y = t.nextZ; _ && _.z >= b && y && y.z <= v;) {
        if (_.x >= f && _.x <= m && _.y >= p && _.y <= g && _ !== r && _ !== o && nu(l, u, a, h, c, d, _.x, _.y) && rn(_.prev, _, _.next) >= 0 || (_ = _.prevZ,
            y.x >= f && y.x <= m && y.y >= p && y.y <= g && y !== r && y !== o && nu(l, u, a, h, c, d, y.x, y.y) && rn(y.prev, y, y.next) >= 0))
            return !1;
        y = y.nextZ
    }
    for (; _ && _.z >= b;) {
        if (_.x >= f && _.x <= m && _.y >= p && _.y <= g && _ !== r && _ !== o && nu(l, u, a, h, c, d, _.x, _.y) && rn(_.prev, _, _.next) >= 0)
            return !1;
        _ = _.prevZ
    }
    for (; y && y.z <= v;) {
        if (y.x >= f && y.x <= m && y.y >= p && y.y <= g && y !== r && y !== o && nu(l, u, a, h, c, d, y.x, y.y) && rn(y.prev, y, y.next) >= 0)
            return !1;
        y = y.nextZ
    }
    return !0
}
function Tie(t, e, n) {
    var s = t;
    do {
        var r = s.prev
            , i = s.next.next;
        !A_(r, i) && q4(r, s, s.next, i) && Nd(r, i) && Nd(i, r) && (e.push(r.i / n | 0),
            e.push(s.i / n | 0),
            e.push(i.i / n | 0),
            Dd(s),
            Dd(s.next),
            s = t = i),
            s = s.next
    } while (s !== t);
    return ac(s)
}
function Cie(t, e, n, s, r, i) {
    var o = t;
    do {
        for (var l = o.next.next; l !== o.prev;) {
            if (o.i !== l.i && Nie(o, l)) {
                var a = K4(o, l);
                o = ac(o, o.next),
                    a = ac(a, a.next),
                    Od(o, e, n, s, r, i, 0),
                    Od(a, e, n, s, r, i, 0);
                return
            }
            l = l.next
        }
        o = o.next
    } while (o !== t)
}
function Iie(t, e, n, s) {
    var r = [], i, o, l, a, c;
    for (i = 0,
        o = e.length; i < o; i++)
        l = e[i] * s,
            a = i < o - 1 ? e[i + 1] * s : t.length,
            c = z4(t, l, a, s, !1),
            c === c.next && (c.steiner = !0),
            r.push(Oie(c));
    for (r.sort(Aie),
        i = 0; i < r.length; i++)
        n = kie(r[i], n);
    return n
}
function Aie(t, e) {
    return t.x - e.x
}
function kie(t, e) {
    var n = Rie(t, e);
    if (!n)
        return e;
    var s = K4(n, t);
    return ac(s, s.next),
        ac(n, n.next)
}
function Rie(t, e) {
    var n = e, s = t.x, r = t.y, i = -1 / 0, o;
    do {
        if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {
            var l = n.x + (r - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
            if (l <= s && l > i && (i = l,
                o = n.x < n.next.x ? n : n.next,
                l === s))
                return o
        }
        n = n.next
    } while (n !== e);
    if (!o)
        return null;
    var a = o, c = o.x, u = o.y, h = 1 / 0, d;
    n = o;
    do
        s >= n.x && n.x >= c && s !== n.x && nu(r < u ? s : i, r, c, u, r < u ? i : s, r, n.x, n.y) && (d = Math.abs(r - n.y) / (s - n.x),
            Nd(n, t) && (d < h || d === h && (n.x > o.x || n.x === o.x && Mie(o, n))) && (o = n,
                h = d)),
            n = n.next;
    while (n !== a);
    return o
}
function Mie(t, e) {
    return rn(t.prev, t, e.prev) < 0 && rn(e.next, t, t.next) < 0
}
function Pie(t, e, n, s) {
    var r = t;
    do
        r.z === 0 && (r.z = tb(r.x, r.y, e, n, s)),
            r.prevZ = r.prev,
            r.nextZ = r.next,
            r = r.next;
    while (r !== t);
    r.prevZ.nextZ = null,
        r.prevZ = null,
        Lie(r)
}
function Lie(t) {
    var e, n, s, r, i, o, l, a, c = 1;
    do {
        for (n = t,
            t = null,
            i = null,
            o = 0; n;) {
            for (o++,
                s = n,
                l = 0,
                e = 0; e < c && (l++,
                    s = s.nextZ,
                    !!s); e++)
                ;
            for (a = c; l > 0 || a > 0 && s;)
                l !== 0 && (a === 0 || !s || n.z <= s.z) ? (r = n,
                    n = n.nextZ,
                    l--) : (r = s,
                        s = s.nextZ,
                        a--),
                    i ? i.nextZ = r : t = r,
                    r.prevZ = i,
                    i = r;
            n = s
        }
        i.nextZ = null,
            c *= 2
    } while (o > 1);
    return t
}
function tb(t, e, n, s, r) {
    return t = (t - n) * r | 0,
        e = (e - s) * r | 0,
        t = (t | t << 8) & 16711935,
        t = (t | t << 4) & 252645135,
        t = (t | t << 2) & 858993459,
        t = (t | t << 1) & 1431655765,
        e = (e | e << 8) & 16711935,
        e = (e | e << 4) & 252645135,
        e = (e | e << 2) & 858993459,
        e = (e | e << 1) & 1431655765,
        t | e << 1
}
function Oie(t) {
    var e = t
        , n = t;
    do
        (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e),
            e = e.next;
    while (e !== t);
    return n
}
function nu(t, e, n, s, r, i, o, l) {
    return (r - o) * (e - l) >= (t - o) * (i - l) && (t - o) * (s - l) >= (n - o) * (e - l) && (n - o) * (i - l) >= (r - o) * (s - l)
}
function Nie(t, e) {
    return t.next.i !== e.i && t.prev.i !== e.i && !Die(t, e) && (Nd(t, e) && Nd(e, t) && Bie(t, e) && (rn(t.prev, t, e.prev) || rn(t, e.prev, e)) || A_(t, e) && rn(t.prev, t, t.next) > 0 && rn(e.prev, e, e.next) > 0)
}
function rn(t, e, n) {
    return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)
}
function A_(t, e) {
    return t.x === e.x && t.y === e.y
}
function q4(t, e, n, s) {
    var r = rp(rn(t, e, n))
        , i = rp(rn(t, e, s))
        , o = rp(rn(n, s, t))
        , l = rp(rn(n, s, e));
    return !!(r !== i && o !== l || r === 0 && sp(t, n, e) || i === 0 && sp(t, s, e) || o === 0 && sp(n, t, s) || l === 0 && sp(n, e, s))
}
function sp(t, e, n) {
    return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y)
}
function rp(t) {
    return t > 0 ? 1 : t < 0 ? -1 : 0
}
function Die(t, e) {
    var n = t;
    do {
        if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && q4(n, n.next, t, e))
            return !0;
        n = n.next
    } while (n !== t);
    return !1
}
function Nd(t, e) {
    return rn(t.prev, t, t.next) < 0 ? rn(t, e, t.next) >= 0 && rn(t, t.prev, e) >= 0 : rn(t, e, t.prev) < 0 || rn(t, t.next, e) < 0
}
function Bie(t, e) {
    var n = t
        , s = !1
        , r = (t.x + e.x) / 2
        , i = (t.y + e.y) / 2;
    do
        n.y > i != n.next.y > i && n.next.y !== n.y && r < (n.next.x - n.x) * (i - n.y) / (n.next.y - n.y) + n.x && (s = !s),
            n = n.next;
    while (n !== t);
    return s
}
function K4(t, e) {
    var n = new nb(t.i, t.x, t.y)
        , s = new nb(e.i, e.x, e.y)
        , r = t.next
        , i = e.prev;
    return t.next = e,
        e.prev = t,
        n.next = r,
        r.prev = n,
        s.next = n,
        n.prev = s,
        i.next = s,
        s.prev = i,
        s
}
function nI(t, e, n, s) {
    var r = new nb(t, e, n);
    return s ? (r.next = s.next,
        r.prev = s,
        s.next.prev = r,
        s.next = r) : (r.prev = r,
            r.next = r),
        r
}
function Dd(t) {
    t.next.prev = t.prev,
        t.prev.next = t.next,
        t.prevZ && (t.prevZ.nextZ = t.nextZ),
        t.nextZ && (t.nextZ.prevZ = t.prevZ)
}
function nb(t, e, n) {
    this.i = t,
        this.x = e,
        this.y = n,
        this.prev = null,
        this.next = null,
        this.z = 0,
        this.prevZ = null,
        this.nextZ = null,
        this.steiner = !1
}
I_.deviation = function (t, e, n, s) {
    var r = e && e.length
        , i = r ? e[0] * n : t.length
        , o = Math.abs(sb(t, 0, i, n));
    if (r)
        for (var l = 0, a = e.length; l < a; l++) {
            var c = e[l] * n
                , u = l < a - 1 ? e[l + 1] * n : t.length;
            o -= Math.abs(sb(t, c, u, n))
        }
    var h = 0;
    for (l = 0; l < s.length; l += 3) {
        var d = s[l] * n
            , f = s[l + 1] * n
            , p = s[l + 2] * n;
        h += Math.abs((t[d] - t[p]) * (t[f + 1] - t[d + 1]) - (t[d] - t[f]) * (t[p + 1] - t[d + 1]))
    }
    return o === 0 && h === 0 ? 0 : Math.abs((h - o) / o)
}
    ;
function sb(t, e, n, s) {
    for (var r = 0, i = e, o = n - s; i < n; i += s)
        r += (t[o] - t[i]) * (t[i + 1] + t[o + 1]),
            o = i;
    return r
}
I_.flatten = function (t) {
    for (var e = t[0][0].length, n = {
        vertices: [],
        holes: [],
        dimensions: e
    }, s = 0, r = 0; r < t.length; r++) {
        for (var i = 0; i < t[r].length; i++)
            for (var o = 0; o < e; o++)
                n.vertices.push(t[r][i][o]);
        r > 0 && (s += t[r - 1].length,
            n.holes.push(s))
    }
    return n
}
    ;
var Fie = Jx.exports;
const $ie = Fv(Fie);
var Hm = {
    exports: {}
};
Hm.exports;
(function (t, e) {
    var n = {};
    (function (s) {
        var r = e && !e.nodeType && e
            , i = t && !t.nodeType && t
            , o = typeof n == "object" && n;
        (o.global === o || o.window === o || o.self === o) && (s = o);
        var l, a = 2147483647, c = 36, u = 1, h = 26, d = 38, f = 700, p = 72, m = 128, g = "-", b = /^xn--/, v = /[^\x20-\x7E]/, _ = /[\x2E\u3002\uFF0E\uFF61]/g, y = {
            overflow: "Overflow: input needs wider integers to process",
            "not-basic": "Illegal input >= 0x80 (not a basic code point)",
            "invalid-input": "Invalid input"
        }, x = c - u, w = Math.floor, S = String.fromCharCode, E;
        function C(Y) {
            throw new RangeError(y[Y])
        }
        function I(Y, ne) {
            for (var oe = Y.length, ce = []; oe--;)
                ce[oe] = ne(Y[oe]);
            return ce
        }
        function L(Y, ne) {
            var oe = Y.split("@")
                , ce = "";
            oe.length > 1 && (ce = oe[0] + "@",
                Y = oe[1]),
                Y = Y.replace(_, ".");
            var ue = Y.split(".")
                , we = I(ue, ne).join(".");
            return ce + we
        }
        function k(Y) {
            for (var ne = [], oe = 0, ce = Y.length, ue, we; oe < ce;)
                ue = Y.charCodeAt(oe++),
                    ue >= 55296 && ue <= 56319 && oe < ce ? (we = Y.charCodeAt(oe++),
                        (we & 64512) == 56320 ? ne.push(((ue & 1023) << 10) + (we & 1023) + 65536) : (ne.push(ue),
                            oe--)) : ne.push(ue);
            return ne
        }
        function R(Y) {
            return I(Y, function (ne) {
                var oe = "";
                return ne > 65535 && (ne -= 65536,
                    oe += S(ne >>> 10 & 1023 | 55296),
                    ne = 56320 | ne & 1023),
                    oe += S(ne),
                    oe
            }).join("")
        }
        function U(Y) {
            return Y - 48 < 10 ? Y - 22 : Y - 65 < 26 ? Y - 65 : Y - 97 < 26 ? Y - 97 : c
        }
        function W(Y, ne) {
            return Y + 22 + 75 * (Y < 26) - ((ne != 0) << 5)
        }
        function H(Y, ne, oe) {
            var ce = 0;
            for (Y = oe ? w(Y / f) : Y >> 1,
                Y += w(Y / ne); Y > x * h >> 1; ce += c)
                Y = w(Y / x);
            return w(ce + (x + 1) * Y / (Y + d))
        }
        function j(Y) {
            var ne = [], oe = Y.length, ce, ue = 0, we = m, K = p, ge, he, be, Pe, De, D, M, X, ae;
            for (ge = Y.lastIndexOf(g),
                ge < 0 && (ge = 0),
                he = 0; he < ge; ++he)
                Y.charCodeAt(he) >= 128 && C("not-basic"),
                    ne.push(Y.charCodeAt(he));
            for (be = ge > 0 ? ge + 1 : 0; be < oe;) {
                for (Pe = ue,
                    De = 1,
                    D = c; be >= oe && C("invalid-input"),
                    M = U(Y.charCodeAt(be++)),
                    (M >= c || M > w((a - ue) / De)) && C("overflow"),
                    ue += M * De,
                    X = D <= K ? u : D >= K + h ? h : D - K,
                    !(M < X); D += c)
                    ae = c - X,
                        De > w(a / ae) && C("overflow"),
                        De *= ae;
                ce = ne.length + 1,
                    K = H(ue - Pe, ce, Pe == 0),
                    w(ue / ce) > a - we && C("overflow"),
                    we += w(ue / ce),
                    ue %= ce,
                    ne.splice(ue++, 0, we)
            }
            return R(ne)
        }
        function z(Y) {
            var ne, oe, ce, ue, we, K, ge, he, be, Pe, De, D = [], M, X, ae, ie;
            for (Y = k(Y),
                M = Y.length,
                ne = m,
                oe = 0,
                we = p,
                K = 0; K < M; ++K)
                De = Y[K],
                    De < 128 && D.push(S(De));
            for (ce = ue = D.length,
                ue && D.push(g); ce < M;) {
                for (ge = a,
                    K = 0; K < M; ++K)
                    De = Y[K],
                        De >= ne && De < ge && (ge = De);
                for (X = ce + 1,
                    ge - ne > w((a - oe) / X) && C("overflow"),
                    oe += (ge - ne) * X,
                    ne = ge,
                    K = 0; K < M; ++K)
                    if (De = Y[K],
                        De < ne && ++oe > a && C("overflow"),
                        De == ne) {
                        for (he = oe,
                            be = c; Pe = be <= we ? u : be >= we + h ? h : be - we,
                            !(he < Pe); be += c)
                            ie = he - Pe,
                                ae = c - Pe,
                                D.push(S(W(Pe + ie % ae, 0))),
                                he = w(ie / ae);
                        D.push(S(W(he, 0))),
                            we = H(oe, X, ce == ue),
                            oe = 0,
                            ++ce
                    }
                ++oe,
                    ++ne
            }
            return D.join("")
        }
        function ee(Y) {
            return L(Y, function (ne) {
                return b.test(ne) ? j(ne.slice(4).toLowerCase()) : ne
            })
        }
        function J(Y) {
            return L(Y, function (ne) {
                return v.test(ne) ? "xn--" + z(ne) : ne
            })
        }
        if (l = {
            version: "1.4.1",
            ucs2: {
                decode: k,
                encode: R
            },
            decode: j,
            encode: z,
            toASCII: J,
            toUnicode: ee
        },
            r && i)
            if (t.exports == r)
                i.exports = l;
            else
                for (E in l)
                    l.hasOwnProperty(E) && (r[E] = l[E]);
        else
            s.punycode = l
    }
    )(X9)
}
)(Hm, Hm.exports);
var Uie = Hm.exports, Vie = Error, Gie = EvalError, Hie = RangeError, Wie = ReferenceError, J4 = SyntaxError, bf = TypeError, Yie = URIError, Xie = function () {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
        return !1;
    if (typeof Symbol.iterator == "symbol")
        return !0;
    var e = {}
        , n = Symbol("test")
        , s = Object(n);
    if (typeof n == "string" || Object.prototype.toString.call(n) !== "[object Symbol]" || Object.prototype.toString.call(s) !== "[object Symbol]")
        return !1;
    var r = 42;
    e[n] = r;
    for (n in e)
        return !1;
    if (typeof Object.keys == "function" && Object.keys(e).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(e).length !== 0)
        return !1;
    var i = Object.getOwnPropertySymbols(e);
    if (i.length !== 1 || i[0] !== n || !Object.prototype.propertyIsEnumerable.call(e, n))
        return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
        var o = Object.getOwnPropertyDescriptor(e, n);
        if (o.value !== r || o.enumerable !== !0)
            return !1
    }
    return !0
}, sI = typeof Symbol < "u" && Symbol, jie = Xie, zie = function () {
    return typeof sI != "function" || typeof Symbol != "function" || typeof sI("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : jie()
}, j0 = {
    __proto__: null,
    foo: {}
}, qie = Object, Kie = function () {
    return {
        __proto__: j0
    }.foo === j0.foo && !(j0 instanceof qie)
}, Jie = "Function.prototype.bind called on incompatible ", Zie = Object.prototype.toString, Qie = Math.max, eoe = "[object Function]", rI = function (e, n) {
    for (var s = [], r = 0; r < e.length; r += 1)
        s[r] = e[r];
    for (var i = 0; i < n.length; i += 1)
        s[i + e.length] = n[i];
    return s
}, toe = function (e, n) {
    for (var s = [], r = n, i = 0; r < e.length; r += 1,
        i += 1)
        s[i] = e[r];
    return s
}, noe = function (t, e) {
    for (var n = "", s = 0; s < t.length; s += 1)
        n += t[s],
            s + 1 < t.length && (n += e);
    return n
}, soe = function (e) {
    var n = this;
    if (typeof n != "function" || Zie.apply(n) !== eoe)
        throw new TypeError(Jie + n);
    for (var s = toe(arguments, 1), r, i = function () {
        if (this instanceof r) {
            var u = n.apply(this, rI(s, arguments));
            return Object(u) === u ? u : this
        }
        return n.apply(e, rI(s, arguments))
    }, o = Qie(0, n.length - s.length), l = [], a = 0; a < o; a++)
        l[a] = "$" + a;
    if (r = Function("binder", "return function (" + noe(l, ",") + "){ return binder.apply(this,arguments); }")(i),
        n.prototype) {
        var c = function () { };
        c.prototype = n.prototype,
            r.prototype = new c,
            c.prototype = null
    }
    return r
}, roe = soe, Zx = Function.prototype.bind || roe, ioe = Function.prototype.call, ooe = Object.prototype.hasOwnProperty, aoe = Zx, loe = aoe.call(ioe, ooe), _t, coe = Vie, uoe = Gie, hoe = Hie, doe = Wie, ju = J4, vu = bf, foe = Yie, Z4 = Function, z0 = function (t) {
    try {
        return Z4('"use strict"; return (' + t + ").constructor;")()
    } catch { }
}, Yl = Object.getOwnPropertyDescriptor;
if (Yl)
    try {
        Yl({}, "")
    } catch {
        Yl = null
    }
var q0 = function () {
    throw new vu
}
    , poe = Yl ? function () {
        try {
            return arguments.callee,
                q0
        } catch {
            try {
                return Yl(arguments, "callee").get
            } catch {
                return q0
            }
        }
    }() : q0
    , Rc = zie()
    , moe = Kie()
    , Wn = Object.getPrototypeOf || (moe ? function (t) {
        return t.__proto__
    }
        : null)
    , Uc = {}
    , goe = typeof Uint8Array > "u" || !Wn ? _t : Wn(Uint8Array)
    , Xl = {
        __proto__: null,
        "%AggregateError%": typeof AggregateError > "u" ? _t : AggregateError,
        "%Array%": Array,
        "%ArrayBuffer%": typeof ArrayBuffer > "u" ? _t : ArrayBuffer,
        "%ArrayIteratorPrototype%": Rc && Wn ? Wn([][Symbol.iterator]()) : _t,
        "%AsyncFromSyncIteratorPrototype%": _t,
        "%AsyncFunction%": Uc,
        "%AsyncGenerator%": Uc,
        "%AsyncGeneratorFunction%": Uc,
        "%AsyncIteratorPrototype%": Uc,
        "%Atomics%": typeof Atomics > "u" ? _t : Atomics,
        "%BigInt%": typeof BigInt > "u" ? _t : BigInt,
        "%BigInt64Array%": typeof BigInt64Array > "u" ? _t : BigInt64Array,
        "%BigUint64Array%": typeof BigUint64Array > "u" ? _t : BigUint64Array,
        "%Boolean%": Boolean,
        "%DataView%": typeof DataView > "u" ? _t : DataView,
        "%Date%": Date,
        "%decodeURI%": decodeURI,
        "%decodeURIComponent%": decodeURIComponent,
        "%encodeURI%": encodeURI,
        "%encodeURIComponent%": encodeURIComponent,
        "%Error%": coe,
        "%eval%": eval,
        "%EvalError%": uoe,
        "%Float32Array%": typeof Float32Array > "u" ? _t : Float32Array,
        "%Float64Array%": typeof Float64Array > "u" ? _t : Float64Array,
        "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? _t : FinalizationRegistry,
        "%Function%": Z4,
        "%GeneratorFunction%": Uc,
        "%Int8Array%": typeof Int8Array > "u" ? _t : Int8Array,
        "%Int16Array%": typeof Int16Array > "u" ? _t : Int16Array,
        "%Int32Array%": typeof Int32Array > "u" ? _t : Int32Array,
        "%isFinite%": isFinite,
        "%isNaN%": isNaN,
        "%IteratorPrototype%": Rc && Wn ? Wn(Wn([][Symbol.iterator]())) : _t,
        "%JSON%": typeof JSON == "object" ? JSON : _t,
        "%Map%": typeof Map > "u" ? _t : Map,
        "%MapIteratorPrototype%": typeof Map > "u" || !Rc || !Wn ? _t : Wn(new Map()[Symbol.iterator]()),
        "%Math%": Math,
        "%Number%": Number,
        "%Object%": Object,
        "%parseFloat%": parseFloat,
        "%parseInt%": parseInt,
        "%Promise%": typeof Promise > "u" ? _t : Promise,
        "%Proxy%": typeof Proxy > "u" ? _t : Proxy,
        "%RangeError%": hoe,
        "%ReferenceError%": doe,
        "%Reflect%": typeof Reflect > "u" ? _t : Reflect,
        "%RegExp%": RegExp,
        "%Set%": typeof Set > "u" ? _t : Set,
        "%SetIteratorPrototype%": typeof Set > "u" || !Rc || !Wn ? _t : Wn(new Set()[Symbol.iterator]()),
        "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? _t : SharedArrayBuffer,
        "%String%": String,
        "%StringIteratorPrototype%": Rc && Wn ? Wn(""[Symbol.iterator]()) : _t,
        "%Symbol%": Rc ? Symbol : _t,
        "%SyntaxError%": ju,
        "%ThrowTypeError%": poe,
        "%TypedArray%": goe,
        "%TypeError%": vu,
        "%Uint8Array%": typeof Uint8Array > "u" ? _t : Uint8Array,
        "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? _t : Uint8ClampedArray,
        "%Uint16Array%": typeof Uint16Array > "u" ? _t : Uint16Array,
        "%Uint32Array%": typeof Uint32Array > "u" ? _t : Uint32Array,
        "%URIError%": foe,
        "%WeakMap%": typeof WeakMap > "u" ? _t : WeakMap,
        "%WeakRef%": typeof WeakRef > "u" ? _t : WeakRef,
        "%WeakSet%": typeof WeakSet > "u" ? _t : WeakSet
    };
if (Wn)
    try {
        null.error
    } catch (t) {
        var _oe = Wn(Wn(t));
        Xl["%Error.prototype%"] = _oe
    }
var yoe = function t(e) {
    var n;
    if (e === "%AsyncFunction%")
        n = z0("async function () {}");
    else if (e === "%GeneratorFunction%")
        n = z0("function* () {}");
    else if (e === "%AsyncGeneratorFunction%")
        n = z0("async function* () {}");
    else if (e === "%AsyncGenerator%") {
        var s = t("%AsyncGeneratorFunction%");
        s && (n = s.prototype)
    } else if (e === "%AsyncIteratorPrototype%") {
        var r = t("%AsyncGenerator%");
        r && Wn && (n = Wn(r.prototype))
    }
    return Xl[e] = n,
        n
}, iI = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, vf = Zx, Wm = loe, boe = vf.call(Function.call, Array.prototype.concat), voe = vf.call(Function.apply, Array.prototype.splice), oI = vf.call(Function.call, String.prototype.replace), Ym = vf.call(Function.call, String.prototype.slice), xoe = vf.call(Function.call, RegExp.prototype.exec), woe = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, Soe = /\\(\\)?/g, Eoe = function (e) {
    var n = Ym(e, 0, 1)
        , s = Ym(e, -1);
    if (n === "%" && s !== "%")
        throw new ju("invalid intrinsic syntax, expected closing `%`");
    if (s === "%" && n !== "%")
        throw new ju("invalid intrinsic syntax, expected opening `%`");
    var r = [];
    return oI(e, woe, function (i, o, l, a) {
        r[r.length] = l ? oI(a, Soe, "$1") : o || i
    }),
        r
}, Toe = function (e, n) {
    var s = e, r;
    if (Wm(iI, s) && (r = iI[s],
        s = "%" + r[0] + "%"),
        Wm(Xl, s)) {
        var i = Xl[s];
        if (i === Uc && (i = yoe(s)),
            typeof i > "u" && !n)
            throw new vu("intrinsic " + e + " exists, but is not available. Please file an issue!");
        return {
            alias: r,
            name: s,
            value: i
        }
    }
    throw new ju("intrinsic " + e + " does not exist!")
}, dh = function (e, n) {
    if (typeof e != "string" || e.length === 0)
        throw new vu("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof n != "boolean")
        throw new vu('"allowMissing" argument must be a boolean');
    if (xoe(/^%?[^%]*%?$/, e) === null)
        throw new ju("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var s = Eoe(e)
        , r = s.length > 0 ? s[0] : ""
        , i = Toe("%" + r + "%", n)
        , o = i.name
        , l = i.value
        , a = !1
        , c = i.alias;
    c && (r = c[0],
        voe(s, boe([0, 1], c)));
    for (var u = 1, h = !0; u < s.length; u += 1) {
        var d = s[u]
            , f = Ym(d, 0, 1)
            , p = Ym(d, -1);
        if ((f === '"' || f === "'" || f === "`" || p === '"' || p === "'" || p === "`") && f !== p)
            throw new ju("property names with quotes must have matching quotes");
        if ((d === "constructor" || !h) && (a = !0),
            r += "." + d,
            o = "%" + r + "%",
            Wm(Xl, o))
            l = Xl[o];
        else if (l != null) {
            if (!(d in l)) {
                if (!n)
                    throw new vu("base intrinsic for " + e + " exists, but the property is not available.");
                return
            }
            if (Yl && u + 1 >= s.length) {
                var m = Yl(l, d);
                h = !!m,
                    h && "get" in m && !("originalValue" in m.get) ? l = m.get : l = l[d]
            } else
                h = Wm(l, d),
                    l = l[d];
            h && !a && (Xl[o] = l)
        }
    }
    return l
}, Q4 = {
    exports: {}
}, K0, aI;
function Qx() {
    if (aI)
        return K0;
    aI = 1;
    var t = dh
        , e = t("%Object.defineProperty%", !0) || !1;
    if (e)
        try {
            e({}, "a", {
                value: 1
            })
        } catch {
            e = !1
        }
    return K0 = e,
        K0
}
var Coe = dh
    , jp = Coe("%Object.getOwnPropertyDescriptor%", !0);
if (jp)
    try {
        jp([], "length")
    } catch {
        jp = null
    }
var e6 = jp
    , lI = Qx()
    , Ioe = J4
    , Mc = bf
    , cI = e6
    , Aoe = function (e, n, s) {
        if (!e || typeof e != "object" && typeof e != "function")
            throw new Mc("`obj` must be an object or a function`");
        if (typeof n != "string" && typeof n != "symbol")
            throw new Mc("`property` must be a string or a symbol`");
        if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
            throw new Mc("`nonEnumerable`, if provided, must be a boolean or null");
        if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
            throw new Mc("`nonWritable`, if provided, must be a boolean or null");
        if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
            throw new Mc("`nonConfigurable`, if provided, must be a boolean or null");
        if (arguments.length > 6 && typeof arguments[6] != "boolean")
            throw new Mc("`loose`, if provided, must be a boolean");
        var r = arguments.length > 3 ? arguments[3] : null
            , i = arguments.length > 4 ? arguments[4] : null
            , o = arguments.length > 5 ? arguments[5] : null
            , l = arguments.length > 6 ? arguments[6] : !1
            , a = !!cI && cI(e, n);
        if (lI)
            lI(e, n, {
                configurable: o === null && a ? a.configurable : !o,
                enumerable: r === null && a ? a.enumerable : !r,
                value: s,
                writable: i === null && a ? a.writable : !i
            });
        else if (l || !r && !i && !o)
            e[n] = s;
        else
            throw new Ioe("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.")
    }
    , rb = Qx()
    , t6 = function () {
        return !!rb
    };
t6.hasArrayLengthDefineBug = function () {
    if (!rb)
        return null;
    try {
        return rb([], "length", {
            value: 1
        }).length !== 1
    } catch {
        return !0
    }
}
    ;
var koe = t6
    , Roe = dh
    , uI = Aoe
    , Moe = koe()
    , hI = e6
    , dI = bf
    , Poe = Roe("%Math.floor%")
    , Loe = function (e, n) {
        if (typeof e != "function")
            throw new dI("`fn` is not a function");
        if (typeof n != "number" || n < 0 || n > 4294967295 || Poe(n) !== n)
            throw new dI("`length` must be a positive 32-bit integer");
        var s = arguments.length > 2 && !!arguments[2]
            , r = !0
            , i = !0;
        if ("length" in e && hI) {
            var o = hI(e, "length");
            o && !o.configurable && (r = !1),
                o && !o.writable && (i = !1)
        }
        return (r || i || !s) && (Moe ? uI(e, "length", n, !0, !0) : uI(e, "length", n)),
            e
    };
(function (t) {
    var e = Zx
        , n = dh
        , s = Loe
        , r = bf
        , i = n("%Function.prototype.apply%")
        , o = n("%Function.prototype.call%")
        , l = n("%Reflect.apply%", !0) || e.call(o, i)
        , a = Qx()
        , c = n("%Math.max%");
    t.exports = function (d) {
        if (typeof d != "function")
            throw new r("a function is required");
        var f = l(e, o, arguments);
        return s(f, 1 + c(0, d.length - (arguments.length - 1)), !0)
    }
        ;
    var u = function () {
        return l(e, i, arguments)
    };
    a ? a(t.exports, "apply", {
        value: u
    }) : t.exports.apply = u
}
)(Q4);
var Ooe = Q4.exports
    , n6 = dh
    , s6 = Ooe
    , Noe = s6(n6("String.prototype.indexOf"))
    , Doe = function (e, n) {
        var s = n6(e, !!n);
        return typeof s == "function" && Noe(e, ".prototype.") > -1 ? s6(s) : s
    };
const Boe = {}
    , Foe = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: Boe
    }, Symbol.toStringTag, {
        value: "Module"
    }))
    , $oe = j9(Foe);
var fI = {}
    , ew = typeof Map == "function" && Map.prototype
    , J0 = Object.getOwnPropertyDescriptor && ew ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null
    , Xm = ew && J0 && typeof J0.get == "function" ? J0.get : null
    , pI = ew && Map.prototype.forEach
    , tw = typeof Set == "function" && Set.prototype
    , Z0 = Object.getOwnPropertyDescriptor && tw ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null
    , jm = tw && Z0 && typeof Z0.get == "function" ? Z0.get : null
    , mI = tw && Set.prototype.forEach
    , Uoe = typeof WeakMap == "function" && WeakMap.prototype
    , cd = Uoe ? WeakMap.prototype.has : null
    , Voe = typeof WeakSet == "function" && WeakSet.prototype
    , ud = Voe ? WeakSet.prototype.has : null
    , Goe = typeof WeakRef == "function" && WeakRef.prototype
    , gI = Goe ? WeakRef.prototype.deref : null
    , Hoe = Boolean.prototype.valueOf
    , Woe = Object.prototype.toString
    , Yoe = Function.prototype.toString
    , Xoe = String.prototype.match
    , nw = String.prototype.slice
    , ka = String.prototype.replace
    , joe = String.prototype.toUpperCase
    , _I = String.prototype.toLowerCase
    , r6 = RegExp.prototype.test
    , yI = Array.prototype.concat
    , Ni = Array.prototype.join
    , zoe = Array.prototype.slice
    , bI = Math.floor
    , ib = typeof BigInt == "function" ? BigInt.prototype.valueOf : null
    , Q0 = Object.getOwnPropertySymbols
    , ob = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null
    , zu = typeof Symbol == "function" && typeof Symbol.iterator == "object"
    , gs = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === zu || !0) ? Symbol.toStringTag : null
    , i6 = Object.prototype.propertyIsEnumerable
    , vI = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function (t) {
        return t.__proto__
    }
        : null);
function xI(t, e) {
    if (t === 1 / 0 || t === -1 / 0 || t !== t || t && t > -1e3 && t < 1e3 || r6.call(/e/, e))
        return e;
    var n = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof t == "number") {
        var s = t < 0 ? -bI(-t) : bI(t);
        if (s !== t) {
            var r = String(s)
                , i = nw.call(e, r.length + 1);
            return ka.call(r, n, "$&_") + "." + ka.call(ka.call(i, /([0-9]{3})/g, "$&_"), /_$/, "")
        }
    }
    return ka.call(e, n, "$&_")
}
var ab = $oe
    , wI = ab.custom
    , SI = a6(wI) ? wI : null
    , qoe = function t(e, n, s, r) {
        var i = n || {};
        if (xa(i, "quoteStyle") && i.quoteStyle !== "single" && i.quoteStyle !== "double")
            throw new TypeError('option "quoteStyle" must be "single" or "double"');
        if (xa(i, "maxStringLength") && (typeof i.maxStringLength == "number" ? i.maxStringLength < 0 && i.maxStringLength !== 1 / 0 : i.maxStringLength !== null))
            throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
        var o = xa(i, "customInspect") ? i.customInspect : !0;
        if (typeof o != "boolean" && o !== "symbol")
            throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
        if (xa(i, "indent") && i.indent !== null && i.indent !== "	" && !(parseInt(i.indent, 10) === i.indent && i.indent > 0))
            throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
        if (xa(i, "numericSeparator") && typeof i.numericSeparator != "boolean")
            throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
        var l = i.numericSeparator;
        if (typeof e > "u")
            return "undefined";
        if (e === null)
            return "null";
        if (typeof e == "boolean")
            return e ? "true" : "false";
        if (typeof e == "string")
            return c6(e, i);
        if (typeof e == "number") {
            if (e === 0)
                return 1 / 0 / e > 0 ? "0" : "-0";
            var a = String(e);
            return l ? xI(e, a) : a
        }
        if (typeof e == "bigint") {
            var c = String(e) + "n";
            return l ? xI(e, c) : c
        }
        var u = typeof i.depth > "u" ? 5 : i.depth;
        if (typeof s > "u" && (s = 0),
            s >= u && u > 0 && typeof e == "object")
            return lb(e) ? "[Array]" : "[Object]";
        var h = fae(i, s);
        if (typeof r > "u")
            r = [];
        else if (l6(r, e) >= 0)
            return "[Circular]";
        function d(R, U, W) {
            if (U && (r = zoe.call(r),
                r.push(U)),
                W) {
                var H = {
                    depth: i.depth
                };
                return xa(i, "quoteStyle") && (H.quoteStyle = i.quoteStyle),
                    t(R, H, s + 1, r)
            }
            return t(R, i, s + 1, r)
        }
        if (typeof e == "function" && !EI(e)) {
            var f = rae(e)
                , p = ip(e, d);
            return "[Function" + (f ? ": " + f : " (anonymous)") + "]" + (p.length > 0 ? " { " + Ni.call(p, ", ") + " }" : "")
        }
        if (a6(e)) {
            var m = zu ? ka.call(String(e), /^(Symbol\(.*\))_[^)]*$/, "$1") : ob.call(e);
            return typeof e == "object" && !zu ? Ah(m) : m
        }
        if (uae(e)) {
            for (var g = "<" + _I.call(String(e.nodeName)), b = e.attributes || [], v = 0; v < b.length; v++)
                g += " " + b[v].name + "=" + o6(Koe(b[v].value), "double", i);
            return g += ">",
                e.childNodes && e.childNodes.length && (g += "..."),
                g += "</" + _I.call(String(e.nodeName)) + ">",
                g
        }
        if (lb(e)) {
            if (e.length === 0)
                return "[]";
            var _ = ip(e, d);
            return h && !dae(_) ? "[" + cb(_, h) + "]" : "[ " + Ni.call(_, ", ") + " ]"
        }
        if (Zoe(e)) {
            var y = ip(e, d);
            return !("cause" in Error.prototype) && "cause" in e && !i6.call(e, "cause") ? "{ [" + String(e) + "] " + Ni.call(yI.call("[cause]: " + d(e.cause), y), ", ") + " }" : y.length === 0 ? "[" + String(e) + "]" : "{ [" + String(e) + "] " + Ni.call(y, ", ") + " }"
        }
        if (typeof e == "object" && o) {
            if (SI && typeof e[SI] == "function" && ab)
                return ab(e, {
                    depth: u - s
                });
            if (o !== "symbol" && typeof e.inspect == "function")
                return e.inspect()
        }
        if (iae(e)) {
            var x = [];
            return pI && pI.call(e, function (R, U) {
                x.push(d(U, e, !0) + " => " + d(R, e))
            }),
                TI("Map", Xm.call(e), x, h)
        }
        if (lae(e)) {
            var w = [];
            return mI && mI.call(e, function (R) {
                w.push(d(R, e))
            }),
                TI("Set", jm.call(e), w, h)
        }
        if (oae(e))
            return e1("WeakMap");
        if (cae(e))
            return e1("WeakSet");
        if (aae(e))
            return e1("WeakRef");
        if (eae(e))
            return Ah(d(Number(e)));
        if (nae(e))
            return Ah(d(ib.call(e)));
        if (tae(e))
            return Ah(Hoe.call(e));
        if (Qoe(e))
            return Ah(d(String(e)));
        if (typeof window < "u" && e === window)
            return "{ [object Window] }";
        if (typeof globalThis < "u" && e === globalThis || typeof fI < "u" && e === fI)
            return "{ [object globalThis] }";
        if (!Joe(e) && !EI(e)) {
            var S = ip(e, d)
                , E = vI ? vI(e) === Object.prototype : e instanceof Object || e.constructor === Object
                , C = e instanceof Object ? "" : "null prototype"
                , I = !E && gs && Object(e) === e && gs in e ? nw.call(ll(e), 8, -1) : C ? "Object" : ""
                , L = E || typeof e.constructor != "function" ? "" : e.constructor.name ? e.constructor.name + " " : ""
                , k = L + (I || C ? "[" + Ni.call(yI.call([], I || [], C || []), ": ") + "] " : "");
            return S.length === 0 ? k + "{}" : h ? k + "{" + cb(S, h) + "}" : k + "{ " + Ni.call(S, ", ") + " }"
        }
        return String(e)
    };
function o6(t, e, n) {
    var s = (n.quoteStyle || e) === "double" ? '"' : "'";
    return s + t + s
}
function Koe(t) {
    return ka.call(String(t), /"/g, "&quot;")
}
function lb(t) {
    return ll(t) === "[object Array]" && (!gs || !(typeof t == "object" && gs in t))
}
function Joe(t) {
    return ll(t) === "[object Date]" && (!gs || !(typeof t == "object" && gs in t))
}
function EI(t) {
    return ll(t) === "[object RegExp]" && (!gs || !(typeof t == "object" && gs in t))
}
function Zoe(t) {
    return ll(t) === "[object Error]" && (!gs || !(typeof t == "object" && gs in t))
}
function Qoe(t) {
    return ll(t) === "[object String]" && (!gs || !(typeof t == "object" && gs in t))
}
function eae(t) {
    return ll(t) === "[object Number]" && (!gs || !(typeof t == "object" && gs in t))
}
function tae(t) {
    return ll(t) === "[object Boolean]" && (!gs || !(typeof t == "object" && gs in t))
}
function a6(t) {
    if (zu)
        return t && typeof t == "object" && t instanceof Symbol;
    if (typeof t == "symbol")
        return !0;
    if (!t || typeof t != "object" || !ob)
        return !1;
    try {
        return ob.call(t),
            !0
    } catch { }
    return !1
}
function nae(t) {
    if (!t || typeof t != "object" || !ib)
        return !1;
    try {
        return ib.call(t),
            !0
    } catch { }
    return !1
}
var sae = Object.prototype.hasOwnProperty || function (t) {
    return t in this
}
    ;
function xa(t, e) {
    return sae.call(t, e)
}
function ll(t) {
    return Woe.call(t)
}
function rae(t) {
    if (t.name)
        return t.name;
    var e = Xoe.call(Yoe.call(t), /^function\s*([\w$]+)/);
    return e ? e[1] : null
}
function l6(t, e) {
    if (t.indexOf)
        return t.indexOf(e);
    for (var n = 0, s = t.length; n < s; n++)
        if (t[n] === e)
            return n;
    return -1
}
function iae(t) {
    if (!Xm || !t || typeof t != "object")
        return !1;
    try {
        Xm.call(t);
        try {
            jm.call(t)
        } catch {
            return !0
        }
        return t instanceof Map
    } catch { }
    return !1
}
function oae(t) {
    if (!cd || !t || typeof t != "object")
        return !1;
    try {
        cd.call(t, cd);
        try {
            ud.call(t, ud)
        } catch {
            return !0
        }
        return t instanceof WeakMap
    } catch { }
    return !1
}
function aae(t) {
    if (!gI || !t || typeof t != "object")
        return !1;
    try {
        return gI.call(t),
            !0
    } catch { }
    return !1
}
function lae(t) {
    if (!jm || !t || typeof t != "object")
        return !1;
    try {
        jm.call(t);
        try {
            Xm.call(t)
        } catch {
            return !0
        }
        return t instanceof Set
    } catch { }
    return !1
}
function cae(t) {
    if (!ud || !t || typeof t != "object")
        return !1;
    try {
        ud.call(t, ud);
        try {
            cd.call(t, cd)
        } catch {
            return !0
        }
        return t instanceof WeakSet
    } catch { }
    return !1
}
function uae(t) {
    return !t || typeof t != "object" ? !1 : typeof HTMLElement < "u" && t instanceof HTMLElement ? !0 : typeof t.nodeName == "string" && typeof t.getAttribute == "function"
}
function c6(t, e) {
    if (t.length > e.maxStringLength) {
        var n = t.length - e.maxStringLength
            , s = "... " + n + " more character" + (n > 1 ? "s" : "");
        return c6(nw.call(t, 0, e.maxStringLength), e) + s
    }
    var r = ka.call(ka.call(t, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, hae);
    return o6(r, "single", e)
}
function hae(t) {
    var e = t.charCodeAt(0)
        , n = {
            8: "b",
            9: "t",
            10: "n",
            12: "f",
            13: "r"
        }[e];
    return n ? "\\" + n : "\\x" + (e < 16 ? "0" : "") + joe.call(e.toString(16))
}
function Ah(t) {
    return "Object(" + t + ")"
}
function e1(t) {
    return t + " { ? }"
}
function TI(t, e, n, s) {
    var r = s ? cb(n, s) : Ni.call(n, ", ");
    return t + " (" + e + ") {" + r + "}"
}
function dae(t) {
    for (var e = 0; e < t.length; e++)
        if (l6(t[e], `
`) >= 0)
            return !1;
    return !0
}
function fae(t, e) {
    var n;
    if (t.indent === "	")
        n = "	";
    else if (typeof t.indent == "number" && t.indent > 0)
        n = Ni.call(Array(t.indent + 1), " ");
    else
        return null;
    return {
        base: n,
        prev: Ni.call(Array(e + 1), n)
    }
}
function cb(t, e) {
    if (t.length === 0)
        return "";
    var n = `
` + e.prev + e.base;
    return n + Ni.call(t, "," + n) + `
` + e.prev
}
function ip(t, e) {
    var n = lb(t)
        , s = [];
    if (n) {
        s.length = t.length;
        for (var r = 0; r < t.length; r++)
            s[r] = xa(t, r) ? e(t[r], t) : ""
    }
    var i = typeof Q0 == "function" ? Q0(t) : [], o;
    if (zu) {
        o = {};
        for (var l = 0; l < i.length; l++)
            o["$" + i[l]] = i[l]
    }
    for (var a in t)
        xa(t, a) && (n && String(Number(a)) === a && a < t.length || zu && o["$" + a] instanceof Symbol || (r6.call(/[^\w$]/, a) ? s.push(e(a, t) + ": " + e(t[a], t)) : s.push(a + ": " + e(t[a], t))));
    if (typeof Q0 == "function")
        for (var c = 0; c < i.length; c++)
            i6.call(t, i[c]) && s.push("[" + e(i[c]) + "]: " + e(t[i[c]], t));
    return s
}
var u6 = dh
    , fh = Doe
    , pae = qoe
    , mae = bf
    , op = u6("%WeakMap%", !0)
    , ap = u6("%Map%", !0)
    , gae = fh("WeakMap.prototype.get", !0)
    , _ae = fh("WeakMap.prototype.set", !0)
    , yae = fh("WeakMap.prototype.has", !0)
    , bae = fh("Map.prototype.get", !0)
    , vae = fh("Map.prototype.set", !0)
    , xae = fh("Map.prototype.has", !0)
    , sw = function (t, e) {
        for (var n = t, s; (s = n.next) !== null; n = s)
            if (s.key === e)
                return n.next = s.next,
                    s.next = t.next,
                    t.next = s,
                    s
    }
    , wae = function (t, e) {
        var n = sw(t, e);
        return n && n.value
    }
    , Sae = function (t, e, n) {
        var s = sw(t, e);
        s ? s.value = n : t.next = {
            key: e,
            next: t.next,
            value: n
        }
    }
    , Eae = function (t, e) {
        return !!sw(t, e)
    }
    , Tae = function () {
        var e, n, s, r = {
            assert: function (i) {
                if (!r.has(i))
                    throw new mae("Side channel does not contain " + pae(i))
            },
            get: function (i) {
                if (op && i && (typeof i == "object" || typeof i == "function")) {
                    if (e)
                        return gae(e, i)
                } else if (ap) {
                    if (n)
                        return bae(n, i)
                } else if (s)
                    return wae(s, i)
            },
            has: function (i) {
                if (op && i && (typeof i == "object" || typeof i == "function")) {
                    if (e)
                        return yae(e, i)
                } else if (ap) {
                    if (n)
                        return xae(n, i)
                } else if (s)
                    return Eae(s, i);
                return !1
            },
            set: function (i, o) {
                op && i && (typeof i == "object" || typeof i == "function") ? (e || (e = new op),
                    _ae(e, i, o)) : ap ? (n || (n = new ap),
                        vae(n, i, o)) : (s || (s = {
                            key: {},
                            next: null
                        }),
                            Sae(s, i, o))
            }
        };
        return r
    }
    , Cae = String.prototype.replace
    , Iae = /%20/g
    , t1 = {
        RFC1738: "RFC1738",
        RFC3986: "RFC3986"
    }
    , rw = {
        default: t1.RFC3986,
        formatters: {
            RFC1738: function (t) {
                return Cae.call(t, Iae, "+")
            },
            RFC3986: function (t) {
                return String(t)
            }
        },
        RFC1738: t1.RFC1738,
        RFC3986: t1.RFC3986
    }
    , Aae = rw
    , n1 = Object.prototype.hasOwnProperty
    , Rl = Array.isArray
    , xi = function () {
        for (var t = [], e = 0; e < 256; ++e)
            t.push("%" + ((e < 16 ? "0" : "") + e.toString(16)).toUpperCase());
        return t
    }()
    , kae = function (e) {
        for (; e.length > 1;) {
            var n = e.pop()
                , s = n.obj[n.prop];
            if (Rl(s)) {
                for (var r = [], i = 0; i < s.length; ++i)
                    typeof s[i] < "u" && r.push(s[i]);
                n.obj[n.prop] = r
            }
        }
    }
    , h6 = function (e, n) {
        for (var s = n && n.plainObjects ? Object.create(null) : {}, r = 0; r < e.length; ++r)
            typeof e[r] < "u" && (s[r] = e[r]);
        return s
    }
    , Rae = function t(e, n, s) {
        if (!n)
            return e;
        if (typeof n != "object") {
            if (Rl(e))
                e.push(n);
            else if (e && typeof e == "object")
                (s && (s.plainObjects || s.allowPrototypes) || !n1.call(Object.prototype, n)) && (e[n] = !0);
            else
                return [e, n];
            return e
        }
        if (!e || typeof e != "object")
            return [e].concat(n);
        var r = e;
        return Rl(e) && !Rl(n) && (r = h6(e, s)),
            Rl(e) && Rl(n) ? (n.forEach(function (i, o) {
                if (n1.call(e, o)) {
                    var l = e[o];
                    l && typeof l == "object" && i && typeof i == "object" ? e[o] = t(l, i, s) : e.push(i)
                } else
                    e[o] = i
            }),
                e) : Object.keys(n).reduce(function (i, o) {
                    var l = n[o];
                    return n1.call(i, o) ? i[o] = t(i[o], l, s) : i[o] = l,
                        i
                }, r)
    }
    , Mae = function (e, n) {
        return Object.keys(n).reduce(function (s, r) {
            return s[r] = n[r],
                s
        }, e)
    }
    , Pae = function (t, e, n) {
        var s = t.replace(/\+/g, " ");
        if (n === "iso-8859-1")
            return s.replace(/%[0-9a-f]{2}/gi, unescape);
        try {
            return decodeURIComponent(s)
        } catch {
            return s
        }
    }
    , s1 = 1024
    , Lae = function (e, n, s, r, i) {
        if (e.length === 0)
            return e;
        var o = e;
        if (typeof e == "symbol" ? o = Symbol.prototype.toString.call(e) : typeof e != "string" && (o = String(e)),
            s === "iso-8859-1")
            return escape(o).replace(/%u[0-9a-f]{4}/gi, function (f) {
                return "%26%23" + parseInt(f.slice(2), 16) + "%3B"
            });
        for (var l = "", a = 0; a < o.length; a += s1) {
            for (var c = o.length >= s1 ? o.slice(a, a + s1) : o, u = [], h = 0; h < c.length; ++h) {
                var d = c.charCodeAt(h);
                if (d === 45 || d === 46 || d === 95 || d === 126 || d >= 48 && d <= 57 || d >= 65 && d <= 90 || d >= 97 && d <= 122 || i === Aae.RFC1738 && (d === 40 || d === 41)) {
                    u[u.length] = c.charAt(h);
                    continue
                }
                if (d < 128) {
                    u[u.length] = xi[d];
                    continue
                }
                if (d < 2048) {
                    u[u.length] = xi[192 | d >> 6] + xi[128 | d & 63];
                    continue
                }
                if (d < 55296 || d >= 57344) {
                    u[u.length] = xi[224 | d >> 12] + xi[128 | d >> 6 & 63] + xi[128 | d & 63];
                    continue
                }
                h += 1,
                    d = 65536 + ((d & 1023) << 10 | c.charCodeAt(h) & 1023),
                    u[u.length] = xi[240 | d >> 18] + xi[128 | d >> 12 & 63] + xi[128 | d >> 6 & 63] + xi[128 | d & 63]
            }
            l += u.join("")
        }
        return l
    }
    , Oae = function (e) {
        for (var n = [{
            obj: {
                o: e
            },
            prop: "o"
        }], s = [], r = 0; r < n.length; ++r)
            for (var i = n[r], o = i.obj[i.prop], l = Object.keys(o), a = 0; a < l.length; ++a) {
                var c = l[a]
                    , u = o[c];
                typeof u == "object" && u !== null && s.indexOf(u) === -1 && (n.push({
                    obj: o,
                    prop: c
                }),
                    s.push(u))
            }
        return kae(n),
            e
    }
    , Nae = function (e) {
        return Object.prototype.toString.call(e) === "[object RegExp]"
    }
    , Dae = function (e) {
        return !e || typeof e != "object" ? !1 : !!(e.constructor && e.constructor.isBuffer && e.constructor.isBuffer(e))
    }
    , Bae = function (e, n) {
        return [].concat(e, n)
    }
    , Fae = function (e, n) {
        if (Rl(e)) {
            for (var s = [], r = 0; r < e.length; r += 1)
                s.push(n(e[r]));
            return s
        }
        return n(e)
    }
    , d6 = {
        arrayToObject: h6,
        assign: Mae,
        combine: Bae,
        compact: Oae,
        decode: Pae,
        encode: Lae,
        isBuffer: Dae,
        isRegExp: Nae,
        maybeMap: Fae,
        merge: Rae
    }
    , f6 = Tae
    , zp = d6
    , hd = rw
    , $ae = Object.prototype.hasOwnProperty
    , p6 = {
        brackets: function (e) {
            return e + "[]"
        },
        comma: "comma",
        indices: function (e, n) {
            return e + "[" + n + "]"
        },
        repeat: function (e) {
            return e
        }
    }
    , Ri = Array.isArray
    , Uae = Array.prototype.push
    , m6 = function (t, e) {
        Uae.apply(t, Ri(e) ? e : [e])
    }
    , Vae = Date.prototype.toISOString
    , CI = hd.default
    , In = {
        addQueryPrefix: !1,
        allowDots: !1,
        allowEmptyArrays: !1,
        arrayFormat: "indices",
        charset: "utf-8",
        charsetSentinel: !1,
        delimiter: "&",
        encode: !0,
        encodeDotInKeys: !1,
        encoder: zp.encode,
        encodeValuesOnly: !1,
        format: CI,
        formatter: hd.formatters[CI],
        indices: !1,
        serializeDate: function (e) {
            return Vae.call(e)
        },
        skipNulls: !1,
        strictNullHandling: !1
    }
    , Gae = function (e) {
        return typeof e == "string" || typeof e == "number" || typeof e == "boolean" || typeof e == "symbol" || typeof e == "bigint"
    }
    , r1 = {}
    , Hae = function t(e, n, s, r, i, o, l, a, c, u, h, d, f, p, m, g, b, v) {
        for (var _ = e, y = v, x = 0, w = !1; (y = y.get(r1)) !== void 0 && !w;) {
            var S = y.get(e);
            if (x += 1,
                typeof S < "u") {
                if (S === x)
                    throw new RangeError("Cyclic object value");
                w = !0
            }
            typeof y.get(r1) > "u" && (x = 0)
        }
        if (typeof u == "function" ? _ = u(n, _) : _ instanceof Date ? _ = f(_) : s === "comma" && Ri(_) && (_ = zp.maybeMap(_, function (J) {
            return J instanceof Date ? f(J) : J
        })),
            _ === null) {
            if (o)
                return c && !g ? c(n, In.encoder, b, "key", p) : n;
            _ = ""
        }
        if (Gae(_) || zp.isBuffer(_)) {
            if (c) {
                var E = g ? n : c(n, In.encoder, b, "key", p);
                return [m(E) + "=" + m(c(_, In.encoder, b, "value", p))]
            }
            return [m(n) + "=" + m(String(_))]
        }
        var C = [];
        if (typeof _ > "u")
            return C;
        var I;
        if (s === "comma" && Ri(_))
            g && c && (_ = zp.maybeMap(_, c)),
                I = [{
                    value: _.length > 0 ? _.join(",") || null : void 0
                }];
        else if (Ri(u))
            I = u;
        else {
            var L = Object.keys(_);
            I = h ? L.sort(h) : L
        }
        var k = a ? n.replace(/\./g, "%2E") : n
            , R = r && Ri(_) && _.length === 1 ? k + "[]" : k;
        if (i && Ri(_) && _.length === 0)
            return R + "[]";
        for (var U = 0; U < I.length; ++U) {
            var W = I[U]
                , H = typeof W == "object" && typeof W.value < "u" ? W.value : _[W];
            if (!(l && H === null)) {
                var j = d && a ? W.replace(/\./g, "%2E") : W
                    , z = Ri(_) ? typeof s == "function" ? s(R, j) : R : R + (d ? "." + j : "[" + j + "]");
                v.set(e, x);
                var ee = f6();
                ee.set(r1, v),
                    m6(C, t(H, z, s, r, i, o, l, a, s === "comma" && g && Ri(_) ? null : c, u, h, d, f, p, m, g, b, ee))
            }
        }
        return C
    }
    , Wae = function (e) {
        if (!e)
            return In;
        if (typeof e.allowEmptyArrays < "u" && typeof e.allowEmptyArrays != "boolean")
            throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
        if (typeof e.encodeDotInKeys < "u" && typeof e.encodeDotInKeys != "boolean")
            throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
        if (e.encoder !== null && typeof e.encoder < "u" && typeof e.encoder != "function")
            throw new TypeError("Encoder has to be a function.");
        var n = e.charset || In.charset;
        if (typeof e.charset < "u" && e.charset !== "utf-8" && e.charset !== "iso-8859-1")
            throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
        var s = hd.default;
        if (typeof e.format < "u") {
            if (!$ae.call(hd.formatters, e.format))
                throw new TypeError("Unknown format option provided.");
            s = e.format
        }
        var r = hd.formatters[s]
            , i = In.filter;
        (typeof e.filter == "function" || Ri(e.filter)) && (i = e.filter);
        var o;
        if (e.arrayFormat in p6 ? o = e.arrayFormat : "indices" in e ? o = e.indices ? "indices" : "repeat" : o = In.arrayFormat,
            "commaRoundTrip" in e && typeof e.commaRoundTrip != "boolean")
            throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
        var l = typeof e.allowDots > "u" ? e.encodeDotInKeys === !0 ? !0 : In.allowDots : !!e.allowDots;
        return {
            addQueryPrefix: typeof e.addQueryPrefix == "boolean" ? e.addQueryPrefix : In.addQueryPrefix,
            allowDots: l,
            allowEmptyArrays: typeof e.allowEmptyArrays == "boolean" ? !!e.allowEmptyArrays : In.allowEmptyArrays,
            arrayFormat: o,
            charset: n,
            charsetSentinel: typeof e.charsetSentinel == "boolean" ? e.charsetSentinel : In.charsetSentinel,
            commaRoundTrip: e.commaRoundTrip,
            delimiter: typeof e.delimiter > "u" ? In.delimiter : e.delimiter,
            encode: typeof e.encode == "boolean" ? e.encode : In.encode,
            encodeDotInKeys: typeof e.encodeDotInKeys == "boolean" ? e.encodeDotInKeys : In.encodeDotInKeys,
            encoder: typeof e.encoder == "function" ? e.encoder : In.encoder,
            encodeValuesOnly: typeof e.encodeValuesOnly == "boolean" ? e.encodeValuesOnly : In.encodeValuesOnly,
            filter: i,
            format: s,
            formatter: r,
            serializeDate: typeof e.serializeDate == "function" ? e.serializeDate : In.serializeDate,
            skipNulls: typeof e.skipNulls == "boolean" ? e.skipNulls : In.skipNulls,
            sort: typeof e.sort == "function" ? e.sort : null,
            strictNullHandling: typeof e.strictNullHandling == "boolean" ? e.strictNullHandling : In.strictNullHandling
        }
    }
    , Yae = function (t, e) {
        var n = t, s = Wae(e), r, i;
        typeof s.filter == "function" ? (i = s.filter,
            n = i("", n)) : Ri(s.filter) && (i = s.filter,
                r = i);
        var o = [];
        if (typeof n != "object" || n === null)
            return "";
        var l = p6[s.arrayFormat]
            , a = l === "comma" && s.commaRoundTrip;
        r || (r = Object.keys(n)),
            s.sort && r.sort(s.sort);
        for (var c = f6(), u = 0; u < r.length; ++u) {
            var h = r[u];
            s.skipNulls && n[h] === null || m6(o, Hae(n[h], h, l, a, s.allowEmptyArrays, s.strictNullHandling, s.skipNulls, s.encodeDotInKeys, s.encode ? s.encoder : null, s.filter, s.sort, s.allowDots, s.serializeDate, s.format, s.formatter, s.encodeValuesOnly, s.charset, c))
        }
        var d = o.join(s.delimiter)
            , f = s.addQueryPrefix === !0 ? "?" : "";
        return s.charsetSentinel && (s.charset === "iso-8859-1" ? f += "utf8=%26%2310003%3B&" : f += "utf8=%E2%9C%93&"),
            d.length > 0 ? f + d : ""
    }
    , qu = d6
    , ub = Object.prototype.hasOwnProperty
    , Xae = Array.isArray
    , gn = {
        allowDots: !1,
        allowEmptyArrays: !1,
        allowPrototypes: !1,
        allowSparse: !1,
        arrayLimit: 20,
        charset: "utf-8",
        charsetSentinel: !1,
        comma: !1,
        decodeDotInKeys: !1,
        decoder: qu.decode,
        delimiter: "&",
        depth: 5,
        duplicates: "combine",
        ignoreQueryPrefix: !1,
        interpretNumericEntities: !1,
        parameterLimit: 1e3,
        parseArrays: !0,
        plainObjects: !1,
        strictNullHandling: !1
    }
    , jae = function (t) {
        return t.replace(/&#(\d+);/g, function (e, n) {
            return String.fromCharCode(parseInt(n, 10))
        })
    }
    , g6 = function (t, e) {
        return t && typeof t == "string" && e.comma && t.indexOf(",") > -1 ? t.split(",") : t
    }
    , zae = "utf8=%26%2310003%3B"
    , qae = "utf8=%E2%9C%93"
    , Kae = function (e, n) {
        var s = {
            __proto__: null
        }
            , r = n.ignoreQueryPrefix ? e.replace(/^\?/, "") : e;
        r = r.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
        var i = n.parameterLimit === 1 / 0 ? void 0 : n.parameterLimit, o = r.split(n.delimiter, i), l = -1, a, c = n.charset;
        if (n.charsetSentinel)
            for (a = 0; a < o.length; ++a)
                o[a].indexOf("utf8=") === 0 && (o[a] === qae ? c = "utf-8" : o[a] === zae && (c = "iso-8859-1"),
                    l = a,
                    a = o.length);
        for (a = 0; a < o.length; ++a)
            if (a !== l) {
                var u = o[a], h = u.indexOf("]="), d = h === -1 ? u.indexOf("=") : h + 1, f, p;
                d === -1 ? (f = n.decoder(u, gn.decoder, c, "key"),
                    p = n.strictNullHandling ? null : "") : (f = n.decoder(u.slice(0, d), gn.decoder, c, "key"),
                        p = qu.maybeMap(g6(u.slice(d + 1), n), function (g) {
                            return n.decoder(g, gn.decoder, c, "value")
                        })),
                    p && n.interpretNumericEntities && c === "iso-8859-1" && (p = jae(p)),
                    u.indexOf("[]=") > -1 && (p = Xae(p) ? [p] : p);
                var m = ub.call(s, f);
                m && n.duplicates === "combine" ? s[f] = qu.combine(s[f], p) : (!m || n.duplicates === "last") && (s[f] = p)
            }
        return s
    }
    , Jae = function (t, e, n, s) {
        for (var r = s ? e : g6(e, n), i = t.length - 1; i >= 0; --i) {
            var o, l = t[i];
            if (l === "[]" && n.parseArrays)
                o = n.allowEmptyArrays && (r === "" || n.strictNullHandling && r === null) ? [] : [].concat(r);
            else {
                o = n.plainObjects ? Object.create(null) : {};
                var a = l.charAt(0) === "[" && l.charAt(l.length - 1) === "]" ? l.slice(1, -1) : l
                    , c = n.decodeDotInKeys ? a.replace(/%2E/g, ".") : a
                    , u = parseInt(c, 10);
                !n.parseArrays && c === "" ? o = {
                    0: r
                } : !isNaN(u) && l !== c && String(u) === c && u >= 0 && n.parseArrays && u <= n.arrayLimit ? (o = [],
                    o[u] = r) : c !== "__proto__" && (o[c] = r)
            }
            r = o
        }
        return r
    }
    , Zae = function (e, n, s, r) {
        if (e) {
            var i = s.allowDots ? e.replace(/\.([^.[]+)/g, "[$1]") : e
                , o = /(\[[^[\]]*])/
                , l = /(\[[^[\]]*])/g
                , a = s.depth > 0 && o.exec(i)
                , c = a ? i.slice(0, a.index) : i
                , u = [];
            if (c) {
                if (!s.plainObjects && ub.call(Object.prototype, c) && !s.allowPrototypes)
                    return;
                u.push(c)
            }
            for (var h = 0; s.depth > 0 && (a = l.exec(i)) !== null && h < s.depth;) {
                if (h += 1,
                    !s.plainObjects && ub.call(Object.prototype, a[1].slice(1, -1)) && !s.allowPrototypes)
                    return;
                u.push(a[1])
            }
            return a && u.push("[" + i.slice(a.index) + "]"),
                Jae(u, n, s, r)
        }
    }
    , Qae = function (e) {
        if (!e)
            return gn;
        if (typeof e.allowEmptyArrays < "u" && typeof e.allowEmptyArrays != "boolean")
            throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
        if (typeof e.decodeDotInKeys < "u" && typeof e.decodeDotInKeys != "boolean")
            throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
        if (e.decoder !== null && typeof e.decoder < "u" && typeof e.decoder != "function")
            throw new TypeError("Decoder has to be a function.");
        if (typeof e.charset < "u" && e.charset !== "utf-8" && e.charset !== "iso-8859-1")
            throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
        var n = typeof e.charset > "u" ? gn.charset : e.charset
            , s = typeof e.duplicates > "u" ? gn.duplicates : e.duplicates;
        if (s !== "combine" && s !== "first" && s !== "last")
            throw new TypeError("The duplicates option must be either combine, first, or last");
        var r = typeof e.allowDots > "u" ? e.decodeDotInKeys === !0 ? !0 : gn.allowDots : !!e.allowDots;
        return {
            allowDots: r,
            allowEmptyArrays: typeof e.allowEmptyArrays == "boolean" ? !!e.allowEmptyArrays : gn.allowEmptyArrays,
            allowPrototypes: typeof e.allowPrototypes == "boolean" ? e.allowPrototypes : gn.allowPrototypes,
            allowSparse: typeof e.allowSparse == "boolean" ? e.allowSparse : gn.allowSparse,
            arrayLimit: typeof e.arrayLimit == "number" ? e.arrayLimit : gn.arrayLimit,
            charset: n,
            charsetSentinel: typeof e.charsetSentinel == "boolean" ? e.charsetSentinel : gn.charsetSentinel,
            comma: typeof e.comma == "boolean" ? e.comma : gn.comma,
            decodeDotInKeys: typeof e.decodeDotInKeys == "boolean" ? e.decodeDotInKeys : gn.decodeDotInKeys,
            decoder: typeof e.decoder == "function" ? e.decoder : gn.decoder,
            delimiter: typeof e.delimiter == "string" || qu.isRegExp(e.delimiter) ? e.delimiter : gn.delimiter,
            depth: typeof e.depth == "number" || e.depth === !1 ? +e.depth : gn.depth,
            duplicates: s,
            ignoreQueryPrefix: e.ignoreQueryPrefix === !0,
            interpretNumericEntities: typeof e.interpretNumericEntities == "boolean" ? e.interpretNumericEntities : gn.interpretNumericEntities,
            parameterLimit: typeof e.parameterLimit == "number" ? e.parameterLimit : gn.parameterLimit,
            parseArrays: e.parseArrays !== !1,
            plainObjects: typeof e.plainObjects == "boolean" ? e.plainObjects : gn.plainObjects,
            strictNullHandling: typeof e.strictNullHandling == "boolean" ? e.strictNullHandling : gn.strictNullHandling
        }
    }
    , ele = function (t, e) {
        var n = Qae(e);
        if (t === "" || t === null || typeof t > "u")
            return n.plainObjects ? Object.create(null) : {};
        for (var s = typeof t == "string" ? Kae(t, n) : t, r = n.plainObjects ? Object.create(null) : {}, i = Object.keys(s), o = 0; o < i.length; ++o) {
            var l = i[o]
                , a = Zae(l, s[l], n, typeof t == "string");
            r = qu.merge(r, a, n)
        }
        return n.allowSparse === !0 ? r : qu.compact(r)
    }
    , tle = Yae
    , nle = ele
    , sle = rw
    , rle = {
        formats: sle,
        parse: nle,
        stringify: tle
    }
    , ile = Uie;
function Ao() {
    this.protocol = null,
        this.slashes = null,
        this.auth = null,
        this.host = null,
        this.port = null,
        this.hostname = null,
        this.hash = null,
        this.search = null,
        this.query = null,
        this.pathname = null,
        this.path = null,
        this.href = null
}
var ole = /^([a-z0-9.+-]+:)/i
    , ale = /:[0-9]*$/
    , lle = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/
    , cle = ["<", ">", '"', "`", " ", "\r", `
`, "	"]
    , ule = ["{", "}", "|", "\\", "^", "`"].concat(cle)
    , hb = ["'"].concat(ule)
    , II = ["%", "/", "?", ";", "#"].concat(hb)
    , AI = ["/", "?", "#"]
    , hle = 255
    , kI = /^[+a-z0-9A-Z_-]{0,63}$/
    , dle = /^([+a-z0-9A-Z_-]{0,63})(.*)$/
    , fle = {
        javascript: !0,
        "javascript:": !0
    }
    , db = {
        javascript: !0,
        "javascript:": !0
    }
    , xu = {
        http: !0,
        https: !0,
        ftp: !0,
        gopher: !0,
        file: !0,
        "http:": !0,
        "https:": !0,
        "ftp:": !0,
        "gopher:": !0,
        "file:": !0
    }
    , fb = rle;
function ple(t, e, n) {
    if (t && typeof t == "object" && t instanceof Ao)
        return t;
    var s = new Ao;
    return s.parse(t, e, n),
        s
}
Ao.prototype.parse = function (t, e, n) {
    if (typeof t != "string")
        throw new TypeError("Parameter 'url' must be a string, not " + typeof t);
    var s = t.indexOf("?")
        , r = s !== -1 && s < t.indexOf("#") ? "?" : "#"
        , i = t.split(r)
        , o = /\\/g;
    i[0] = i[0].replace(o, "/"),
        t = i.join(r);
    var l = t;
    if (l = l.trim(),
        !n && t.split("#").length === 1) {
        var a = lle.exec(l);
        if (a)
            return this.path = l,
                this.href = l,
                this.pathname = a[1],
                a[2] ? (this.search = a[2],
                    e ? this.query = fb.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : e && (this.search = "",
                        this.query = {}),
                this
    }
    var c = ole.exec(l);
    if (c) {
        c = c[0];
        var u = c.toLowerCase();
        this.protocol = u,
            l = l.substr(c.length)
    }
    if (n || c || l.match(/^\/\/[^@/]+@[^@/]+/)) {
        var h = l.substr(0, 2) === "//";
        h && !(c && db[c]) && (l = l.substr(2),
            this.slashes = !0)
    }
    if (!db[c] && (h || c && !xu[c])) {
        for (var d = -1, f = 0; f < AI.length; f++) {
            var p = l.indexOf(AI[f]);
            p !== -1 && (d === -1 || p < d) && (d = p)
        }
        var m, g;
        d === -1 ? g = l.lastIndexOf("@") : g = l.lastIndexOf("@", d),
            g !== -1 && (m = l.slice(0, g),
                l = l.slice(g + 1),
                this.auth = decodeURIComponent(m)),
            d = -1;
        for (var f = 0; f < II.length; f++) {
            var p = l.indexOf(II[f]);
            p !== -1 && (d === -1 || p < d) && (d = p)
        }
        d === -1 && (d = l.length),
            this.host = l.slice(0, d),
            l = l.slice(d),
            this.parseHost(),
            this.hostname = this.hostname || "";
        var b = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!b)
            for (var v = this.hostname.split(/\./), f = 0, _ = v.length; f < _; f++) {
                var y = v[f];
                if (y && !y.match(kI)) {
                    for (var x = "", w = 0, S = y.length; w < S; w++)
                        y.charCodeAt(w) > 127 ? x += "x" : x += y[w];
                    if (!x.match(kI)) {
                        var E = v.slice(0, f)
                            , C = v.slice(f + 1)
                            , I = y.match(dle);
                        I && (E.push(I[1]),
                            C.unshift(I[2])),
                            C.length && (l = "/" + C.join(".") + l),
                            this.hostname = E.join(".");
                        break
                    }
                }
            }
        this.hostname.length > hle ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(),
            b || (this.hostname = ile.toASCII(this.hostname));
        var L = this.port ? ":" + this.port : ""
            , k = this.hostname || "";
        this.host = k + L,
            this.href += this.host,
            b && (this.hostname = this.hostname.substr(1, this.hostname.length - 2),
                l[0] !== "/" && (l = "/" + l))
    }
    if (!fle[u])
        for (var f = 0, _ = hb.length; f < _; f++) {
            var R = hb[f];
            if (l.indexOf(R) !== -1) {
                var U = encodeURIComponent(R);
                U === R && (U = escape(R)),
                    l = l.split(R).join(U)
            }
        }
    var W = l.indexOf("#");
    W !== -1 && (this.hash = l.substr(W),
        l = l.slice(0, W));
    var H = l.indexOf("?");
    if (H !== -1 ? (this.search = l.substr(H),
        this.query = l.substr(H + 1),
        e && (this.query = fb.parse(this.query)),
        l = l.slice(0, H)) : e && (this.search = "",
            this.query = {}),
        l && (this.pathname = l),
        xu[u] && this.hostname && !this.pathname && (this.pathname = "/"),
        this.pathname || this.search) {
        var L = this.pathname || ""
            , j = this.search || "";
        this.path = L + j
    }
    return this.href = this.format(),
        this
}
    ;
Ao.prototype.format = function () {
    var t = this.auth || "";
    t && (t = encodeURIComponent(t),
        t = t.replace(/%3A/i, ":"),
        t += "@");
    var e = this.protocol || ""
        , n = this.pathname || ""
        , s = this.hash || ""
        , r = !1
        , i = "";
    this.host ? r = t + this.host : this.hostname && (r = t + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"),
        this.port && (r += ":" + this.port)),
        this.query && typeof this.query == "object" && Object.keys(this.query).length && (i = fb.stringify(this.query, {
            arrayFormat: "repeat",
            addQueryPrefix: !1
        }));
    var o = this.search || i && "?" + i || "";
    return e && e.substr(-1) !== ":" && (e += ":"),
        this.slashes || (!e || xu[e]) && r !== !1 ? (r = "//" + (r || ""),
            n && n.charAt(0) !== "/" && (n = "/" + n)) : r || (r = ""),
        s && s.charAt(0) !== "#" && (s = "#" + s),
        o && o.charAt(0) !== "?" && (o = "?" + o),
        n = n.replace(/[?#]/g, function (l) {
            return encodeURIComponent(l)
        }),
        o = o.replace("#", "%23"),
        e + r + n + o + s
}
    ;
Ao.prototype.resolve = function (t) {
    return this.resolveObject(ple(t, !1, !0)).format()
}
    ;
Ao.prototype.resolveObject = function (t) {
    if (typeof t == "string") {
        var e = new Ao;
        e.parse(t, !1, !0),
            t = e
    }
    for (var n = new Ao, s = Object.keys(this), r = 0; r < s.length; r++) {
        var i = s[r];
        n[i] = this[i]
    }
    if (n.hash = t.hash,
        t.href === "")
        return n.href = n.format(),
            n;
    if (t.slashes && !t.protocol) {
        for (var o = Object.keys(t), l = 0; l < o.length; l++) {
            var a = o[l];
            a !== "protocol" && (n[a] = t[a])
        }
        return xu[n.protocol] && n.hostname && !n.pathname && (n.pathname = "/",
            n.path = n.pathname),
            n.href = n.format(),
            n
    }
    if (t.protocol && t.protocol !== n.protocol) {
        if (!xu[t.protocol]) {
            for (var c = Object.keys(t), u = 0; u < c.length; u++) {
                var h = c[u];
                n[h] = t[h]
            }
            return n.href = n.format(),
                n
        }
        if (n.protocol = t.protocol,
            !t.host && !db[t.protocol]) {
            for (var _ = (t.pathname || "").split("/"); _.length && !(t.host = _.shift());)
                ;
            t.host || (t.host = ""),
                t.hostname || (t.hostname = ""),
                _[0] !== "" && _.unshift(""),
                _.length < 2 && _.unshift(""),
                n.pathname = _.join("/")
        } else
            n.pathname = t.pathname;
        if (n.search = t.search,
            n.query = t.query,
            n.host = t.host || "",
            n.auth = t.auth,
            n.hostname = t.hostname || t.host,
            n.port = t.port,
            n.pathname || n.search) {
            var d = n.pathname || ""
                , f = n.search || "";
            n.path = d + f
        }
        return n.slashes = n.slashes || t.slashes,
            n.href = n.format(),
            n
    }
    var p = n.pathname && n.pathname.charAt(0) === "/"
        , m = t.host || t.pathname && t.pathname.charAt(0) === "/"
        , g = m || p || n.host && t.pathname
        , b = g
        , v = n.pathname && n.pathname.split("/") || []
        , _ = t.pathname && t.pathname.split("/") || []
        , y = n.protocol && !xu[n.protocol];
    if (y && (n.hostname = "",
        n.port = null,
        n.host && (v[0] === "" ? v[0] = n.host : v.unshift(n.host)),
        n.host = "",
        t.protocol && (t.hostname = null,
            t.port = null,
            t.host && (_[0] === "" ? _[0] = t.host : _.unshift(t.host)),
            t.host = null),
        g = g && (_[0] === "" || v[0] === "")),
        m)
        n.host = t.host || t.host === "" ? t.host : n.host,
            n.hostname = t.hostname || t.hostname === "" ? t.hostname : n.hostname,
            n.search = t.search,
            n.query = t.query,
            v = _;
    else if (_.length)
        v || (v = []),
            v.pop(),
            v = v.concat(_),
            n.search = t.search,
            n.query = t.query;
    else if (t.search != null) {
        if (y) {
            n.host = v.shift(),
                n.hostname = n.host;
            var x = n.host && n.host.indexOf("@") > 0 ? n.host.split("@") : !1;
            x && (n.auth = x.shift(),
                n.hostname = x.shift(),
                n.host = n.hostname)
        }
        return n.search = t.search,
            n.query = t.query,
            (n.pathname !== null || n.search !== null) && (n.path = (n.pathname ? n.pathname : "") + (n.search ? n.search : "")),
            n.href = n.format(),
            n
    }
    if (!v.length)
        return n.pathname = null,
            n.search ? n.path = "/" + n.search : n.path = null,
            n.href = n.format(),
            n;
    for (var w = v.slice(-1)[0], S = (n.host || t.host || v.length > 1) && (w === "." || w === "..") || w === "", E = 0, C = v.length; C >= 0; C--)
        w = v[C],
            w === "." ? v.splice(C, 1) : w === ".." ? (v.splice(C, 1),
                E++) : E && (v.splice(C, 1),
                    E--);
    if (!g && !b)
        for (; E--; E)
            v.unshift("..");
    g && v[0] !== "" && (!v[0] || v[0].charAt(0) !== "/") && v.unshift(""),
        S && v.join("/").substr(-1) !== "/" && v.push("");
    var I = v[0] === "" || v[0] && v[0].charAt(0) === "/";
    if (y) {
        n.hostname = I ? "" : v.length ? v.shift() : "",
            n.host = n.hostname;
        var x = n.host && n.host.indexOf("@") > 0 ? n.host.split("@") : !1;
        x && (n.auth = x.shift(),
            n.hostname = x.shift(),
            n.host = n.hostname)
    }
    return g = g || n.host && v.length,
        g && !I && v.unshift(""),
        v.length > 0 ? n.pathname = v.join("/") : (n.pathname = null,
            n.path = null),
        (n.pathname !== null || n.search !== null) && (n.path = (n.pathname ? n.pathname : "") + (n.search ? n.search : "")),
        n.auth = t.auth || n.auth,
        n.slashes = n.slashes || t.slashes,
        n.href = n.format(),
        n
}
    ;
Ao.prototype.parseHost = function () {
    var t = this.host
        , e = ale.exec(t);
    e && (e = e[0],
        e !== ":" && (this.port = e.substr(1)),
        t = t.substr(0, t.length - e.length)),
        t && (this.hostname = t)
}
    ;
const RI = {};
function dt(t, e, n = 3) {
    if (RI[e])
        return;
    let s = new Error().stack;
    typeof s > "u" ? console.warn("PixiJS Deprecation Warning: ", `${e}
Deprecated since v${t}`) : (s = s.split(`
`).splice(n).join(`
`),
        console.groupCollapsed ? (console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", `${e}
Deprecated since v${t}`),
            console.warn(s),
            console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", `${e}
Deprecated since v${t}`),
                console.warn(s))),
        RI[e] = !0
}
function Fr(t) {
    if (typeof t != "string")
        throw new TypeError(`Path must be a string. Received ${JSON.stringify(t)}`)
}
function kh(t) {
    return t.split("?")[0].split("#")[0]
}
function mle(t) {
    return t.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")
}
function gle(t, e, n) {
    return t.replace(new RegExp(mle(e), "g"), n)
}
function _le(t, e) {
    let n = ""
        , s = 0
        , r = -1
        , i = 0
        , o = -1;
    for (let l = 0; l <= t.length; ++l) {
        if (l < t.length)
            o = t.charCodeAt(l);
        else {
            if (o === 47)
                break;
            o = 47
        }
        if (o === 47) {
            if (!(r === l - 1 || i === 1))
                if (r !== l - 1 && i === 2) {
                    if (n.length < 2 || s !== 2 || n.charCodeAt(n.length - 1) !== 46 || n.charCodeAt(n.length - 2) !== 46) {
                        if (n.length > 2) {
                            const a = n.lastIndexOf("/");
                            if (a !== n.length - 1) {
                                a === -1 ? (n = "",
                                    s = 0) : (n = n.slice(0, a),
                                        s = n.length - 1 - n.lastIndexOf("/")),
                                    r = l,
                                    i = 0;
                                continue
                            }
                        } else if (n.length === 2 || n.length === 1) {
                            n = "",
                                s = 0,
                                r = l,
                                i = 0;
                            continue
                        }
                    }
                } else
                    n.length > 0 ? n += `/${t.slice(r + 1, l)}` : n = t.slice(r + 1, l),
                        s = l - r - 1;
            r = l,
                i = 0
        } else
            o === 46 && i !== -1 ? ++i : i = -1
    }
    return n
}
const zt = {
    toPosix(t) {
        return gle(t, "\\", "/")
    },
    isUrl(t) {
        return /^https?:/.test(this.toPosix(t))
    },
    isDataUrl(t) {
        return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(t)
    },
    isBlobUrl(t) {
        return t.startsWith("blob:")
    },
    hasProtocol(t) {
        return /^[^/:]+:/.test(this.toPosix(t))
    },
    getProtocol(t) {
        Fr(t),
            t = this.toPosix(t);
        const e = /^file:\/\/\//.exec(t);
        if (e)
            return e[0];
        const n = /^[^/:]+:\/{0,2}/.exec(t);
        return n ? n[0] : ""
    },
    toAbsolute(t, e, n) {
        if (Fr(t),
            this.isDataUrl(t) || this.isBlobUrl(t))
            return t;
        const s = kh(this.toPosix(e ?? Le.ADAPTER.getBaseUrl()))
            , r = kh(this.toPosix(n ?? this.rootname(s)));
        return t = this.toPosix(t),
            t.startsWith("/") ? zt.join(r, t.slice(1)) : this.isAbsolute(t) ? t : this.join(s, t)
    },
    normalize(t) {
        if (Fr(t),
            t.length === 0)
            return ".";
        if (this.isDataUrl(t) || this.isBlobUrl(t))
            return t;
        t = this.toPosix(t);
        let e = "";
        const n = t.startsWith("/");
        this.hasProtocol(t) && (e = this.rootname(t),
            t = t.slice(e.length));
        const s = t.endsWith("/");
        return t = _le(t),
            t.length > 0 && s && (t += "/"),
            n ? `/${t}` : e + t
    },
    isAbsolute(t) {
        return Fr(t),
            t = this.toPosix(t),
            this.hasProtocol(t) ? !0 : t.startsWith("/")
    },
    join(...t) {
        if (t.length === 0)
            return ".";
        let e;
        for (let n = 0; n < t.length; ++n) {
            const s = t[n];
            if (Fr(s),
                s.length > 0)
                if (e === void 0)
                    e = s;
                else {
                    const r = t[n - 1] ?? "";
                    this.joinExtensions.includes(this.extname(r).toLowerCase()) ? e += `/../${s}` : e += `/${s}`
                }
        }
        return e === void 0 ? "." : this.normalize(e)
    },
    dirname(t) {
        if (Fr(t),
            t.length === 0)
            return ".";
        t = this.toPosix(t);
        let e = t.charCodeAt(0);
        const n = e === 47;
        let s = -1
            , r = !0;
        const i = this.getProtocol(t)
            , o = t;
        t = t.slice(i.length);
        for (let l = t.length - 1; l >= 1; --l)
            if (e = t.charCodeAt(l),
                e === 47) {
                if (!r) {
                    s = l;
                    break
                }
            } else
                r = !1;
        return s === -1 ? n ? "/" : this.isUrl(o) ? i + t : i : n && s === 1 ? "//" : i + t.slice(0, s)
    },
    rootname(t) {
        Fr(t),
            t = this.toPosix(t);
        let e = "";
        if (t.startsWith("/") ? e = "/" : e = this.getProtocol(t),
            this.isUrl(t)) {
            const n = t.indexOf("/", e.length);
            n !== -1 ? e = t.slice(0, n) : e = t,
                e.endsWith("/") || (e += "/")
        }
        return e
    },
    basename(t, e) {
        Fr(t),
            e && Fr(e),
            t = kh(this.toPosix(t));
        let n = 0, s = -1, r = !0, i;
        if (e !== void 0 && e.length > 0 && e.length <= t.length) {
            if (e.length === t.length && e === t)
                return "";
            let o = e.length - 1
                , l = -1;
            for (i = t.length - 1; i >= 0; --i) {
                const a = t.charCodeAt(i);
                if (a === 47) {
                    if (!r) {
                        n = i + 1;
                        break
                    }
                } else
                    l === -1 && (r = !1,
                        l = i + 1),
                        o >= 0 && (a === e.charCodeAt(o) ? --o === -1 && (s = i) : (o = -1,
                            s = l))
            }
            return n === s ? s = l : s === -1 && (s = t.length),
                t.slice(n, s)
        }
        for (i = t.length - 1; i >= 0; --i)
            if (t.charCodeAt(i) === 47) {
                if (!r) {
                    n = i + 1;
                    break
                }
            } else
                s === -1 && (r = !1,
                    s = i + 1);
        return s === -1 ? "" : t.slice(n, s)
    },
    extname(t) {
        Fr(t),
            t = kh(this.toPosix(t));
        let e = -1
            , n = 0
            , s = -1
            , r = !0
            , i = 0;
        for (let o = t.length - 1; o >= 0; --o) {
            const l = t.charCodeAt(o);
            if (l === 47) {
                if (!r) {
                    n = o + 1;
                    break
                }
                continue
            }
            s === -1 && (r = !1,
                s = o + 1),
                l === 46 ? e === -1 ? e = o : i !== 1 && (i = 1) : e !== -1 && (i = -1)
        }
        return e === -1 || s === -1 || i === 0 || i === 1 && e === s - 1 && e === n + 1 ? "" : t.slice(e, s)
    },
    parse(t) {
        Fr(t);
        const e = {
            root: "",
            dir: "",
            base: "",
            ext: "",
            name: ""
        };
        if (t.length === 0)
            return e;
        t = kh(this.toPosix(t));
        let n = t.charCodeAt(0);
        const s = this.isAbsolute(t);
        let r;
        e.root = this.rootname(t),
            s || this.hasProtocol(t) ? r = 1 : r = 0;
        let i = -1
            , o = 0
            , l = -1
            , a = !0
            , c = t.length - 1
            , u = 0;
        for (; c >= r; --c) {
            if (n = t.charCodeAt(c),
                n === 47) {
                if (!a) {
                    o = c + 1;
                    break
                }
                continue
            }
            l === -1 && (a = !1,
                l = c + 1),
                n === 46 ? i === -1 ? i = c : u !== 1 && (u = 1) : i !== -1 && (u = -1)
        }
        return i === -1 || l === -1 || u === 0 || u === 1 && i === l - 1 && i === o + 1 ? l !== -1 && (o === 0 && s ? e.base = e.name = t.slice(1, l) : e.base = e.name = t.slice(o, l)) : (o === 0 && s ? (e.name = t.slice(1, i),
            e.base = t.slice(1, l)) : (e.name = t.slice(o, i),
                e.base = t.slice(o, l)),
            e.ext = t.slice(i, l)),
            e.dir = this.dirname(t),
            e
    },
    sep: "/",
    delimiter: ":",
    joinExtensions: [".html"]
};
let i1;
async function yle() {
    return i1 ?? (i1 = (async () => {
        var i;
        const t = document.createElement("canvas").getContext("webgl");
        if (!t)
            return Is.UNPACK;
        const e = await new Promise(o => {
            const l = document.createElement("video");
            l.onloadeddata = () => o(l),
                l.onerror = () => o(null),
                l.autoplay = !1,
                l.crossOrigin = "anonymous",
                l.preload = "auto",
                l.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=",
                l.load()
        }
        );
        if (!e)
            return Is.UNPACK;
        const n = t.createTexture();
        t.bindTexture(t.TEXTURE_2D, n);
        const s = t.createFramebuffer();
        t.bindFramebuffer(t.FRAMEBUFFER, s),
            t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, n, 0),
            t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1),
            t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, t.NONE),
            t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, e);
        const r = new Uint8Array(4);
        return t.readPixels(0, 0, 1, 1, t.RGBA, t.UNSIGNED_BYTE, r),
            t.deleteFramebuffer(s),
            t.deleteTexture(n),
            (i = t.getExtension("WEBGL_lose_context")) == null || i.loseContext(),
            r[0] <= r[3] ? Is.PMA : Is.UNPACK
    }
    )()),
        i1
}
let o1;
function ble() {
    return typeof o1 > "u" && (o1 = function () {
        var e;
        const t = {
            stencil: !0,
            failIfMajorPerformanceCaveat: Le.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
        };
        try {
            if (!Le.ADAPTER.getWebGLRenderingContext())
                return !1;
            const n = Le.ADAPTER.createCanvas();
            let s = n.getContext("webgl", t) || n.getContext("experimental-webgl", t);
            const r = !!((e = s == null ? void 0 : s.getContextAttributes()) != null && e.stencil);
            if (s) {
                const i = s.getExtension("WEBGL_lose_context");
                i && i.loseContext()
            }
            return s = null,
                r
        } catch {
            return !1
        }
    }()),
        o1
}
var vle = {
    grad: .9,
    turn: 360,
    rad: 360 / (2 * Math.PI)
}
    , so = function (t) {
        return typeof t == "string" ? t.length > 0 : typeof t == "number"
    }
    , Yn = function (t, e, n) {
        return e === void 0 && (e = 0),
            n === void 0 && (n = Math.pow(10, e)),
            Math.round(n * t) / n + 0
    }
    , Tr = function (t, e, n) {
        return e === void 0 && (e = 0),
            n === void 0 && (n = 1),
            t > n ? n : t > e ? t : e
    }
    , _6 = function (t) {
        return (t = isFinite(t) ? t % 360 : 0) > 0 ? t : t + 360
    }
    , MI = function (t) {
        return {
            r: Tr(t.r, 0, 255),
            g: Tr(t.g, 0, 255),
            b: Tr(t.b, 0, 255),
            a: Tr(t.a)
        }
    }
    , a1 = function (t) {
        return {
            r: Yn(t.r),
            g: Yn(t.g),
            b: Yn(t.b),
            a: Yn(t.a, 3)
        }
    }
    , xle = /^#([0-9a-f]{3,8})$/i
    , lp = function (t) {
        var e = t.toString(16);
        return e.length < 2 ? "0" + e : e
    }
    , y6 = function (t) {
        var e = t.r
            , n = t.g
            , s = t.b
            , r = t.a
            , i = Math.max(e, n, s)
            , o = i - Math.min(e, n, s)
            , l = o ? i === e ? (n - s) / o : i === n ? 2 + (s - e) / o : 4 + (e - n) / o : 0;
        return {
            h: 60 * (l < 0 ? l + 6 : l),
            s: i ? o / i * 100 : 0,
            v: i / 255 * 100,
            a: r
        }
    }
    , b6 = function (t) {
        var e = t.h
            , n = t.s
            , s = t.v
            , r = t.a;
        e = e / 360 * 6,
            n /= 100,
            s /= 100;
        var i = Math.floor(e)
            , o = s * (1 - n)
            , l = s * (1 - (e - i) * n)
            , a = s * (1 - (1 - e + i) * n)
            , c = i % 6;
        return {
            r: 255 * [s, l, o, o, a, s][c],
            g: 255 * [a, s, s, l, o, o][c],
            b: 255 * [o, o, a, s, s, l][c],
            a: r
        }
    }
    , PI = function (t) {
        return {
            h: _6(t.h),
            s: Tr(t.s, 0, 100),
            l: Tr(t.l, 0, 100),
            a: Tr(t.a)
        }
    }
    , LI = function (t) {
        return {
            h: Yn(t.h),
            s: Yn(t.s),
            l: Yn(t.l),
            a: Yn(t.a, 3)
        }
    }
    , OI = function (t) {
        return b6((n = (e = t).s,
        {
            h: e.h,
            s: (n *= ((s = e.l) < 50 ? s : 100 - s) / 100) > 0 ? 2 * n / (s + n) * 100 : 0,
            v: s + n,
            a: e.a
        }));
        var e, n, s
    }
    , dd = function (t) {
        return {
            h: (e = y6(t)).h,
            s: (r = (200 - (n = e.s)) * (s = e.v) / 100) > 0 && r < 200 ? n * s / 100 / (r <= 100 ? r : 200 - r) * 100 : 0,
            l: r / 2,
            a: e.a
        };
        var e, n, s, r
    }
    , wle = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i
    , Sle = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i
    , Ele = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i
    , Tle = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i
    , pb = {
        string: [[function (t) {
            var e = xle.exec(t);
            return e ? (t = e[1]).length <= 4 ? {
                r: parseInt(t[0] + t[0], 16),
                g: parseInt(t[1] + t[1], 16),
                b: parseInt(t[2] + t[2], 16),
                a: t.length === 4 ? Yn(parseInt(t[3] + t[3], 16) / 255, 2) : 1
            } : t.length === 6 || t.length === 8 ? {
                r: parseInt(t.substr(0, 2), 16),
                g: parseInt(t.substr(2, 2), 16),
                b: parseInt(t.substr(4, 2), 16),
                a: t.length === 8 ? Yn(parseInt(t.substr(6, 2), 16) / 255, 2) : 1
            } : null : null
        }
            , "hex"], [function (t) {
                var e = Ele.exec(t) || Tle.exec(t);
                return e ? e[2] !== e[4] || e[4] !== e[6] ? null : MI({
                    r: Number(e[1]) / (e[2] ? 100 / 255 : 1),
                    g: Number(e[3]) / (e[4] ? 100 / 255 : 1),
                    b: Number(e[5]) / (e[6] ? 100 / 255 : 1),
                    a: e[7] === void 0 ? 1 : Number(e[7]) / (e[8] ? 100 : 1)
                }) : null
            }
            , "rgb"], [function (t) {
                var e = wle.exec(t) || Sle.exec(t);
                if (!e)
                    return null;
                var n, s, r = PI({
                    h: (n = e[1],
                        s = e[2],
                        s === void 0 && (s = "deg"),
                        Number(n) * (vle[s] || 1)),
                    s: Number(e[3]),
                    l: Number(e[4]),
                    a: e[5] === void 0 ? 1 : Number(e[5]) / (e[6] ? 100 : 1)
                });
                return OI(r)
            }
            , "hsl"]],
        object: [[function (t) {
            var e = t.r
                , n = t.g
                , s = t.b
                , r = t.a
                , i = r === void 0 ? 1 : r;
            return so(e) && so(n) && so(s) ? MI({
                r: Number(e),
                g: Number(n),
                b: Number(s),
                a: Number(i)
            }) : null
        }
            , "rgb"], [function (t) {
                var e = t.h
                    , n = t.s
                    , s = t.l
                    , r = t.a
                    , i = r === void 0 ? 1 : r;
                if (!so(e) || !so(n) || !so(s))
                    return null;
                var o = PI({
                    h: Number(e),
                    s: Number(n),
                    l: Number(s),
                    a: Number(i)
                });
                return OI(o)
            }
            , "hsl"], [function (t) {
                var e = t.h
                    , n = t.s
                    , s = t.v
                    , r = t.a
                    , i = r === void 0 ? 1 : r;
                if (!so(e) || !so(n) || !so(s))
                    return null;
                var o = function (l) {
                    return {
                        h: _6(l.h),
                        s: Tr(l.s, 0, 100),
                        v: Tr(l.v, 0, 100),
                        a: Tr(l.a)
                    }
                }({
                    h: Number(e),
                    s: Number(n),
                    v: Number(s),
                    a: Number(i)
                });
                return b6(o)
            }
            , "hsv"]]
    }
    , NI = function (t, e) {
        for (var n = 0; n < e.length; n++) {
            var s = e[n][0](t);
            if (s)
                return [s, e[n][1]]
        }
        return [null, void 0]
    }
    , Cle = function (t) {
        return typeof t == "string" ? NI(t.trim(), pb.string) : typeof t == "object" && t !== null ? NI(t, pb.object) : [null, void 0]
    }
    , l1 = function (t, e) {
        var n = dd(t);
        return {
            h: n.h,
            s: Tr(n.s + 100 * e, 0, 100),
            l: n.l,
            a: n.a
        }
    }
    , c1 = function (t) {
        return (299 * t.r + 587 * t.g + 114 * t.b) / 1e3 / 255
    }
    , DI = function (t, e) {
        var n = dd(t);
        return {
            h: n.h,
            s: n.s,
            l: Tr(n.l + 100 * e, 0, 100),
            a: n.a
        }
    }
    , mb = function () {
        function t(e) {
            this.parsed = Cle(e)[0],
                this.rgba = this.parsed || {
                    r: 0,
                    g: 0,
                    b: 0,
                    a: 1
                }
        }
        return t.prototype.isValid = function () {
            return this.parsed !== null
        }
            ,
            t.prototype.brightness = function () {
                return Yn(c1(this.rgba), 2)
            }
            ,
            t.prototype.isDark = function () {
                return c1(this.rgba) < .5
            }
            ,
            t.prototype.isLight = function () {
                return c1(this.rgba) >= .5
            }
            ,
            t.prototype.toHex = function () {
                return e = a1(this.rgba),
                    n = e.r,
                    s = e.g,
                    r = e.b,
                    o = (i = e.a) < 1 ? lp(Yn(255 * i)) : "",
                    "#" + lp(n) + lp(s) + lp(r) + o;
                var e, n, s, r, i, o
            }
            ,
            t.prototype.toRgb = function () {
                return a1(this.rgba)
            }
            ,
            t.prototype.toRgbString = function () {
                return e = a1(this.rgba),
                    n = e.r,
                    s = e.g,
                    r = e.b,
                    (i = e.a) < 1 ? "rgba(" + n + ", " + s + ", " + r + ", " + i + ")" : "rgb(" + n + ", " + s + ", " + r + ")";
                var e, n, s, r, i
            }
            ,
            t.prototype.toHsl = function () {
                return LI(dd(this.rgba))
            }
            ,
            t.prototype.toHslString = function () {
                return e = LI(dd(this.rgba)),
                    n = e.h,
                    s = e.s,
                    r = e.l,
                    (i = e.a) < 1 ? "hsla(" + n + ", " + s + "%, " + r + "%, " + i + ")" : "hsl(" + n + ", " + s + "%, " + r + "%)";
                var e, n, s, r, i
            }
            ,
            t.prototype.toHsv = function () {
                return e = y6(this.rgba),
                {
                    h: Yn(e.h),
                    s: Yn(e.s),
                    v: Yn(e.v),
                    a: Yn(e.a, 3)
                };
                var e
            }
            ,
            t.prototype.invert = function () {
                return Ei({
                    r: 255 - (e = this.rgba).r,
                    g: 255 - e.g,
                    b: 255 - e.b,
                    a: e.a
                });
                var e
            }
            ,
            t.prototype.saturate = function (e) {
                return e === void 0 && (e = .1),
                    Ei(l1(this.rgba, e))
            }
            ,
            t.prototype.desaturate = function (e) {
                return e === void 0 && (e = .1),
                    Ei(l1(this.rgba, -e))
            }
            ,
            t.prototype.grayscale = function () {
                return Ei(l1(this.rgba, -1))
            }
            ,
            t.prototype.lighten = function (e) {
                return e === void 0 && (e = .1),
                    Ei(DI(this.rgba, e))
            }
            ,
            t.prototype.darken = function (e) {
                return e === void 0 && (e = .1),
                    Ei(DI(this.rgba, -e))
            }
            ,
            t.prototype.rotate = function (e) {
                return e === void 0 && (e = 15),
                    this.hue(this.hue() + e)
            }
            ,
            t.prototype.alpha = function (e) {
                return typeof e == "number" ? Ei({
                    r: (n = this.rgba).r,
                    g: n.g,
                    b: n.b,
                    a: e
                }) : Yn(this.rgba.a, 3);
                var n
            }
            ,
            t.prototype.hue = function (e) {
                var n = dd(this.rgba);
                return typeof e == "number" ? Ei({
                    h: e,
                    s: n.s,
                    l: n.l,
                    a: n.a
                }) : Yn(n.h)
            }
            ,
            t.prototype.isEqual = function (e) {
                return this.toHex() === Ei(e).toHex()
            }
            ,
            t
    }()
    , Ei = function (t) {
        return t instanceof mb ? t : new mb(t)
    }
    , BI = []
    , Ile = function (t) {
        t.forEach(function (e) {
            BI.indexOf(e) < 0 && (e(mb, pb),
                BI.push(e))
        })
    };
function Ale(t, e) {
    var n = {
        white: "#ffffff",
        bisque: "#ffe4c4",
        blue: "#0000ff",
        cadetblue: "#5f9ea0",
        chartreuse: "#7fff00",
        chocolate: "#d2691e",
        coral: "#ff7f50",
        antiquewhite: "#faebd7",
        aqua: "#00ffff",
        azure: "#f0ffff",
        whitesmoke: "#f5f5f5",
        papayawhip: "#ffefd5",
        plum: "#dda0dd",
        blanchedalmond: "#ffebcd",
        black: "#000000",
        gold: "#ffd700",
        goldenrod: "#daa520",
        gainsboro: "#dcdcdc",
        cornsilk: "#fff8dc",
        cornflowerblue: "#6495ed",
        burlywood: "#deb887",
        aquamarine: "#7fffd4",
        beige: "#f5f5dc",
        crimson: "#dc143c",
        cyan: "#00ffff",
        darkblue: "#00008b",
        darkcyan: "#008b8b",
        darkgoldenrod: "#b8860b",
        darkkhaki: "#bdb76b",
        darkgray: "#a9a9a9",
        darkgreen: "#006400",
        darkgrey: "#a9a9a9",
        peachpuff: "#ffdab9",
        darkmagenta: "#8b008b",
        darkred: "#8b0000",
        darkorchid: "#9932cc",
        darkorange: "#ff8c00",
        darkslateblue: "#483d8b",
        gray: "#808080",
        darkslategray: "#2f4f4f",
        darkslategrey: "#2f4f4f",
        deeppink: "#ff1493",
        deepskyblue: "#00bfff",
        wheat: "#f5deb3",
        firebrick: "#b22222",
        floralwhite: "#fffaf0",
        ghostwhite: "#f8f8ff",
        darkviolet: "#9400d3",
        magenta: "#ff00ff",
        green: "#008000",
        dodgerblue: "#1e90ff",
        grey: "#808080",
        honeydew: "#f0fff0",
        hotpink: "#ff69b4",
        blueviolet: "#8a2be2",
        forestgreen: "#228b22",
        lawngreen: "#7cfc00",
        indianred: "#cd5c5c",
        indigo: "#4b0082",
        fuchsia: "#ff00ff",
        brown: "#a52a2a",
        maroon: "#800000",
        mediumblue: "#0000cd",
        lightcoral: "#f08080",
        darkturquoise: "#00ced1",
        lightcyan: "#e0ffff",
        ivory: "#fffff0",
        lightyellow: "#ffffe0",
        lightsalmon: "#ffa07a",
        lightseagreen: "#20b2aa",
        linen: "#faf0e6",
        mediumaquamarine: "#66cdaa",
        lemonchiffon: "#fffacd",
        lime: "#00ff00",
        khaki: "#f0e68c",
        mediumseagreen: "#3cb371",
        limegreen: "#32cd32",
        mediumspringgreen: "#00fa9a",
        lightskyblue: "#87cefa",
        lightblue: "#add8e6",
        midnightblue: "#191970",
        lightpink: "#ffb6c1",
        mistyrose: "#ffe4e1",
        moccasin: "#ffe4b5",
        mintcream: "#f5fffa",
        lightslategray: "#778899",
        lightslategrey: "#778899",
        navajowhite: "#ffdead",
        navy: "#000080",
        mediumvioletred: "#c71585",
        powderblue: "#b0e0e6",
        palegoldenrod: "#eee8aa",
        oldlace: "#fdf5e6",
        paleturquoise: "#afeeee",
        mediumturquoise: "#48d1cc",
        mediumorchid: "#ba55d3",
        rebeccapurple: "#663399",
        lightsteelblue: "#b0c4de",
        mediumslateblue: "#7b68ee",
        thistle: "#d8bfd8",
        tan: "#d2b48c",
        orchid: "#da70d6",
        mediumpurple: "#9370db",
        purple: "#800080",
        pink: "#ffc0cb",
        skyblue: "#87ceeb",
        springgreen: "#00ff7f",
        palegreen: "#98fb98",
        red: "#ff0000",
        yellow: "#ffff00",
        slateblue: "#6a5acd",
        lavenderblush: "#fff0f5",
        peru: "#cd853f",
        palevioletred: "#db7093",
        violet: "#ee82ee",
        teal: "#008080",
        slategray: "#708090",
        slategrey: "#708090",
        aliceblue: "#f0f8ff",
        darkseagreen: "#8fbc8f",
        darkolivegreen: "#556b2f",
        greenyellow: "#adff2f",
        seagreen: "#2e8b57",
        seashell: "#fff5ee",
        tomato: "#ff6347",
        silver: "#c0c0c0",
        sienna: "#a0522d",
        lavender: "#e6e6fa",
        lightgreen: "#90ee90",
        orange: "#ffa500",
        orangered: "#ff4500",
        steelblue: "#4682b4",
        royalblue: "#4169e1",
        turquoise: "#40e0d0",
        yellowgreen: "#9acd32",
        salmon: "#fa8072",
        saddlebrown: "#8b4513",
        sandybrown: "#f4a460",
        rosybrown: "#bc8f8f",
        darksalmon: "#e9967a",
        lightgoldenrodyellow: "#fafad2",
        snow: "#fffafa",
        lightgrey: "#d3d3d3",
        lightgray: "#d3d3d3",
        dimgray: "#696969",
        dimgrey: "#696969",
        olivedrab: "#6b8e23",
        olive: "#808000"
    }
        , s = {};
    for (var r in n)
        s[n[r]] = r;
    var i = {};
    t.prototype.toName = function (o) {
        if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b))
            return "transparent";
        var l, a, c = s[this.toHex()];
        if (c)
            return c;
        if (o != null && o.closest) {
            var u = this.toRgb()
                , h = 1 / 0
                , d = "black";
            if (!i.length)
                for (var f in n)
                    i[f] = new t(n[f]).toRgb();
            for (var p in n) {
                var m = (l = u,
                    a = i[p],
                    Math.pow(l.r - a.r, 2) + Math.pow(l.g - a.g, 2) + Math.pow(l.b - a.b, 2));
                m < h && (h = m,
                    d = p)
            }
            return d
        }
    }
        ,
        e.string.push([function (o) {
            var l = o.toLowerCase()
                , a = l === "transparent" ? "#0000" : n[l];
            return a ? new t(a).toRgb() : null
        }
            , "name"])
}
Ile([Ale]);
const Vc = class qp {
    constructor(e = 16777215) {
        this._value = null,
            this._components = new Float32Array(4),
            this._components.fill(1),
            this._int = 16777215,
            this.value = e
    }
    get red() {
        return this._components[0]
    }
    get green() {
        return this._components[1]
    }
    get blue() {
        return this._components[2]
    }
    get alpha() {
        return this._components[3]
    }
    setValue(e) {
        return this.value = e,
            this
    }
    set value(e) {
        if (e instanceof qp)
            this._value = this.cloneSource(e._value),
                this._int = e._int,
                this._components.set(e._components);
        else {
            if (e === null)
                throw new Error("Cannot set PIXI.Color#value to null");
            (this._value === null || !this.isSourceEqual(this._value, e)) && (this.normalize(e),
                this._value = this.cloneSource(e))
        }
    }
    get value() {
        return this._value
    }
    cloneSource(e) {
        return typeof e == "string" || typeof e == "number" || e instanceof Number || e === null ? e : Array.isArray(e) || ArrayBuffer.isView(e) ? e.slice(0) : typeof e == "object" && e !== null ? {
            ...e
        } : e
    }
    isSourceEqual(e, n) {
        const s = typeof e;
        if (s !== typeof n)
            return !1;
        if (s === "number" || s === "string" || e instanceof Number)
            return e === n;
        if (Array.isArray(e) && Array.isArray(n) || ArrayBuffer.isView(e) && ArrayBuffer.isView(n))
            return e.length !== n.length ? !1 : e.every((r, i) => r === n[i]);
        if (e !== null && n !== null) {
            const r = Object.keys(e)
                , i = Object.keys(n);
            return r.length !== i.length ? !1 : r.every(o => e[o] === n[o])
        }
        return e === n
    }
    toRgba() {
        const [e, n, s, r] = this._components;
        return {
            r: e,
            g: n,
            b: s,
            a: r
        }
    }
    toRgb() {
        const [e, n, s] = this._components;
        return {
            r: e,
            g: n,
            b: s
        }
    }
    toRgbaString() {
        const [e, n, s] = this.toUint8RgbArray();
        return `rgba(${e},${n},${s},${this.alpha})`
    }
    toUint8RgbArray(e) {
        const [n, s, r] = this._components;
        return e = e ?? [],
            e[0] = Math.round(n * 255),
            e[1] = Math.round(s * 255),
            e[2] = Math.round(r * 255),
            e
    }
    toRgbArray(e) {
        e = e ?? [];
        const [n, s, r] = this._components;
        return e[0] = n,
            e[1] = s,
            e[2] = r,
            e
    }
    toNumber() {
        return this._int
    }
    toLittleEndianNumber() {
        const e = this._int;
        return (e >> 16) + (e & 65280) + ((e & 255) << 16)
    }
    multiply(e) {
        const [n, s, r, i] = qp.temp.setValue(e)._components;
        return this._components[0] *= n,
            this._components[1] *= s,
            this._components[2] *= r,
            this._components[3] *= i,
            this.refreshInt(),
            this._value = null,
            this
    }
    premultiply(e, n = !0) {
        return n && (this._components[0] *= e,
            this._components[1] *= e,
            this._components[2] *= e),
            this._components[3] = e,
            this.refreshInt(),
            this._value = null,
            this
    }
    toPremultiplied(e, n = !0) {
        if (e === 1)
            return (255 << 24) + this._int;
        if (e === 0)
            return n ? 0 : this._int;
        let s = this._int >> 16 & 255
            , r = this._int >> 8 & 255
            , i = this._int & 255;
        return n && (s = s * e + .5 | 0,
            r = r * e + .5 | 0,
            i = i * e + .5 | 0),
            (e * 255 << 24) + (s << 16) + (r << 8) + i
    }
    toHex() {
        const e = this._int.toString(16);
        return `#${"000000".substring(0, 6 - e.length) + e}`
    }
    toHexa() {
        const e = Math.round(this._components[3] * 255).toString(16);
        return this.toHex() + "00".substring(0, 2 - e.length) + e
    }
    setAlpha(e) {
        return this._components[3] = this._clamp(e),
            this
    }
    round(e) {
        const [n, s, r] = this._components;
        return this._components[0] = Math.round(n * e) / e,
            this._components[1] = Math.round(s * e) / e,
            this._components[2] = Math.round(r * e) / e,
            this.refreshInt(),
            this._value = null,
            this
    }
    toArray(e) {
        e = e ?? [];
        const [n, s, r, i] = this._components;
        return e[0] = n,
            e[1] = s,
            e[2] = r,
            e[3] = i,
            e
    }
    normalize(e) {
        let n, s, r, i;
        if ((typeof e == "number" || e instanceof Number) && e >= 0 && e <= 16777215) {
            const o = e;
            n = (o >> 16 & 255) / 255,
                s = (o >> 8 & 255) / 255,
                r = (o & 255) / 255,
                i = 1
        } else if ((Array.isArray(e) || e instanceof Float32Array) && e.length >= 3 && e.length <= 4)
            e = this._clamp(e),
                [n, s, r, i = 1] = e;
        else if ((e instanceof Uint8Array || e instanceof Uint8ClampedArray) && e.length >= 3 && e.length <= 4)
            e = this._clamp(e, 0, 255),
                [n, s, r, i = 255] = e,
                n /= 255,
                s /= 255,
                r /= 255,
                i /= 255;
        else if (typeof e == "string" || typeof e == "object") {
            if (typeof e == "string") {
                const l = qp.HEX_PATTERN.exec(e);
                l && (e = `#${l[2]}`)
            }
            const o = Ei(e);
            o.isValid() && ({ r: n, g: s, b: r, a: i } = o.rgba,
                n /= 255,
                s /= 255,
                r /= 255)
        }
        if (n !== void 0)
            this._components[0] = n,
                this._components[1] = s,
                this._components[2] = r,
                this._components[3] = i,
                this.refreshInt();
        else
            throw new Error(`Unable to convert color ${e}`)
    }
    refreshInt() {
        this._clamp(this._components);
        const [e, n, s] = this._components;
        this._int = (e * 255 << 16) + (n * 255 << 8) + (s * 255 | 0)
    }
    _clamp(e, n = 0, s = 1) {
        return typeof e == "number" ? Math.min(Math.max(e, n), s) : (e.forEach((r, i) => {
            e[i] = Math.min(Math.max(r, n), s)
        }
        ),
            e)
    }
}
    ;
Vc.shared = new Vc,
    Vc.temp = new Vc,
    Vc.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
let Yt = Vc;
function kle(t, e = []) {
    return dt("7.2.0", "utils.hex2rgb is deprecated, use Color#toRgbArray instead"),
        Yt.shared.setValue(t).toRgbArray(e)
}
function Rle(t) {
    return dt("7.2.0", "utils.hex2string is deprecated, use Color#toHex instead"),
        Yt.shared.setValue(t).toHex()
}
function Kp(t) {
    return dt("7.2.0", "utils.rgb2hex is deprecated, use Color#toNumber instead"),
        Yt.shared.setValue(t).toNumber()
}
function Mle() {
    const t = []
        , e = [];
    for (let s = 0; s < 32; s++)
        t[s] = s,
            e[s] = s;
    t[Oe.NORMAL_NPM] = Oe.NORMAL,
        t[Oe.ADD_NPM] = Oe.ADD,
        t[Oe.SCREEN_NPM] = Oe.SCREEN,
        e[Oe.NORMAL] = Oe.NORMAL_NPM,
        e[Oe.ADD] = Oe.ADD_NPM,
        e[Oe.SCREEN] = Oe.SCREEN_NPM;
    const n = [];
    return n.push(e),
        n.push(t),
        n
}
const v6 = Mle();
function x6(t, e) {
    return v6[e ? 1 : 0][t]
}
function Ple(t, e = null) {
    const n = t * 6;
    if (e = e || new Uint16Array(n),
        e.length !== n)
        throw new Error(`Out buffer length is incorrect, got ${e.length} and expected ${n}`);
    for (let s = 0, r = 0; s < n; s += 6,
        r += 4)
        e[s + 0] = r + 0,
            e[s + 1] = r + 1,
            e[s + 2] = r + 2,
            e[s + 3] = r + 0,
            e[s + 4] = r + 2,
            e[s + 5] = r + 3;
    return e
}
function w6(t) {
    if (t.BYTES_PER_ELEMENT === 4)
        return t instanceof Float32Array ? "Float32Array" : t instanceof Uint32Array ? "Uint32Array" : "Int32Array";
    if (t.BYTES_PER_ELEMENT === 2) {
        if (t instanceof Uint16Array)
            return "Uint16Array"
    } else if (t.BYTES_PER_ELEMENT === 1 && t instanceof Uint8Array)
        return "Uint8Array";
    return null
}
function zm(t) {
    return t += t === 0 ? 1 : 0,
        --t,
        t |= t >>> 1,
        t |= t >>> 2,
        t |= t >>> 4,
        t |= t >>> 8,
        t |= t >>> 16,
        t + 1
}
function FI(t) {
    return !(t & t - 1) && !!t
}
function $I(t) {
    let e = (t > 65535 ? 1 : 0) << 4;
    t >>>= e;
    let n = (t > 255 ? 1 : 0) << 3;
    return t >>>= n,
        e |= n,
        n = (t > 15 ? 1 : 0) << 2,
        t >>>= n,
        e |= n,
        n = (t > 3 ? 1 : 0) << 1,
        t >>>= n,
        e |= n,
        e | t >> 1
}
function wu(t, e, n) {
    const s = t.length;
    let r;
    if (e >= s || n === 0)
        return;
    n = e + n > s ? s - e : n;
    const i = s - n;
    for (r = e; r < i; ++r)
        t[r] = t[r + n];
    t.length = i
}
function Ra(t) {
    return t === 0 ? 0 : t < 0 ? -1 : 1
}
let Lle = 0;
function lc() {
    return ++Lle
}
const gb = class {
    constructor(t, e, n, s) {
        this.left = t,
            this.top = e,
            this.right = n,
            this.bottom = s
    }
    get width() {
        return this.right - this.left
    }
    get height() {
        return this.bottom - this.top
    }
    isEmpty() {
        return this.left === this.right || this.top === this.bottom
    }
}
    ;
gb.EMPTY = new gb(0, 0, 0, 0);
let UI = gb;
const VI = {}
    , Ti = Object.create(null)
    , ta = Object.create(null);
class Ole {
    constructor(e, n, s) {
        this._canvas = Le.ADAPTER.createCanvas(),
            this._context = this._canvas.getContext("2d"),
            this.resolution = s || Le.RESOLUTION,
            this.resize(e, n)
    }
    clear() {
        this._checkDestroyed(),
            this._context.setTransform(1, 0, 0, 1, 0, 0),
            this._context.clearRect(0, 0, this._canvas.width, this._canvas.height)
    }
    resize(e, n) {
        this._checkDestroyed(),
            this._canvas.width = Math.round(e * this.resolution),
            this._canvas.height = Math.round(n * this.resolution)
    }
    destroy() {
        this._context = null,
            this._canvas = null
    }
    get width() {
        return this._checkDestroyed(),
            this._canvas.width
    }
    set width(e) {
        this._checkDestroyed(),
            this._canvas.width = Math.round(e)
    }
    get height() {
        return this._checkDestroyed(),
            this._canvas.height
    }
    set height(e) {
        this._checkDestroyed(),
            this._canvas.height = Math.round(e)
    }
    get canvas() {
        return this._checkDestroyed(),
            this._canvas
    }
    get context() {
        return this._checkDestroyed(),
            this._context
    }
    _checkDestroyed() {
        if (this._canvas === null)
            throw new TypeError("The CanvasRenderTarget has already been destroyed")
    }
}
function GI(t, e, n) {
    for (let s = 0, r = 4 * n * e; s < e; ++s,
        r += 4)
        if (t[r + 3] !== 0)
            return !1;
    return !0
}
function HI(t, e, n, s, r) {
    const i = 4 * e;
    for (let o = s, l = s * i + 4 * n; o <= r; ++o,
        l += i)
        if (t[l + 3] !== 0)
            return !1;
    return !0
}
function Nle(t) {
    const { width: e, height: n } = t
        , s = t.getContext("2d", {
            willReadFrequently: !0
        });
    if (s === null)
        throw new TypeError("Failed to get canvas 2D context");
    const r = s.getImageData(0, 0, e, n).data;
    let i = 0
        , o = 0
        , l = e - 1
        , a = n - 1;
    for (; o < n && GI(r, e, o);)
        ++o;
    if (o === n)
        return UI.EMPTY;
    for (; GI(r, e, a);)
        --a;
    for (; HI(r, e, i, o, a);)
        ++i;
    for (; HI(r, e, l, o, a);)
        --l;
    return ++l,
        ++a,
        new UI(i, o, l, a)
}
function Dle(t) {
    const e = Nle(t)
        , { width: n, height: s } = e;
    let r = null;
    if (!e.isEmpty()) {
        const i = t.getContext("2d");
        if (i === null)
            throw new TypeError("Failed to get canvas 2D context");
        r = i.getImageData(e.left, e.top, n, s)
    }
    return {
        width: n,
        height: s,
        data: r
    }
}
function Ble(t, e = globalThis.location) {
    if (t.startsWith("data:"))
        return "";
    e = e || globalThis.location;
    const n = new URL(t, document.baseURI);
    return n.hostname !== e.hostname || n.port !== e.port || n.protocol !== e.protocol ? "anonymous" : ""
}
function Vo(t, e = 1) {
    var s;
    const n = (s = Le.RETINA_PREFIX) == null ? void 0 : s.exec(t);
    return n ? parseFloat(n[1]) : e
}
var Ae = (t => (t.Renderer = "renderer",
    t.Application = "application",
    t.RendererSystem = "renderer-webgl-system",
    t.RendererPlugin = "renderer-webgl-plugin",
    t.CanvasRendererSystem = "renderer-canvas-system",
    t.CanvasRendererPlugin = "renderer-canvas-plugin",
    t.Asset = "asset",
    t.LoadParser = "load-parser",
    t.ResolveParser = "resolve-parser",
    t.CacheParser = "cache-parser",
    t.DetectionParser = "detection-parser",
    t))(Ae || {});
const _b = t => {
    if (typeof t == "function" || typeof t == "object" && t.extension) {
        if (!t.extension)
            throw new Error("Extension class must have an extension object");
        t = {
            ...typeof t.extension != "object" ? {
                type: t.extension
            } : t.extension,
            ref: t
        }
    }
    if (typeof t == "object")
        t = {
            ...t
        };
    else
        throw new Error("Invalid extension type");
    return typeof t.type == "string" && (t.type = [t.type]),
        t
}
    , WI = (t, e) => _b(t).priority ?? e
    , Ue = {
        _addHandlers: {},
        _removeHandlers: {},
        _queue: {},
        remove(...t) {
            return t.map(_b).forEach(e => {
                e.type.forEach(n => {
                    var s, r;
                    return (r = (s = this._removeHandlers)[n]) == null ? void 0 : r.call(s, e)
                }
                )
            }
            ),
                this
        },
        add(...t) {
            return t.map(_b).forEach(e => {
                e.type.forEach(n => {
                    var i, o;
                    const s = this._addHandlers
                        , r = this._queue;
                    s[n] ? (i = s[n]) == null || i.call(s, e) : (r[n] = r[n] || [],
                        (o = r[n]) == null || o.push(e))
                }
                )
            }
            ),
                this
        },
        handle(t, e, n) {
            var o;
            const s = this._addHandlers
                , r = this._removeHandlers;
            if (s[t] || r[t])
                throw new Error(`Extension type ${t} already has a handler`);
            s[t] = e,
                r[t] = n;
            const i = this._queue;
            return i[t] && ((o = i[t]) == null || o.forEach(l => e(l)),
                delete i[t]),
                this
        },
        handleByMap(t, e) {
            return this.handle(t, n => {
                n.name && (e[n.name] = n.ref)
            }
                , n => {
                    n.name && delete e[n.name]
                }
            )
        },
        handleByList(t, e, n = -1) {
            return this.handle(t, s => {
                e.includes(s.ref) || (e.push(s.ref),
                    e.sort((r, i) => WI(i, n) - WI(r, n)))
            }
                , s => {
                    const r = e.indexOf(s.ref);
                    r !== -1 && e.splice(r, 1)
                }
            )
        }
    };
class yb {
    constructor(e) {
        typeof e == "number" ? this.rawBinaryData = new ArrayBuffer(e) : e instanceof Uint8Array ? this.rawBinaryData = e.buffer : this.rawBinaryData = e,
            this.uint32View = new Uint32Array(this.rawBinaryData),
            this.float32View = new Float32Array(this.rawBinaryData)
    }
    get int8View() {
        return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)),
            this._int8View
    }
    get uint8View() {
        return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)),
            this._uint8View
    }
    get int16View() {
        return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)),
            this._int16View
    }
    get uint16View() {
        return this._uint16View || (this._uint16View = new Uint16Array(this.rawBinaryData)),
            this._uint16View
    }
    get int32View() {
        return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)),
            this._int32View
    }
    view(e) {
        return this[`${e}View`]
    }
    destroy() {
        this.rawBinaryData = null,
            this._int8View = null,
            this._uint8View = null,
            this._int16View = null,
            this._uint16View = null,
            this._int32View = null,
            this.uint32View = null,
            this.float32View = null
    }
    static sizeOf(e) {
        switch (e) {
            case "int8":
            case "uint8":
                return 1;
            case "int16":
            case "uint16":
                return 2;
            case "int32":
            case "uint32":
            case "float32":
                return 4;
            default:
                throw new Error(`${e} isn't a valid view type`)
        }
    }
}
const Fle = ["precision mediump float;", "void main(void){", "float test = 0.1;", "%forloop%", "gl_FragColor = vec4(0.0);", "}"].join(`
`);
function $le(t) {
    let e = "";
    for (let n = 0; n < t; ++n)
        n > 0 && (e += `
else `),
            n < t - 1 && (e += `if(test == ${n}.0){}`);
    return e
}
function Ule(t, e) {
    if (t === 0)
        throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
    const n = e.createShader(e.FRAGMENT_SHADER);
    for (; ;) {
        const s = Fle.replace(/%forloop%/gi, $le(t));
        if (e.shaderSource(n, s),
            e.compileShader(n),
            !e.getShaderParameter(n, e.COMPILE_STATUS))
            t = t / 2 | 0;
        else
            break
    }
    return t
}
const u1 = 0
    , h1 = 1
    , d1 = 2
    , f1 = 3
    , p1 = 4
    , m1 = 5;
class Ji {
    constructor() {
        this.data = 0,
            this.blendMode = Oe.NORMAL,
            this.polygonOffset = 0,
            this.blend = !0,
            this.depthMask = !0
    }
    get blend() {
        return !!(this.data & 1 << u1)
    }
    set blend(e) {
        !!(this.data & 1 << u1) !== e && (this.data ^= 1 << u1)
    }
    get offsets() {
        return !!(this.data & 1 << h1)
    }
    set offsets(e) {
        !!(this.data & 1 << h1) !== e && (this.data ^= 1 << h1)
    }
    get culling() {
        return !!(this.data & 1 << d1)
    }
    set culling(e) {
        !!(this.data & 1 << d1) !== e && (this.data ^= 1 << d1)
    }
    get depthTest() {
        return !!(this.data & 1 << f1)
    }
    set depthTest(e) {
        !!(this.data & 1 << f1) !== e && (this.data ^= 1 << f1)
    }
    get depthMask() {
        return !!(this.data & 1 << m1)
    }
    set depthMask(e) {
        !!(this.data & 1 << m1) !== e && (this.data ^= 1 << m1)
    }
    get clockwiseFrontFace() {
        return !!(this.data & 1 << p1)
    }
    set clockwiseFrontFace(e) {
        !!(this.data & 1 << p1) !== e && (this.data ^= 1 << p1)
    }
    get blendMode() {
        return this._blendMode
    }
    set blendMode(e) {
        this.blend = e !== Oe.NONE,
            this._blendMode = e
    }
    get polygonOffset() {
        return this._polygonOffset
    }
    set polygonOffset(e) {
        this.offsets = !!e,
            this._polygonOffset = e
    }
    static for2d() {
        const e = new Ji;
        return e.depthTest = !1,
            e.blend = !0,
            e
    }
}
Ji.prototype.toString = function () {
    return `[@pixi/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`
}
    ;
const bb = [];
function S6(t, e) {
    if (!t)
        return null;
    let n = "";
    if (typeof t == "string") {
        const s = /\.(\w{3,4})(?:$|\?|#)/i.exec(t);
        s && (n = s[1].toLowerCase())
    }
    for (let s = bb.length - 1; s >= 0; --s) {
        const r = bb[s];
        if (r.test && r.test(t, n))
            return new r(t, e)
    }
    throw new Error("Unrecognized source type to auto-detect Resource")
}
class ri {
    constructor(e) {
        this.items = [],
            this._name = e,
            this._aliasCount = 0
    }
    emit(e, n, s, r, i, o, l, a) {
        if (arguments.length > 8)
            throw new Error("max arguments reached");
        const { name: c, items: u } = this;
        this._aliasCount++;
        for (let h = 0, d = u.length; h < d; h++)
            u[h][c](e, n, s, r, i, o, l, a);
        return u === this.items && this._aliasCount--,
            this
    }
    ensureNonAliasedItems() {
        this._aliasCount > 0 && this.items.length > 1 && (this._aliasCount = 0,
            this.items = this.items.slice(0))
    }
    add(e) {
        return e[this._name] && (this.ensureNonAliasedItems(),
            this.remove(e),
            this.items.push(e)),
            this
    }
    remove(e) {
        const n = this.items.indexOf(e);
        return n !== -1 && (this.ensureNonAliasedItems(),
            this.items.splice(n, 1)),
            this
    }
    contains(e) {
        return this.items.includes(e)
    }
    removeAll() {
        return this.ensureNonAliasedItems(),
            this.items.length = 0,
            this
    }
    destroy() {
        this.removeAll(),
            this.items.length = 0,
            this._name = ""
    }
    get empty() {
        return this.items.length === 0
    }
    get name() {
        return this._name
    }
}
Object.defineProperties(ri.prototype, {
    dispatch: {
        value: ri.prototype.emit
    },
    run: {
        value: ri.prototype.emit
    }
});
class Bd {
    constructor(e = 0, n = 0) {
        this._width = e,
            this._height = n,
            this.destroyed = !1,
            this.internal = !1,
            this.onResize = new ri("setRealSize"),
            this.onUpdate = new ri("update"),
            this.onError = new ri("onError")
    }
    bind(e) {
        this.onResize.add(e),
            this.onUpdate.add(e),
            this.onError.add(e),
            (this._width || this._height) && this.onResize.emit(this._width, this._height)
    }
    unbind(e) {
        this.onResize.remove(e),
            this.onUpdate.remove(e),
            this.onError.remove(e)
    }
    resize(e, n) {
        (e !== this._width || n !== this._height) && (this._width = e,
            this._height = n,
            this.onResize.emit(e, n))
    }
    get valid() {
        return !!this._width && !!this._height
    }
    update() {
        this.destroyed || this.onUpdate.emit()
    }
    load() {
        return Promise.resolve(this)
    }
    get width() {
        return this._width
    }
    get height() {
        return this._height
    }
    style(e, n, s) {
        return !1
    }
    dispose() { }
    destroy() {
        this.destroyed || (this.destroyed = !0,
            this.dispose(),
            this.onError.removeAll(),
            this.onError = null,
            this.onResize.removeAll(),
            this.onResize = null,
            this.onUpdate.removeAll(),
            this.onUpdate = null)
    }
    static test(e, n) {
        return !1
    }
}
class k_ extends Bd {
    constructor(e, n) {
        const { width: s, height: r } = n || {};
        if (!s || !r)
            throw new Error("BufferResource width or height invalid");
        super(s, r),
            this.data = e,
            this.unpackAlignment = n.unpackAlignment ?? 4
    }
    upload(e, n, s) {
        const r = e.gl;
        r.pixelStorei(r.UNPACK_ALIGNMENT, this.unpackAlignment),
            r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, n.alphaMode === Is.UNPACK);
        const i = n.realWidth
            , o = n.realHeight;
        return s.width === i && s.height === o ? r.texSubImage2D(n.target, 0, 0, 0, i, o, n.format, s.type, this.data) : (s.width = i,
            s.height = o,
            r.texImage2D(n.target, 0, s.internalFormat, i, o, 0, n.format, s.type, this.data)),
            !0
    }
    dispose() {
        this.data = null
    }
    static test(e) {
        return e === null || e instanceof Int8Array || e instanceof Uint8Array || e instanceof Uint8ClampedArray || e instanceof Int16Array || e instanceof Uint16Array || e instanceof Int32Array || e instanceof Uint32Array || e instanceof Float32Array
    }
}
const Vle = {
    scaleMode: ar.NEAREST,
    alphaMode: Is.NPM
}
    , vb = class Gc extends yf {
        constructor(e = null, n = null) {
            super(),
                n = Object.assign({}, Gc.defaultOptions, n);
            const { alphaMode: s, mipmap: r, anisotropicLevel: i, scaleMode: o, width: l, height: a, wrapMode: c, format: u, type: h, target: d, resolution: f, resourceOptions: p } = n;
            e && !(e instanceof Bd) && (e = S6(e, p),
                e.internal = !0),
                this.resolution = f || Le.RESOLUTION,
                this.width = Math.round((l || 0) * this.resolution) / this.resolution,
                this.height = Math.round((a || 0) * this.resolution) / this.resolution,
                this._mipmap = r,
                this.anisotropicLevel = i,
                this._wrapMode = c,
                this._scaleMode = o,
                this.format = u,
                this.type = h,
                this.target = d,
                this.alphaMode = s,
                this.uid = lc(),
                this.touched = 0,
                this.isPowerOfTwo = !1,
                this._refreshPOT(),
                this._glTextures = {},
                this.dirtyId = 0,
                this.dirtyStyleId = 0,
                this.cacheId = null,
                this.valid = l > 0 && a > 0,
                this.textureCacheIds = [],
                this.destroyed = !1,
                this.resource = null,
                this._batchEnabled = 0,
                this._batchLocation = 0,
                this.parentTextureArray = null,
                this.setResource(e)
        }
        get realWidth() {
            return Math.round(this.width * this.resolution)
        }
        get realHeight() {
            return Math.round(this.height * this.resolution)
        }
        get mipmap() {
            return this._mipmap
        }
        set mipmap(e) {
            this._mipmap !== e && (this._mipmap = e,
                this.dirtyStyleId++)
        }
        get scaleMode() {
            return this._scaleMode
        }
        set scaleMode(e) {
            this._scaleMode !== e && (this._scaleMode = e,
                this.dirtyStyleId++)
        }
        get wrapMode() {
            return this._wrapMode
        }
        set wrapMode(e) {
            this._wrapMode !== e && (this._wrapMode = e,
                this.dirtyStyleId++)
        }
        setStyle(e, n) {
            let s;
            return e !== void 0 && e !== this.scaleMode && (this.scaleMode = e,
                s = !0),
                n !== void 0 && n !== this.mipmap && (this.mipmap = n,
                    s = !0),
                s && this.dirtyStyleId++,
                this
        }
        setSize(e, n, s) {
            return s = s || this.resolution,
                this.setRealSize(e * s, n * s, s)
        }
        setRealSize(e, n, s) {
            return this.resolution = s || this.resolution,
                this.width = Math.round(e) / this.resolution,
                this.height = Math.round(n) / this.resolution,
                this._refreshPOT(),
                this.update(),
                this
        }
        _refreshPOT() {
            this.isPowerOfTwo = FI(this.realWidth) && FI(this.realHeight)
        }
        setResolution(e) {
            const n = this.resolution;
            return n === e ? this : (this.resolution = e,
                this.valid && (this.width = Math.round(this.width * n) / e,
                    this.height = Math.round(this.height * n) / e,
                    this.emit("update", this)),
                this._refreshPOT(),
                this)
        }
        setResource(e) {
            if (this.resource === e)
                return this;
            if (this.resource)
                throw new Error("Resource can be set only once");
            return e.bind(this),
                this.resource = e,
                this
        }
        update() {
            this.valid ? (this.dirtyId++,
                this.dirtyStyleId++,
                this.emit("update", this)) : this.width > 0 && this.height > 0 && (this.valid = !0,
                    this.emit("loaded", this),
                    this.emit("update", this))
        }
        onError(e) {
            this.emit("error", this, e)
        }
        destroy() {
            this.resource && (this.resource.unbind(this),
                this.resource.internal && this.resource.destroy(),
                this.resource = null),
                this.cacheId && (delete ta[this.cacheId],
                    delete Ti[this.cacheId],
                    this.cacheId = null),
                this.valid = !1,
                this.dispose(),
                Gc.removeFromCache(this),
                this.textureCacheIds = null,
                this.destroyed = !0,
                this.emit("destroyed", this),
                this.removeAllListeners()
        }
        dispose() {
            this.emit("dispose", this)
        }
        castToBaseTexture() {
            return this
        }
        static from(e, n, s = Le.STRICT_TEXTURE_CACHE) {
            const r = typeof e == "string";
            let i = null;
            if (r)
                i = e;
            else {
                if (!e._pixiId) {
                    const l = (n == null ? void 0 : n.pixiIdPrefix) || "pixiid";
                    e._pixiId = `${l}_${lc()}`
                }
                i = e._pixiId
            }
            let o = ta[i];
            if (r && s && !o)
                throw new Error(`The cacheId "${i}" does not exist in BaseTextureCache.`);
            return o || (o = new Gc(e, n),
                o.cacheId = i,
                Gc.addToCache(o, i)),
                o
        }
        static fromBuffer(e, n, s, r) {
            e = e || new Float32Array(n * s * 4);
            const i = new k_(e, {
                width: n,
                height: s,
                ...r == null ? void 0 : r.resourceOptions
            });
            let o, l;
            return e instanceof Float32Array ? (o = Ee.RGBA,
                l = Ge.FLOAT) : e instanceof Int32Array ? (o = Ee.RGBA_INTEGER,
                    l = Ge.INT) : e instanceof Uint32Array ? (o = Ee.RGBA_INTEGER,
                        l = Ge.UNSIGNED_INT) : e instanceof Int16Array ? (o = Ee.RGBA_INTEGER,
                            l = Ge.SHORT) : e instanceof Uint16Array ? (o = Ee.RGBA_INTEGER,
                                l = Ge.UNSIGNED_SHORT) : e instanceof Int8Array ? (o = Ee.RGBA,
                                    l = Ge.BYTE) : (o = Ee.RGBA,
                                        l = Ge.UNSIGNED_BYTE),
                i.internal = !0,
                new Gc(i, Object.assign({}, Vle, {
                    type: l,
                    format: o
                }, r))
        }
        static addToCache(e, n) {
            n && (e.textureCacheIds.includes(n) || e.textureCacheIds.push(n),
                ta[n] && ta[n] !== e && console.warn(`BaseTexture added to the cache with an id [${n}] that already had an entry`),
                ta[n] = e)
        }
        static removeFromCache(e) {
            if (typeof e == "string") {
                const n = ta[e];
                if (n) {
                    const s = n.textureCacheIds.indexOf(e);
                    return s > -1 && n.textureCacheIds.splice(s, 1),
                        delete ta[e],
                        n
                }
            } else if (e != null && e.textureCacheIds) {
                for (let n = 0; n < e.textureCacheIds.length; ++n)
                    delete ta[e.textureCacheIds[n]];
                return e.textureCacheIds.length = 0,
                    e
            }
            return null
        }
    }
    ;
vb.defaultOptions = {
    mipmap: ci.POW2,
    anisotropicLevel: 0,
    scaleMode: ar.LINEAR,
    wrapMode: Ua.CLAMP,
    alphaMode: Is.UNPACK,
    target: bu.TEXTURE_2D,
    format: Ee.RGBA,
    type: Ge.UNSIGNED_BYTE
},
    vb._globalBatch = 0;
let st = vb;
class xb {
    constructor() {
        this.texArray = null,
            this.blend = 0,
            this.type = ti.TRIANGLES,
            this.start = 0,
            this.size = 0,
            this.data = null
    }
}
let Gle = 0;
class _n {
    constructor(e, n = !0, s = !1) {
        this.data = e || new Float32Array(1),
            this._glBuffers = {},
            this._updateID = 0,
            this.index = s,
            this.static = n,
            this.id = Gle++,
            this.disposeRunner = new ri("disposeBuffer")
    }
    update(e) {
        e instanceof Array && (e = new Float32Array(e)),
            this.data = e || this.data,
            this._updateID++
    }
    dispose() {
        this.disposeRunner.emit(this, !1)
    }
    destroy() {
        this.dispose(),
            this.data = null
    }
    set index(e) {
        this.type = e ? Gi.ELEMENT_ARRAY_BUFFER : Gi.ARRAY_BUFFER
    }
    get index() {
        return this.type === Gi.ELEMENT_ARRAY_BUFFER
    }
    static from(e) {
        return e instanceof Array && (e = new Float32Array(e)),
            new _n(e)
    }
}
class qm {
    constructor(e, n = 0, s = !1, r = Ge.FLOAT, i, o, l, a = 1) {
        this.buffer = e,
            this.size = n,
            this.normalized = s,
            this.type = r,
            this.stride = i,
            this.start = o,
            this.instance = l,
            this.divisor = a
    }
    destroy() {
        this.buffer = null
    }
    static from(e, n, s, r, i) {
        return new qm(e, n, s, r, i)
    }
}
const Hle = {
    Float32Array,
    Uint32Array,
    Int32Array,
    Uint8Array
};
function Wle(t, e) {
    let n = 0
        , s = 0;
    const r = {};
    for (let a = 0; a < t.length; a++)
        s += e[a],
            n += t[a].length;
    const i = new ArrayBuffer(n * 4);
    let o = null
        , l = 0;
    for (let a = 0; a < t.length; a++) {
        const c = e[a]
            , u = t[a]
            , h = w6(u);
        r[h] || (r[h] = new Hle[h](i)),
            o = r[h];
        for (let d = 0; d < u.length; d++) {
            const f = (d / c | 0) * s + l
                , p = d % c;
            o[f + p] = u[d]
        }
        l += c
    }
    return new Float32Array(i)
}
const YI = {
    5126: 4,
    5123: 2,
    5121: 1
};
let Yle = 0;
const Xle = {
    Float32Array,
    Uint32Array,
    Int32Array,
    Uint8Array,
    Uint16Array
};
class ja {
    constructor(e = [], n = {}) {
        this.buffers = e,
            this.indexBuffer = null,
            this.attributes = n,
            this.glVertexArrayObjects = {},
            this.id = Yle++,
            this.instanced = !1,
            this.instanceCount = 1,
            this.disposeRunner = new ri("disposeGeometry"),
            this.refCount = 0
    }
    addAttribute(e, n, s = 0, r = !1, i, o, l, a = !1) {
        if (!n)
            throw new Error("You must pass a buffer when creating an attribute");
        n instanceof _n || (n instanceof Array && (n = new Float32Array(n)),
            n = new _n(n));
        const c = e.split("|");
        if (c.length > 1) {
            for (let h = 0; h < c.length; h++)
                this.addAttribute(c[h], n, s, r, i);
            return this
        }
        let u = this.buffers.indexOf(n);
        return u === -1 && (this.buffers.push(n),
            u = this.buffers.length - 1),
            this.attributes[e] = new qm(u, s, r, i, o, l, a),
            this.instanced = this.instanced || a,
            this
    }
    getAttribute(e) {
        return this.attributes[e]
    }
    getBuffer(e) {
        return this.buffers[this.getAttribute(e).buffer]
    }
    addIndex(e) {
        return e instanceof _n || (e instanceof Array && (e = new Uint16Array(e)),
            e = new _n(e)),
            e.type = Gi.ELEMENT_ARRAY_BUFFER,
            this.indexBuffer = e,
            this.buffers.includes(e) || this.buffers.push(e),
            this
    }
    getIndex() {
        return this.indexBuffer
    }
    interleave() {
        if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer)
            return this;
        const e = []
            , n = []
            , s = new _n;
        let r;
        for (r in this.attributes) {
            const i = this.attributes[r]
                , o = this.buffers[i.buffer];
            e.push(o.data),
                n.push(i.size * YI[i.type] / 4),
                i.buffer = 0
        }
        for (s.data = Wle(e, n),
            r = 0; r < this.buffers.length; r++)
            this.buffers[r] !== this.indexBuffer && this.buffers[r].destroy();
        return this.buffers = [s],
            this.indexBuffer && this.buffers.push(this.indexBuffer),
            this
    }
    getSize() {
        for (const e in this.attributes) {
            const n = this.attributes[e];
            return this.buffers[n.buffer].data.length / (n.stride / 4 || n.size)
        }
        return 0
    }
    dispose() {
        this.disposeRunner.emit(this, !1)
    }
    destroy() {
        this.dispose(),
            this.buffers = null,
            this.indexBuffer = null,
            this.attributes = null
    }
    clone() {
        const e = new ja;
        for (let n = 0; n < this.buffers.length; n++)
            e.buffers[n] = new _n(this.buffers[n].data.slice(0));
        for (const n in this.attributes) {
            const s = this.attributes[n];
            e.attributes[n] = new qm(s.buffer, s.size, s.normalized, s.type, s.stride, s.start, s.instance)
        }
        return this.indexBuffer && (e.indexBuffer = e.buffers[this.buffers.indexOf(this.indexBuffer)],
            e.indexBuffer.type = Gi.ELEMENT_ARRAY_BUFFER),
            e
    }
    static merge(e) {
        const n = new ja
            , s = []
            , r = []
            , i = [];
        let o;
        for (let l = 0; l < e.length; l++) {
            o = e[l];
            for (let a = 0; a < o.buffers.length; a++)
                r[a] = r[a] || 0,
                    r[a] += o.buffers[a].data.length,
                    i[a] = 0
        }
        for (let l = 0; l < o.buffers.length; l++)
            s[l] = new Xle[w6(o.buffers[l].data)](r[l]),
                n.buffers[l] = new _n(s[l]);
        for (let l = 0; l < e.length; l++) {
            o = e[l];
            for (let a = 0; a < o.buffers.length; a++)
                s[a].set(o.buffers[a].data, i[a]),
                    i[a] += o.buffers[a].data.length
        }
        if (n.attributes = o.attributes,
            o.indexBuffer) {
            n.indexBuffer = n.buffers[o.buffers.indexOf(o.indexBuffer)],
                n.indexBuffer.type = Gi.ELEMENT_ARRAY_BUFFER;
            let l = 0
                , a = 0
                , c = 0
                , u = 0;
            for (let h = 0; h < o.buffers.length; h++)
                if (o.buffers[h] !== o.indexBuffer) {
                    u = h;
                    break
                }
            for (const h in o.attributes) {
                const d = o.attributes[h];
                (d.buffer | 0) === u && (a += d.size * YI[d.type] / 4)
            }
            for (let h = 0; h < e.length; h++) {
                const d = e[h].indexBuffer.data;
                for (let f = 0; f < d.length; f++)
                    n.indexBuffer.data[f + c] += l;
                l += e[h].buffers[u].data.length / a,
                    c += d.length
            }
        }
        return n
    }
}
class E6 extends ja {
    constructor(e = !1) {
        super(),
            this._buffer = new _n(null, e, !1),
            this._indexBuffer = new _n(null, e, !0),
            this.addAttribute("aVertexPosition", this._buffer, 2, !1, Ge.FLOAT).addAttribute("aTextureCoord", this._buffer, 2, !1, Ge.FLOAT).addAttribute("aColor", this._buffer, 4, !0, Ge.UNSIGNED_BYTE).addAttribute("aTextureId", this._buffer, 1, !0, Ge.FLOAT).addIndex(this._indexBuffer)
    }
}
const Km = Math.PI * 2
    , jle = 180 / Math.PI
    , zle = Math.PI / 180;
var ss = (t => (t[t.POLY = 0] = "POLY",
    t[t.RECT = 1] = "RECT",
    t[t.CIRC = 2] = "CIRC",
    t[t.ELIP = 3] = "ELIP",
    t[t.RREC = 4] = "RREC",
    t))(ss || {});
class At {
    constructor(e = 0, n = 0) {
        this.x = 0,
            this.y = 0,
            this.x = e,
            this.y = n
    }
    clone() {
        return new At(this.x, this.y)
    }
    copyFrom(e) {
        return this.set(e.x, e.y),
            this
    }
    copyTo(e) {
        return e.set(this.x, this.y),
            e
    }
    equals(e) {
        return e.x === this.x && e.y === this.y
    }
    set(e = 0, n = e) {
        return this.x = e,
            this.y = n,
            this
    }
}
At.prototype.toString = function () {
    return `[@pixi/math:Point x=${this.x} y=${this.y}]`
}
    ;
const cp = [new At, new At, new At, new At];
class nt {
    constructor(e = 0, n = 0, s = 0, r = 0) {
        this.x = Number(e),
            this.y = Number(n),
            this.width = Number(s),
            this.height = Number(r),
            this.type = ss.RECT
    }
    get left() {
        return this.x
    }
    get right() {
        return this.x + this.width
    }
    get top() {
        return this.y
    }
    get bottom() {
        return this.y + this.height
    }
    static get EMPTY() {
        return new nt(0, 0, 0, 0)
    }
    clone() {
        return new nt(this.x, this.y, this.width, this.height)
    }
    copyFrom(e) {
        return this.x = e.x,
            this.y = e.y,
            this.width = e.width,
            this.height = e.height,
            this
    }
    copyTo(e) {
        return e.x = this.x,
            e.y = this.y,
            e.width = this.width,
            e.height = this.height,
            e
    }
    contains(e, n) {
        return this.width <= 0 || this.height <= 0 ? !1 : e >= this.x && e < this.x + this.width && n >= this.y && n < this.y + this.height
    }
    intersects(e, n) {
        if (!n) {
            const E = this.x < e.x ? e.x : this.x;
            if ((this.right > e.right ? e.right : this.right) <= E)
                return !1;
            const C = this.y < e.y ? e.y : this.y;
            return (this.bottom > e.bottom ? e.bottom : this.bottom) > C
        }
        const s = this.left
            , r = this.right
            , i = this.top
            , o = this.bottom;
        if (r <= s || o <= i)
            return !1;
        const l = cp[0].set(e.left, e.top)
            , a = cp[1].set(e.left, e.bottom)
            , c = cp[2].set(e.right, e.top)
            , u = cp[3].set(e.right, e.bottom);
        if (c.x <= l.x || a.y <= l.y)
            return !1;
        const h = Math.sign(n.a * n.d - n.b * n.c);
        if (h === 0 || (n.apply(l, l),
            n.apply(a, a),
            n.apply(c, c),
            n.apply(u, u),
            Math.max(l.x, a.x, c.x, u.x) <= s || Math.min(l.x, a.x, c.x, u.x) >= r || Math.max(l.y, a.y, c.y, u.y) <= i || Math.min(l.y, a.y, c.y, u.y) >= o))
            return !1;
        const d = h * (a.y - l.y)
            , f = h * (l.x - a.x)
            , p = d * s + f * i
            , m = d * r + f * i
            , g = d * s + f * o
            , b = d * r + f * o;
        if (Math.max(p, m, g, b) <= d * l.x + f * l.y || Math.min(p, m, g, b) >= d * u.x + f * u.y)
            return !1;
        const v = h * (l.y - c.y)
            , _ = h * (c.x - l.x)
            , y = v * s + _ * i
            , x = v * r + _ * i
            , w = v * s + _ * o
            , S = v * r + _ * o;
        return !(Math.max(y, x, w, S) <= v * l.x + _ * l.y || Math.min(y, x, w, S) >= v * u.x + _ * u.y)
    }
    pad(e = 0, n = e) {
        return this.x -= e,
            this.y -= n,
            this.width += e * 2,
            this.height += n * 2,
            this
    }
    fit(e) {
        const n = Math.max(this.x, e.x)
            , s = Math.min(this.x + this.width, e.x + e.width)
            , r = Math.max(this.y, e.y)
            , i = Math.min(this.y + this.height, e.y + e.height);
        return this.x = n,
            this.width = Math.max(s - n, 0),
            this.y = r,
            this.height = Math.max(i - r, 0),
            this
    }
    ceil(e = 1, n = .001) {
        const s = Math.ceil((this.x + this.width - n) * e) / e
            , r = Math.ceil((this.y + this.height - n) * e) / e;
        return this.x = Math.floor((this.x + n) * e) / e,
            this.y = Math.floor((this.y + n) * e) / e,
            this.width = s - this.x,
            this.height = r - this.y,
            this
    }
    enlarge(e) {
        const n = Math.min(this.x, e.x)
            , s = Math.max(this.x + this.width, e.x + e.width)
            , r = Math.min(this.y, e.y)
            , i = Math.max(this.y + this.height, e.y + e.height);
        return this.x = n,
            this.width = s - n,
            this.y = r,
            this.height = i - r,
            this
    }
}
nt.prototype.toString = function () {
    return `[@pixi/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`
}
    ;
class R_ {
    constructor(e = 0, n = 0, s = 0) {
        this.x = e,
            this.y = n,
            this.radius = s,
            this.type = ss.CIRC
    }
    clone() {
        return new R_(this.x, this.y, this.radius)
    }
    contains(e, n) {
        if (this.radius <= 0)
            return !1;
        const s = this.radius * this.radius;
        let r = this.x - e
            , i = this.y - n;
        return r *= r,
            i *= i,
            r + i <= s
    }
    getBounds() {
        return new nt(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2)
    }
}
R_.prototype.toString = function () {
    return `[@pixi/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`
}
    ;
class M_ {
    constructor(e = 0, n = 0, s = 0, r = 0) {
        this.x = e,
            this.y = n,
            this.width = s,
            this.height = r,
            this.type = ss.ELIP
    }
    clone() {
        return new M_(this.x, this.y, this.width, this.height)
    }
    contains(e, n) {
        if (this.width <= 0 || this.height <= 0)
            return !1;
        let s = (e - this.x) / this.width
            , r = (n - this.y) / this.height;
        return s *= s,
            r *= r,
            s + r <= 1
    }
    getBounds() {
        return new nt(this.x - this.width, this.y - this.height, this.width, this.height)
    }
}
M_.prototype.toString = function () {
    return `[@pixi/math:Ellipse x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`
}
    ;
class Va {
    constructor(...e) {
        let n = Array.isArray(e[0]) ? e[0] : e;
        if (typeof n[0] != "number") {
            const s = [];
            for (let r = 0, i = n.length; r < i; r++)
                s.push(n[r].x, n[r].y);
            n = s
        }
        this.points = n,
            this.type = ss.POLY,
            this.closeStroke = !0
    }
    clone() {
        const e = this.points.slice()
            , n = new Va(e);
        return n.closeStroke = this.closeStroke,
            n
    }
    contains(e, n) {
        let s = !1;
        const r = this.points.length / 2;
        for (let i = 0, o = r - 1; i < r; o = i++) {
            const l = this.points[i * 2]
                , a = this.points[i * 2 + 1]
                , c = this.points[o * 2]
                , u = this.points[o * 2 + 1];
            a > n != u > n && e < (c - l) * ((n - a) / (u - a)) + l && (s = !s)
        }
        return s
    }
}
Va.prototype.toString = function () {
    return `[@pixi/math:PolygoncloseStroke=${this.closeStroke}points=${this.points.reduce((t, e) => `${t}, ${e}`, "")}]`
}
    ;
class P_ {
    constructor(e = 0, n = 0, s = 0, r = 0, i = 20) {
        this.x = e,
            this.y = n,
            this.width = s,
            this.height = r,
            this.radius = i,
            this.type = ss.RREC
    }
    clone() {
        return new P_(this.x, this.y, this.width, this.height, this.radius)
    }
    contains(e, n) {
        if (this.width <= 0 || this.height <= 0)
            return !1;
        if (e >= this.x && e <= this.x + this.width && n >= this.y && n <= this.y + this.height) {
            const s = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
            if (n >= this.y + s && n <= this.y + this.height - s || e >= this.x + s && e <= this.x + this.width - s)
                return !0;
            let r = e - (this.x + s)
                , i = n - (this.y + s);
            const o = s * s;
            if (r * r + i * i <= o || (r = e - (this.x + this.width - s),
                r * r + i * i <= o) || (i = n - (this.y + this.height - s),
                    r * r + i * i <= o) || (r = e - (this.x + s),
                        r * r + i * i <= o))
                return !0
        }
        return !1
    }
}
P_.prototype.toString = function () {
    return `[@pixi/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`
}
    ;
class Bt {
    constructor(e = 1, n = 0, s = 0, r = 1, i = 0, o = 0) {
        this.array = null,
            this.a = e,
            this.b = n,
            this.c = s,
            this.d = r,
            this.tx = i,
            this.ty = o
    }
    fromArray(e) {
        this.a = e[0],
            this.b = e[1],
            this.c = e[3],
            this.d = e[4],
            this.tx = e[2],
            this.ty = e[5]
    }
    set(e, n, s, r, i, o) {
        return this.a = e,
            this.b = n,
            this.c = s,
            this.d = r,
            this.tx = i,
            this.ty = o,
            this
    }
    toArray(e, n) {
        this.array || (this.array = new Float32Array(9));
        const s = n || this.array;
        return e ? (s[0] = this.a,
            s[1] = this.b,
            s[2] = 0,
            s[3] = this.c,
            s[4] = this.d,
            s[5] = 0,
            s[6] = this.tx,
            s[7] = this.ty,
            s[8] = 1) : (s[0] = this.a,
                s[1] = this.c,
                s[2] = this.tx,
                s[3] = this.b,
                s[4] = this.d,
                s[5] = this.ty,
                s[6] = 0,
                s[7] = 0,
                s[8] = 1),
            s
    }
    apply(e, n) {
        n = n || new At;
        const s = e.x
            , r = e.y;
        return n.x = this.a * s + this.c * r + this.tx,
            n.y = this.b * s + this.d * r + this.ty,
            n
    }
    applyInverse(e, n) {
        n = n || new At;
        const s = 1 / (this.a * this.d + this.c * -this.b)
            , r = e.x
            , i = e.y;
        return n.x = this.d * s * r + -this.c * s * i + (this.ty * this.c - this.tx * this.d) * s,
            n.y = this.a * s * i + -this.b * s * r + (-this.ty * this.a + this.tx * this.b) * s,
            n
    }
    translate(e, n) {
        return this.tx += e,
            this.ty += n,
            this
    }
    scale(e, n) {
        return this.a *= e,
            this.d *= n,
            this.c *= e,
            this.b *= n,
            this.tx *= e,
            this.ty *= n,
            this
    }
    rotate(e) {
        const n = Math.cos(e)
            , s = Math.sin(e)
            , r = this.a
            , i = this.c
            , o = this.tx;
        return this.a = r * n - this.b * s,
            this.b = r * s + this.b * n,
            this.c = i * n - this.d * s,
            this.d = i * s + this.d * n,
            this.tx = o * n - this.ty * s,
            this.ty = o * s + this.ty * n,
            this
    }
    append(e) {
        const n = this.a
            , s = this.b
            , r = this.c
            , i = this.d;
        return this.a = e.a * n + e.b * r,
            this.b = e.a * s + e.b * i,
            this.c = e.c * n + e.d * r,
            this.d = e.c * s + e.d * i,
            this.tx = e.tx * n + e.ty * r + this.tx,
            this.ty = e.tx * s + e.ty * i + this.ty,
            this
    }
    setTransform(e, n, s, r, i, o, l, a, c) {
        return this.a = Math.cos(l + c) * i,
            this.b = Math.sin(l + c) * i,
            this.c = -Math.sin(l - a) * o,
            this.d = Math.cos(l - a) * o,
            this.tx = e - (s * this.a + r * this.c),
            this.ty = n - (s * this.b + r * this.d),
            this
    }
    prepend(e) {
        const n = this.tx;
        if (e.a !== 1 || e.b !== 0 || e.c !== 0 || e.d !== 1) {
            const s = this.a
                , r = this.c;
            this.a = s * e.a + this.b * e.c,
                this.b = s * e.b + this.b * e.d,
                this.c = r * e.a + this.d * e.c,
                this.d = r * e.b + this.d * e.d
        }
        return this.tx = n * e.a + this.ty * e.c + e.tx,
            this.ty = n * e.b + this.ty * e.d + e.ty,
            this
    }
    decompose(e) {
        const n = this.a
            , s = this.b
            , r = this.c
            , i = this.d
            , o = e.pivot
            , l = -Math.atan2(-r, i)
            , a = Math.atan2(s, n)
            , c = Math.abs(l + a);
        return c < 1e-5 || Math.abs(Km - c) < 1e-5 ? (e.rotation = a,
            e.skew.x = e.skew.y = 0) : (e.rotation = 0,
                e.skew.x = l,
                e.skew.y = a),
            e.scale.x = Math.sqrt(n * n + s * s),
            e.scale.y = Math.sqrt(r * r + i * i),
            e.position.x = this.tx + (o.x * n + o.y * r),
            e.position.y = this.ty + (o.x * s + o.y * i),
            e
    }
    invert() {
        const e = this.a
            , n = this.b
            , s = this.c
            , r = this.d
            , i = this.tx
            , o = e * r - n * s;
        return this.a = r / o,
            this.b = -n / o,
            this.c = -s / o,
            this.d = e / o,
            this.tx = (s * this.ty - r * i) / o,
            this.ty = -(e * this.ty - n * i) / o,
            this
    }
    identity() {
        return this.a = 1,
            this.b = 0,
            this.c = 0,
            this.d = 1,
            this.tx = 0,
            this.ty = 0,
            this
    }
    clone() {
        const e = new Bt;
        return e.a = this.a,
            e.b = this.b,
            e.c = this.c,
            e.d = this.d,
            e.tx = this.tx,
            e.ty = this.ty,
            e
    }
    copyTo(e) {
        return e.a = this.a,
            e.b = this.b,
            e.c = this.c,
            e.d = this.d,
            e.tx = this.tx,
            e.ty = this.ty,
            e
    }
    copyFrom(e) {
        return this.a = e.a,
            this.b = e.b,
            this.c = e.c,
            this.d = e.d,
            this.tx = e.tx,
            this.ty = e.ty,
            this
    }
    static get IDENTITY() {
        return new Bt
    }
    static get TEMP_MATRIX() {
        return new Bt
    }
}
Bt.prototype.toString = function () {
    return `[@pixi/math:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`
}
    ;
const vl = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1]
    , xl = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1]
    , wl = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1]
    , Sl = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1]
    , wb = []
    , T6 = []
    , up = Math.sign;
function qle() {
    for (let t = 0; t < 16; t++) {
        const e = [];
        wb.push(e);
        for (let n = 0; n < 16; n++) {
            const s = up(vl[t] * vl[n] + wl[t] * xl[n])
                , r = up(xl[t] * vl[n] + Sl[t] * xl[n])
                , i = up(vl[t] * wl[n] + wl[t] * Sl[n])
                , o = up(xl[t] * wl[n] + Sl[t] * Sl[n]);
            for (let l = 0; l < 16; l++)
                if (vl[l] === s && xl[l] === r && wl[l] === i && Sl[l] === o) {
                    e.push(l);
                    break
                }
        }
    }
    for (let t = 0; t < 16; t++) {
        const e = new Bt;
        e.set(vl[t], xl[t], wl[t], Sl[t], 0, 0),
            T6.push(e)
    }
}
qle();
const sn = {
    E: 0,
    SE: 1,
    S: 2,
    SW: 3,
    W: 4,
    NW: 5,
    N: 6,
    NE: 7,
    MIRROR_VERTICAL: 8,
    MAIN_DIAGONAL: 10,
    MIRROR_HORIZONTAL: 12,
    REVERSE_DIAGONAL: 14,
    uX: t => vl[t],
    uY: t => xl[t],
    vX: t => wl[t],
    vY: t => Sl[t],
    inv: t => t & 8 ? t & 15 : -t & 7,
    add: (t, e) => wb[t][e],
    sub: (t, e) => wb[t][sn.inv(e)],
    rotate180: t => t ^ 4,
    isVertical: t => (t & 3) === 2,
    byDirection: (t, e) => Math.abs(t) * 2 <= Math.abs(e) ? e >= 0 ? sn.S : sn.N : Math.abs(e) * 2 <= Math.abs(t) ? t > 0 ? sn.E : sn.W : e > 0 ? t > 0 ? sn.SE : sn.SW : t > 0 ? sn.NE : sn.NW,
    matrixAppendRotationInv: (t, e, n = 0, s = 0) => {
        const r = T6[sn.inv(e)];
        r.tx = n,
            r.ty = s,
            t.append(r)
    }
};
class wo {
    constructor(e, n, s = 0, r = 0) {
        this._x = s,
            this._y = r,
            this.cb = e,
            this.scope = n
    }
    clone(e = this.cb, n = this.scope) {
        return new wo(e, n, this._x, this._y)
    }
    set(e = 0, n = e) {
        return (this._x !== e || this._y !== n) && (this._x = e,
            this._y = n,
            this.cb.call(this.scope)),
            this
    }
    copyFrom(e) {
        return (this._x !== e.x || this._y !== e.y) && (this._x = e.x,
            this._y = e.y,
            this.cb.call(this.scope)),
            this
    }
    copyTo(e) {
        return e.set(this._x, this._y),
            e
    }
    equals(e) {
        return e.x === this._x && e.y === this._y
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x !== e && (this._x = e,
            this.cb.call(this.scope))
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y !== e && (this._y = e,
            this.cb.call(this.scope))
    }
}
wo.prototype.toString = function () {
    return `[@pixi/math:ObservablePoint x=${this.x} y=${this.y} scope=${this.scope}]`
}
    ;
const Sb = class {
    constructor() {
        this.worldTransform = new Bt,
            this.localTransform = new Bt,
            this.position = new wo(this.onChange, this, 0, 0),
            this.scale = new wo(this.onChange, this, 1, 1),
            this.pivot = new wo(this.onChange, this, 0, 0),
            this.skew = new wo(this.updateSkew, this, 0, 0),
            this._rotation = 0,
            this._cx = 1,
            this._sx = 0,
            this._cy = 0,
            this._sy = 1,
            this._localID = 0,
            this._currentLocalID = 0,
            this._worldID = 0,
            this._parentID = 0
    }
    onChange() {
        this._localID++
    }
    updateSkew() {
        this._cx = Math.cos(this._rotation + this.skew.y),
            this._sx = Math.sin(this._rotation + this.skew.y),
            this._cy = -Math.sin(this._rotation - this.skew.x),
            this._sy = Math.cos(this._rotation - this.skew.x),
            this._localID++
    }
    updateLocalTransform() {
        const t = this.localTransform;
        this._localID !== this._currentLocalID && (t.a = this._cx * this.scale.x,
            t.b = this._sx * this.scale.x,
            t.c = this._cy * this.scale.y,
            t.d = this._sy * this.scale.y,
            t.tx = this.position.x - (this.pivot.x * t.a + this.pivot.y * t.c),
            t.ty = this.position.y - (this.pivot.x * t.b + this.pivot.y * t.d),
            this._currentLocalID = this._localID,
            this._parentID = -1)
    }
    updateTransform(t) {
        const e = this.localTransform;
        if (this._localID !== this._currentLocalID && (e.a = this._cx * this.scale.x,
            e.b = this._sx * this.scale.x,
            e.c = this._cy * this.scale.y,
            e.d = this._sy * this.scale.y,
            e.tx = this.position.x - (this.pivot.x * e.a + this.pivot.y * e.c),
            e.ty = this.position.y - (this.pivot.x * e.b + this.pivot.y * e.d),
            this._currentLocalID = this._localID,
            this._parentID = -1),
            this._parentID !== t._worldID) {
            const n = t.worldTransform
                , s = this.worldTransform;
            s.a = e.a * n.a + e.b * n.c,
                s.b = e.a * n.b + e.b * n.d,
                s.c = e.c * n.a + e.d * n.c,
                s.d = e.c * n.b + e.d * n.d,
                s.tx = e.tx * n.a + e.ty * n.c + n.tx,
                s.ty = e.tx * n.b + e.ty * n.d + n.ty,
                this._parentID = t._worldID,
                this._worldID++
        }
    }
    setFromMatrix(t) {
        t.decompose(this),
            this._localID++
    }
    get rotation() {
        return this._rotation
    }
    set rotation(t) {
        this._rotation !== t && (this._rotation = t,
            this.updateSkew())
    }
}
    ;
Sb.IDENTITY = new Sb;
let L_ = Sb;
L_.prototype.toString = function () {
    return `[@pixi/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`
}
    ;
var Kle = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;

void main(void){
   gl_FragColor *= texture2D(uSampler, vTextureCoord);
}`
    , Jle = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void){
   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
   vTextureCoord = aTextureCoord;
}
`;
function XI(t, e, n) {
    const s = t.createShader(e);
    return t.shaderSource(s, n),
        t.compileShader(s),
        s
}
function g1(t) {
    const e = new Array(t);
    for (let n = 0; n < e.length; n++)
        e[n] = !1;
    return e
}
function C6(t, e) {
    switch (t) {
        case "float":
            return 0;
        case "vec2":
            return new Float32Array(2 * e);
        case "vec3":
            return new Float32Array(3 * e);
        case "vec4":
            return new Float32Array(4 * e);
        case "int":
        case "uint":
        case "sampler2D":
        case "sampler2DArray":
            return 0;
        case "ivec2":
            return new Int32Array(2 * e);
        case "ivec3":
            return new Int32Array(3 * e);
        case "ivec4":
            return new Int32Array(4 * e);
        case "uvec2":
            return new Uint32Array(2 * e);
        case "uvec3":
            return new Uint32Array(3 * e);
        case "uvec4":
            return new Uint32Array(4 * e);
        case "bool":
            return !1;
        case "bvec2":
            return g1(2 * e);
        case "bvec3":
            return g1(3 * e);
        case "bvec4":
            return g1(4 * e);
        case "mat2":
            return new Float32Array([1, 0, 0, 1]);
        case "mat3":
            return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
        case "mat4":
            return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])
    }
    return null
}
const Su = [{
    test: t => t.type === "float" && t.size === 1 && !t.isArray,
    code: t => `
            if(uv["${t}"] !== ud["${t}"].value)
            {
                ud["${t}"].value = uv["${t}"]
                gl.uniform1f(ud["${t}"].location, uv["${t}"])
            }
            `
}, {
    test: (t, e) => (t.type === "sampler2D" || t.type === "samplerCube" || t.type === "sampler2DArray") && t.size === 1 && !t.isArray && (e == null || e.castToBaseTexture !== void 0),
    code: t => `t = syncData.textureCount++;

            renderer.texture.bind(uv["${t}"], t);

            if(ud["${t}"].value !== t)
            {
                ud["${t}"].value = t;
                gl.uniform1i(ud["${t}"].location, t);
; // eslint-disable-line max-len
            }`
}, {
    test: (t, e) => t.type === "mat3" && t.size === 1 && !t.isArray && e.a !== void 0,
    code: t => `
            gl.uniformMatrix3fv(ud["${t}"].location, false, uv["${t}"].toArray(true));
            `,
    codeUbo: t => `
                var ${t}_matrix = uv.${t}.toArray(true);

                data[offset] = ${t}_matrix[0];
                data[offset+1] = ${t}_matrix[1];
                data[offset+2] = ${t}_matrix[2];
        
                data[offset + 4] = ${t}_matrix[3];
                data[offset + 5] = ${t}_matrix[4];
                data[offset + 6] = ${t}_matrix[5];
        
                data[offset + 8] = ${t}_matrix[6];
                data[offset + 9] = ${t}_matrix[7];
                data[offset + 10] = ${t}_matrix[8];
            `
}, {
    test: (t, e) => t.type === "vec2" && t.size === 1 && !t.isArray && e.x !== void 0,
    code: t => `
                cv = ud["${t}"].value;
                v = uv["${t}"];

                if(cv[0] !== v.x || cv[1] !== v.y)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    gl.uniform2f(ud["${t}"].location, v.x, v.y);
                }`,
    codeUbo: t => `
                v = uv.${t};

                data[offset] = v.x;
                data[offset+1] = v.y;
            `
}, {
    test: t => t.type === "vec2" && t.size === 1 && !t.isArray,
    code: t => `
                cv = ud["${t}"].value;
                v = uv["${t}"];

                if(cv[0] !== v[0] || cv[1] !== v[1])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    gl.uniform2f(ud["${t}"].location, v[0], v[1]);
                }
            `
}, {
    test: (t, e) => t.type === "vec4" && t.size === 1 && !t.isArray && e.width !== void 0,
    code: t => `
                cv = ud["${t}"].value;
                v = uv["${t}"];

                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    cv[2] = v.width;
                    cv[3] = v.height;
                    gl.uniform4f(ud["${t}"].location, v.x, v.y, v.width, v.height)
                }`,
    codeUbo: t => `
                    v = uv.${t};

                    data[offset] = v.x;
                    data[offset+1] = v.y;
                    data[offset+2] = v.width;
                    data[offset+3] = v.height;
                `
}, {
    test: (t, e) => t.type === "vec4" && t.size === 1 && !t.isArray && e.red !== void 0,
    code: t => `
                cv = ud["${t}"].value;
                v = uv["${t}"];

                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha)
                {
                    cv[0] = v.red;
                    cv[1] = v.green;
                    cv[2] = v.blue;
                    cv[3] = v.alpha;
                    gl.uniform4f(ud["${t}"].location, v.red, v.green, v.blue, v.alpha)
                }`,
    codeUbo: t => `
                    v = uv.${t};

                    data[offset] = v.red;
                    data[offset+1] = v.green;
                    data[offset+2] = v.blue;
                    data[offset+3] = v.alpha;
                `
}, {
    test: (t, e) => t.type === "vec3" && t.size === 1 && !t.isArray && e.red !== void 0,
    code: t => `
                cv = ud["${t}"].value;
                v = uv["${t}"];

                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.a)
                {
                    cv[0] = v.red;
                    cv[1] = v.green;
                    cv[2] = v.blue;
    
                    gl.uniform3f(ud["${t}"].location, v.red, v.green, v.blue)
                }`,
    codeUbo: t => `
                    v = uv.${t};

                    data[offset] = v.red;
                    data[offset+1] = v.green;
                    data[offset+2] = v.blue;
                `
}, {
    test: t => t.type === "vec4" && t.size === 1 && !t.isArray,
    code: t => `
                cv = ud["${t}"].value;
                v = uv["${t}"];

                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    cv[2] = v[2];
                    cv[3] = v[3];

                    gl.uniform4f(ud["${t}"].location, v[0], v[1], v[2], v[3])
                }`
}]
    , Zle = {
        float: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1f(location, v);
    }`,
        vec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2f(location, v[0], v[1])
    }`,
        vec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3f(location, v[0], v[1], v[2])
    }`,
        vec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4f(location, v[0], v[1], v[2], v[3]);
    }`,
        int: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
        ivec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
        ivec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
        ivec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
        uint: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1ui(location, v);
    }`,
        uvec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2ui(location, v[0], v[1]);
    }`,
        uvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3ui(location, v[0], v[1], v[2]);
    }`,
        uvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
    }`,
        bool: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1i(location, v);
    }`,
        bvec2: `
    if (cv[0] != v[0] || cv[1] != v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
        bvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
        bvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
        mat2: "gl.uniformMatrix2fv(location, false, v)",
        mat3: "gl.uniformMatrix3fv(location, false, v)",
        mat4: "gl.uniformMatrix4fv(location, false, v)",
        sampler2D: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
        samplerCube: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
        sampler2DArray: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`
    }
    , Qle = {
        float: "gl.uniform1fv(location, v)",
        vec2: "gl.uniform2fv(location, v)",
        vec3: "gl.uniform3fv(location, v)",
        vec4: "gl.uniform4fv(location, v)",
        mat4: "gl.uniformMatrix4fv(location, false, v)",
        mat3: "gl.uniformMatrix3fv(location, false, v)",
        mat2: "gl.uniformMatrix2fv(location, false, v)",
        int: "gl.uniform1iv(location, v)",
        ivec2: "gl.uniform2iv(location, v)",
        ivec3: "gl.uniform3iv(location, v)",
        ivec4: "gl.uniform4iv(location, v)",
        uint: "gl.uniform1uiv(location, v)",
        uvec2: "gl.uniform2uiv(location, v)",
        uvec3: "gl.uniform3uiv(location, v)",
        uvec4: "gl.uniform4uiv(location, v)",
        bool: "gl.uniform1iv(location, v)",
        bvec2: "gl.uniform2iv(location, v)",
        bvec3: "gl.uniform3iv(location, v)",
        bvec4: "gl.uniform4iv(location, v)",
        sampler2D: "gl.uniform1iv(location, v)",
        samplerCube: "gl.uniform1iv(location, v)",
        sampler2DArray: "gl.uniform1iv(location, v)"
    };
function ece(t, e) {
    var s;
    const n = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
    `];
    for (const r in t.uniforms) {
        const i = e[r];
        if (!i) {
            ((s = t.uniforms[r]) == null ? void 0 : s.group) === !0 && (t.uniforms[r].ubo ? n.push(`
                        renderer.shader.syncUniformBufferGroup(uv.${r}, '${r}');
                    `) : n.push(`
                        renderer.shader.syncUniformGroup(uv.${r}, syncData);
                    `));
            continue
        }
        const o = t.uniforms[r];
        let l = !1;
        for (let a = 0; a < Su.length; a++)
            if (Su[a].test(i, o)) {
                n.push(Su[a].code(r, o)),
                    l = !0;
                break
            }
        if (!l) {
            const a = (i.size === 1 && !i.isArray ? Zle : Qle)[i.type].replace("location", `ud["${r}"].location`);
            n.push(`
            cu = ud["${r}"];
            cv = cu.value;
            v = uv["${r}"];
            ${a};`)
        }
    }
    return new Function("ud", "uv", "renderer", "syncData", n.join(`
`))
}
const I6 = {};
let Pc = I6;
function tce() {
    if (Pc === I6 || Pc != null && Pc.isContextLost()) {
        const t = Le.ADAPTER.createCanvas();
        let e;
        Le.PREFER_ENV >= wc.WEBGL2 && (e = t.getContext("webgl2", {})),
            e || (e = t.getContext("webgl", {}) || t.getContext("experimental-webgl", {}),
                e ? e.getExtension("WEBGL_draw_buffers") : e = null),
            Pc = e
    }
    return Pc
}
let hp;
function nce() {
    if (!hp) {
        hp = Er.MEDIUM;
        const t = tce();
        if (t && t.getShaderPrecisionFormat) {
            const e = t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT);
            e && (hp = e.precision ? Er.HIGH : Er.MEDIUM)
        }
    }
    return hp
}
function jI(t, e) {
    const n = t.getShaderSource(e).split(`
`).map((c, u) => `${u}: ${c}`)
        , s = t.getShaderInfoLog(e)
        , r = s.split(`
`)
        , i = {}
        , o = r.map(c => parseFloat(c.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter(c => c && !i[c] ? (i[c] = !0,
            !0) : !1)
        , l = [""];
    o.forEach(c => {
        n[c - 1] = `%c${n[c - 1]}%c`,
            l.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px")
    }
    );
    const a = n.join(`
`);
    l[0] = a,
        console.error(s),
        console.groupCollapsed("click to view full shader code"),
        console.warn(...l),
        console.groupEnd()
}
function sce(t, e, n, s) {
    t.getProgramParameter(e, t.LINK_STATUS) || (t.getShaderParameter(n, t.COMPILE_STATUS) || jI(t, n),
        t.getShaderParameter(s, t.COMPILE_STATUS) || jI(t, s),
        console.error("PixiJS Error: Could not initialize shader."),
        t.getProgramInfoLog(e) !== "" && console.warn("PixiJS Warning: gl.getProgramInfoLog()", t.getProgramInfoLog(e)))
}
const rce = {
    float: 1,
    vec2: 2,
    vec3: 3,
    vec4: 4,
    int: 1,
    ivec2: 2,
    ivec3: 3,
    ivec4: 4,
    uint: 1,
    uvec2: 2,
    uvec3: 3,
    uvec4: 4,
    bool: 1,
    bvec2: 2,
    bvec3: 3,
    bvec4: 4,
    mat2: 4,
    mat3: 9,
    mat4: 16,
    sampler2D: 1
};
function A6(t) {
    return rce[t]
}
let dp = null;
const zI = {
    FLOAT: "float",
    FLOAT_VEC2: "vec2",
    FLOAT_VEC3: "vec3",
    FLOAT_VEC4: "vec4",
    INT: "int",
    INT_VEC2: "ivec2",
    INT_VEC3: "ivec3",
    INT_VEC4: "ivec4",
    UNSIGNED_INT: "uint",
    UNSIGNED_INT_VEC2: "uvec2",
    UNSIGNED_INT_VEC3: "uvec3",
    UNSIGNED_INT_VEC4: "uvec4",
    BOOL: "bool",
    BOOL_VEC2: "bvec2",
    BOOL_VEC3: "bvec3",
    BOOL_VEC4: "bvec4",
    FLOAT_MAT2: "mat2",
    FLOAT_MAT3: "mat3",
    FLOAT_MAT4: "mat4",
    SAMPLER_2D: "sampler2D",
    INT_SAMPLER_2D: "sampler2D",
    UNSIGNED_INT_SAMPLER_2D: "sampler2D",
    SAMPLER_CUBE: "samplerCube",
    INT_SAMPLER_CUBE: "samplerCube",
    UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
    SAMPLER_2D_ARRAY: "sampler2DArray",
    INT_SAMPLER_2D_ARRAY: "sampler2DArray",
    UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
};
function k6(t, e) {
    if (!dp) {
        const n = Object.keys(zI);
        dp = {};
        for (let s = 0; s < n.length; ++s) {
            const r = n[s];
            dp[t[r]] = zI[r]
        }
    }
    return dp[e]
}
function qI(t, e, n) {
    if (t.substring(0, 9) !== "precision") {
        let s = e;
        return e === Er.HIGH && n !== Er.HIGH && (s = Er.MEDIUM),
            `precision ${s} float;
${t}`
    } else if (n !== Er.HIGH && t.substring(0, 15) === "precision highp")
        return t.replace("precision highp", "precision mediump");
    return t
}
let Rh;
function ice() {
    if (typeof Rh == "boolean")
        return Rh;
    try {
        Rh = new Function("param1", "param2", "param3", "return param1[param2] === param3;")({
            a: "b"
        }, "a", "b") === !0
    } catch {
        Rh = !1
    }
    return Rh
}
let oce = 0;
const fp = {}
    , Eb = class Hc {
        constructor(e, n, s = "pixi-shader", r = {}) {
            this.extra = {},
                this.id = oce++,
                this.vertexSrc = e || Hc.defaultVertexSrc,
                this.fragmentSrc = n || Hc.defaultFragmentSrc,
                this.vertexSrc = this.vertexSrc.trim(),
                this.fragmentSrc = this.fragmentSrc.trim(),
                this.extra = r,
                this.vertexSrc.substring(0, 8) !== "#version" && (s = s.replace(/\s+/g, "-"),
                    fp[s] ? (fp[s]++,
                        s += `-${fp[s]}`) : fp[s] = 1,
                    this.vertexSrc = `#define SHADER_NAME ${s}
${this.vertexSrc}`,
                    this.fragmentSrc = `#define SHADER_NAME ${s}
${this.fragmentSrc}`,
                    this.vertexSrc = qI(this.vertexSrc, Hc.defaultVertexPrecision, Er.HIGH),
                    this.fragmentSrc = qI(this.fragmentSrc, Hc.defaultFragmentPrecision, nce())),
                this.glPrograms = {},
                this.syncUniforms = null
        }
        static get defaultVertexSrc() {
            return Jle
        }
        static get defaultFragmentSrc() {
            return Kle
        }
        static from(e, n, s) {
            const r = e + n;
            let i = VI[r];
            return i || (VI[r] = i = new Hc(e, n, s)),
                i
        }
    }
    ;
Eb.defaultVertexPrecision = Er.HIGH,
    Eb.defaultFragmentPrecision = xo.apple.device ? Er.HIGH : Er.MEDIUM;
let So = Eb
    , ace = 0;
class ii {
    constructor(e, n, s) {
        this.group = !0,
            this.syncUniforms = {},
            this.dirtyId = 0,
            this.id = ace++,
            this.static = !!n,
            this.ubo = !!s,
            e instanceof _n ? (this.buffer = e,
                this.buffer.type = Gi.UNIFORM_BUFFER,
                this.autoManage = !1,
                this.ubo = !0) : (this.uniforms = e,
                    this.ubo && (this.buffer = new _n(new Float32Array(1)),
                        this.buffer.type = Gi.UNIFORM_BUFFER,
                        this.autoManage = !0))
    }
    update() {
        this.dirtyId++,
            !this.autoManage && this.buffer && this.buffer.update()
    }
    add(e, n, s) {
        if (!this.ubo)
            this.uniforms[e] = new ii(n, s);
        else
            throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them")
    }
    static from(e, n, s) {
        return new ii(e, n, s)
    }
    static uboFrom(e, n) {
        return new ii(e, n ?? !0, !0)
    }
}
class Hi {
    constructor(e, n) {
        this.uniformBindCount = 0,
            this.program = e,
            n ? n instanceof ii ? this.uniformGroup = n : this.uniformGroup = new ii(n) : this.uniformGroup = new ii({}),
            this.disposeRunner = new ri("disposeShader")
    }
    checkUniformExists(e, n) {
        if (n.uniforms[e])
            return !0;
        for (const s in n.uniforms) {
            const r = n.uniforms[s];
            if (r.group === !0 && this.checkUniformExists(e, r))
                return !0
        }
        return !1
    }
    destroy() {
        this.uniformGroup = null,
            this.disposeRunner.emit(this),
            this.disposeRunner.destroy()
    }
    get uniforms() {
        return this.uniformGroup.uniforms
    }
    static from(e, n, s) {
        const r = So.from(e, n);
        return new Hi(r, s)
    }
}
class lce {
    constructor(e, n) {
        if (this.vertexSrc = e,
            this.fragTemplate = n,
            this.programCache = {},
            this.defaultGroupCache = {},
            !n.includes("%count%"))
            throw new Error('Fragment template must contain "%count%".');
        if (!n.includes("%forloop%"))
            throw new Error('Fragment template must contain "%forloop%".')
    }
    generateShader(e) {
        if (!this.programCache[e]) {
            const s = new Int32Array(e);
            for (let i = 0; i < e; i++)
                s[i] = i;
            this.defaultGroupCache[e] = ii.from({
                uSamplers: s
            }, !0);
            let r = this.fragTemplate;
            r = r.replace(/%count%/gi, `${e}`),
                r = r.replace(/%forloop%/gi, this.generateSampleSrc(e)),
                this.programCache[e] = new So(this.vertexSrc, r)
        }
        const n = {
            tint: new Float32Array([1, 1, 1, 1]),
            translationMatrix: new Bt,
            default: this.defaultGroupCache[e]
        };
        return new Hi(this.programCache[e], n)
    }
    generateSampleSrc(e) {
        let n = "";
        n += `
`,
            n += `
`;
        for (let s = 0; s < e; s++)
            s > 0 && (n += `
else `),
                s < e - 1 && (n += `if(vTextureId < ${s}.5)`),
                n += `
{`,
                n += `
	color = texture2D(uSamplers[${s}], vTextureCoord);`,
                n += `
}`;
        return n += `
`,
            n += `
`,
            n
    }
}
class Tb {
    constructor() {
        this.elements = [],
            this.ids = [],
            this.count = 0
    }
    clear() {
        for (let e = 0; e < this.count; e++)
            this.elements[e] = null;
        this.count = 0
    }
}
function cce() {
    return !xo.apple.device
}
function uce(t) {
    let e = !0;
    const n = Le.ADAPTER.getNavigator();
    if (xo.tablet || xo.phone) {
        if (xo.apple.device) {
            const s = n.userAgent.match(/OS (\d+)_(\d+)?/);
            s && parseInt(s[1], 10) < 11 && (e = !1)
        }
        if (xo.android.device) {
            const s = n.userAgent.match(/Android\s([0-9.]*)/);
            s && parseInt(s[1], 10) < 7 && (e = !1)
        }
    }
    return e ? t : 4
}
class O_ {
    constructor(e) {
        this.renderer = e
    }
    flush() { }
    destroy() {
        this.renderer = null
    }
    start() { }
    stop() {
        this.flush()
    }
    render(e) { }
}
var hce = `varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;
uniform sampler2D uSamplers[%count%];

void main(void){
    vec4 color;
    %forloop%
    gl_FragColor = color * vColor;
}
`
    , dce = `precision highp float;
attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;
attribute float aTextureId;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform vec4 tint;

varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;

void main(void){
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vTextureId = aTextureId;
    vColor = aColor * tint;
}
`;
const Oh = class Vr extends O_ {
    constructor(e) {
        super(e),
            this.setShaderGenerator(),
            this.geometryClass = E6,
            this.vertexSize = 6,
            this.state = Ji.for2d(),
            this.size = Vr.defaultBatchSize * 4,
            this._vertexCount = 0,
            this._indexCount = 0,
            this._bufferedElements = [],
            this._bufferedTextures = [],
            this._bufferSize = 0,
            this._shader = null,
            this._packedGeometries = [],
            this._packedGeometryPoolSize = 2,
            this._flushId = 0,
            this._aBuffers = {},
            this._iBuffers = {},
            this.maxTextures = 1,
            this.renderer.on("prerender", this.onPrerender, this),
            e.runners.contextChange.add(this),
            this._dcIndex = 0,
            this._aIndex = 0,
            this._iIndex = 0,
            this._attributeBuffer = null,
            this._indexBuffer = null,
            this._tempBoundTextures = []
    }
    static get defaultMaxTextures() {
        return this._defaultMaxTextures = this._defaultMaxTextures ?? uce(32),
            this._defaultMaxTextures
    }
    static set defaultMaxTextures(e) {
        this._defaultMaxTextures = e
    }
    static get canUploadSameBuffer() {
        return this._canUploadSameBuffer = this._canUploadSameBuffer ?? cce(),
            this._canUploadSameBuffer
    }
    static set canUploadSameBuffer(e) {
        this._canUploadSameBuffer = e
    }
    get MAX_TEXTURES() {
        return dt("7.1.0", "BatchRenderer#MAX_TEXTURES renamed to BatchRenderer#maxTextures"),
            this.maxTextures
    }
    static get defaultVertexSrc() {
        return dce
    }
    static get defaultFragmentTemplate() {
        return hce
    }
    setShaderGenerator({ vertex: e = Vr.defaultVertexSrc, fragment: n = Vr.defaultFragmentTemplate } = {}) {
        this.shaderGenerator = new lce(e, n)
    }
    contextChange() {
        const e = this.renderer.gl;
        Le.PREFER_ENV === wc.WEBGL_LEGACY ? this.maxTextures = 1 : (this.maxTextures = Math.min(e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS), Vr.defaultMaxTextures),
            this.maxTextures = Ule(this.maxTextures, e)),
            this._shader = this.shaderGenerator.generateShader(this.maxTextures);
        for (let n = 0; n < this._packedGeometryPoolSize; n++)
            this._packedGeometries[n] = new this.geometryClass;
        this.initFlushBuffers()
    }
    initFlushBuffers() {
        const { _drawCallPool: e, _textureArrayPool: n } = Vr
            , s = this.size / 4
            , r = Math.floor(s / this.maxTextures) + 1;
        for (; e.length < s;)
            e.push(new xb);
        for (; n.length < r;)
            n.push(new Tb);
        for (let i = 0; i < this.maxTextures; i++)
            this._tempBoundTextures[i] = null
    }
    onPrerender() {
        this._flushId = 0
    }
    render(e) {
        e._texture.valid && (this._vertexCount + e.vertexData.length / 2 > this.size && this.flush(),
            this._vertexCount += e.vertexData.length / 2,
            this._indexCount += e.indices.length,
            this._bufferedTextures[this._bufferSize] = e._texture.baseTexture,
            this._bufferedElements[this._bufferSize++] = e)
    }
    buildTexturesAndDrawCalls() {
        const { _bufferedTextures: e, maxTextures: n } = this
            , s = Vr._textureArrayPool
            , r = this.renderer.batch
            , i = this._tempBoundTextures
            , o = this.renderer.textureGC.count;
        let l = ++st._globalBatch
            , a = 0
            , c = s[0]
            , u = 0;
        r.copyBoundTextures(i, n);
        for (let h = 0; h < this._bufferSize; ++h) {
            const d = e[h];
            e[h] = null,
                d._batchEnabled !== l && (c.count >= n && (r.boundArray(c, i, l, n),
                    this.buildDrawCalls(c, u, h),
                    u = h,
                    c = s[++a],
                    ++l),
                    d._batchEnabled = l,
                    d.touched = o,
                    c.elements[c.count++] = d)
        }
        c.count > 0 && (r.boundArray(c, i, l, n),
            this.buildDrawCalls(c, u, this._bufferSize),
            ++a,
            ++l);
        for (let h = 0; h < i.length; h++)
            i[h] = null;
        st._globalBatch = l
    }
    buildDrawCalls(e, n, s) {
        const { _bufferedElements: r, _attributeBuffer: i, _indexBuffer: o, vertexSize: l } = this
            , a = Vr._drawCallPool;
        let c = this._dcIndex
            , u = this._aIndex
            , h = this._iIndex
            , d = a[c];
        d.start = this._iIndex,
            d.texArray = e;
        for (let f = n; f < s; ++f) {
            const p = r[f]
                , m = p._texture.baseTexture
                , g = v6[m.alphaMode ? 1 : 0][p.blendMode];
            r[f] = null,
                n < f && d.blend !== g && (d.size = h - d.start,
                    n = f,
                    d = a[++c],
                    d.texArray = e,
                    d.start = h),
                this.packInterleavedGeometry(p, i, o, u, h),
                u += p.vertexData.length / 2 * l,
                h += p.indices.length,
                d.blend = g
        }
        n < s && (d.size = h - d.start,
            ++c),
            this._dcIndex = c,
            this._aIndex = u,
            this._iIndex = h
    }
    bindAndClearTexArray(e) {
        const n = this.renderer.texture;
        for (let s = 0; s < e.count; s++)
            n.bind(e.elements[s], e.ids[s]),
                e.elements[s] = null;
        e.count = 0
    }
    updateGeometry() {
        const { _packedGeometries: e, _attributeBuffer: n, _indexBuffer: s } = this;
        Vr.canUploadSameBuffer ? (e[this._flushId]._buffer.update(n.rawBinaryData),
            e[this._flushId]._indexBuffer.update(s),
            this.renderer.geometry.updateBuffers()) : (this._packedGeometryPoolSize <= this._flushId && (this._packedGeometryPoolSize++,
                e[this._flushId] = new this.geometryClass),
                e[this._flushId]._buffer.update(n.rawBinaryData),
                e[this._flushId]._indexBuffer.update(s),
                this.renderer.geometry.bind(e[this._flushId]),
                this.renderer.geometry.updateBuffers(),
                this._flushId++)
    }
    drawBatches() {
        const e = this._dcIndex
            , { gl: n, state: s } = this.renderer
            , r = Vr._drawCallPool;
        let i = null;
        for (let o = 0; o < e; o++) {
            const { texArray: l, type: a, size: c, start: u, blend: h } = r[o];
            i !== l && (i = l,
                this.bindAndClearTexArray(l)),
                this.state.blendMode = h,
                s.set(this.state),
                n.drawElements(a, c, n.UNSIGNED_SHORT, u * 2)
        }
    }
    flush() {
        this._vertexCount !== 0 && (this._attributeBuffer = this.getAttributeBuffer(this._vertexCount),
            this._indexBuffer = this.getIndexBuffer(this._indexCount),
            this._aIndex = 0,
            this._iIndex = 0,
            this._dcIndex = 0,
            this.buildTexturesAndDrawCalls(),
            this.updateGeometry(),
            this.drawBatches(),
            this._bufferSize = 0,
            this._vertexCount = 0,
            this._indexCount = 0)
    }
    start() {
        this.renderer.state.set(this.state),
            this.renderer.texture.ensureSamplerType(this.maxTextures),
            this.renderer.shader.bind(this._shader),
            Vr.canUploadSameBuffer && this.renderer.geometry.bind(this._packedGeometries[this._flushId])
    }
    stop() {
        this.flush()
    }
    destroy() {
        for (let e = 0; e < this._packedGeometryPoolSize; e++)
            this._packedGeometries[e] && this._packedGeometries[e].destroy();
        this.renderer.off("prerender", this.onPrerender, this),
            this._aBuffers = null,
            this._iBuffers = null,
            this._packedGeometries = null,
            this._attributeBuffer = null,
            this._indexBuffer = null,
            this._shader && (this._shader.destroy(),
                this._shader = null),
            super.destroy()
    }
    getAttributeBuffer(e) {
        const n = zm(Math.ceil(e / 8))
            , s = $I(n)
            , r = n * 8;
        this._aBuffers.length <= s && (this._iBuffers.length = s + 1);
        let i = this._aBuffers[r];
        return i || (this._aBuffers[r] = i = new yb(r * this.vertexSize * 4)),
            i
    }
    getIndexBuffer(e) {
        const n = zm(Math.ceil(e / 12))
            , s = $I(n)
            , r = n * 12;
        this._iBuffers.length <= s && (this._iBuffers.length = s + 1);
        let i = this._iBuffers[s];
        return i || (this._iBuffers[s] = i = new Uint16Array(r)),
            i
    }
    packInterleavedGeometry(e, n, s, r, i) {
        const { uint32View: o, float32View: l } = n
            , a = r / this.vertexSize
            , c = e.uvs
            , u = e.indices
            , h = e.vertexData
            , d = e._texture.baseTexture._batchLocation
            , f = Math.min(e.worldAlpha, 1)
            , p = Yt.shared.setValue(e._tintRGB).toPremultiplied(f, e._texture.baseTexture.alphaMode > 0);
        for (let m = 0; m < h.length; m += 2)
            l[r++] = h[m],
                l[r++] = h[m + 1],
                l[r++] = c[m],
                l[r++] = c[m + 1],
                o[r++] = p,
                l[r++] = d;
        for (let m = 0; m < u.length; m++)
            s[i++] = a + u[m]
    }
}
    ;
Oh.defaultBatchSize = 4096,
    Oh.extension = {
        name: "batch",
        type: Ae.RendererPlugin
    },
    Oh._drawCallPool = [],
    Oh._textureArrayPool = [];
let El = Oh;
Ue.add(El);
var fce = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;

void main(void){
   gl_FragColor = texture2D(uSampler, vTextureCoord);
}
`
    , pce = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`;
const Cb = class Nh extends Hi {
    constructor(e, n, s) {
        const r = So.from(e || Nh.defaultVertexSrc, n || Nh.defaultFragmentSrc);
        super(r, s),
            this.padding = 0,
            this.resolution = Nh.defaultResolution,
            this.multisample = Nh.defaultMultisample,
            this.enabled = !0,
            this.autoFit = !0,
            this.state = new Ji
    }
    apply(e, n, s, r, i) {
        e.applyFilter(this, n, s, r)
    }
    get blendMode() {
        return this.state.blendMode
    }
    set blendMode(e) {
        this.state.blendMode = e
    }
    get resolution() {
        return this._resolution
    }
    set resolution(e) {
        this._resolution = e
    }
    static get defaultVertexSrc() {
        return pce
    }
    static get defaultFragmentSrc() {
        return fce
    }
}
    ;
Cb.defaultResolution = 1,
    Cb.defaultMultisample = En.NONE;
let As = Cb;
class Jm {
    constructor() {
        this.clearBeforeRender = !0,
            this._backgroundColor = new Yt(0),
            this.alpha = 1
    }
    init(e) {
        this.clearBeforeRender = e.clearBeforeRender;
        const { backgroundColor: n, background: s, backgroundAlpha: r } = e
            , i = s ?? n;
        i !== void 0 && (this.color = i),
            this.alpha = r
    }
    get color() {
        return this._backgroundColor.value
    }
    set color(e) {
        this._backgroundColor.setValue(e)
    }
    get alpha() {
        return this._backgroundColor.alpha
    }
    set alpha(e) {
        this._backgroundColor.setAlpha(e)
    }
    get backgroundColor() {
        return this._backgroundColor
    }
    destroy() { }
}
Jm.defaultOptions = {
    backgroundAlpha: 1,
    backgroundColor: 0,
    clearBeforeRender: !0
},
    Jm.extension = {
        type: [Ae.RendererSystem, Ae.CanvasRendererSystem],
        name: "background"
    };
Ue.add(Jm);
class R6 {
    constructor(e) {
        this.renderer = e,
            this.emptyRenderer = new O_(e),
            this.currentRenderer = this.emptyRenderer
    }
    setObjectRenderer(e) {
        this.currentRenderer !== e && (this.currentRenderer.stop(),
            this.currentRenderer = e,
            this.currentRenderer.start())
    }
    flush() {
        this.setObjectRenderer(this.emptyRenderer)
    }
    reset() {
        this.setObjectRenderer(this.emptyRenderer)
    }
    copyBoundTextures(e, n) {
        const { boundTextures: s } = this.renderer.texture;
        for (let r = n - 1; r >= 0; --r)
            e[r] = s[r] || null,
                e[r] && (e[r]._batchLocation = r)
    }
    boundArray(e, n, s, r) {
        const { elements: i, ids: o, count: l } = e;
        let a = 0;
        for (let c = 0; c < l; c++) {
            const u = i[c]
                , h = u._batchLocation;
            if (h >= 0 && h < r && n[h] === u) {
                o[c] = h;
                continue
            }
            for (; a < r;) {
                const d = n[a];
                if (d && d._batchEnabled === s && d._batchLocation === a) {
                    a++;
                    continue
                }
                o[c] = a,
                    u._batchLocation = a,
                    n[a] = u;
                break
            }
        }
    }
    destroy() {
        this.renderer = null
    }
}
R6.extension = {
    type: Ae.RendererSystem,
    name: "batch"
};
Ue.add(R6);
let KI = 0;
class Zm {
    constructor(e) {
        this.renderer = e,
            this.webGLVersion = 1,
            this.extensions = {},
            this.supports = {
                uint32Indices: !1
            },
            this.handleContextLost = this.handleContextLost.bind(this),
            this.handleContextRestored = this.handleContextRestored.bind(this)
    }
    get isLost() {
        return !this.gl || this.gl.isContextLost()
    }
    contextChange(e) {
        this.gl = e,
            this.renderer.gl = e,
            this.renderer.CONTEXT_UID = KI++
    }
    init(e) {
        if (e.context)
            this.initFromContext(e.context);
        else {
            const n = this.renderer.background.alpha < 1
                , s = e.premultipliedAlpha;
            this.preserveDrawingBuffer = e.preserveDrawingBuffer,
                this.useContextAlpha = e.useContextAlpha,
                this.powerPreference = e.powerPreference,
                this.initFromOptions({
                    alpha: n,
                    premultipliedAlpha: s,
                    antialias: e.antialias,
                    stencil: !0,
                    preserveDrawingBuffer: e.preserveDrawingBuffer,
                    powerPreference: e.powerPreference
                })
        }
    }
    initFromContext(e) {
        this.gl = e,
            this.validateContext(e),
            this.renderer.gl = e,
            this.renderer.CONTEXT_UID = KI++,
            this.renderer.runners.contextChange.emit(e);
        const n = this.renderer.view;
        n.addEventListener !== void 0 && (n.addEventListener("webglcontextlost", this.handleContextLost, !1),
            n.addEventListener("webglcontextrestored", this.handleContextRestored, !1))
    }
    initFromOptions(e) {
        const n = this.createContext(this.renderer.view, e);
        this.initFromContext(n)
    }
    createContext(e, n) {
        let s;
        if (Le.PREFER_ENV >= wc.WEBGL2 && (s = e.getContext("webgl2", n)),
            s)
            this.webGLVersion = 2;
        else if (this.webGLVersion = 1,
            s = e.getContext("webgl", n) || e.getContext("experimental-webgl", n),
            !s)
            throw new Error("This browser does not support WebGL. Try using the canvas renderer");
        return this.gl = s,
            this.getExtensions(),
            this.gl
    }
    getExtensions() {
        const { gl: e } = this
            , n = {
                loseContext: e.getExtension("WEBGL_lose_context"),
                anisotropicFiltering: e.getExtension("EXT_texture_filter_anisotropic"),
                floatTextureLinear: e.getExtension("OES_texture_float_linear"),
                s3tc: e.getExtension("WEBGL_compressed_texture_s3tc"),
                s3tc_sRGB: e.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
                etc: e.getExtension("WEBGL_compressed_texture_etc"),
                etc1: e.getExtension("WEBGL_compressed_texture_etc1"),
                pvrtc: e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
                atc: e.getExtension("WEBGL_compressed_texture_atc"),
                astc: e.getExtension("WEBGL_compressed_texture_astc"),
                bptc: e.getExtension("EXT_texture_compression_bptc")
            };
        this.webGLVersion === 1 ? Object.assign(this.extensions, n, {
            drawBuffers: e.getExtension("WEBGL_draw_buffers"),
            depthTexture: e.getExtension("WEBGL_depth_texture"),
            vertexArrayObject: e.getExtension("OES_vertex_array_object") || e.getExtension("MOZ_OES_vertex_array_object") || e.getExtension("WEBKIT_OES_vertex_array_object"),
            uint32ElementIndex: e.getExtension("OES_element_index_uint"),
            floatTexture: e.getExtension("OES_texture_float"),
            floatTextureLinear: e.getExtension("OES_texture_float_linear"),
            textureHalfFloat: e.getExtension("OES_texture_half_float"),
            textureHalfFloatLinear: e.getExtension("OES_texture_half_float_linear")
        }) : this.webGLVersion === 2 && Object.assign(this.extensions, n, {
            colorBufferFloat: e.getExtension("EXT_color_buffer_float")
        })
    }
    handleContextLost(e) {
        e.preventDefault(),
            setTimeout(() => {
                this.gl.isContextLost() && this.extensions.loseContext && this.extensions.loseContext.restoreContext()
            }
                , 0)
    }
    handleContextRestored() {
        this.renderer.runners.contextChange.emit(this.gl)
    }
    destroy() {
        const e = this.renderer.view;
        this.renderer = null,
            e.removeEventListener !== void 0 && (e.removeEventListener("webglcontextlost", this.handleContextLost),
                e.removeEventListener("webglcontextrestored", this.handleContextRestored)),
            this.gl.useProgram(null),
            this.extensions.loseContext && this.extensions.loseContext.loseContext()
    }
    postrender() {
        this.renderer.objectRenderer.renderingToScreen && this.gl.flush()
    }
    validateContext(e) {
        const n = e.getContextAttributes()
            , s = "WebGL2RenderingContext" in globalThis && e instanceof globalThis.WebGL2RenderingContext;
        s && (this.webGLVersion = 2),
            n && !n.stencil && console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
        const r = s || !!e.getExtension("OES_element_index_uint");
        this.supports.uint32Indices = r,
            r || console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly")
    }
}
Zm.defaultOptions = {
    context: null,
    antialias: !1,
    premultipliedAlpha: !0,
    preserveDrawingBuffer: !1,
    powerPreference: "default"
},
    Zm.extension = {
        type: Ae.RendererSystem,
        name: "context"
    };
Ue.add(Zm);
class Ib {
    constructor(e, n) {
        if (this.width = Math.round(e),
            this.height = Math.round(n),
            !this.width || !this.height)
            throw new Error("Framebuffer width or height is zero");
        this.stencil = !1,
            this.depth = !1,
            this.dirtyId = 0,
            this.dirtyFormat = 0,
            this.dirtySize = 0,
            this.depthTexture = null,
            this.colorTextures = [],
            this.glFramebuffers = {},
            this.disposeRunner = new ri("disposeFramebuffer"),
            this.multisample = En.NONE
    }
    get colorTexture() {
        return this.colorTextures[0]
    }
    addColorTexture(e = 0, n) {
        return this.colorTextures[e] = n || new st(null, {
            scaleMode: ar.NEAREST,
            resolution: 1,
            mipmap: ci.OFF,
            width: this.width,
            height: this.height
        }),
            this.dirtyId++,
            this.dirtyFormat++,
            this
    }
    addDepthTexture(e) {
        return this.depthTexture = e || new st(null, {
            scaleMode: ar.NEAREST,
            resolution: 1,
            width: this.width,
            height: this.height,
            mipmap: ci.OFF,
            format: Ee.DEPTH_COMPONENT,
            type: Ge.UNSIGNED_SHORT
        }),
            this.dirtyId++,
            this.dirtyFormat++,
            this
    }
    enableDepth() {
        return this.depth = !0,
            this.dirtyId++,
            this.dirtyFormat++,
            this
    }
    enableStencil() {
        return this.stencil = !0,
            this.dirtyId++,
            this.dirtyFormat++,
            this
    }
    resize(e, n) {
        if (e = Math.round(e),
            n = Math.round(n),
            !e || !n)
            throw new Error("Framebuffer width and height must not be zero");
        if (!(e === this.width && n === this.height)) {
            this.width = e,
                this.height = n,
                this.dirtyId++,
                this.dirtySize++;
            for (let s = 0; s < this.colorTextures.length; s++) {
                const r = this.colorTextures[s]
                    , i = r.resolution;
                r.setSize(e / i, n / i)
            }
            if (this.depthTexture) {
                const s = this.depthTexture.resolution;
                this.depthTexture.setSize(e / s, n / s)
            }
        }
    }
    dispose() {
        this.disposeRunner.emit(this, !1)
    }
    destroyDepthTexture() {
        this.depthTexture && (this.depthTexture.destroy(),
            this.depthTexture = null,
            ++this.dirtyId,
            ++this.dirtyFormat)
    }
}
class M6 extends st {
    constructor(e = {}) {
        if (typeof e == "number") {
            const n = arguments[0]
                , s = arguments[1]
                , r = arguments[2]
                , i = arguments[3];
            e = {
                width: n,
                height: s,
                scaleMode: r,
                resolution: i
            }
        }
        e.width = e.width ?? 100,
            e.height = e.height ?? 100,
            e.multisample ?? (e.multisample = En.NONE),
            super(null, e),
            this.mipmap = ci.OFF,
            this.valid = !0,
            this._clear = new Yt([0, 0, 0, 0]),
            this.framebuffer = new Ib(this.realWidth, this.realHeight).addColorTexture(0, this),
            this.framebuffer.multisample = e.multisample,
            this.maskStack = [],
            this.filterStack = [{}]
    }
    set clearColor(e) {
        this._clear.setValue(e)
    }
    get clearColor() {
        return this._clear.value
    }
    get clear() {
        return this._clear
    }
    get multisample() {
        return this.framebuffer.multisample
    }
    set multisample(e) {
        this.framebuffer.multisample = e
    }
    resize(e, n) {
        this.framebuffer.resize(e * this.resolution, n * this.resolution),
            this.setRealSize(this.framebuffer.width, this.framebuffer.height)
    }
    dispose() {
        this.framebuffer.dispose(),
            super.dispose()
    }
    destroy() {
        super.destroy(),
            this.framebuffer.destroyDepthTexture(),
            this.framebuffer = null
    }
}
class Go extends Bd {
    constructor(e) {
        const n = e
            , s = n.naturalWidth || n.videoWidth || n.displayWidth || n.width
            , r = n.naturalHeight || n.videoHeight || n.displayHeight || n.height;
        super(s, r),
            this.source = e,
            this.noSubImage = !1
    }
    static crossOrigin(e, n, s) {
        s === void 0 && !n.startsWith("data:") ? e.crossOrigin = Ble(n) : s !== !1 && (e.crossOrigin = typeof s == "string" ? s : "anonymous")
    }
    upload(e, n, s, r) {
        const i = e.gl
            , o = n.realWidth
            , l = n.realHeight;
        if (r = r || this.source,
            typeof HTMLImageElement < "u" && r instanceof HTMLImageElement) {
            if (!r.complete || r.naturalWidth === 0)
                return !1
        } else if (typeof HTMLVideoElement < "u" && r instanceof HTMLVideoElement && r.readyState <= 1)
            return !1;
        return i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, n.alphaMode === Is.UNPACK),
            !this.noSubImage && n.target === i.TEXTURE_2D && s.width === o && s.height === l ? i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, n.format, s.type, r) : (s.width = o,
                s.height = l,
                i.texImage2D(n.target, 0, s.internalFormat, n.format, s.type, r)),
            !0
    }
    update() {
        if (this.destroyed)
            return;
        const e = this.source
            , n = e.naturalWidth || e.videoWidth || e.width
            , s = e.naturalHeight || e.videoHeight || e.height;
        this.resize(n, s),
            super.update()
    }
    dispose() {
        this.source = null
    }
}
class P6 extends Go {
    constructor(e, n) {
        if (n = n || {},
            typeof e == "string") {
            const s = new Image;
            Go.crossOrigin(s, e, n.crossorigin),
                s.src = e,
                e = s
        }
        super(e),
            !e.complete && this._width && this._height && (this._width = 0,
                this._height = 0),
            this.url = e.src,
            this._process = null,
            this.preserveBitmap = !1,
            this.createBitmap = (n.createBitmap ?? Le.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap,
            this.alphaMode = typeof n.alphaMode == "number" ? n.alphaMode : null,
            this.bitmap = null,
            this._load = null,
            n.autoLoad !== !1 && this.load()
    }
    load(e) {
        return this._load ? this._load : (e !== void 0 && (this.createBitmap = e),
            this._load = new Promise((n, s) => {
                const r = this.source;
                this.url = r.src;
                const i = () => {
                    this.destroyed || (r.onload = null,
                        r.onerror = null,
                        this.update(),
                        this._load = null,
                        this.createBitmap ? n(this.process()) : n(this))
                }
                    ;
                r.complete && r.src ? i() : (r.onload = i,
                    r.onerror = o => {
                        s(o),
                            this.onError.emit(o)
                    }
                )
            }
            ),
            this._load)
    }
    process() {
        const e = this.source;
        if (this._process !== null)
            return this._process;
        if (this.bitmap !== null || !globalThis.createImageBitmap)
            return Promise.resolve(this);
        const n = globalThis.createImageBitmap
            , s = !e.crossOrigin || e.crossOrigin === "anonymous";
        return this._process = fetch(e.src, {
            mode: s ? "cors" : "no-cors"
        }).then(r => r.blob()).then(r => n(r, 0, 0, e.width, e.height, {
            premultiplyAlpha: this.alphaMode === null || this.alphaMode === Is.UNPACK ? "premultiply" : "none"
        })).then(r => this.destroyed ? Promise.reject() : (this.bitmap = r,
            this.update(),
            this._process = null,
            Promise.resolve(this))),
            this._process
    }
    upload(e, n, s) {
        if (typeof this.alphaMode == "number" && (n.alphaMode = this.alphaMode),
            !this.createBitmap)
            return super.upload(e, n, s);
        if (!this.bitmap && (this.process(),
            !this.bitmap))
            return !1;
        if (super.upload(e, n, s, this.bitmap),
            !this.preserveBitmap) {
            let r = !0;
            const i = n._glTextures;
            for (const o in i) {
                const l = i[o];
                if (l !== s && l.dirtyId !== n.dirtyId) {
                    r = !1;
                    break
                }
            }
            r && (this.bitmap.close && this.bitmap.close(),
                this.bitmap = null)
        }
        return !0
    }
    dispose() {
        this.source.onload = null,
            this.source.onerror = null,
            super.dispose(),
            this.bitmap && (this.bitmap.close(),
                this.bitmap = null),
            this._process = null,
            this._load = null
    }
    static test(e) {
        return typeof HTMLImageElement < "u" && (typeof e == "string" || e instanceof HTMLImageElement)
    }
}
class iw {
    constructor() {
        this.x0 = 0,
            this.y0 = 0,
            this.x1 = 1,
            this.y1 = 0,
            this.x2 = 1,
            this.y2 = 1,
            this.x3 = 0,
            this.y3 = 1,
            this.uvsFloat32 = new Float32Array(8)
    }
    set(e, n, s) {
        const r = n.width
            , i = n.height;
        if (s) {
            const o = e.width / 2 / r
                , l = e.height / 2 / i
                , a = e.x / r + o
                , c = e.y / i + l;
            s = sn.add(s, sn.NW),
                this.x0 = a + o * sn.uX(s),
                this.y0 = c + l * sn.uY(s),
                s = sn.add(s, 2),
                this.x1 = a + o * sn.uX(s),
                this.y1 = c + l * sn.uY(s),
                s = sn.add(s, 2),
                this.x2 = a + o * sn.uX(s),
                this.y2 = c + l * sn.uY(s),
                s = sn.add(s, 2),
                this.x3 = a + o * sn.uX(s),
                this.y3 = c + l * sn.uY(s)
        } else
            this.x0 = e.x / r,
                this.y0 = e.y / i,
                this.x1 = (e.x + e.width) / r,
                this.y1 = e.y / i,
                this.x2 = (e.x + e.width) / r,
                this.y2 = (e.y + e.height) / i,
                this.x3 = e.x / r,
                this.y3 = (e.y + e.height) / i;
        this.uvsFloat32[0] = this.x0,
            this.uvsFloat32[1] = this.y0,
            this.uvsFloat32[2] = this.x1,
            this.uvsFloat32[3] = this.y1,
            this.uvsFloat32[4] = this.x2,
            this.uvsFloat32[5] = this.y2,
            this.uvsFloat32[6] = this.x3,
            this.uvsFloat32[7] = this.y3
    }
}
iw.prototype.toString = function () {
    return `[@pixi/core:TextureUvs x0=${this.x0} y0=${this.y0} x1=${this.x1} y1=${this.y1} x2=${this.x2} y2=${this.y2} x3=${this.x3} y3=${this.y3}]`
}
    ;
const JI = new iw;
function pp(t) {
    t.destroy = function () { }
        ,
        t.on = function () { }
        ,
        t.once = function () { }
        ,
        t.emit = function () { }
}
class $e extends yf {
    constructor(e, n, s, r, i, o, l) {
        if (super(),
            this.noFrame = !1,
            n || (this.noFrame = !0,
                n = new nt(0, 0, 1, 1)),
            e instanceof $e && (e = e.baseTexture),
            this.baseTexture = e,
            this._frame = n,
            this.trim = r,
            this.valid = !1,
            this.destroyed = !1,
            this._uvs = JI,
            this.uvMatrix = null,
            this.orig = s || n,
            this._rotate = Number(i || 0),
            i === !0)
            this._rotate = 2;
        else if (this._rotate % 2 !== 0)
            throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
        this.defaultAnchor = o ? new At(o.x, o.y) : new At(0, 0),
            this.defaultBorders = l,
            this._updateID = 0,
            this.textureCacheIds = [],
            e.valid ? this.noFrame ? e.valid && this.onBaseTextureUpdated(e) : this.frame = n : e.once("loaded", this.onBaseTextureUpdated, this),
            this.noFrame && e.on("update", this.onBaseTextureUpdated, this)
    }
    update() {
        this.baseTexture.resource && this.baseTexture.resource.update()
    }
    onBaseTextureUpdated(e) {
        if (this.noFrame) {
            if (!this.baseTexture.valid)
                return;
            this._frame.width = e.width,
                this._frame.height = e.height,
                this.valid = !0,
                this.updateUvs()
        } else
            this.frame = this._frame;
        this.emit("update", this)
    }
    destroy(e) {
        if (this.baseTexture) {
            if (e) {
                const { resource: n } = this.baseTexture;
                n != null && n.url && Ti[n.url] && $e.removeFromCache(n.url),
                    this.baseTexture.destroy()
            }
            this.baseTexture.off("loaded", this.onBaseTextureUpdated, this),
                this.baseTexture.off("update", this.onBaseTextureUpdated, this),
                this.baseTexture = null
        }
        this._frame = null,
            this._uvs = null,
            this.trim = null,
            this.orig = null,
            this.valid = !1,
            $e.removeFromCache(this),
            this.textureCacheIds = null,
            this.destroyed = !0,
            this.emit("destroyed", this),
            this.removeAllListeners()
    }
    clone() {
        var r;
        const e = this._frame.clone()
            , n = this._frame === this.orig ? e : this.orig.clone()
            , s = new $e(this.baseTexture, !this.noFrame && e, n, (r = this.trim) == null ? void 0 : r.clone(), this.rotate, this.defaultAnchor, this.defaultBorders);
        return this.noFrame && (s._frame = e),
            s
    }
    updateUvs() {
        this._uvs === JI && (this._uvs = new iw),
            this._uvs.set(this._frame, this.baseTexture, this.rotate),
            this._updateID++
    }
    static from(e, n = {}, s = Le.STRICT_TEXTURE_CACHE) {
        const r = typeof e == "string";
        let i = null;
        if (r)
            i = e;
        else if (e instanceof st) {
            if (!e.cacheId) {
                const l = (n == null ? void 0 : n.pixiIdPrefix) || "pixiid";
                e.cacheId = `${l}-${lc()}`,
                    st.addToCache(e, e.cacheId)
            }
            i = e.cacheId
        } else {
            if (!e._pixiId) {
                const l = (n == null ? void 0 : n.pixiIdPrefix) || "pixiid";
                e._pixiId = `${l}_${lc()}`
            }
            i = e._pixiId
        }
        let o = Ti[i];
        if (r && s && !o)
            throw new Error(`The cacheId "${i}" does not exist in TextureCache.`);
        return !o && !(e instanceof st) ? (n.resolution || (n.resolution = Vo(e)),
            o = new $e(new st(e, n)),
            o.baseTexture.cacheId = i,
            st.addToCache(o.baseTexture, i),
            $e.addToCache(o, i)) : !o && e instanceof st && (o = new $e(e),
                $e.addToCache(o, i)),
            o
    }
    static fromURL(e, n) {
        const s = Object.assign({
            autoLoad: !1
        }, n == null ? void 0 : n.resourceOptions)
            , r = $e.from(e, Object.assign({
                resourceOptions: s
            }, n), !1)
            , i = r.baseTexture.resource;
        return r.baseTexture.valid ? Promise.resolve(r) : i.load().then(() => Promise.resolve(r))
    }
    static fromBuffer(e, n, s, r) {
        return new $e(st.fromBuffer(e, n, s, r))
    }
    static fromLoader(e, n, s, r) {
        const i = new st(e, Object.assign({
            scaleMode: st.defaultOptions.scaleMode,
            resolution: Vo(n)
        }, r))
            , { resource: o } = i;
        o instanceof P6 && (o.url = n);
        const l = new $e(i);
        return s || (s = n),
            st.addToCache(l.baseTexture, s),
            $e.addToCache(l, s),
            s !== n && (st.addToCache(l.baseTexture, n),
                $e.addToCache(l, n)),
            l.baseTexture.valid ? Promise.resolve(l) : new Promise(a => {
                l.baseTexture.once("loaded", () => a(l))
            }
            )
    }
    static addToCache(e, n) {
        n && (e.textureCacheIds.includes(n) || e.textureCacheIds.push(n),
            Ti[n] && Ti[n] !== e && console.warn(`Texture added to the cache with an id [${n}] that already had an entry`),
            Ti[n] = e)
    }
    static removeFromCache(e) {
        if (typeof e == "string") {
            const n = Ti[e];
            if (n) {
                const s = n.textureCacheIds.indexOf(e);
                return s > -1 && n.textureCacheIds.splice(s, 1),
                    delete Ti[e],
                    n
            }
        } else if (e != null && e.textureCacheIds) {
            for (let n = 0; n < e.textureCacheIds.length; ++n)
                Ti[e.textureCacheIds[n]] === e && delete Ti[e.textureCacheIds[n]];
            return e.textureCacheIds.length = 0,
                e
        }
        return null
    }
    get resolution() {
        return this.baseTexture.resolution
    }
    get frame() {
        return this._frame
    }
    set frame(e) {
        this._frame = e,
            this.noFrame = !1;
        const { x: n, y: s, width: r, height: i } = e
            , o = n + r > this.baseTexture.width
            , l = s + i > this.baseTexture.height;
        if (o || l) {
            const a = o && l ? "and" : "or"
                , c = `X: ${n} + ${r} = ${n + r} > ${this.baseTexture.width}`
                , u = `Y: ${s} + ${i} = ${s + i} > ${this.baseTexture.height}`;
            throw new Error(`Texture Error: frame does not fit inside the base Texture dimensions: ${c} ${a} ${u}`)
        }
        this.valid = r && i && this.baseTexture.valid,
            !this.trim && !this.rotate && (this.orig = e),
            this.valid && this.updateUvs()
    }
    get rotate() {
        return this._rotate
    }
    set rotate(e) {
        this._rotate = e,
            this.valid && this.updateUvs()
    }
    get width() {
        return this.orig.width
    }
    get height() {
        return this.orig.height
    }
    castToBaseTexture() {
        return this.baseTexture
    }
    static get EMPTY() {
        return $e._EMPTY || ($e._EMPTY = new $e(new st),
            pp($e._EMPTY),
            pp($e._EMPTY.baseTexture)),
            $e._EMPTY
    }
    static get WHITE() {
        if (!$e._WHITE) {
            const e = Le.ADAPTER.createCanvas(16, 16)
                , n = e.getContext("2d");
            e.width = 16,
                e.height = 16,
                n.fillStyle = "white",
                n.fillRect(0, 0, 16, 16),
                $e._WHITE = new $e(st.from(e)),
                pp($e._WHITE),
                pp($e._WHITE.baseTexture)
        }
        return $e._WHITE
    }
}
class Sc extends $e {
    constructor(e, n) {
        super(e, n),
            this.valid = !0,
            this.filterFrame = null,
            this.filterPoolKey = null,
            this.updateUvs()
    }
    get framebuffer() {
        return this.baseTexture.framebuffer
    }
    get multisample() {
        return this.framebuffer.multisample
    }
    set multisample(e) {
        this.framebuffer.multisample = e
    }
    resize(e, n, s = !0) {
        const r = this.baseTexture.resolution
            , i = Math.round(e * r) / r
            , o = Math.round(n * r) / r;
        this.valid = i > 0 && o > 0,
            this._frame.width = this.orig.width = i,
            this._frame.height = this.orig.height = o,
            s && this.baseTexture.resize(i, o),
            this.updateUvs()
    }
    setResolution(e) {
        const { baseTexture: n } = this;
        n.resolution !== e && (n.setResolution(e),
            this.resize(n.width, n.height, !1))
    }
    static create(e) {
        return new Sc(new M6(e))
    }
}
class L6 {
    constructor(e) {
        this.texturePool = {},
            this.textureOptions = e || {},
            this.enableFullScreen = !1,
            this._pixelsWidth = 0,
            this._pixelsHeight = 0
    }
    createTexture(e, n, s = En.NONE) {
        const r = new M6(Object.assign({
            width: e,
            height: n,
            resolution: 1,
            multisample: s
        }, this.textureOptions));
        return new Sc(r)
    }
    getOptimalTexture(e, n, s = 1, r = En.NONE) {
        let i;
        e = Math.max(Math.ceil(e * s - 1e-6), 1),
            n = Math.max(Math.ceil(n * s - 1e-6), 1),
            !this.enableFullScreen || e !== this._pixelsWidth || n !== this._pixelsHeight ? (e = zm(e),
                n = zm(n),
                i = ((e & 65535) << 16 | n & 65535) >>> 0,
                r > 1 && (i += r * 4294967296)) : i = r > 1 ? -r : -1,
            this.texturePool[i] || (this.texturePool[i] = []);
        let o = this.texturePool[i].pop();
        return o || (o = this.createTexture(e, n, r)),
            o.filterPoolKey = i,
            o.setResolution(s),
            o
    }
    getFilterTexture(e, n, s) {
        const r = this.getOptimalTexture(e.width, e.height, n || e.resolution, s || En.NONE);
        return r.filterFrame = e.filterFrame,
            r
    }
    returnTexture(e) {
        const n = e.filterPoolKey;
        e.filterFrame = null,
            this.texturePool[n].push(e)
    }
    returnFilterTexture(e) {
        this.returnTexture(e)
    }
    clear(e) {
        if (e = e !== !1,
            e)
            for (const n in this.texturePool) {
                const s = this.texturePool[n];
                if (s)
                    for (let r = 0; r < s.length; r++)
                        s[r].destroy(!0)
            }
        this.texturePool = {}
    }
    setScreenSize(e) {
        if (!(e.width === this._pixelsWidth && e.height === this._pixelsHeight)) {
            this.enableFullScreen = e.width > 0 && e.height > 0;
            for (const n in this.texturePool) {
                if (!(Number(n) < 0))
                    continue;
                const s = this.texturePool[n];
                if (s)
                    for (let r = 0; r < s.length; r++)
                        s[r].destroy(!0);
                this.texturePool[n] = []
            }
            this._pixelsWidth = e.width,
                this._pixelsHeight = e.height
        }
    }
}
L6.SCREEN_KEY = -1;
class mce extends ja {
    constructor() {
        super(),
            this.addAttribute("aVertexPosition", new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])).addIndex([0, 1, 3, 2])
    }
}
class O6 extends ja {
    constructor() {
        super(),
            this.vertices = new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1]),
            this.uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
            this.vertexBuffer = new _n(this.vertices),
            this.uvBuffer = new _n(this.uvs),
            this.addAttribute("aVertexPosition", this.vertexBuffer).addAttribute("aTextureCoord", this.uvBuffer).addIndex([0, 1, 2, 0, 2, 3])
    }
    map(e, n) {
        let s = 0
            , r = 0;
        return this.uvs[0] = s,
            this.uvs[1] = r,
            this.uvs[2] = s + n.width / e.width,
            this.uvs[3] = r,
            this.uvs[4] = s + n.width / e.width,
            this.uvs[5] = r + n.height / e.height,
            this.uvs[6] = s,
            this.uvs[7] = r + n.height / e.height,
            s = n.x,
            r = n.y,
            this.vertices[0] = s,
            this.vertices[1] = r,
            this.vertices[2] = s + n.width,
            this.vertices[3] = r,
            this.vertices[4] = s + n.width,
            this.vertices[5] = r + n.height,
            this.vertices[6] = s,
            this.vertices[7] = r + n.height,
            this.invalidate(),
            this
    }
    invalidate() {
        return this.vertexBuffer._updateID++,
            this.uvBuffer._updateID++,
            this
    }
}
class gce {
    constructor() {
        this.renderTexture = null,
            this.target = null,
            this.legacy = !1,
            this.resolution = 1,
            this.multisample = En.NONE,
            this.sourceFrame = new nt,
            this.destinationFrame = new nt,
            this.bindingSourceFrame = new nt,
            this.bindingDestinationFrame = new nt,
            this.filters = [],
            this.transform = null
    }
    clear() {
        this.target = null,
            this.filters = null,
            this.renderTexture = null
    }
}
const mp = [new At, new At, new At, new At]
    , _1 = new Bt;
class N6 {
    constructor(e) {
        this.renderer = e,
            this.defaultFilterStack = [{}],
            this.texturePool = new L6,
            this.statePool = [],
            this.quad = new mce,
            this.quadUv = new O6,
            this.tempRect = new nt,
            this.activeState = {},
            this.globalUniforms = new ii({
                outputFrame: new nt,
                inputSize: new Float32Array(4),
                inputPixel: new Float32Array(4),
                inputClamp: new Float32Array(4),
                resolution: 1,
                filterArea: new Float32Array(4),
                filterClamp: new Float32Array(4)
            }, !0),
            this.forceClear = !1,
            this.useMaxPadding = !1
    }
    init() {
        this.texturePool.setScreenSize(this.renderer.view)
    }
    push(e, n) {
        const s = this.renderer
            , r = this.defaultFilterStack
            , i = this.statePool.pop() || new gce
            , o = s.renderTexture;
        let l, a;
        if (o.current) {
            const g = o.current;
            l = g.resolution,
                a = g.multisample
        } else
            l = s.resolution,
                a = s.multisample;
        let c = n[0].resolution || l
            , u = n[0].multisample ?? a
            , h = n[0].padding
            , d = n[0].autoFit
            , f = n[0].legacy ?? !0;
        for (let g = 1; g < n.length; g++) {
            const b = n[g];
            c = Math.min(c, b.resolution || l),
                u = Math.min(u, b.multisample ?? a),
                h = this.useMaxPadding ? Math.max(h, b.padding) : h + b.padding,
                d = d && b.autoFit,
                f = f || (b.legacy ?? !0)
        }
        r.length === 1 && (this.defaultFilterStack[0].renderTexture = o.current),
            r.push(i),
            i.resolution = c,
            i.multisample = u,
            i.legacy = f,
            i.target = e,
            i.sourceFrame.copyFrom(e.filterArea || e.getBounds(!0)),
            i.sourceFrame.pad(h);
        const p = this.tempRect.copyFrom(o.sourceFrame);
        s.projection.transform && this.transformAABB(_1.copyFrom(s.projection.transform).invert(), p),
            d ? (i.sourceFrame.fit(p),
                (i.sourceFrame.width <= 0 || i.sourceFrame.height <= 0) && (i.sourceFrame.width = 0,
                    i.sourceFrame.height = 0)) : i.sourceFrame.intersects(p) || (i.sourceFrame.width = 0,
                        i.sourceFrame.height = 0),
            this.roundFrame(i.sourceFrame, o.current ? o.current.resolution : s.resolution, o.sourceFrame, o.destinationFrame, s.projection.transform),
            i.renderTexture = this.getOptimalFilterTexture(i.sourceFrame.width, i.sourceFrame.height, c, u),
            i.filters = n,
            i.destinationFrame.width = i.renderTexture.width,
            i.destinationFrame.height = i.renderTexture.height;
        const m = this.tempRect;
        m.x = 0,
            m.y = 0,
            m.width = i.sourceFrame.width,
            m.height = i.sourceFrame.height,
            i.renderTexture.filterFrame = i.sourceFrame,
            i.bindingSourceFrame.copyFrom(o.sourceFrame),
            i.bindingDestinationFrame.copyFrom(o.destinationFrame),
            i.transform = s.projection.transform,
            s.projection.transform = null,
            o.bind(i.renderTexture, i.sourceFrame, m),
            s.framebuffer.clear(0, 0, 0, 0)
    }
    pop() {
        const e = this.defaultFilterStack
            , n = e.pop()
            , s = n.filters;
        this.activeState = n;
        const r = this.globalUniforms.uniforms;
        r.outputFrame = n.sourceFrame,
            r.resolution = n.resolution;
        const i = r.inputSize
            , o = r.inputPixel
            , l = r.inputClamp;
        if (i[0] = n.destinationFrame.width,
            i[1] = n.destinationFrame.height,
            i[2] = 1 / i[0],
            i[3] = 1 / i[1],
            o[0] = Math.round(i[0] * n.resolution),
            o[1] = Math.round(i[1] * n.resolution),
            o[2] = 1 / o[0],
            o[3] = 1 / o[1],
            l[0] = .5 * o[2],
            l[1] = .5 * o[3],
            l[2] = n.sourceFrame.width * i[2] - .5 * o[2],
            l[3] = n.sourceFrame.height * i[3] - .5 * o[3],
            n.legacy) {
            const c = r.filterArea;
            c[0] = n.destinationFrame.width,
                c[1] = n.destinationFrame.height,
                c[2] = n.sourceFrame.x,
                c[3] = n.sourceFrame.y,
                r.filterClamp = r.inputClamp
        }
        this.globalUniforms.update();
        const a = e[e.length - 1];
        if (this.renderer.framebuffer.blit(),
            s.length === 1)
            s[0].apply(this, n.renderTexture, a.renderTexture, Oi.BLEND, n),
                this.returnFilterTexture(n.renderTexture);
        else {
            let c = n.renderTexture
                , u = this.getOptimalFilterTexture(c.width, c.height, n.resolution);
            u.filterFrame = c.filterFrame;
            let h = 0;
            for (h = 0; h < s.length - 1; ++h) {
                h === 1 && n.multisample > 1 && (u = this.getOptimalFilterTexture(c.width, c.height, n.resolution),
                    u.filterFrame = c.filterFrame),
                    s[h].apply(this, c, u, Oi.CLEAR, n);
                const d = c;
                c = u,
                    u = d
            }
            s[h].apply(this, c, a.renderTexture, Oi.BLEND, n),
                h > 1 && n.multisample > 1 && this.returnFilterTexture(n.renderTexture),
                this.returnFilterTexture(c),
                this.returnFilterTexture(u)
        }
        n.clear(),
            this.statePool.push(n)
    }
    bindAndClear(e, n = Oi.CLEAR) {
        const { renderTexture: s, state: r } = this.renderer;
        if (e === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? this.renderer.projection.transform = this.activeState.transform : this.renderer.projection.transform = null,
            e == null ? void 0 : e.filterFrame) {
            const o = this.tempRect;
            o.x = 0,
                o.y = 0,
                o.width = e.filterFrame.width,
                o.height = e.filterFrame.height,
                s.bind(e, e.filterFrame, o)
        } else
            e !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? s.bind(e) : this.renderer.renderTexture.bind(e, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);
        const i = r.stateId & 1 || this.forceClear;
        (n === Oi.CLEAR || n === Oi.BLIT && i) && this.renderer.framebuffer.clear(0, 0, 0, 0)
    }
    applyFilter(e, n, s, r) {
        const i = this.renderer;
        i.state.set(e.state),
            this.bindAndClear(s, r),
            e.uniforms.uSampler = n,
            e.uniforms.filterGlobals = this.globalUniforms,
            i.shader.bind(e),
            e.legacy = !!e.program.attributeData.aTextureCoord,
            e.legacy ? (this.quadUv.map(n._frame, n.filterFrame),
                i.geometry.bind(this.quadUv),
                i.geometry.draw(ti.TRIANGLES)) : (i.geometry.bind(this.quad),
                    i.geometry.draw(ti.TRIANGLE_STRIP))
    }
    calculateSpriteMatrix(e, n) {
        const { sourceFrame: s, destinationFrame: r } = this.activeState
            , { orig: i } = n._texture
            , o = e.set(r.width, 0, 0, r.height, s.x, s.y)
            , l = n.worldTransform.copyTo(Bt.TEMP_MATRIX);
        return l.invert(),
            o.prepend(l),
            o.scale(1 / i.width, 1 / i.height),
            o.translate(n.anchor.x, n.anchor.y),
            o
    }
    destroy() {
        this.renderer = null,
            this.texturePool.clear(!1)
    }
    getOptimalFilterTexture(e, n, s = 1, r = En.NONE) {
        return this.texturePool.getOptimalTexture(e, n, s, r)
    }
    getFilterTexture(e, n, s) {
        if (typeof e == "number") {
            const i = e;
            e = n,
                n = i
        }
        e = e || this.activeState.renderTexture;
        const r = this.texturePool.getOptimalTexture(e.width, e.height, n || e.resolution, s || En.NONE);
        return r.filterFrame = e.filterFrame,
            r
    }
    returnFilterTexture(e) {
        this.texturePool.returnTexture(e)
    }
    emptyPool() {
        this.texturePool.clear(!0)
    }
    resize() {
        this.texturePool.setScreenSize(this.renderer.view)
    }
    transformAABB(e, n) {
        const s = mp[0]
            , r = mp[1]
            , i = mp[2]
            , o = mp[3];
        s.set(n.left, n.top),
            r.set(n.left, n.bottom),
            i.set(n.right, n.top),
            o.set(n.right, n.bottom),
            e.apply(s, s),
            e.apply(r, r),
            e.apply(i, i),
            e.apply(o, o);
        const l = Math.min(s.x, r.x, i.x, o.x)
            , a = Math.min(s.y, r.y, i.y, o.y)
            , c = Math.max(s.x, r.x, i.x, o.x)
            , u = Math.max(s.y, r.y, i.y, o.y);
        n.x = l,
            n.y = a,
            n.width = c - l,
            n.height = u - a
    }
    roundFrame(e, n, s, r, i) {
        if (!(e.width <= 0 || e.height <= 0 || s.width <= 0 || s.height <= 0)) {
            if (i) {
                const { a: o, b: l, c: a, d: c } = i;
                if ((Math.abs(l) > 1e-4 || Math.abs(a) > 1e-4) && (Math.abs(o) > 1e-4 || Math.abs(c) > 1e-4))
                    return
            }
            i = i ? _1.copyFrom(i) : _1.identity(),
                i.translate(-s.x, -s.y).scale(r.width / s.width, r.height / s.height).translate(r.x, r.y),
                this.transformAABB(i, e),
                e.ceil(n),
                this.transformAABB(i.invert(), e)
        }
    }
}
N6.extension = {
    type: Ae.RendererSystem,
    name: "filter"
};
Ue.add(N6);
class _ce {
    constructor(e) {
        this.framebuffer = e,
            this.stencil = null,
            this.dirtyId = -1,
            this.dirtyFormat = -1,
            this.dirtySize = -1,
            this.multisample = En.NONE,
            this.msaaBuffer = null,
            this.blitFramebuffer = null,
            this.mipLevel = 0
    }
}
const yce = new nt;
class D6 {
    constructor(e) {
        this.renderer = e,
            this.managedFramebuffers = [],
            this.unknownFramebuffer = new Ib(10, 10),
            this.msaaSamples = null
    }
    contextChange() {
        this.disposeAll(!0);
        const e = this.gl = this.renderer.gl;
        if (this.CONTEXT_UID = this.renderer.CONTEXT_UID,
            this.current = this.unknownFramebuffer,
            this.viewport = new nt,
            this.hasMRT = !0,
            this.writeDepthTexture = !0,
            this.renderer.context.webGLVersion === 1) {
            let n = this.renderer.context.extensions.drawBuffers
                , s = this.renderer.context.extensions.depthTexture;
            Le.PREFER_ENV === wc.WEBGL_LEGACY && (n = null,
                s = null),
                n ? e.drawBuffers = r => n.drawBuffersWEBGL(r) : (this.hasMRT = !1,
                    e.drawBuffers = () => { }
                ),
                s || (this.writeDepthTexture = !1)
        } else
            this.msaaSamples = e.getInternalformatParameter(e.RENDERBUFFER, e.RGBA8, e.SAMPLES)
    }
    bind(e, n, s = 0) {
        const { gl: r } = this;
        if (e) {
            const i = e.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(e);
            this.current !== e && (this.current = e,
                r.bindFramebuffer(r.FRAMEBUFFER, i.framebuffer)),
                i.mipLevel !== s && (e.dirtyId++,
                    e.dirtyFormat++,
                    i.mipLevel = s),
                i.dirtyId !== e.dirtyId && (i.dirtyId = e.dirtyId,
                    i.dirtyFormat !== e.dirtyFormat ? (i.dirtyFormat = e.dirtyFormat,
                        i.dirtySize = e.dirtySize,
                        this.updateFramebuffer(e, s)) : i.dirtySize !== e.dirtySize && (i.dirtySize = e.dirtySize,
                            this.resizeFramebuffer(e)));
            for (let o = 0; o < e.colorTextures.length; o++) {
                const l = e.colorTextures[o];
                this.renderer.texture.unbind(l.parentTextureArray || l)
            }
            if (e.depthTexture && this.renderer.texture.unbind(e.depthTexture),
                n) {
                const o = n.width >> s
                    , l = n.height >> s
                    , a = o / n.width;
                this.setViewport(n.x * a, n.y * a, o, l)
            } else {
                const o = e.width >> s
                    , l = e.height >> s;
                this.setViewport(0, 0, o, l)
            }
        } else
            this.current && (this.current = null,
                r.bindFramebuffer(r.FRAMEBUFFER, null)),
                n ? this.setViewport(n.x, n.y, n.width, n.height) : this.setViewport(0, 0, this.renderer.width, this.renderer.height)
    }
    setViewport(e, n, s, r) {
        const i = this.viewport;
        e = Math.round(e),
            n = Math.round(n),
            s = Math.round(s),
            r = Math.round(r),
            (i.width !== s || i.height !== r || i.x !== e || i.y !== n) && (i.x = e,
                i.y = n,
                i.width = s,
                i.height = r,
                this.gl.viewport(e, n, s, r))
    }
    get size() {
        return this.current ? {
            x: 0,
            y: 0,
            width: this.current.width,
            height: this.current.height
        } : {
            x: 0,
            y: 0,
            width: this.renderer.width,
            height: this.renderer.height
        }
    }
    clear(e, n, s, r, i = eb.COLOR | eb.DEPTH) {
        const { gl: o } = this;
        o.clearColor(e, n, s, r),
            o.clear(i)
    }
    initFramebuffer(e) {
        const { gl: n } = this
            , s = new _ce(n.createFramebuffer());
        return s.multisample = this.detectSamples(e.multisample),
            e.glFramebuffers[this.CONTEXT_UID] = s,
            this.managedFramebuffers.push(e),
            e.disposeRunner.add(this),
            s
    }
    resizeFramebuffer(e) {
        const { gl: n } = this
            , s = e.glFramebuffers[this.CONTEXT_UID];
        if (s.stencil) {
            n.bindRenderbuffer(n.RENDERBUFFER, s.stencil);
            let o;
            this.renderer.context.webGLVersion === 1 ? o = n.DEPTH_STENCIL : e.depth && e.stencil ? o = n.DEPTH24_STENCIL8 : e.depth ? o = n.DEPTH_COMPONENT24 : o = n.STENCIL_INDEX8,
                s.msaaBuffer ? n.renderbufferStorageMultisample(n.RENDERBUFFER, s.multisample, o, e.width, e.height) : n.renderbufferStorage(n.RENDERBUFFER, o, e.width, e.height)
        }
        const r = e.colorTextures;
        let i = r.length;
        n.drawBuffers || (i = Math.min(i, 1));
        for (let o = 0; o < i; o++) {
            const l = r[o]
                , a = l.parentTextureArray || l;
            this.renderer.texture.bind(a, 0),
                o === 0 && s.msaaBuffer && (n.bindRenderbuffer(n.RENDERBUFFER, s.msaaBuffer),
                    n.renderbufferStorageMultisample(n.RENDERBUFFER, s.multisample, a._glTextures[this.CONTEXT_UID].internalFormat, e.width, e.height))
        }
        e.depthTexture && this.writeDepthTexture && this.renderer.texture.bind(e.depthTexture, 0)
    }
    updateFramebuffer(e, n) {
        const { gl: s } = this
            , r = e.glFramebuffers[this.CONTEXT_UID]
            , i = e.colorTextures;
        let o = i.length;
        s.drawBuffers || (o = Math.min(o, 1)),
            r.multisample > 1 && this.canMultisampleFramebuffer(e) ? r.msaaBuffer = r.msaaBuffer || s.createRenderbuffer() : r.msaaBuffer && (s.deleteRenderbuffer(r.msaaBuffer),
                r.msaaBuffer = null,
                r.blitFramebuffer && (r.blitFramebuffer.dispose(),
                    r.blitFramebuffer = null));
        const l = [];
        for (let a = 0; a < o; a++) {
            const c = i[a]
                , u = c.parentTextureArray || c;
            this.renderer.texture.bind(u, 0),
                a === 0 && r.msaaBuffer ? (s.bindRenderbuffer(s.RENDERBUFFER, r.msaaBuffer),
                    s.renderbufferStorageMultisample(s.RENDERBUFFER, r.multisample, u._glTextures[this.CONTEXT_UID].internalFormat, e.width, e.height),
                    s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.RENDERBUFFER, r.msaaBuffer)) : (s.framebufferTexture2D(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + a, c.target, u._glTextures[this.CONTEXT_UID].texture, n),
                        l.push(s.COLOR_ATTACHMENT0 + a))
        }
        if (l.length > 1 && s.drawBuffers(l),
            e.depthTexture && this.writeDepthTexture) {
            const a = e.depthTexture;
            this.renderer.texture.bind(a, 0),
                s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.TEXTURE_2D, a._glTextures[this.CONTEXT_UID].texture, n)
        }
        if ((e.stencil || e.depth) && !(e.depthTexture && this.writeDepthTexture)) {
            r.stencil = r.stencil || s.createRenderbuffer();
            let a, c;
            this.renderer.context.webGLVersion === 1 ? (a = s.DEPTH_STENCIL_ATTACHMENT,
                c = s.DEPTH_STENCIL) : e.depth && e.stencil ? (a = s.DEPTH_STENCIL_ATTACHMENT,
                    c = s.DEPTH24_STENCIL8) : e.depth ? (a = s.DEPTH_ATTACHMENT,
                        c = s.DEPTH_COMPONENT24) : (a = s.STENCIL_ATTACHMENT,
                            c = s.STENCIL_INDEX8),
                s.bindRenderbuffer(s.RENDERBUFFER, r.stencil),
                r.msaaBuffer ? s.renderbufferStorageMultisample(s.RENDERBUFFER, r.multisample, c, e.width, e.height) : s.renderbufferStorage(s.RENDERBUFFER, c, e.width, e.height),
                s.framebufferRenderbuffer(s.FRAMEBUFFER, a, s.RENDERBUFFER, r.stencil)
        } else
            r.stencil && (s.deleteRenderbuffer(r.stencil),
                r.stencil = null)
    }
    canMultisampleFramebuffer(e) {
        return this.renderer.context.webGLVersion !== 1 && e.colorTextures.length <= 1 && !e.depthTexture
    }
    detectSamples(e) {
        const { msaaSamples: n } = this;
        let s = En.NONE;
        if (e <= 1 || n === null)
            return s;
        for (let r = 0; r < n.length; r++)
            if (n[r] <= e) {
                s = n[r];
                break
            }
        return s === 1 && (s = En.NONE),
            s
    }
    blit(e, n, s) {
        const { current: r, renderer: i, gl: o, CONTEXT_UID: l } = this;
        if (i.context.webGLVersion !== 2 || !r)
            return;
        const a = r.glFramebuffers[l];
        if (!a)
            return;
        if (!e) {
            if (!a.msaaBuffer)
                return;
            const u = r.colorTextures[0];
            if (!u)
                return;
            a.blitFramebuffer || (a.blitFramebuffer = new Ib(r.width, r.height),
                a.blitFramebuffer.addColorTexture(0, u)),
                e = a.blitFramebuffer,
                e.colorTextures[0] !== u && (e.colorTextures[0] = u,
                    e.dirtyId++,
                    e.dirtyFormat++),
                (e.width !== r.width || e.height !== r.height) && (e.width = r.width,
                    e.height = r.height,
                    e.dirtyId++,
                    e.dirtySize++)
        }
        n || (n = yce,
            n.width = r.width,
            n.height = r.height),
            s || (s = n);
        const c = n.width === s.width && n.height === s.height;
        this.bind(e),
            o.bindFramebuffer(o.READ_FRAMEBUFFER, a.framebuffer),
            o.blitFramebuffer(n.left, n.top, n.right, n.bottom, s.left, s.top, s.right, s.bottom, o.COLOR_BUFFER_BIT, c ? o.NEAREST : o.LINEAR),
            o.bindFramebuffer(o.READ_FRAMEBUFFER, e.glFramebuffers[this.CONTEXT_UID].framebuffer)
    }
    disposeFramebuffer(e, n) {
        const s = e.glFramebuffers[this.CONTEXT_UID]
            , r = this.gl;
        if (!s)
            return;
        delete e.glFramebuffers[this.CONTEXT_UID];
        const i = this.managedFramebuffers.indexOf(e);
        i >= 0 && this.managedFramebuffers.splice(i, 1),
            e.disposeRunner.remove(this),
            n || (r.deleteFramebuffer(s.framebuffer),
                s.msaaBuffer && r.deleteRenderbuffer(s.msaaBuffer),
                s.stencil && r.deleteRenderbuffer(s.stencil)),
            s.blitFramebuffer && this.disposeFramebuffer(s.blitFramebuffer, n)
    }
    disposeAll(e) {
        const n = this.managedFramebuffers;
        this.managedFramebuffers = [];
        for (let s = 0; s < n.length; s++)
            this.disposeFramebuffer(n[s], e)
    }
    forceStencil() {
        const e = this.current;
        if (!e)
            return;
        const n = e.glFramebuffers[this.CONTEXT_UID];
        if (!n || n.stencil && e.stencil)
            return;
        e.stencil = !0;
        const s = e.width
            , r = e.height
            , i = this.gl
            , o = n.stencil = i.createRenderbuffer();
        i.bindRenderbuffer(i.RENDERBUFFER, o);
        let l, a;
        this.renderer.context.webGLVersion === 1 ? (l = i.DEPTH_STENCIL_ATTACHMENT,
            a = i.DEPTH_STENCIL) : e.depth ? (l = i.DEPTH_STENCIL_ATTACHMENT,
                a = i.DEPTH24_STENCIL8) : (l = i.STENCIL_ATTACHMENT,
                    a = i.STENCIL_INDEX8),
            n.msaaBuffer ? i.renderbufferStorageMultisample(i.RENDERBUFFER, n.multisample, a, s, r) : i.renderbufferStorage(i.RENDERBUFFER, a, s, r),
            i.framebufferRenderbuffer(i.FRAMEBUFFER, l, i.RENDERBUFFER, o)
    }
    reset() {
        this.current = this.unknownFramebuffer,
            this.viewport = new nt
    }
    destroy() {
        this.renderer = null
    }
}
D6.extension = {
    type: Ae.RendererSystem,
    name: "framebuffer"
};
Ue.add(D6);
const y1 = {
    5126: 4,
    5123: 2,
    5121: 1
};
class B6 {
    constructor(e) {
        this.renderer = e,
            this._activeGeometry = null,
            this._activeVao = null,
            this.hasVao = !0,
            this.hasInstance = !0,
            this.canUseUInt32ElementIndex = !1,
            this.managedGeometries = {}
    }
    contextChange() {
        this.disposeAll(!0);
        const e = this.gl = this.renderer.gl
            , n = this.renderer.context;
        if (this.CONTEXT_UID = this.renderer.CONTEXT_UID,
            n.webGLVersion !== 2) {
            let s = this.renderer.context.extensions.vertexArrayObject;
            Le.PREFER_ENV === wc.WEBGL_LEGACY && (s = null),
                s ? (e.createVertexArray = () => s.createVertexArrayOES(),
                    e.bindVertexArray = r => s.bindVertexArrayOES(r),
                    e.deleteVertexArray = r => s.deleteVertexArrayOES(r)) : (this.hasVao = !1,
                        e.createVertexArray = () => null,
                        e.bindVertexArray = () => null,
                        e.deleteVertexArray = () => null)
        }
        if (n.webGLVersion !== 2) {
            const s = e.getExtension("ANGLE_instanced_arrays");
            s ? (e.vertexAttribDivisor = (r, i) => s.vertexAttribDivisorANGLE(r, i),
                e.drawElementsInstanced = (r, i, o, l, a) => s.drawElementsInstancedANGLE(r, i, o, l, a),
                e.drawArraysInstanced = (r, i, o, l) => s.drawArraysInstancedANGLE(r, i, o, l)) : this.hasInstance = !1
        }
        this.canUseUInt32ElementIndex = n.webGLVersion === 2 || !!n.extensions.uint32ElementIndex
    }
    bind(e, n) {
        n = n || this.renderer.shader.shader;
        const { gl: s } = this;
        let r = e.glVertexArrayObjects[this.CONTEXT_UID]
            , i = !1;
        r || (this.managedGeometries[e.id] = e,
            e.disposeRunner.add(this),
            e.glVertexArrayObjects[this.CONTEXT_UID] = r = {},
            i = !0);
        const o = r[n.program.id] || this.initGeometryVao(e, n, i);
        this._activeGeometry = e,
            this._activeVao !== o && (this._activeVao = o,
                this.hasVao ? s.bindVertexArray(o) : this.activateVao(e, n.program)),
            this.updateBuffers()
    }
    reset() {
        this.unbind()
    }
    updateBuffers() {
        const e = this._activeGeometry
            , n = this.renderer.buffer;
        for (let s = 0; s < e.buffers.length; s++) {
            const r = e.buffers[s];
            n.update(r)
        }
    }
    checkCompatibility(e, n) {
        const s = e.attributes
            , r = n.attributeData;
        for (const i in r)
            if (!s[i])
                throw new Error(`shader and geometry incompatible, geometry missing the "${i}" attribute`)
    }
    getSignature(e, n) {
        const s = e.attributes
            , r = n.attributeData
            , i = ["g", e.id];
        for (const o in s)
            r[o] && i.push(o, r[o].location);
        return i.join("-")
    }
    initGeometryVao(e, n, s = !0) {
        const r = this.gl
            , i = this.CONTEXT_UID
            , o = this.renderer.buffer
            , l = n.program;
        l.glPrograms[i] || this.renderer.shader.generateProgram(n),
            this.checkCompatibility(e, l);
        const a = this.getSignature(e, l)
            , c = e.glVertexArrayObjects[this.CONTEXT_UID];
        let u = c[a];
        if (u)
            return c[l.id] = u,
                u;
        const h = e.buffers
            , d = e.attributes
            , f = {}
            , p = {};
        for (const m in h)
            f[m] = 0,
                p[m] = 0;
        for (const m in d)
            !d[m].size && l.attributeData[m] ? d[m].size = l.attributeData[m].size : d[m].size || console.warn(`PIXI Geometry attribute '${m}' size cannot be determined (likely the bound shader does not have the attribute)`),
                f[d[m].buffer] += d[m].size * y1[d[m].type];
        for (const m in d) {
            const g = d[m]
                , b = g.size;
            g.stride === void 0 && (f[g.buffer] === b * y1[g.type] ? g.stride = 0 : g.stride = f[g.buffer]),
                g.start === void 0 && (g.start = p[g.buffer],
                    p[g.buffer] += b * y1[g.type])
        }
        u = r.createVertexArray(),
            r.bindVertexArray(u);
        for (let m = 0; m < h.length; m++) {
            const g = h[m];
            o.bind(g),
                s && g._glBuffers[i].refCount++
        }
        return this.activateVao(e, l),
            c[l.id] = u,
            c[a] = u,
            r.bindVertexArray(null),
            o.unbind(Gi.ARRAY_BUFFER),
            u
    }
    disposeGeometry(e, n) {
        var l;
        if (!this.managedGeometries[e.id])
            return;
        delete this.managedGeometries[e.id];
        const s = e.glVertexArrayObjects[this.CONTEXT_UID]
            , r = this.gl
            , i = e.buffers
            , o = (l = this.renderer) == null ? void 0 : l.buffer;
        if (e.disposeRunner.remove(this),
            !!s) {
            if (o)
                for (let a = 0; a < i.length; a++) {
                    const c = i[a]._glBuffers[this.CONTEXT_UID];
                    c && (c.refCount--,
                        c.refCount === 0 && !n && o.dispose(i[a], n))
                }
            if (!n) {
                for (const a in s)
                    if (a[0] === "g") {
                        const c = s[a];
                        this._activeVao === c && this.unbind(),
                            r.deleteVertexArray(c)
                    }
            }
            delete e.glVertexArrayObjects[this.CONTEXT_UID]
        }
    }
    disposeAll(e) {
        const n = Object.keys(this.managedGeometries);
        for (let s = 0; s < n.length; s++)
            this.disposeGeometry(this.managedGeometries[n[s]], e)
    }
    activateVao(e, n) {
        const s = this.gl
            , r = this.CONTEXT_UID
            , i = this.renderer.buffer
            , o = e.buffers
            , l = e.attributes;
        e.indexBuffer && i.bind(e.indexBuffer);
        let a = null;
        for (const c in l) {
            const u = l[c]
                , h = o[u.buffer]
                , d = h._glBuffers[r];
            if (n.attributeData[c]) {
                a !== d && (i.bind(h),
                    a = d);
                const f = n.attributeData[c].location;
                if (s.enableVertexAttribArray(f),
                    s.vertexAttribPointer(f, u.size, u.type || s.FLOAT, u.normalized, u.stride, u.start),
                    u.instance)
                    if (this.hasInstance)
                        s.vertexAttribDivisor(f, u.divisor);
                    else
                        throw new Error("geometry error, GPU Instancing is not supported on this device")
            }
        }
    }
    draw(e, n, s, r) {
        const { gl: i } = this
            , o = this._activeGeometry;
        if (o.indexBuffer) {
            const l = o.indexBuffer.data.BYTES_PER_ELEMENT
                , a = l === 2 ? i.UNSIGNED_SHORT : i.UNSIGNED_INT;
            l === 2 || l === 4 && this.canUseUInt32ElementIndex ? o.instanced ? i.drawElementsInstanced(e, n || o.indexBuffer.data.length, a, (s || 0) * l, r || 1) : i.drawElements(e, n || o.indexBuffer.data.length, a, (s || 0) * l) : console.warn("unsupported index buffer type: uint32")
        } else
            o.instanced ? i.drawArraysInstanced(e, s, n || o.getSize(), r || 1) : i.drawArrays(e, s, n || o.getSize());
        return this
    }
    unbind() {
        this.gl.bindVertexArray(null),
            this._activeVao = null,
            this._activeGeometry = null
    }
    destroy() {
        this.renderer = null
    }
}
B6.extension = {
    type: Ae.RendererSystem,
    name: "geometry"
};
Ue.add(B6);
const ZI = new Bt;
class F6 {
    constructor(e, n) {
        this._texture = e,
            this.mapCoord = new Bt,
            this.uClampFrame = new Float32Array(4),
            this.uClampOffset = new Float32Array(2),
            this._textureID = -1,
            this._updateID = 0,
            this.clampOffset = 0,
            this.clampMargin = typeof n > "u" ? .5 : n,
            this.isSimple = !1
    }
    get texture() {
        return this._texture
    }
    set texture(e) {
        this._texture = e,
            this._textureID = -1
    }
    multiplyUvs(e, n) {
        n === void 0 && (n = e);
        const s = this.mapCoord;
        for (let r = 0; r < e.length; r += 2) {
            const i = e[r]
                , o = e[r + 1];
            n[r] = i * s.a + o * s.c + s.tx,
                n[r + 1] = i * s.b + o * s.d + s.ty
        }
        return n
    }
    update(e) {
        const n = this._texture;
        if (!n || !n.valid || !e && this._textureID === n._updateID)
            return !1;
        this._textureID = n._updateID,
            this._updateID++;
        const s = n._uvs;
        this.mapCoord.set(s.x1 - s.x0, s.y1 - s.y0, s.x3 - s.x0, s.y3 - s.y0, s.x0, s.y0);
        const r = n.orig
            , i = n.trim;
        i && (ZI.set(r.width / i.width, 0, 0, r.height / i.height, -i.x / i.width, -i.y / i.height),
            this.mapCoord.append(ZI));
        const o = n.baseTexture
            , l = this.uClampFrame
            , a = this.clampMargin / o.resolution
            , c = this.clampOffset;
        return l[0] = (n._frame.x + a + c) / o.width,
            l[1] = (n._frame.y + a + c) / o.height,
            l[2] = (n._frame.x + n._frame.width - a + c) / o.width,
            l[3] = (n._frame.y + n._frame.height - a + c) / o.height,
            this.uClampOffset[0] = c / o.realWidth,
            this.uClampOffset[1] = c / o.realHeight,
            this.isSimple = n._frame.width === o.width && n._frame.height === o.height && n.rotate === 0,
            !0
    }
}
var bce = `varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform sampler2D mask;
uniform float alpha;
uniform float npmAlpha;
uniform vec4 maskClamp;

void main(void)
{
    float clip = step(3.5,
        step(maskClamp.x, vMaskCoord.x) +
        step(maskClamp.y, vMaskCoord.y) +
        step(vMaskCoord.x, maskClamp.z) +
        step(vMaskCoord.y, maskClamp.w));

    vec4 original = texture2D(uSampler, vTextureCoord);
    vec4 masky = texture2D(mask, vMaskCoord);
    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);

    original *= (alphaMul * masky.r * alpha * clip);

    gl_FragColor = original;
}
`
    , vce = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 otherMatrix;

varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;
}
`;
class xce extends As {
    constructor(e, n, s) {
        let r = null;
        typeof e != "string" && n === void 0 && s === void 0 && (r = e,
            e = void 0,
            n = void 0,
            s = void 0),
            super(e || vce, n || bce, s),
            this.maskSprite = r,
            this.maskMatrix = new Bt
    }
    get maskSprite() {
        return this._maskSprite
    }
    set maskSprite(e) {
        this._maskSprite = e,
            this._maskSprite && (this._maskSprite.renderable = !1)
    }
    apply(e, n, s, r) {
        const i = this._maskSprite
            , o = i._texture;
        o.valid && (o.uvMatrix || (o.uvMatrix = new F6(o, 0)),
            o.uvMatrix.update(),
            this.uniforms.npmAlpha = o.baseTexture.alphaMode ? 0 : 1,
            this.uniforms.mask = o,
            this.uniforms.otherMatrix = e.calculateSpriteMatrix(this.maskMatrix, i).prepend(o.uvMatrix.mapCoord),
            this.uniforms.alpha = i.worldAlpha,
            this.uniforms.maskClamp = o.uvMatrix.uClampFrame,
            e.applyFilter(this, n, s, r))
    }
}
class wce {
    constructor(e = null) {
        this.type = An.NONE,
            this.autoDetect = !0,
            this.maskObject = e || null,
            this.pooled = !1,
            this.isMaskData = !0,
            this.resolution = null,
            this.multisample = As.defaultMultisample,
            this.enabled = !0,
            this.colorMask = 15,
            this._filters = null,
            this._stencilCounter = 0,
            this._scissorCounter = 0,
            this._scissorRect = null,
            this._scissorRectLocal = null,
            this._colorMask = 15,
            this._target = null
    }
    get filter() {
        return this._filters ? this._filters[0] : null
    }
    set filter(e) {
        e ? this._filters ? this._filters[0] = e : this._filters = [e] : this._filters = null
    }
    reset() {
        this.pooled && (this.maskObject = null,
            this.type = An.NONE,
            this.autoDetect = !0),
            this._target = null,
            this._scissorRectLocal = null
    }
    copyCountersOrReset(e) {
        e ? (this._stencilCounter = e._stencilCounter,
            this._scissorCounter = e._scissorCounter,
            this._scissorRect = e._scissorRect) : (this._stencilCounter = 0,
                this._scissorCounter = 0,
                this._scissorRect = null)
    }
}
class $6 {
    constructor(e) {
        this.renderer = e,
            this.enableScissor = !0,
            this.alphaMaskPool = [],
            this.maskDataPool = [],
            this.maskStack = [],
            this.alphaMaskIndex = 0
    }
    setMaskStack(e) {
        this.maskStack = e,
            this.renderer.scissor.setMaskStack(e),
            this.renderer.stencil.setMaskStack(e)
    }
    push(e, n) {
        let s = n;
        if (!s.isMaskData) {
            const i = this.maskDataPool.pop() || new wce;
            i.pooled = !0,
                i.maskObject = n,
                s = i
        }
        const r = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
        if (s.copyCountersOrReset(r),
            s._colorMask = r ? r._colorMask : 15,
            s.autoDetect && this.detect(s),
            s._target = e,
            s.type !== An.SPRITE && this.maskStack.push(s),
            s.enabled)
            switch (s.type) {
                case An.SCISSOR:
                    this.renderer.scissor.push(s);
                    break;
                case An.STENCIL:
                    this.renderer.stencil.push(s);
                    break;
                case An.SPRITE:
                    s.copyCountersOrReset(null),
                        this.pushSpriteMask(s);
                    break;
                case An.COLOR:
                    this.pushColorMask(s);
                    break
            }
        s.type === An.SPRITE && this.maskStack.push(s)
    }
    pop(e) {
        const n = this.maskStack.pop();
        if (!(!n || n._target !== e)) {
            if (n.enabled)
                switch (n.type) {
                    case An.SCISSOR:
                        this.renderer.scissor.pop(n);
                        break;
                    case An.STENCIL:
                        this.renderer.stencil.pop(n.maskObject);
                        break;
                    case An.SPRITE:
                        this.popSpriteMask(n);
                        break;
                    case An.COLOR:
                        this.popColorMask(n);
                        break
                }
            if (n.reset(),
                n.pooled && this.maskDataPool.push(n),
                this.maskStack.length !== 0) {
                const s = this.maskStack[this.maskStack.length - 1];
                s.type === An.SPRITE && s._filters && (s._filters[0].maskSprite = s.maskObject)
            }
        }
    }
    detect(e) {
        const n = e.maskObject;
        n ? n.isSprite ? e.type = An.SPRITE : this.enableScissor && this.renderer.scissor.testScissor(e) ? e.type = An.SCISSOR : e.type = An.STENCIL : e.type = An.COLOR
    }
    pushSpriteMask(e) {
        const { maskObject: n } = e
            , s = e._target;
        let r = e._filters;
        r || (r = this.alphaMaskPool[this.alphaMaskIndex],
            r || (r = this.alphaMaskPool[this.alphaMaskIndex] = [new xce])),
            r[0].resolution = e.resolution,
            r[0].multisample = e.multisample,
            r[0].maskSprite = n;
        const i = s.filterArea;
        s.filterArea = n.getBounds(!0),
            this.renderer.filter.push(s, r),
            s.filterArea = i,
            e._filters || this.alphaMaskIndex++
    }
    popSpriteMask(e) {
        this.renderer.filter.pop(),
            e._filters ? e._filters[0].maskSprite = null : (this.alphaMaskIndex--,
                this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null)
    }
    pushColorMask(e) {
        const n = e._colorMask
            , s = e._colorMask = n & e.colorMask;
        s !== n && this.renderer.gl.colorMask((s & 1) !== 0, (s & 2) !== 0, (s & 4) !== 0, (s & 8) !== 0)
    }
    popColorMask(e) {
        const n = e._colorMask
            , s = this.maskStack.length > 0 ? this.maskStack[this.maskStack.length - 1]._colorMask : 15;
        s !== n && this.renderer.gl.colorMask((s & 1) !== 0, (s & 2) !== 0, (s & 4) !== 0, (s & 8) !== 0)
    }
    destroy() {
        this.renderer = null
    }
}
$6.extension = {
    type: Ae.RendererSystem,
    name: "mask"
};
Ue.add($6);
class U6 {
    constructor(e) {
        this.renderer = e,
            this.maskStack = [],
            this.glConst = 0
    }
    getStackLength() {
        return this.maskStack.length
    }
    setMaskStack(e) {
        const { gl: n } = this.renderer
            , s = this.getStackLength();
        this.maskStack = e;
        const r = this.getStackLength();
        r !== s && (r === 0 ? n.disable(this.glConst) : (n.enable(this.glConst),
            this._useCurrent()))
    }
    _useCurrent() { }
    destroy() {
        this.renderer = null,
            this.maskStack = null
    }
}
const QI = new Bt
    , eA = []
    , V6 = class Jp extends U6 {
        constructor(e) {
            super(e),
                this.glConst = Le.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST
        }
        getStackLength() {
            const e = this.maskStack[this.maskStack.length - 1];
            return e ? e._scissorCounter : 0
        }
        calcScissorRect(e) {
            if (e._scissorRectLocal)
                return;
            const n = e._scissorRect
                , { maskObject: s } = e
                , { renderer: r } = this
                , i = r.renderTexture
                , o = s.getBounds(!0, eA.pop() ?? new nt);
            this.roundFrameToPixels(o, i.current ? i.current.resolution : r.resolution, i.sourceFrame, i.destinationFrame, r.projection.transform),
                n && o.fit(n),
                e._scissorRectLocal = o
        }
        static isMatrixRotated(e) {
            if (!e)
                return !1;
            const { a: n, b: s, c: r, d: i } = e;
            return (Math.abs(s) > 1e-4 || Math.abs(r) > 1e-4) && (Math.abs(n) > 1e-4 || Math.abs(i) > 1e-4)
        }
        testScissor(e) {
            const { maskObject: n } = e;
            if (!n.isFastRect || !n.isFastRect() || Jp.isMatrixRotated(n.worldTransform) || Jp.isMatrixRotated(this.renderer.projection.transform))
                return !1;
            this.calcScissorRect(e);
            const s = e._scissorRectLocal;
            return s.width > 0 && s.height > 0
        }
        roundFrameToPixels(e, n, s, r, i) {
            Jp.isMatrixRotated(i) || (i = i ? QI.copyFrom(i) : QI.identity(),
                i.translate(-s.x, -s.y).scale(r.width / s.width, r.height / s.height).translate(r.x, r.y),
                this.renderer.filter.transformAABB(i, e),
                e.fit(r),
                e.x = Math.round(e.x * n),
                e.y = Math.round(e.y * n),
                e.width = Math.round(e.width * n),
                e.height = Math.round(e.height * n))
        }
        push(e) {
            e._scissorRectLocal || this.calcScissorRect(e);
            const { gl: n } = this.renderer;
            e._scissorRect || n.enable(n.SCISSOR_TEST),
                e._scissorCounter++,
                e._scissorRect = e._scissorRectLocal,
                this._useCurrent()
        }
        pop(e) {
            const { gl: n } = this.renderer;
            e && eA.push(e._scissorRectLocal),
                this.getStackLength() > 0 ? this._useCurrent() : n.disable(n.SCISSOR_TEST)
        }
        _useCurrent() {
            const e = this.maskStack[this.maskStack.length - 1]._scissorRect;
            let n;
            this.renderer.renderTexture.current ? n = e.y : n = this.renderer.height - e.height - e.y,
                this.renderer.gl.scissor(e.x, n, e.width, e.height)
        }
    }
    ;
V6.extension = {
    type: Ae.RendererSystem,
    name: "scissor"
};
let Sce = V6;
Ue.add(Sce);
class G6 extends U6 {
    constructor(e) {
        super(e),
            this.glConst = Le.ADAPTER.getWebGLRenderingContext().STENCIL_TEST
    }
    getStackLength() {
        const e = this.maskStack[this.maskStack.length - 1];
        return e ? e._stencilCounter : 0
    }
    push(e) {
        const n = e.maskObject
            , { gl: s } = this.renderer
            , r = e._stencilCounter;
        r === 0 && (this.renderer.framebuffer.forceStencil(),
            s.clearStencil(0),
            s.clear(s.STENCIL_BUFFER_BIT),
            s.enable(s.STENCIL_TEST)),
            e._stencilCounter++;
        const i = e._colorMask;
        i !== 0 && (e._colorMask = 0,
            s.colorMask(!1, !1, !1, !1)),
            s.stencilFunc(s.EQUAL, r, 4294967295),
            s.stencilOp(s.KEEP, s.KEEP, s.INCR),
            n.renderable = !0,
            n.render(this.renderer),
            this.renderer.batch.flush(),
            n.renderable = !1,
            i !== 0 && (e._colorMask = i,
                s.colorMask((i & 1) !== 0, (i & 2) !== 0, (i & 4) !== 0, (i & 8) !== 0)),
            this._useCurrent()
    }
    pop(e) {
        const n = this.renderer.gl;
        if (this.getStackLength() === 0)
            n.disable(n.STENCIL_TEST);
        else {
            const s = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null
                , r = s ? s._colorMask : 15;
            r !== 0 && (s._colorMask = 0,
                n.colorMask(!1, !1, !1, !1)),
                n.stencilOp(n.KEEP, n.KEEP, n.DECR),
                e.renderable = !0,
                e.render(this.renderer),
                this.renderer.batch.flush(),
                e.renderable = !1,
                r !== 0 && (s._colorMask = r,
                    n.colorMask((r & 1) !== 0, (r & 2) !== 0, (r & 4) !== 0, (r & 8) !== 0)),
                this._useCurrent()
        }
    }
    _useCurrent() {
        const e = this.renderer.gl;
        e.stencilFunc(e.EQUAL, this.getStackLength(), 4294967295),
            e.stencilOp(e.KEEP, e.KEEP, e.KEEP)
    }
}
G6.extension = {
    type: Ae.RendererSystem,
    name: "stencil"
};
Ue.add(G6);
class H6 {
    constructor(e) {
        this.renderer = e,
            this.plugins = {},
            Object.defineProperties(this.plugins, {
                extract: {
                    enumerable: !1,
                    get() {
                        return dt("7.0.0", "renderer.plugins.extract has moved to renderer.extract"),
                            e.extract
                    }
                },
                prepare: {
                    enumerable: !1,
                    get() {
                        return dt("7.0.0", "renderer.plugins.prepare has moved to renderer.prepare"),
                            e.prepare
                    }
                },
                interaction: {
                    enumerable: !1,
                    get() {
                        return dt("7.0.0", "renderer.plugins.interaction has been deprecated, use renderer.events"),
                            e.events
                    }
                }
            })
    }
    init() {
        const e = this.rendererPlugins;
        for (const n in e)
            this.plugins[n] = new e[n](this.renderer)
    }
    destroy() {
        for (const e in this.plugins)
            this.plugins[e].destroy(),
                this.plugins[e] = null
    }
}
H6.extension = {
    type: [Ae.RendererSystem, Ae.CanvasRendererSystem],
    name: "_plugin"
};
Ue.add(H6);
class W6 {
    constructor(e) {
        this.renderer = e,
            this.destinationFrame = null,
            this.sourceFrame = null,
            this.defaultFrame = null,
            this.projectionMatrix = new Bt,
            this.transform = null
    }
    update(e, n, s, r) {
        this.destinationFrame = e || this.destinationFrame || this.defaultFrame,
            this.sourceFrame = n || this.sourceFrame || e,
            this.calculateProjection(this.destinationFrame, this.sourceFrame, s, r),
            this.transform && this.projectionMatrix.append(this.transform);
        const i = this.renderer;
        i.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix,
            i.globalUniforms.update(),
            i.shader.shader && i.shader.syncUniformGroup(i.shader.shader.uniforms.globals)
    }
    calculateProjection(e, n, s, r) {
        const i = this.projectionMatrix
            , o = r ? -1 : 1;
        i.identity(),
            i.a = 1 / n.width * 2,
            i.d = o * (1 / n.height * 2),
            i.tx = -1 - n.x * i.a,
            i.ty = -o - n.y * i.d
    }
    setTransform(e) { }
    destroy() {
        this.renderer = null
    }
}
W6.extension = {
    type: Ae.RendererSystem,
    name: "projection"
};
Ue.add(W6);
const Ece = new L_
    , tA = new nt;
class Y6 {
    constructor(e) {
        this.renderer = e,
            this._tempMatrix = new Bt
    }
    generateTexture(e, n) {
        const { region: s, ...r } = n || {}
            , i = (s == null ? void 0 : s.copyTo(tA)) || e.getLocalBounds(tA, !0)
            , o = r.resolution || this.renderer.resolution;
        i.width = Math.max(i.width, 1 / o),
            i.height = Math.max(i.height, 1 / o),
            r.width = i.width,
            r.height = i.height,
            r.resolution = o,
            r.multisample ?? (r.multisample = this.renderer.multisample);
        const l = Sc.create(r);
        this._tempMatrix.tx = -i.x,
            this._tempMatrix.ty = -i.y;
        const a = e.transform;
        return e.transform = Ece,
            this.renderer.render(e, {
                renderTexture: l,
                transform: this._tempMatrix,
                skipUpdateTransform: !!e.parent,
                blit: !0
            }),
            e.transform = a,
            l
    }
    destroy() { }
}
Y6.extension = {
    type: [Ae.RendererSystem, Ae.CanvasRendererSystem],
    name: "textureGenerator"
};
Ue.add(Y6);
const _l = new nt
    , Mh = new nt;
class X6 {
    constructor(e) {
        this.renderer = e,
            this.defaultMaskStack = [],
            this.current = null,
            this.sourceFrame = new nt,
            this.destinationFrame = new nt,
            this.viewportFrame = new nt
    }
    contextChange() {
        var n;
        const e = (n = this.renderer) == null ? void 0 : n.gl.getContextAttributes();
        this._rendererPremultipliedAlpha = !!(e && e.alpha && e.premultipliedAlpha)
    }
    bind(e = null, n, s) {
        const r = this.renderer;
        this.current = e;
        let i, o, l;
        e ? (i = e.baseTexture,
            l = i.resolution,
            n || (_l.width = e.frame.width,
                _l.height = e.frame.height,
                n = _l),
            s || (Mh.x = e.frame.x,
                Mh.y = e.frame.y,
                Mh.width = n.width,
                Mh.height = n.height,
                s = Mh),
            o = i.framebuffer) : (l = r.resolution,
                n || (_l.width = r._view.screen.width,
                    _l.height = r._view.screen.height,
                    n = _l),
                s || (s = _l,
                    s.width = n.width,
                    s.height = n.height));
        const a = this.viewportFrame;
        a.x = s.x * l,
            a.y = s.y * l,
            a.width = s.width * l,
            a.height = s.height * l,
            e || (a.y = r.view.height - (a.y + a.height)),
            a.ceil(),
            this.renderer.framebuffer.bind(o, a),
            this.renderer.projection.update(s, n, l, !o),
            e ? this.renderer.mask.setMaskStack(i.maskStack) : this.renderer.mask.setMaskStack(this.defaultMaskStack),
            this.sourceFrame.copyFrom(n),
            this.destinationFrame.copyFrom(s)
    }
    clear(e, n) {
        const s = this.current ? this.current.baseTexture.clear : this.renderer.background.backgroundColor
            , r = Yt.shared.setValue(e || s);
        (this.current && this.current.baseTexture.alphaMode > 0 || !this.current && this._rendererPremultipliedAlpha) && r.premultiply(r.alpha);
        const i = this.destinationFrame
            , o = this.current ? this.current.baseTexture : this.renderer._view.screen
            , l = i.width !== o.width || i.height !== o.height;
        if (l) {
            let { x: a, y: c, width: u, height: h } = this.viewportFrame;
            a = Math.round(a),
                c = Math.round(c),
                u = Math.round(u),
                h = Math.round(h),
                this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST),
                this.renderer.gl.scissor(a, c, u, h)
        }
        this.renderer.framebuffer.clear(r.red, r.green, r.blue, r.alpha, n),
            l && this.renderer.scissor.pop()
    }
    resize() {
        this.bind(null)
    }
    reset() {
        this.bind(null)
    }
    destroy() {
        this.renderer = null
    }
}
X6.extension = {
    type: Ae.RendererSystem,
    name: "renderTexture"
};
Ue.add(X6);
class Tce {
    constructor(e, n) {
        this.program = e,
            this.uniformData = n,
            this.uniformGroups = {},
            this.uniformDirtyGroups = {},
            this.uniformBufferBindings = {}
    }
    destroy() {
        this.uniformData = null,
            this.uniformGroups = null,
            this.uniformDirtyGroups = null,
            this.uniformBufferBindings = null,
            this.program = null
    }
}
function Cce(t, e) {
    const n = {}
        , s = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES);
    for (let r = 0; r < s; r++) {
        const i = e.getActiveAttrib(t, r);
        if (i.name.startsWith("gl_"))
            continue;
        const o = k6(e, i.type)
            , l = {
                type: o,
                name: i.name,
                size: A6(o),
                location: e.getAttribLocation(t, i.name)
            };
        n[i.name] = l
    }
    return n
}
function Ice(t, e) {
    const n = {}
        , s = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let r = 0; r < s; r++) {
        const i = e.getActiveUniform(t, r)
            , o = i.name.replace(/\[.*?\]$/, "")
            , l = !!i.name.match(/\[.*?\]$/)
            , a = k6(e, i.type);
        n[o] = {
            name: o,
            index: r,
            type: a,
            size: i.size,
            isArray: l,
            value: C6(a, i.size)
        }
    }
    return n
}
function Ace(t, e) {
    var l;
    const n = XI(t, t.VERTEX_SHADER, e.vertexSrc)
        , s = XI(t, t.FRAGMENT_SHADER, e.fragmentSrc)
        , r = t.createProgram();
    t.attachShader(r, n),
        t.attachShader(r, s);
    const i = (l = e.extra) == null ? void 0 : l.transformFeedbackVaryings;
    if (i && (typeof t.transformFeedbackVaryings != "function" ? console.warn("TransformFeedback is not supported but TransformFeedbackVaryings are given.") : t.transformFeedbackVaryings(r, i.names, i.bufferMode === "separate" ? t.SEPARATE_ATTRIBS : t.INTERLEAVED_ATTRIBS)),
        t.linkProgram(r),
        t.getProgramParameter(r, t.LINK_STATUS) || sce(t, r, n, s),
        e.attributeData = Cce(r, t),
        e.uniformData = Ice(r, t),
        !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(e.vertexSrc)) {
        const a = Object.keys(e.attributeData);
        a.sort((c, u) => c > u ? 1 : -1);
        for (let c = 0; c < a.length; c++)
            e.attributeData[a[c]].location = c,
                t.bindAttribLocation(r, c, a[c]);
        t.linkProgram(r)
    }
    t.deleteShader(n),
        t.deleteShader(s);
    const o = {};
    for (const a in e.uniformData) {
        const c = e.uniformData[a];
        o[a] = {
            location: t.getUniformLocation(r, a),
            value: C6(c.type, c.size)
        }
    }
    return new Tce(r, o)
}
function kce(t, e, n, s, r) {
    n.buffer.update(r)
}
const Rce = {
    float: `
        data[offset] = v;
    `,
    vec2: `
        data[offset] = v[0];
        data[offset+1] = v[1];
    `,
    vec3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

    `,
    vec4: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];
        data[offset+3] = v[3];
    `,
    mat2: `
        data[offset] = v[0];
        data[offset+1] = v[1];

        data[offset+4] = v[2];
        data[offset+5] = v[3];
    `,
    mat3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];

        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];
    `,
    mat4: `
        for(var i = 0; i < 16; i++)
        {
            data[offset + i] = v[i];
        }
    `
}
    , j6 = {
        float: 4,
        vec2: 8,
        vec3: 12,
        vec4: 16,
        int: 4,
        ivec2: 8,
        ivec3: 12,
        ivec4: 16,
        uint: 4,
        uvec2: 8,
        uvec3: 12,
        uvec4: 16,
        bool: 4,
        bvec2: 8,
        bvec3: 12,
        bvec4: 16,
        mat2: 16 * 2,
        mat3: 16 * 3,
        mat4: 16 * 4
    };
function Mce(t) {
    const e = t.map(i => ({
        data: i,
        offset: 0,
        dataLen: 0,
        dirty: 0
    }));
    let n = 0
        , s = 0
        , r = 0;
    for (let i = 0; i < e.length; i++) {
        const o = e[i];
        if (n = j6[o.data.type],
            o.data.size > 1 && (n = Math.max(n, 16) * o.data.size),
            o.dataLen = n,
            s % n !== 0 && s < 16) {
            const l = s % n % 16;
            s += l,
                r += l
        }
        s + n > 16 ? (r = Math.ceil(r / 16) * 16,
            o.offset = r,
            r += n,
            s = n) : (o.offset = r,
                s += n,
                r += n)
    }
    return r = Math.ceil(r / 16) * 16,
    {
        uboElements: e,
        size: r
    }
}
function Pce(t, e) {
    const n = [];
    for (const s in t)
        e[s] && n.push(e[s]);
    return n.sort((s, r) => s.index - r.index),
        n
}
function Lce(t, e) {
    if (!t.autoManage)
        return {
            size: 0,
            syncFunc: kce
        };
    const n = Pce(t.uniforms, e)
        , { uboElements: s, size: r } = Mce(n)
        , i = [`
    var v = null;
    var v2 = null;
    var cv = null;
    var t = 0;
    var gl = renderer.gl
    var index = 0;
    var data = buffer.data;
    `];
    for (let o = 0; o < s.length; o++) {
        const l = s[o]
            , a = t.uniforms[l.data.name]
            , c = l.data.name;
        let u = !1;
        for (let h = 0; h < Su.length; h++) {
            const d = Su[h];
            if (d.codeUbo && d.test(l.data, a)) {
                i.push(`offset = ${l.offset / 4};`, Su[h].codeUbo(l.data.name, a)),
                    u = !0;
                break
            }
        }
        if (!u)
            if (l.data.size > 1) {
                const h = A6(l.data.type)
                    , d = Math.max(j6[l.data.type] / 16, 1)
                    , f = h / d
                    , p = (4 - f % 4) % 4;
                i.push(`
                cv = ud.${c}.value;
                v = uv.${c};
                offset = ${l.offset / 4};

                t = 0;

                for(var i=0; i < ${l.data.size * d}; i++)
                {
                    for(var j = 0; j < ${f}; j++)
                    {
                        data[offset++] = v[t++];
                    }
                    offset += ${p};
                }

                `)
            } else {
                const h = Rce[l.data.type];
                i.push(`
                cv = ud.${c}.value;
                v = uv.${c};
                offset = ${l.offset / 4};
                ${h};
                `)
            }
    }
    return i.push(`
       renderer.buffer.update(buffer);
    `),
    {
        size: r,
        syncFunc: new Function("ud", "uv", "renderer", "syncData", "buffer", i.join(`
`))
    }
}
let Oce = 0;
const gp = {
    textureCount: 0,
    uboCount: 0
};
class z6 {
    constructor(e) {
        this.destroyed = !1,
            this.renderer = e,
            this.systemCheck(),
            this.gl = null,
            this.shader = null,
            this.program = null,
            this.cache = {},
            this._uboCache = {},
            this.id = Oce++
    }
    systemCheck() {
        if (!ice())
            throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.")
    }
    contextChange(e) {
        this.gl = e,
            this.reset()
    }
    bind(e, n) {
        e.disposeRunner.add(this),
            e.uniforms.globals = this.renderer.globalUniforms;
        const s = e.program
            , r = s.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(e);
        return this.shader = e,
            this.program !== s && (this.program = s,
                this.gl.useProgram(r.program)),
            n || (gp.textureCount = 0,
                gp.uboCount = 0,
                this.syncUniformGroup(e.uniformGroup, gp)),
            r
    }
    setUniforms(e) {
        const n = this.shader.program
            , s = n.glPrograms[this.renderer.CONTEXT_UID];
        n.syncUniforms(s.uniformData, e, this.renderer)
    }
    syncUniformGroup(e, n) {
        const s = this.getGlProgram();
        (!e.static || e.dirtyId !== s.uniformDirtyGroups[e.id]) && (s.uniformDirtyGroups[e.id] = e.dirtyId,
            this.syncUniforms(e, s, n))
    }
    syncUniforms(e, n, s) {
        (e.syncUniforms[this.shader.program.id] || this.createSyncGroups(e))(n.uniformData, e.uniforms, this.renderer, s)
    }
    createSyncGroups(e) {
        const n = this.getSignature(e, this.shader.program.uniformData, "u");
        return this.cache[n] || (this.cache[n] = ece(e, this.shader.program.uniformData)),
            e.syncUniforms[this.shader.program.id] = this.cache[n],
            e.syncUniforms[this.shader.program.id]
    }
    syncUniformBufferGroup(e, n) {
        const s = this.getGlProgram();
        if (!e.static || e.dirtyId !== 0 || !s.uniformGroups[e.id]) {
            e.dirtyId = 0;
            const r = s.uniformGroups[e.id] || this.createSyncBufferGroup(e, s, n);
            e.buffer.update(),
                r(s.uniformData, e.uniforms, this.renderer, gp, e.buffer)
        }
        this.renderer.buffer.bindBufferBase(e.buffer, s.uniformBufferBindings[n])
    }
    createSyncBufferGroup(e, n, s) {
        const { gl: r } = this.renderer;
        this.renderer.buffer.bind(e.buffer);
        const i = this.gl.getUniformBlockIndex(n.program, s);
        n.uniformBufferBindings[s] = this.shader.uniformBindCount,
            r.uniformBlockBinding(n.program, i, this.shader.uniformBindCount),
            this.shader.uniformBindCount++;
        const o = this.getSignature(e, this.shader.program.uniformData, "ubo");
        let l = this._uboCache[o];
        if (l || (l = this._uboCache[o] = Lce(e, this.shader.program.uniformData)),
            e.autoManage) {
            const a = new Float32Array(l.size / 4);
            e.buffer.update(a)
        }
        return n.uniformGroups[e.id] = l.syncFunc,
            n.uniformGroups[e.id]
    }
    getSignature(e, n, s) {
        const r = e.uniforms
            , i = [`${s}-`];
        for (const o in r)
            i.push(o),
                n[o] && i.push(n[o].type);
        return i.join("-")
    }
    getGlProgram() {
        return this.shader ? this.shader.program.glPrograms[this.renderer.CONTEXT_UID] : null
    }
    generateProgram(e) {
        const n = this.gl
            , s = e.program
            , r = Ace(n, s);
        return s.glPrograms[this.renderer.CONTEXT_UID] = r,
            r
    }
    reset() {
        this.program = null,
            this.shader = null
    }
    disposeShader(e) {
        this.shader === e && (this.shader = null)
    }
    destroy() {
        this.renderer = null,
            this.destroyed = !0
    }
}
z6.extension = {
    type: Ae.RendererSystem,
    name: "shader"
};
Ue.add(z6);
class Qm {
    constructor(e) {
        this.renderer = e
    }
    run(e) {
        const { renderer: n } = this;
        n.runners.init.emit(n.options),
            e.hello && console.log(`PixiJS 7.4.2 - ${n.rendererLogId} - https://pixijs.com`),
            n.resize(n.screen.width, n.screen.height)
    }
    destroy() { }
}
Qm.defaultOptions = {
    hello: !1
},
    Qm.extension = {
        type: [Ae.RendererSystem, Ae.CanvasRendererSystem],
        name: "startup"
    };
Ue.add(Qm);
function Nce(t, e = []) {
    return e[Oe.NORMAL] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
        e[Oe.ADD] = [t.ONE, t.ONE],
        e[Oe.MULTIPLY] = [t.DST_COLOR, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA],
        e[Oe.SCREEN] = [t.ONE, t.ONE_MINUS_SRC_COLOR, t.ONE, t.ONE_MINUS_SRC_ALPHA],
        e[Oe.OVERLAY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
        e[Oe.DARKEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
        e[Oe.LIGHTEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
        e[Oe.COLOR_DODGE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
        e[Oe.COLOR_BURN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
        e[Oe.HARD_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
        e[Oe.SOFT_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
        e[Oe.DIFFERENCE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
        e[Oe.EXCLUSION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
        e[Oe.HUE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
        e[Oe.SATURATION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
        e[Oe.COLOR] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
        e[Oe.LUMINOSITY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
        e[Oe.NONE] = [0, 0],
        e[Oe.NORMAL_NPM] = [t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA],
        e[Oe.ADD_NPM] = [t.SRC_ALPHA, t.ONE, t.ONE, t.ONE],
        e[Oe.SCREEN_NPM] = [t.SRC_ALPHA, t.ONE_MINUS_SRC_COLOR, t.ONE, t.ONE_MINUS_SRC_ALPHA],
        e[Oe.SRC_IN] = [t.DST_ALPHA, t.ZERO],
        e[Oe.SRC_OUT] = [t.ONE_MINUS_DST_ALPHA, t.ZERO],
        e[Oe.SRC_ATOP] = [t.DST_ALPHA, t.ONE_MINUS_SRC_ALPHA],
        e[Oe.DST_OVER] = [t.ONE_MINUS_DST_ALPHA, t.ONE],
        e[Oe.DST_IN] = [t.ZERO, t.SRC_ALPHA],
        e[Oe.DST_OUT] = [t.ZERO, t.ONE_MINUS_SRC_ALPHA],
        e[Oe.DST_ATOP] = [t.ONE_MINUS_DST_ALPHA, t.SRC_ALPHA],
        e[Oe.XOR] = [t.ONE_MINUS_DST_ALPHA, t.ONE_MINUS_SRC_ALPHA],
        e[Oe.SUBTRACT] = [t.ONE, t.ONE, t.ONE, t.ONE, t.FUNC_REVERSE_SUBTRACT, t.FUNC_ADD],
        e
}
const Dce = 0
    , Bce = 1
    , Fce = 2
    , $ce = 3
    , Uce = 4
    , Vce = 5
    , q6 = class Ab {
        constructor() {
            this.gl = null,
                this.stateId = 0,
                this.polygonOffset = 0,
                this.blendMode = Oe.NONE,
                this._blendEq = !1,
                this.map = [],
                this.map[Dce] = this.setBlend,
                this.map[Bce] = this.setOffset,
                this.map[Fce] = this.setCullFace,
                this.map[$ce] = this.setDepthTest,
                this.map[Uce] = this.setFrontFace,
                this.map[Vce] = this.setDepthMask,
                this.checks = [],
                this.defaultState = new Ji,
                this.defaultState.blend = !0
        }
        contextChange(e) {
            this.gl = e,
                this.blendModes = Nce(e),
                this.set(this.defaultState),
                this.reset()
        }
        set(e) {
            if (e = e || this.defaultState,
                this.stateId !== e.data) {
                let n = this.stateId ^ e.data
                    , s = 0;
                for (; n;)
                    n & 1 && this.map[s].call(this, !!(e.data & 1 << s)),
                        n = n >> 1,
                        s++;
                this.stateId = e.data
            }
            for (let n = 0; n < this.checks.length; n++)
                this.checks[n](this, e)
        }
        forceState(e) {
            e = e || this.defaultState;
            for (let n = 0; n < this.map.length; n++)
                this.map[n].call(this, !!(e.data & 1 << n));
            for (let n = 0; n < this.checks.length; n++)
                this.checks[n](this, e);
            this.stateId = e.data
        }
        setBlend(e) {
            this.updateCheck(Ab.checkBlendMode, e),
                this.gl[e ? "enable" : "disable"](this.gl.BLEND)
        }
        setOffset(e) {
            this.updateCheck(Ab.checkPolygonOffset, e),
                this.gl[e ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL)
        }
        setDepthTest(e) {
            this.gl[e ? "enable" : "disable"](this.gl.DEPTH_TEST)
        }
        setDepthMask(e) {
            this.gl.depthMask(e)
        }
        setCullFace(e) {
            this.gl[e ? "enable" : "disable"](this.gl.CULL_FACE)
        }
        setFrontFace(e) {
            this.gl.frontFace(this.gl[e ? "CW" : "CCW"])
        }
        setBlendMode(e) {
            if (e === this.blendMode)
                return;
            this.blendMode = e;
            const n = this.blendModes[e]
                , s = this.gl;
            n.length === 2 ? s.blendFunc(n[0], n[1]) : s.blendFuncSeparate(n[0], n[1], n[2], n[3]),
                n.length === 6 ? (this._blendEq = !0,
                    s.blendEquationSeparate(n[4], n[5])) : this._blendEq && (this._blendEq = !1,
                        s.blendEquationSeparate(s.FUNC_ADD, s.FUNC_ADD))
        }
        setPolygonOffset(e, n) {
            this.gl.polygonOffset(e, n)
        }
        reset() {
            this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1),
                this.forceState(this.defaultState),
                this._blendEq = !0,
                this.blendMode = -1,
                this.setBlendMode(0)
        }
        updateCheck(e, n) {
            const s = this.checks.indexOf(e);
            n && s === -1 ? this.checks.push(e) : !n && s !== -1 && this.checks.splice(s, 1)
        }
        static checkBlendMode(e, n) {
            e.setBlendMode(n.blendMode)
        }
        static checkPolygonOffset(e, n) {
            e.setPolygonOffset(1, n.polygonOffset)
        }
        destroy() {
            this.gl = null
        }
    }
    ;
q6.extension = {
    type: Ae.RendererSystem,
    name: "state"
};
let Gce = q6;
Ue.add(Gce);
class Hce extends yf {
    constructor() {
        super(...arguments),
            this.runners = {},
            this._systemsHash = {}
    }
    setup(e) {
        this.addRunners(...e.runners);
        const n = (e.priority ?? []).filter(r => e.systems[r])
            , s = [...n, ...Object.keys(e.systems).filter(r => !n.includes(r))];
        for (const r of s)
            this.addSystem(e.systems[r], r)
    }
    addRunners(...e) {
        e.forEach(n => {
            this.runners[n] = new ri(n)
        }
        )
    }
    addSystem(e, n) {
        const s = new e(this);
        if (this[n])
            throw new Error(`Whoops! The name "${n}" is already in use`);
        this[n] = s,
            this._systemsHash[n] = s;
        for (const r in this.runners)
            this.runners[r].add(s);
        return this
    }
    emitWithCustomOptions(e, n) {
        const s = Object.keys(this._systemsHash);
        e.items.forEach(r => {
            const i = s.find(o => this._systemsHash[o] === r);
            r[e.name](n[i])
        }
        )
    }
    destroy() {
        Object.values(this.runners).forEach(e => {
            e.destroy()
        }
        ),
            this._systemsHash = {}
    }
}
const Dh = class Zp {
    constructor(e) {
        this.renderer = e,
            this.count = 0,
            this.checkCount = 0,
            this.maxIdle = Zp.defaultMaxIdle,
            this.checkCountMax = Zp.defaultCheckCountMax,
            this.mode = Zp.defaultMode
    }
    postrender() {
        this.renderer.objectRenderer.renderingToScreen && (this.count++,
            this.mode !== Kx.MANUAL && (this.checkCount++,
                this.checkCount > this.checkCountMax && (this.checkCount = 0,
                    this.run())))
    }
    run() {
        const e = this.renderer.texture
            , n = e.managedTextures;
        let s = !1;
        for (let r = 0; r < n.length; r++) {
            const i = n[r];
            i.resource && this.count - i.touched > this.maxIdle && (e.destroyTexture(i, !0),
                n[r] = null,
                s = !0)
        }
        if (s) {
            let r = 0;
            for (let i = 0; i < n.length; i++)
                n[i] !== null && (n[r++] = n[i]);
            n.length = r
        }
    }
    unload(e) {
        const n = this.renderer.texture
            , s = e._texture;
        s && !s.framebuffer && n.destroyTexture(s);
        for (let r = e.children.length - 1; r >= 0; r--)
            this.unload(e.children[r])
    }
    destroy() {
        this.renderer = null
    }
}
    ;
Dh.defaultMode = Kx.AUTO,
    Dh.defaultMaxIdle = 60 * 60,
    Dh.defaultCheckCountMax = 60 * 10,
    Dh.extension = {
        type: Ae.RendererSystem,
        name: "textureGC"
    };
let Tl = Dh;
Ue.add(Tl);
class b1 {
    constructor(e) {
        this.texture = e,
            this.width = -1,
            this.height = -1,
            this.dirtyId = -1,
            this.dirtyStyleId = -1,
            this.mipmap = !1,
            this.wrapMode = 33071,
            this.type = Ge.UNSIGNED_BYTE,
            this.internalFormat = Ee.RGBA,
            this.samplerType = 0
    }
}
function Wce(t) {
    let e;
    return "WebGL2RenderingContext" in globalThis && t instanceof globalThis.WebGL2RenderingContext ? e = {
        [t.RGB]: Ne.FLOAT,
        [t.RGBA]: Ne.FLOAT,
        [t.ALPHA]: Ne.FLOAT,
        [t.LUMINANCE]: Ne.FLOAT,
        [t.LUMINANCE_ALPHA]: Ne.FLOAT,
        [t.R8]: Ne.FLOAT,
        [t.R8_SNORM]: Ne.FLOAT,
        [t.RG8]: Ne.FLOAT,
        [t.RG8_SNORM]: Ne.FLOAT,
        [t.RGB8]: Ne.FLOAT,
        [t.RGB8_SNORM]: Ne.FLOAT,
        [t.RGB565]: Ne.FLOAT,
        [t.RGBA4]: Ne.FLOAT,
        [t.RGB5_A1]: Ne.FLOAT,
        [t.RGBA8]: Ne.FLOAT,
        [t.RGBA8_SNORM]: Ne.FLOAT,
        [t.RGB10_A2]: Ne.FLOAT,
        [t.RGB10_A2UI]: Ne.FLOAT,
        [t.SRGB8]: Ne.FLOAT,
        [t.SRGB8_ALPHA8]: Ne.FLOAT,
        [t.R16F]: Ne.FLOAT,
        [t.RG16F]: Ne.FLOAT,
        [t.RGB16F]: Ne.FLOAT,
        [t.RGBA16F]: Ne.FLOAT,
        [t.R32F]: Ne.FLOAT,
        [t.RG32F]: Ne.FLOAT,
        [t.RGB32F]: Ne.FLOAT,
        [t.RGBA32F]: Ne.FLOAT,
        [t.R11F_G11F_B10F]: Ne.FLOAT,
        [t.RGB9_E5]: Ne.FLOAT,
        [t.R8I]: Ne.INT,
        [t.R8UI]: Ne.UINT,
        [t.R16I]: Ne.INT,
        [t.R16UI]: Ne.UINT,
        [t.R32I]: Ne.INT,
        [t.R32UI]: Ne.UINT,
        [t.RG8I]: Ne.INT,
        [t.RG8UI]: Ne.UINT,
        [t.RG16I]: Ne.INT,
        [t.RG16UI]: Ne.UINT,
        [t.RG32I]: Ne.INT,
        [t.RG32UI]: Ne.UINT,
        [t.RGB8I]: Ne.INT,
        [t.RGB8UI]: Ne.UINT,
        [t.RGB16I]: Ne.INT,
        [t.RGB16UI]: Ne.UINT,
        [t.RGB32I]: Ne.INT,
        [t.RGB32UI]: Ne.UINT,
        [t.RGBA8I]: Ne.INT,
        [t.RGBA8UI]: Ne.UINT,
        [t.RGBA16I]: Ne.INT,
        [t.RGBA16UI]: Ne.UINT,
        [t.RGBA32I]: Ne.INT,
        [t.RGBA32UI]: Ne.UINT,
        [t.DEPTH_COMPONENT16]: Ne.FLOAT,
        [t.DEPTH_COMPONENT24]: Ne.FLOAT,
        [t.DEPTH_COMPONENT32F]: Ne.FLOAT,
        [t.DEPTH_STENCIL]: Ne.FLOAT,
        [t.DEPTH24_STENCIL8]: Ne.FLOAT,
        [t.DEPTH32F_STENCIL8]: Ne.FLOAT
    } : e = {
        [t.RGB]: Ne.FLOAT,
        [t.RGBA]: Ne.FLOAT,
        [t.ALPHA]: Ne.FLOAT,
        [t.LUMINANCE]: Ne.FLOAT,
        [t.LUMINANCE_ALPHA]: Ne.FLOAT,
        [t.DEPTH_STENCIL]: Ne.FLOAT
    },
        e
}
function Yce(t) {
    let e;
    return "WebGL2RenderingContext" in globalThis && t instanceof globalThis.WebGL2RenderingContext ? e = {
        [Ge.UNSIGNED_BYTE]: {
            [Ee.RGBA]: t.RGBA8,
            [Ee.RGB]: t.RGB8,
            [Ee.RG]: t.RG8,
            [Ee.RED]: t.R8,
            [Ee.RGBA_INTEGER]: t.RGBA8UI,
            [Ee.RGB_INTEGER]: t.RGB8UI,
            [Ee.RG_INTEGER]: t.RG8UI,
            [Ee.RED_INTEGER]: t.R8UI,
            [Ee.ALPHA]: t.ALPHA,
            [Ee.LUMINANCE]: t.LUMINANCE,
            [Ee.LUMINANCE_ALPHA]: t.LUMINANCE_ALPHA
        },
        [Ge.BYTE]: {
            [Ee.RGBA]: t.RGBA8_SNORM,
            [Ee.RGB]: t.RGB8_SNORM,
            [Ee.RG]: t.RG8_SNORM,
            [Ee.RED]: t.R8_SNORM,
            [Ee.RGBA_INTEGER]: t.RGBA8I,
            [Ee.RGB_INTEGER]: t.RGB8I,
            [Ee.RG_INTEGER]: t.RG8I,
            [Ee.RED_INTEGER]: t.R8I
        },
        [Ge.UNSIGNED_SHORT]: {
            [Ee.RGBA_INTEGER]: t.RGBA16UI,
            [Ee.RGB_INTEGER]: t.RGB16UI,
            [Ee.RG_INTEGER]: t.RG16UI,
            [Ee.RED_INTEGER]: t.R16UI,
            [Ee.DEPTH_COMPONENT]: t.DEPTH_COMPONENT16
        },
        [Ge.SHORT]: {
            [Ee.RGBA_INTEGER]: t.RGBA16I,
            [Ee.RGB_INTEGER]: t.RGB16I,
            [Ee.RG_INTEGER]: t.RG16I,
            [Ee.RED_INTEGER]: t.R16I
        },
        [Ge.UNSIGNED_INT]: {
            [Ee.RGBA_INTEGER]: t.RGBA32UI,
            [Ee.RGB_INTEGER]: t.RGB32UI,
            [Ee.RG_INTEGER]: t.RG32UI,
            [Ee.RED_INTEGER]: t.R32UI,
            [Ee.DEPTH_COMPONENT]: t.DEPTH_COMPONENT24
        },
        [Ge.INT]: {
            [Ee.RGBA_INTEGER]: t.RGBA32I,
            [Ee.RGB_INTEGER]: t.RGB32I,
            [Ee.RG_INTEGER]: t.RG32I,
            [Ee.RED_INTEGER]: t.R32I
        },
        [Ge.FLOAT]: {
            [Ee.RGBA]: t.RGBA32F,
            [Ee.RGB]: t.RGB32F,
            [Ee.RG]: t.RG32F,
            [Ee.RED]: t.R32F,
            [Ee.DEPTH_COMPONENT]: t.DEPTH_COMPONENT32F
        },
        [Ge.HALF_FLOAT]: {
            [Ee.RGBA]: t.RGBA16F,
            [Ee.RGB]: t.RGB16F,
            [Ee.RG]: t.RG16F,
            [Ee.RED]: t.R16F
        },
        [Ge.UNSIGNED_SHORT_5_6_5]: {
            [Ee.RGB]: t.RGB565
        },
        [Ge.UNSIGNED_SHORT_4_4_4_4]: {
            [Ee.RGBA]: t.RGBA4
        },
        [Ge.UNSIGNED_SHORT_5_5_5_1]: {
            [Ee.RGBA]: t.RGB5_A1
        },
        [Ge.UNSIGNED_INT_2_10_10_10_REV]: {
            [Ee.RGBA]: t.RGB10_A2,
            [Ee.RGBA_INTEGER]: t.RGB10_A2UI
        },
        [Ge.UNSIGNED_INT_10F_11F_11F_REV]: {
            [Ee.RGB]: t.R11F_G11F_B10F
        },
        [Ge.UNSIGNED_INT_5_9_9_9_REV]: {
            [Ee.RGB]: t.RGB9_E5
        },
        [Ge.UNSIGNED_INT_24_8]: {
            [Ee.DEPTH_STENCIL]: t.DEPTH24_STENCIL8
        },
        [Ge.FLOAT_32_UNSIGNED_INT_24_8_REV]: {
            [Ee.DEPTH_STENCIL]: t.DEPTH32F_STENCIL8
        }
    } : e = {
        [Ge.UNSIGNED_BYTE]: {
            [Ee.RGBA]: t.RGBA,
            [Ee.RGB]: t.RGB,
            [Ee.ALPHA]: t.ALPHA,
            [Ee.LUMINANCE]: t.LUMINANCE,
            [Ee.LUMINANCE_ALPHA]: t.LUMINANCE_ALPHA
        },
        [Ge.UNSIGNED_SHORT_5_6_5]: {
            [Ee.RGB]: t.RGB
        },
        [Ge.UNSIGNED_SHORT_4_4_4_4]: {
            [Ee.RGBA]: t.RGBA
        },
        [Ge.UNSIGNED_SHORT_5_5_5_1]: {
            [Ee.RGBA]: t.RGBA
        }
    },
        e
}
class K6 {
    constructor(e) {
        this.renderer = e,
            this.boundTextures = [],
            this.currentLocation = -1,
            this.managedTextures = [],
            this._unknownBoundTextures = !1,
            this.unknownTexture = new st,
            this.hasIntegerTextures = !1
    }
    contextChange() {
        const e = this.gl = this.renderer.gl;
        this.CONTEXT_UID = this.renderer.CONTEXT_UID,
            this.webGLVersion = this.renderer.context.webGLVersion,
            this.internalFormats = Yce(e),
            this.samplerTypes = Wce(e);
        const n = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS);
        this.boundTextures.length = n;
        for (let r = 0; r < n; r++)
            this.boundTextures[r] = null;
        this.emptyTextures = {};
        const s = new b1(e.createTexture());
        e.bindTexture(e.TEXTURE_2D, s.texture),
            e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, 1, 1, 0, e.RGBA, e.UNSIGNED_BYTE, new Uint8Array(4)),
            this.emptyTextures[e.TEXTURE_2D] = s,
            this.emptyTextures[e.TEXTURE_CUBE_MAP] = new b1(e.createTexture()),
            e.bindTexture(e.TEXTURE_CUBE_MAP, this.emptyTextures[e.TEXTURE_CUBE_MAP].texture);
        for (let r = 0; r < 6; r++)
            e.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + r, 0, e.RGBA, 1, 1, 0, e.RGBA, e.UNSIGNED_BYTE, null);
        e.texParameteri(e.TEXTURE_CUBE_MAP, e.TEXTURE_MAG_FILTER, e.LINEAR),
            e.texParameteri(e.TEXTURE_CUBE_MAP, e.TEXTURE_MIN_FILTER, e.LINEAR);
        for (let r = 0; r < this.boundTextures.length; r++)
            this.bind(null, r)
    }
    bind(e, n = 0) {
        const { gl: s } = this;
        if (e = e == null ? void 0 : e.castToBaseTexture(),
            (e == null ? void 0 : e.valid) && !e.parentTextureArray) {
            e.touched = this.renderer.textureGC.count;
            const r = e._glTextures[this.CONTEXT_UID] || this.initTexture(e);
            this.boundTextures[n] !== e && (this.currentLocation !== n && (this.currentLocation = n,
                s.activeTexture(s.TEXTURE0 + n)),
                s.bindTexture(e.target, r.texture)),
                r.dirtyId !== e.dirtyId ? (this.currentLocation !== n && (this.currentLocation = n,
                    s.activeTexture(s.TEXTURE0 + n)),
                    this.updateTexture(e)) : r.dirtyStyleId !== e.dirtyStyleId && this.updateTextureStyle(e),
                this.boundTextures[n] = e
        } else
            this.currentLocation !== n && (this.currentLocation = n,
                s.activeTexture(s.TEXTURE0 + n)),
                s.bindTexture(s.TEXTURE_2D, this.emptyTextures[s.TEXTURE_2D].texture),
                this.boundTextures[n] = null
    }
    reset() {
        this._unknownBoundTextures = !0,
            this.hasIntegerTextures = !1,
            this.currentLocation = -1;
        for (let e = 0; e < this.boundTextures.length; e++)
            this.boundTextures[e] = this.unknownTexture
    }
    unbind(e) {
        const { gl: n, boundTextures: s } = this;
        if (this._unknownBoundTextures) {
            this._unknownBoundTextures = !1;
            for (let r = 0; r < s.length; r++)
                s[r] === this.unknownTexture && this.bind(null, r)
        }
        for (let r = 0; r < s.length; r++)
            s[r] === e && (this.currentLocation !== r && (n.activeTexture(n.TEXTURE0 + r),
                this.currentLocation = r),
                n.bindTexture(e.target, this.emptyTextures[e.target].texture),
                s[r] = null)
    }
    ensureSamplerType(e) {
        const { boundTextures: n, hasIntegerTextures: s, CONTEXT_UID: r } = this;
        if (s)
            for (let i = e - 1; i >= 0; --i) {
                const o = n[i];
                o && o._glTextures[r].samplerType !== Ne.FLOAT && this.renderer.texture.unbind(o)
            }
    }
    initTexture(e) {
        const n = new b1(this.gl.createTexture());
        return n.dirtyId = -1,
            e._glTextures[this.CONTEXT_UID] = n,
            this.managedTextures.push(e),
            e.on("dispose", this.destroyTexture, this),
            n
    }
    initTextureType(e, n) {
        var s;
        n.internalFormat = ((s = this.internalFormats[e.type]) == null ? void 0 : s[e.format]) ?? e.format,
            n.samplerType = this.samplerTypes[n.internalFormat] ?? Ne.FLOAT,
            this.webGLVersion === 2 && e.type === Ge.HALF_FLOAT ? n.type = this.gl.HALF_FLOAT : n.type = e.type
    }
    updateTexture(e) {
        var r;
        const n = e._glTextures[this.CONTEXT_UID];
        if (!n)
            return;
        const s = this.renderer;
        if (this.initTextureType(e, n),
            (r = e.resource) == null ? void 0 : r.upload(s, e, n))
            n.samplerType !== Ne.FLOAT && (this.hasIntegerTextures = !0);
        else {
            const i = e.realWidth
                , o = e.realHeight
                , l = s.gl;
            (n.width !== i || n.height !== o || n.dirtyId < 0) && (n.width = i,
                n.height = o,
                l.texImage2D(e.target, 0, n.internalFormat, i, o, 0, e.format, n.type, null))
        }
        e.dirtyStyleId !== n.dirtyStyleId && this.updateTextureStyle(e),
            n.dirtyId = e.dirtyId
    }
    destroyTexture(e, n) {
        const { gl: s } = this;
        if (e = e.castToBaseTexture(),
            e._glTextures[this.CONTEXT_UID] && (this.unbind(e),
                s.deleteTexture(e._glTextures[this.CONTEXT_UID].texture),
                e.off("dispose", this.destroyTexture, this),
                delete e._glTextures[this.CONTEXT_UID],
                !n)) {
            const r = this.managedTextures.indexOf(e);
            r !== -1 && wu(this.managedTextures, r, 1)
        }
    }
    updateTextureStyle(e) {
        var s;
        const n = e._glTextures[this.CONTEXT_UID];
        n && ((e.mipmap === ci.POW2 || this.webGLVersion !== 2) && !e.isPowerOfTwo ? n.mipmap = !1 : n.mipmap = e.mipmap >= 1,
            this.webGLVersion !== 2 && !e.isPowerOfTwo ? n.wrapMode = Ua.CLAMP : n.wrapMode = e.wrapMode,
            (s = e.resource) != null && s.style(this.renderer, e, n) || this.setStyle(e, n),
            n.dirtyStyleId = e.dirtyStyleId)
    }
    setStyle(e, n) {
        const s = this.gl;
        if (n.mipmap && e.mipmap !== ci.ON_MANUAL && s.generateMipmap(e.target),
            s.texParameteri(e.target, s.TEXTURE_WRAP_S, n.wrapMode),
            s.texParameteri(e.target, s.TEXTURE_WRAP_T, n.wrapMode),
            n.mipmap) {
            s.texParameteri(e.target, s.TEXTURE_MIN_FILTER, e.scaleMode === ar.LINEAR ? s.LINEAR_MIPMAP_LINEAR : s.NEAREST_MIPMAP_NEAREST);
            const r = this.renderer.context.extensions.anisotropicFiltering;
            if (r && e.anisotropicLevel > 0 && e.scaleMode === ar.LINEAR) {
                const i = Math.min(e.anisotropicLevel, s.getParameter(r.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
                s.texParameterf(e.target, r.TEXTURE_MAX_ANISOTROPY_EXT, i)
            }
        } else
            s.texParameteri(e.target, s.TEXTURE_MIN_FILTER, e.scaleMode === ar.LINEAR ? s.LINEAR : s.NEAREST);
        s.texParameteri(e.target, s.TEXTURE_MAG_FILTER, e.scaleMode === ar.LINEAR ? s.LINEAR : s.NEAREST)
    }
    destroy() {
        this.renderer = null
    }
}
K6.extension = {
    type: Ae.RendererSystem,
    name: "texture"
};
Ue.add(K6);
class J6 {
    constructor(e) {
        this.renderer = e
    }
    contextChange() {
        this.gl = this.renderer.gl,
            this.CONTEXT_UID = this.renderer.CONTEXT_UID
    }
    bind(e) {
        const { gl: n, CONTEXT_UID: s } = this
            , r = e._glTransformFeedbacks[s] || this.createGLTransformFeedback(e);
        n.bindTransformFeedback(n.TRANSFORM_FEEDBACK, r)
    }
    unbind() {
        const { gl: e } = this;
        e.bindTransformFeedback(e.TRANSFORM_FEEDBACK, null)
    }
    beginTransformFeedback(e, n) {
        const { gl: s, renderer: r } = this;
        n && r.shader.bind(n),
            s.beginTransformFeedback(e)
    }
    endTransformFeedback() {
        const { gl: e } = this;
        e.endTransformFeedback()
    }
    createGLTransformFeedback(e) {
        const { gl: n, renderer: s, CONTEXT_UID: r } = this
            , i = n.createTransformFeedback();
        e._glTransformFeedbacks[r] = i,
            n.bindTransformFeedback(n.TRANSFORM_FEEDBACK, i);
        for (let o = 0; o < e.buffers.length; o++) {
            const l = e.buffers[o];
            l && (s.buffer.update(l),
                l._glBuffers[r].refCount++,
                n.bindBufferBase(n.TRANSFORM_FEEDBACK_BUFFER, o, l._glBuffers[r].buffer || null))
        }
        return n.bindTransformFeedback(n.TRANSFORM_FEEDBACK, null),
            e.disposeRunner.add(this),
            i
    }
    disposeTransformFeedback(e, n) {
        const s = e._glTransformFeedbacks[this.CONTEXT_UID]
            , r = this.gl;
        e.disposeRunner.remove(this);
        const i = this.renderer.buffer;
        if (i)
            for (let o = 0; o < e.buffers.length; o++) {
                const l = e.buffers[o];
                if (!l)
                    continue;
                const a = l._glBuffers[this.CONTEXT_UID];
                a && (a.refCount--,
                    a.refCount === 0 && !n && i.dispose(l, n))
            }
        s && (n || r.deleteTransformFeedback(s),
            delete e._glTransformFeedbacks[this.CONTEXT_UID])
    }
    destroy() {
        this.renderer = null
    }
}
J6.extension = {
    type: Ae.RendererSystem,
    name: "transformFeedback"
};
Ue.add(J6);
class eg {
    constructor(e) {
        this.renderer = e
    }
    init(e) {
        this.screen = new nt(0, 0, e.width, e.height),
            this.element = e.view || Le.ADAPTER.createCanvas(),
            this.resolution = e.resolution || Le.RESOLUTION,
            this.autoDensity = !!e.autoDensity
    }
    resizeView(e, n) {
        this.element.width = Math.round(e * this.resolution),
            this.element.height = Math.round(n * this.resolution);
        const s = this.element.width / this.resolution
            , r = this.element.height / this.resolution;
        this.screen.width = s,
            this.screen.height = r,
            this.autoDensity && (this.element.style.width = `${s}px`,
                this.element.style.height = `${r}px`),
            this.renderer.emit("resize", s, r),
            this.renderer.runners.resize.emit(this.screen.width, this.screen.height)
    }
    destroy(e) {
        var n;
        e && ((n = this.element.parentNode) == null || n.removeChild(this.element)),
            this.renderer = null,
            this.element = null,
            this.screen = null
    }
}
eg.defaultOptions = {
    width: 800,
    height: 600,
    resolution: void 0,
    autoDensity: !1
},
    eg.extension = {
        type: [Ae.RendererSystem, Ae.CanvasRendererSystem],
        name: "_view"
    };
Ue.add(eg);
Le.PREFER_ENV = wc.WEBGL2;
Le.STRICT_TEXTURE_CACHE = !1;
Le.RENDER_OPTIONS = {
    ...Zm.defaultOptions,
    ...Jm.defaultOptions,
    ...eg.defaultOptions,
    ...Qm.defaultOptions
};
Object.defineProperties(Le, {
    WRAP_MODE: {
        get() {
            return st.defaultOptions.wrapMode
        },
        set(t) {
            dt("7.1.0", "settings.WRAP_MODE is deprecated, use BaseTexture.defaultOptions.wrapMode"),
                st.defaultOptions.wrapMode = t
        }
    },
    SCALE_MODE: {
        get() {
            return st.defaultOptions.scaleMode
        },
        set(t) {
            dt("7.1.0", "settings.SCALE_MODE is deprecated, use BaseTexture.defaultOptions.scaleMode"),
                st.defaultOptions.scaleMode = t
        }
    },
    MIPMAP_TEXTURES: {
        get() {
            return st.defaultOptions.mipmap
        },
        set(t) {
            dt("7.1.0", "settings.MIPMAP_TEXTURES is deprecated, use BaseTexture.defaultOptions.mipmap"),
                st.defaultOptions.mipmap = t
        }
    },
    ANISOTROPIC_LEVEL: {
        get() {
            return st.defaultOptions.anisotropicLevel
        },
        set(t) {
            dt("7.1.0", "settings.ANISOTROPIC_LEVEL is deprecated, use BaseTexture.defaultOptions.anisotropicLevel"),
                st.defaultOptions.anisotropicLevel = t
        }
    },
    FILTER_RESOLUTION: {
        get() {
            return dt("7.1.0", "settings.FILTER_RESOLUTION is deprecated, use Filter.defaultResolution"),
                As.defaultResolution
        },
        set(t) {
            As.defaultResolution = t
        }
    },
    FILTER_MULTISAMPLE: {
        get() {
            return dt("7.1.0", "settings.FILTER_MULTISAMPLE is deprecated, use Filter.defaultMultisample"),
                As.defaultMultisample
        },
        set(t) {
            As.defaultMultisample = t
        }
    },
    SPRITE_MAX_TEXTURES: {
        get() {
            return El.defaultMaxTextures
        },
        set(t) {
            dt("7.1.0", "settings.SPRITE_MAX_TEXTURES is deprecated, use BatchRenderer.defaultMaxTextures"),
                El.defaultMaxTextures = t
        }
    },
    SPRITE_BATCH_SIZE: {
        get() {
            return El.defaultBatchSize
        },
        set(t) {
            dt("7.1.0", "settings.SPRITE_BATCH_SIZE is deprecated, use BatchRenderer.defaultBatchSize"),
                El.defaultBatchSize = t
        }
    },
    CAN_UPLOAD_SAME_BUFFER: {
        get() {
            return El.canUploadSameBuffer
        },
        set(t) {
            dt("7.1.0", "settings.CAN_UPLOAD_SAME_BUFFER is deprecated, use BatchRenderer.canUploadSameBuffer"),
                El.canUploadSameBuffer = t
        }
    },
    GC_MODE: {
        get() {
            return Tl.defaultMode
        },
        set(t) {
            dt("7.1.0", "settings.GC_MODE is deprecated, use TextureGCSystem.defaultMode"),
                Tl.defaultMode = t
        }
    },
    GC_MAX_IDLE: {
        get() {
            return Tl.defaultMaxIdle
        },
        set(t) {
            dt("7.1.0", "settings.GC_MAX_IDLE is deprecated, use TextureGCSystem.defaultMaxIdle"),
                Tl.defaultMaxIdle = t
        }
    },
    GC_MAX_CHECK_COUNT: {
        get() {
            return Tl.defaultCheckCountMax
        },
        set(t) {
            dt("7.1.0", "settings.GC_MAX_CHECK_COUNT is deprecated, use TextureGCSystem.defaultCheckCountMax"),
                Tl.defaultCheckCountMax = t
        }
    },
    PRECISION_VERTEX: {
        get() {
            return So.defaultVertexPrecision
        },
        set(t) {
            dt("7.1.0", "settings.PRECISION_VERTEX is deprecated, use Program.defaultVertexPrecision"),
                So.defaultVertexPrecision = t
        }
    },
    PRECISION_FRAGMENT: {
        get() {
            return So.defaultFragmentPrecision
        },
        set(t) {
            dt("7.1.0", "settings.PRECISION_FRAGMENT is deprecated, use Program.defaultFragmentPrecision"),
                So.defaultFragmentPrecision = t
        }
    }
});
var cc = (t => (t[t.INTERACTION = 50] = "INTERACTION",
    t[t.HIGH = 25] = "HIGH",
    t[t.NORMAL = 0] = "NORMAL",
    t[t.LOW = -25] = "LOW",
    t[t.UTILITY = -50] = "UTILITY",
    t))(cc || {});
class v1 {
    constructor(e, n = null, s = 0, r = !1) {
        this.next = null,
            this.previous = null,
            this._destroyed = !1,
            this.fn = e,
            this.context = n,
            this.priority = s,
            this.once = r
    }
    match(e, n = null) {
        return this.fn === e && this.context === n
    }
    emit(e) {
        this.fn && (this.context ? this.fn.call(this.context, e) : this.fn(e));
        const n = this.next;
        return this.once && this.destroy(!0),
            this._destroyed && (this.next = null),
            n
    }
    connect(e) {
        this.previous = e,
            e.next && (e.next.previous = this),
            this.next = e.next,
            e.next = this
    }
    destroy(e = !1) {
        this._destroyed = !0,
            this.fn = null,
            this.context = null,
            this.previous && (this.previous.next = this.next),
            this.next && (this.next.previous = this.previous);
        const n = this.next;
        return this.next = e ? null : n,
            this.previous = null,
            n
    }
}
const Z6 = class nr {
    constructor() {
        this.autoStart = !1,
            this.deltaTime = 1,
            this.lastTime = -1,
            this.speed = 1,
            this.started = !1,
            this._requestId = null,
            this._maxElapsedMS = 100,
            this._minElapsedMS = 0,
            this._protected = !1,
            this._lastFrame = -1,
            this._head = new v1(null, null, 1 / 0),
            this.deltaMS = 1 / nr.targetFPMS,
            this.elapsedMS = 1 / nr.targetFPMS,
            this._tick = e => {
                this._requestId = null,
                    this.started && (this.update(e),
                        this.started && this._requestId === null && this._head.next && (this._requestId = requestAnimationFrame(this._tick)))
            }
    }
    _requestIfNeeded() {
        this._requestId === null && this._head.next && (this.lastTime = performance.now(),
            this._lastFrame = this.lastTime,
            this._requestId = requestAnimationFrame(this._tick))
    }
    _cancelIfNeeded() {
        this._requestId !== null && (cancelAnimationFrame(this._requestId),
            this._requestId = null)
    }
    _startIfPossible() {
        this.started ? this._requestIfNeeded() : this.autoStart && this.start()
    }
    add(e, n, s = cc.NORMAL) {
        return this._addListener(new v1(e, n, s))
    }
    addOnce(e, n, s = cc.NORMAL) {
        return this._addListener(new v1(e, n, s, !0))
    }
    _addListener(e) {
        let n = this._head.next
            , s = this._head;
        if (!n)
            e.connect(s);
        else {
            for (; n;) {
                if (e.priority > n.priority) {
                    e.connect(s);
                    break
                }
                s = n,
                    n = n.next
            }
            e.previous || e.connect(s)
        }
        return this._startIfPossible(),
            this
    }
    remove(e, n) {
        let s = this._head.next;
        for (; s;)
            s.match(e, n) ? s = s.destroy() : s = s.next;
        return this._head.next || this._cancelIfNeeded(),
            this
    }
    get count() {
        if (!this._head)
            return 0;
        let e = 0
            , n = this._head;
        for (; n = n.next;)
            e++;
        return e
    }
    start() {
        this.started || (this.started = !0,
            this._requestIfNeeded())
    }
    stop() {
        this.started && (this.started = !1,
            this._cancelIfNeeded())
    }
    destroy() {
        if (!this._protected) {
            this.stop();
            let e = this._head.next;
            for (; e;)
                e = e.destroy(!0);
            this._head.destroy(),
                this._head = null
        }
    }
    update(e = performance.now()) {
        let n;
        if (e > this.lastTime) {
            if (n = this.elapsedMS = e - this.lastTime,
                n > this._maxElapsedMS && (n = this._maxElapsedMS),
                n *= this.speed,
                this._minElapsedMS) {
                const i = e - this._lastFrame | 0;
                if (i < this._minElapsedMS)
                    return;
                this._lastFrame = e - i % this._minElapsedMS
            }
            this.deltaMS = n,
                this.deltaTime = this.deltaMS * nr.targetFPMS;
            const s = this._head;
            let r = s.next;
            for (; r;)
                r = r.emit(this.deltaTime);
            s.next || this._cancelIfNeeded()
        } else
            this.deltaTime = this.deltaMS = this.elapsedMS = 0;
        this.lastTime = e
    }
    get FPS() {
        return 1e3 / this.elapsedMS
    }
    get minFPS() {
        return 1e3 / this._maxElapsedMS
    }
    set minFPS(e) {
        const n = Math.min(this.maxFPS, e)
            , s = Math.min(Math.max(0, n) / 1e3, nr.targetFPMS);
        this._maxElapsedMS = 1 / s
    }
    get maxFPS() {
        return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0
    }
    set maxFPS(e) {
        if (e === 0)
            this._minElapsedMS = 0;
        else {
            const n = Math.max(this.minFPS, e);
            this._minElapsedMS = 1 / (n / 1e3)
        }
    }
    static get shared() {
        if (!nr._shared) {
            const e = nr._shared = new nr;
            e.autoStart = !0,
                e._protected = !0
        }
        return nr._shared
    }
    static get system() {
        if (!nr._system) {
            const e = nr._system = new nr;
            e.autoStart = !0,
                e._protected = !0
        }
        return nr._system
    }
}
    ;
Z6.targetFPMS = .06;
let lr = Z6;
Object.defineProperties(Le, {
    TARGET_FPMS: {
        get() {
            return lr.targetFPMS
        },
        set(t) {
            dt("7.1.0", "settings.TARGET_FPMS is deprecated, use Ticker.targetFPMS"),
                lr.targetFPMS = t
        }
    }
});
class Q6 {
    static init(e) {
        e = Object.assign({
            autoStart: !0,
            sharedTicker: !1
        }, e),
            Object.defineProperty(this, "ticker", {
                set(n) {
                    this._ticker && this._ticker.remove(this.render, this),
                        this._ticker = n,
                        n && n.add(this.render, this, cc.LOW)
                },
                get() {
                    return this._ticker
                }
            }),
            this.stop = () => {
                this._ticker.stop()
            }
            ,
            this.start = () => {
                this._ticker.start()
            }
            ,
            this._ticker = null,
            this.ticker = e.sharedTicker ? lr.shared : new lr,
            e.autoStart && this.start()
    }
    static destroy() {
        if (this._ticker) {
            const e = this._ticker;
            this.ticker = null,
                e.destroy()
        }
    }
}
Q6.extension = Ae.Application;
Ue.add(Q6);
const e5 = [];
Ue.handleByList(Ae.Renderer, e5);
function Xce(t) {
    for (const e of e5)
        if (e.test(t))
            return new e(t);
    throw new Error("Unable to auto-detect a suitable renderer.")
}
var jce = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
    vTextureCoord = aTextureCoord;
}`
    , zce = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`;
const qce = jce
    , t5 = zce;
class n5 {
    constructor(e) {
        this.renderer = e
    }
    contextChange(e) {
        let n;
        if (this.renderer.context.webGLVersion === 1) {
            const s = e.getParameter(e.FRAMEBUFFER_BINDING);
            e.bindFramebuffer(e.FRAMEBUFFER, null),
                n = e.getParameter(e.SAMPLES),
                e.bindFramebuffer(e.FRAMEBUFFER, s)
        } else {
            const s = e.getParameter(e.DRAW_FRAMEBUFFER_BINDING);
            e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null),
                n = e.getParameter(e.SAMPLES),
                e.bindFramebuffer(e.DRAW_FRAMEBUFFER, s)
        }
        n >= En.HIGH ? this.multisample = En.HIGH : n >= En.MEDIUM ? this.multisample = En.MEDIUM : n >= En.LOW ? this.multisample = En.LOW : this.multisample = En.NONE
    }
    destroy() { }
}
n5.extension = {
    type: Ae.RendererSystem,
    name: "_multisample"
};
Ue.add(n5);
class Kce {
    constructor(e) {
        this.buffer = e || null,
            this.updateID = -1,
            this.byteLength = -1,
            this.refCount = 0
    }
}
class s5 {
    constructor(e) {
        this.renderer = e,
            this.managedBuffers = {},
            this.boundBufferBases = {}
    }
    destroy() {
        this.renderer = null
    }
    contextChange() {
        this.disposeAll(!0),
            this.gl = this.renderer.gl,
            this.CONTEXT_UID = this.renderer.CONTEXT_UID
    }
    bind(e) {
        const { gl: n, CONTEXT_UID: s } = this
            , r = e._glBuffers[s] || this.createGLBuffer(e);
        n.bindBuffer(e.type, r.buffer)
    }
    unbind(e) {
        const { gl: n } = this;
        n.bindBuffer(e, null)
    }
    bindBufferBase(e, n) {
        const { gl: s, CONTEXT_UID: r } = this;
        if (this.boundBufferBases[n] !== e) {
            const i = e._glBuffers[r] || this.createGLBuffer(e);
            this.boundBufferBases[n] = e,
                s.bindBufferBase(s.UNIFORM_BUFFER, n, i.buffer)
        }
    }
    bindBufferRange(e, n, s) {
        const { gl: r, CONTEXT_UID: i } = this;
        s = s || 0;
        const o = e._glBuffers[i] || this.createGLBuffer(e);
        r.bindBufferRange(r.UNIFORM_BUFFER, n || 0, o.buffer, s * 256, 256)
    }
    update(e) {
        const { gl: n, CONTEXT_UID: s } = this
            , r = e._glBuffers[s] || this.createGLBuffer(e);
        if (e._updateID !== r.updateID)
            if (r.updateID = e._updateID,
                n.bindBuffer(e.type, r.buffer),
                r.byteLength >= e.data.byteLength)
                n.bufferSubData(e.type, 0, e.data);
            else {
                const i = e.static ? n.STATIC_DRAW : n.DYNAMIC_DRAW;
                r.byteLength = e.data.byteLength,
                    n.bufferData(e.type, e.data, i)
            }
    }
    dispose(e, n) {
        if (!this.managedBuffers[e.id])
            return;
        delete this.managedBuffers[e.id];
        const s = e._glBuffers[this.CONTEXT_UID]
            , r = this.gl;
        e.disposeRunner.remove(this),
            s && (n || r.deleteBuffer(s.buffer),
                delete e._glBuffers[this.CONTEXT_UID])
    }
    disposeAll(e) {
        const n = Object.keys(this.managedBuffers);
        for (let s = 0; s < n.length; s++)
            this.dispose(this.managedBuffers[n[s]], e)
    }
    createGLBuffer(e) {
        const { CONTEXT_UID: n, gl: s } = this;
        return e._glBuffers[n] = new Kce(s.createBuffer()),
            this.managedBuffers[e.id] = e,
            e.disposeRunner.add(this),
            e._glBuffers[n]
    }
}
s5.extension = {
    type: Ae.RendererSystem,
    name: "buffer"
};
Ue.add(s5);
class r5 {
    constructor(e) {
        this.renderer = e
    }
    render(e, n) {
        const s = this.renderer;
        let r, i, o, l;
        if (n && (r = n.renderTexture,
            i = n.clear,
            o = n.transform,
            l = n.skipUpdateTransform),
            this.renderingToScreen = !r,
            s.runners.prerender.emit(),
            s.emit("prerender"),
            s.projection.transform = o,
            !s.context.isLost) {
            if (r || (this.lastObjectRendered = e),
                !l) {
                const a = e.enableTempParent();
                e.updateTransform(),
                    e.disableTempParent(a)
            }
            s.renderTexture.bind(r),
                s.batch.currentRenderer.start(),
                (i ?? s.background.clearBeforeRender) && s.renderTexture.clear(),
                e.render(s),
                s.batch.currentRenderer.flush(),
                r && (n.blit && s.framebuffer.blit(),
                    r.baseTexture.update()),
                s.runners.postrender.emit(),
                s.projection.transform = null,
                s.emit("postrender")
        }
    }
    destroy() {
        this.renderer = null,
            this.lastObjectRendered = null
    }
}
r5.extension = {
    type: Ae.RendererSystem,
    name: "objectRenderer"
};
Ue.add(r5);
const Qp = class kb extends Hce {
    constructor(e) {
        super(),
            this.type = X4.WEBGL,
            e = Object.assign({}, Le.RENDER_OPTIONS, e),
            this.gl = null,
            this.CONTEXT_UID = 0,
            this.globalUniforms = new ii({
                projectionMatrix: new Bt
            }, !0);
        const n = {
            runners: ["init", "destroy", "contextChange", "resolutionChange", "reset", "update", "postrender", "prerender", "resize"],
            systems: kb.__systems,
            priority: ["_view", "textureGenerator", "background", "_plugin", "startup", "context", "state", "texture", "buffer", "geometry", "framebuffer", "transformFeedback", "mask", "scissor", "stencil", "projection", "textureGC", "filter", "renderTexture", "batch", "objectRenderer", "_multisample"]
        };
        this.setup(n),
            "useContextAlpha" in e && (dt("7.0.0", "options.useContextAlpha is deprecated, use options.premultipliedAlpha and options.backgroundAlpha instead"),
                e.premultipliedAlpha = e.useContextAlpha && e.useContextAlpha !== "notMultiplied",
                e.backgroundAlpha = e.useContextAlpha === !1 ? 1 : e.backgroundAlpha),
            this._plugin.rendererPlugins = kb.__plugins,
            this.options = e,
            this.startup.run(this.options)
    }
    static test(e) {
        return e != null && e.forceCanvas ? !1 : ble()
    }
    render(e, n) {
        this.objectRenderer.render(e, n)
    }
    resize(e, n) {
        this._view.resizeView(e, n)
    }
    reset() {
        return this.runners.reset.emit(),
            this
    }
    clear() {
        this.renderTexture.bind(),
            this.renderTexture.clear()
    }
    destroy(e = !1) {
        this.runners.destroy.items.reverse(),
            this.emitWithCustomOptions(this.runners.destroy, {
                _view: e
            }),
            super.destroy()
    }
    get plugins() {
        return this._plugin.plugins
    }
    get multisample() {
        return this._multisample.multisample
    }
    get width() {
        return this._view.element.width
    }
    get height() {
        return this._view.element.height
    }
    get resolution() {
        return this._view.resolution
    }
    set resolution(e) {
        this._view.resolution = e,
            this.runners.resolutionChange.emit(e)
    }
    get autoDensity() {
        return this._view.autoDensity
    }
    get view() {
        return this._view.element
    }
    get screen() {
        return this._view.screen
    }
    get lastObjectRendered() {
        return this.objectRenderer.lastObjectRendered
    }
    get renderingToScreen() {
        return this.objectRenderer.renderingToScreen
    }
    get rendererLogId() {
        return `WebGL ${this.context.webGLVersion}`
    }
    get clearBeforeRender() {
        return dt("7.0.0", "renderer.clearBeforeRender has been deprecated, please use renderer.background.clearBeforeRender instead."),
            this.background.clearBeforeRender
    }
    get useContextAlpha() {
        return dt("7.0.0", "renderer.useContextAlpha has been deprecated, please use renderer.context.premultipliedAlpha instead."),
            this.context.useContextAlpha
    }
    get preserveDrawingBuffer() {
        return dt("7.0.0", "renderer.preserveDrawingBuffer has been deprecated, we cannot truly know this unless pixi created the context"),
            this.context.preserveDrawingBuffer
    }
    get backgroundColor() {
        return dt("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead."),
            this.background.color
    }
    set backgroundColor(e) {
        dt("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead."),
            this.background.color = e
    }
    get backgroundAlpha() {
        return dt("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead."),
            this.background.alpha
    }
    set backgroundAlpha(e) {
        dt("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead."),
            this.background.alpha = e
    }
    get powerPreference() {
        return dt("7.0.0", "renderer.powerPreference has been deprecated, we can only know this if pixi creates the context"),
            this.context.powerPreference
    }
    generateTexture(e, n) {
        return this.textureGenerator.generateTexture(e, n)
    }
}
    ;
Qp.extension = {
    type: Ae.Renderer,
    priority: 1
},
    Qp.__plugins = {},
    Qp.__systems = {};
let ow = Qp;
Ue.handleByMap(Ae.RendererPlugin, ow.__plugins);
Ue.handleByMap(Ae.RendererSystem, ow.__systems);
Ue.add(ow);
class i5 extends Bd {
    constructor(e, n) {
        const { width: s, height: r } = n || {};
        super(s, r),
            this.items = [],
            this.itemDirtyIds = [];
        for (let i = 0; i < e; i++) {
            const o = new st;
            this.items.push(o),
                this.itemDirtyIds.push(-2)
        }
        this.length = e,
            this._load = null,
            this.baseTexture = null
    }
    initFromArray(e, n) {
        for (let s = 0; s < this.length; s++)
            e[s] && (e[s].castToBaseTexture ? this.addBaseTextureAt(e[s].castToBaseTexture(), s) : e[s] instanceof Bd ? this.addResourceAt(e[s], s) : this.addResourceAt(S6(e[s], n), s))
    }
    dispose() {
        for (let e = 0, n = this.length; e < n; e++)
            this.items[e].destroy();
        this.items = null,
            this.itemDirtyIds = null,
            this._load = null
    }
    addResourceAt(e, n) {
        if (!this.items[n])
            throw new Error(`Index ${n} is out of bounds`);
        return e.valid && !this.valid && this.resize(e.width, e.height),
            this.items[n].setResource(e),
            this
    }
    bind(e) {
        if (this.baseTexture !== null)
            throw new Error("Only one base texture per TextureArray is allowed");
        super.bind(e);
        for (let n = 0; n < this.length; n++)
            this.items[n].parentTextureArray = e,
                this.items[n].on("update", e.update, e)
    }
    unbind(e) {
        super.unbind(e);
        for (let n = 0; n < this.length; n++)
            this.items[n].parentTextureArray = null,
                this.items[n].off("update", e.update, e)
    }
    load() {
        if (this._load)
            return this._load;
        const e = this.items.map(n => n.resource).filter(n => n).map(n => n.load());
        return this._load = Promise.all(e).then(() => {
            const { realWidth: n, realHeight: s } = this.items[0];
            return this.resize(n, s),
                this.update(),
                Promise.resolve(this)
        }
        ),
            this._load
    }
}
class Jce extends i5 {
    constructor(e, n) {
        const { width: s, height: r } = n || {};
        let i, o;
        Array.isArray(e) ? (i = e,
            o = e.length) : o = e,
            super(o, {
                width: s,
                height: r
            }),
            i && this.initFromArray(i, n)
    }
    addBaseTextureAt(e, n) {
        if (e.resource)
            this.addResourceAt(e.resource, n);
        else
            throw new Error("ArrayResource does not support RenderTexture");
        return this
    }
    bind(e) {
        super.bind(e),
            e.target = bu.TEXTURE_2D_ARRAY
    }
    upload(e, n, s) {
        const { length: r, itemDirtyIds: i, items: o } = this
            , { gl: l } = e;
        s.dirtyId < 0 && l.texImage3D(l.TEXTURE_2D_ARRAY, 0, s.internalFormat, this._width, this._height, r, 0, n.format, s.type, null);
        for (let a = 0; a < r; a++) {
            const c = o[a];
            i[a] < c.dirtyId && (i[a] = c.dirtyId,
                c.valid && l.texSubImage3D(l.TEXTURE_2D_ARRAY, 0, 0, 0, a, c.resource.width, c.resource.height, 1, n.format, s.type, c.resource.source))
        }
        return !0
    }
}
class Zce extends Go {
    constructor(e) {
        super(e)
    }
    static test(e) {
        const { OffscreenCanvas: n } = globalThis;
        return n && e instanceof n ? !0 : globalThis.HTMLCanvasElement && e instanceof HTMLCanvasElement
    }
}
const o5 = class Bh extends i5 {
    constructor(e, n) {
        const { width: s, height: r, autoLoad: i, linkBaseTexture: o } = n || {};
        if (e && e.length !== Bh.SIDES)
            throw new Error(`Invalid length. Got ${e.length}, expected 6`);
        super(6, {
            width: s,
            height: r
        });
        for (let l = 0; l < Bh.SIDES; l++)
            this.items[l].target = bu.TEXTURE_CUBE_MAP_POSITIVE_X + l;
        this.linkBaseTexture = o !== !1,
            e && this.initFromArray(e, n),
            i !== !1 && this.load()
    }
    bind(e) {
        super.bind(e),
            e.target = bu.TEXTURE_CUBE_MAP
    }
    addBaseTextureAt(e, n, s) {
        if (s === void 0 && (s = this.linkBaseTexture),
            !this.items[n])
            throw new Error(`Index ${n} is out of bounds`);
        if (!this.linkBaseTexture || e.parentTextureArray || Object.keys(e._glTextures).length > 0)
            if (e.resource)
                this.addResourceAt(e.resource, n);
            else
                throw new Error("CubeResource does not support copying of renderTexture.");
        else
            e.target = bu.TEXTURE_CUBE_MAP_POSITIVE_X + n,
                e.parentTextureArray = this.baseTexture,
                this.items[n] = e;
        return e.valid && !this.valid && this.resize(e.realWidth, e.realHeight),
            this.items[n] = e,
            this
    }
    upload(e, n, s) {
        const r = this.itemDirtyIds;
        for (let i = 0; i < Bh.SIDES; i++) {
            const o = this.items[i];
            (r[i] < o.dirtyId || s.dirtyId < n.dirtyId) && (o.valid && o.resource ? (o.resource.upload(e, o, s),
                r[i] = o.dirtyId) : r[i] < -1 && (e.gl.texImage2D(o.target, 0, s.internalFormat, n.realWidth, n.realHeight, 0, n.format, s.type, null),
                    r[i] = -1))
        }
        return !0
    }
    static test(e) {
        return Array.isArray(e) && e.length === Bh.SIDES
    }
}
    ;
o5.SIDES = 6;
let Qce = o5;
class su extends Go {
    constructor(e, n) {
        n = n || {};
        let s, r, i;
        typeof e == "string" ? (s = su.EMPTY,
            r = e,
            i = !0) : (s = e,
                r = null,
                i = !1),
            super(s),
            this.url = r,
            this.crossOrigin = n.crossOrigin ?? !0,
            this.alphaMode = typeof n.alphaMode == "number" ? n.alphaMode : null,
            this.ownsImageBitmap = n.ownsImageBitmap ?? i,
            this._load = null,
            n.autoLoad !== !1 && this.load()
    }
    load() {
        return this._load ? this._load : (this._load = new Promise(async (e, n) => {
            if (this.url === null) {
                e(this);
                return
            }
            try {
                const s = await Le.ADAPTER.fetch(this.url, {
                    mode: this.crossOrigin ? "cors" : "no-cors"
                });
                if (this.destroyed)
                    return;
                const r = await s.blob();
                if (this.destroyed)
                    return;
                const i = await createImageBitmap(r, {
                    premultiplyAlpha: this.alphaMode === null || this.alphaMode === Is.UNPACK ? "premultiply" : "none"
                });
                if (this.destroyed) {
                    i.close();
                    return
                }
                this.source = i,
                    this.update(),
                    e(this)
            } catch (s) {
                if (this.destroyed)
                    return;
                n(s),
                    this.onError.emit(s)
            }
        }
        ),
            this._load)
    }
    upload(e, n, s) {
        return this.source instanceof ImageBitmap ? (typeof this.alphaMode == "number" && (n.alphaMode = this.alphaMode),
            super.upload(e, n, s)) : (this.load(),
                !1)
    }
    dispose() {
        this.ownsImageBitmap && this.source instanceof ImageBitmap && this.source.close(),
            super.dispose(),
            this._load = null
    }
    static test(e) {
        return !!globalThis.createImageBitmap && typeof ImageBitmap < "u" && (typeof e == "string" || e instanceof ImageBitmap)
    }
    static get EMPTY() {
        return su._EMPTY = su._EMPTY ?? Le.ADAPTER.createCanvas(0, 0),
            su._EMPTY
    }
}
const Rb = class em extends Go {
    constructor(e, n) {
        n = n || {},
            super(Le.ADAPTER.createCanvas()),
            this._width = 0,
            this._height = 0,
            this.svg = e,
            this.scale = n.scale || 1,
            this._overrideWidth = n.width,
            this._overrideHeight = n.height,
            this._resolve = null,
            this._crossorigin = n.crossorigin,
            this._load = null,
            n.autoLoad !== !1 && this.load()
    }
    load() {
        return this._load ? this._load : (this._load = new Promise(e => {
            if (this._resolve = () => {
                this.update(),
                    e(this)
            }
                ,
                em.SVG_XML.test(this.svg.trim())) {
                if (!btoa)
                    throw new Error("Your browser doesn't support base64 conversions.");
                this.svg = `data:image/svg+xml;base64,${btoa(unescape(encodeURIComponent(this.svg)))}`
            }
            this._loadSvg()
        }
        ),
            this._load)
    }
    _loadSvg() {
        const e = new Image;
        Go.crossOrigin(e, this.svg, this._crossorigin),
            e.src = this.svg,
            e.onerror = n => {
                this._resolve && (e.onerror = null,
                    this.onError.emit(n))
            }
            ,
            e.onload = () => {
                if (!this._resolve)
                    return;
                const n = e.width
                    , s = e.height;
                if (!n || !s)
                    throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
                let r = n * this.scale
                    , i = s * this.scale;
                (this._overrideWidth || this._overrideHeight) && (r = this._overrideWidth || this._overrideHeight / s * n,
                    i = this._overrideHeight || this._overrideWidth / n * s),
                    r = Math.round(r),
                    i = Math.round(i);
                const o = this.source;
                o.width = r,
                    o.height = i,
                    o._pixiId = `canvas_${lc()}`,
                    o.getContext("2d").drawImage(e, 0, 0, n, s, 0, 0, r, i),
                    this._resolve(),
                    this._resolve = null
            }
    }
    static getSize(e) {
        const n = em.SVG_SIZE.exec(e)
            , s = {};
        return n && (s[n[1]] = Math.round(parseFloat(n[3])),
            s[n[5]] = Math.round(parseFloat(n[7]))),
            s
    }
    dispose() {
        super.dispose(),
            this._resolve = null,
            this._crossorigin = null
    }
    static test(e, n) {
        return n === "svg" || typeof e == "string" && e.startsWith("data:image/svg+xml") || typeof e == "string" && em.SVG_XML.test(e)
    }
}
    ;
Rb.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m,
    Rb.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i;
let Mb = Rb;
class eue extends Go {
    constructor(e) {
        super(e)
    }
    static test(e) {
        return !!globalThis.VideoFrame && e instanceof globalThis.VideoFrame
    }
}
const Pb = class Lb extends Go {
    constructor(e, n) {
        if (n = n || {},
            !(e instanceof HTMLVideoElement)) {
            const s = document.createElement("video");
            n.autoLoad !== !1 && s.setAttribute("preload", "auto"),
                n.playsinline !== !1 && (s.setAttribute("webkit-playsinline", ""),
                    s.setAttribute("playsinline", "")),
                n.muted === !0 && (s.setAttribute("muted", ""),
                    s.muted = !0),
                n.loop === !0 && s.setAttribute("loop", ""),
                n.autoPlay !== !1 && s.setAttribute("autoplay", ""),
                typeof e == "string" && (e = [e]);
            const r = e[0].src || e[0];
            Go.crossOrigin(s, r, n.crossorigin);
            for (let i = 0; i < e.length; ++i) {
                const o = document.createElement("source");
                let { src: l, mime: a } = e[i];
                if (l = l || e[i],
                    l.startsWith("data:"))
                    a = l.slice(5, l.indexOf(";"));
                else if (!l.startsWith("blob:")) {
                    const c = l.split("?").shift().toLowerCase()
                        , u = c.slice(c.lastIndexOf(".") + 1);
                    a = a || Lb.MIME_TYPES[u] || `video/${u}`
                }
                o.src = l,
                    a && (o.type = a),
                    s.appendChild(o)
            }
            e = s
        }
        super(e),
            this.noSubImage = !0,
            this._autoUpdate = !0,
            this._isConnectedToTicker = !1,
            this._updateFPS = n.updateFPS || 0,
            this._msToNextUpdate = 0,
            this.autoPlay = n.autoPlay !== !1,
            this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this),
            this._videoFrameRequestCallbackHandle = null,
            this._load = null,
            this._resolve = null,
            this._reject = null,
            this._onCanPlay = this._onCanPlay.bind(this),
            this._onError = this._onError.bind(this),
            this._onPlayStart = this._onPlayStart.bind(this),
            this._onPlayStop = this._onPlayStop.bind(this),
            this._onSeeked = this._onSeeked.bind(this),
            n.autoLoad !== !1 && this.load()
    }
    update(e = 0) {
        if (!this.destroyed) {
            if (this._updateFPS) {
                const n = lr.shared.elapsedMS * this.source.playbackRate;
                this._msToNextUpdate = Math.floor(this._msToNextUpdate - n)
            }
            (!this._updateFPS || this._msToNextUpdate <= 0) && (super.update(),
                this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0)
        }
    }
    _videoFrameRequestCallback() {
        this.update(),
            this.destroyed ? this._videoFrameRequestCallbackHandle = null : this._videoFrameRequestCallbackHandle = this.source.requestVideoFrameCallback(this._videoFrameRequestCallback)
    }
    load() {
        if (this._load)
            return this._load;
        const e = this.source;
        return (e.readyState === e.HAVE_ENOUGH_DATA || e.readyState === e.HAVE_FUTURE_DATA) && e.width && e.height && (e.complete = !0),
            e.addEventListener("play", this._onPlayStart),
            e.addEventListener("pause", this._onPlayStop),
            e.addEventListener("seeked", this._onSeeked),
            this._isSourceReady() ? this._onCanPlay() : (e.addEventListener("canplay", this._onCanPlay),
                e.addEventListener("canplaythrough", this._onCanPlay),
                e.addEventListener("error", this._onError, !0)),
            this._load = new Promise((n, s) => {
                this.valid ? n(this) : (this._resolve = n,
                    this._reject = s,
                    e.load())
            }
            ),
            this._load
    }
    _onError(e) {
        this.source.removeEventListener("error", this._onError, !0),
            this.onError.emit(e),
            this._reject && (this._reject(e),
                this._reject = null,
                this._resolve = null)
    }
    _isSourcePlaying() {
        const e = this.source;
        return !e.paused && !e.ended
    }
    _isSourceReady() {
        return this.source.readyState > 2
    }
    _onPlayStart() {
        this.valid || this._onCanPlay(),
            this._configureAutoUpdate()
    }
    _onPlayStop() {
        this._configureAutoUpdate()
    }
    _onSeeked() {
        this._autoUpdate && !this._isSourcePlaying() && (this._msToNextUpdate = 0,
            this.update(),
            this._msToNextUpdate = 0)
    }
    _onCanPlay() {
        const e = this.source;
        e.removeEventListener("canplay", this._onCanPlay),
            e.removeEventListener("canplaythrough", this._onCanPlay);
        const n = this.valid;
        this._msToNextUpdate = 0,
            this.update(),
            this._msToNextUpdate = 0,
            !n && this._resolve && (this._resolve(this),
                this._resolve = null,
                this._reject = null),
            this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && e.play()
    }
    dispose() {
        this._configureAutoUpdate();
        const e = this.source;
        e && (e.removeEventListener("play", this._onPlayStart),
            e.removeEventListener("pause", this._onPlayStop),
            e.removeEventListener("seeked", this._onSeeked),
            e.removeEventListener("canplay", this._onCanPlay),
            e.removeEventListener("canplaythrough", this._onCanPlay),
            e.removeEventListener("error", this._onError, !0),
            e.pause(),
            e.src = "",
            e.load()),
            super.dispose()
    }
    get autoUpdate() {
        return this._autoUpdate
    }
    set autoUpdate(e) {
        e !== this._autoUpdate && (this._autoUpdate = e,
            this._configureAutoUpdate())
    }
    get updateFPS() {
        return this._updateFPS
    }
    set updateFPS(e) {
        e !== this._updateFPS && (this._updateFPS = e,
            this._configureAutoUpdate())
    }
    _configureAutoUpdate() {
        this._autoUpdate && this._isSourcePlaying() ? !this._updateFPS && this.source.requestVideoFrameCallback ? (this._isConnectedToTicker && (lr.shared.remove(this.update, this),
            this._isConnectedToTicker = !1,
            this._msToNextUpdate = 0),
            this._videoFrameRequestCallbackHandle === null && (this._videoFrameRequestCallbackHandle = this.source.requestVideoFrameCallback(this._videoFrameRequestCallback))) : (this._videoFrameRequestCallbackHandle !== null && (this.source.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle),
                this._videoFrameRequestCallbackHandle = null),
                this._isConnectedToTicker || (lr.shared.add(this.update, this),
                    this._isConnectedToTicker = !0,
                    this._msToNextUpdate = 0)) : (this._videoFrameRequestCallbackHandle !== null && (this.source.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle),
                        this._videoFrameRequestCallbackHandle = null),
                        this._isConnectedToTicker && (lr.shared.remove(this.update, this),
                            this._isConnectedToTicker = !1,
                            this._msToNextUpdate = 0))
    }
    static test(e, n) {
        return globalThis.HTMLVideoElement && e instanceof HTMLVideoElement || Lb.TYPES.includes(n)
    }
}
    ;
Pb.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"],
    Pb.MIME_TYPES = {
        ogv: "video/ogg",
        mov: "video/quicktime",
        m4v: "video/mp4"
    };
let a5 = Pb;
bb.push(su, P6, Zce, a5, eue, Mb, k_, Qce, Jce);
function nA(t) {
    switch (t.toLowerCase()) {
        case "nearest":
            return Hs.Nearest;
        case "linear":
            return Hs.Linear;
        case "mipmap":
            return Hs.MipMap;
        case "mipmapnearestnearest":
            return Hs.MipMapNearestNearest;
        case "mipmaplinearnearest":
            return Hs.MipMapLinearNearest;
        case "mipmapnearestlinear":
            return Hs.MipMapNearestLinear;
        case "mipmaplinearlinear":
            return Hs.MipMapLinearLinear;
        default:
            throw new Error(`Unknown texture filter ${t}`)
    }
}
var Hs = (t => (t[t.Nearest = 9728] = "Nearest",
    t[t.Linear = 9729] = "Linear",
    t[t.MipMap = 9987] = "MipMap",
    t[t.MipMapNearestNearest = 9984] = "MipMapNearestNearest",
    t[t.MipMapLinearNearest = 9985] = "MipMapLinearNearest",
    t[t.MipMapNearestLinear = 9986] = "MipMapNearestLinear",
    t[t.MipMapLinearLinear = 9987] = "MipMapLinearLinear",
    t))(Hs || {})
    , Nl = (t => (t[t.MirroredRepeat = 33648] = "MirroredRepeat",
        t[t.ClampToEdge = 33071] = "ClampToEdge",
        t[t.Repeat = 10497] = "Repeat",
        t))(Nl || {});
class Ob {
    constructor() {
        this.size = null,
            this.names = null,
            this.values = null,
            this.renderObject = null
    }
    get width() {
        const e = this.texture;
        return e.trim ? e.trim.width : e.orig.width
    }
    get height() {
        const e = this.texture;
        return e.trim ? e.trim.height : e.orig.height
    }
    get u() {
        return this.texture._uvs.x0
    }
    get v() {
        return this.texture._uvs.y0
    }
    get u2() {
        return this.texture._uvs.x2
    }
    get v2() {
        return this.texture._uvs.y2
    }
    get offsetX() {
        const e = this.texture;
        return e.trim ? e.trim.x : 0
    }
    get offsetY() {
        return this.spineOffsetY
    }
    get pixiOffsetY() {
        const e = this.texture;
        return e.trim ? e.trim.y : 0
    }
    get spineOffsetY() {
        const e = this.texture;
        return this.originalHeight - this.height - (e.trim ? e.trim.y : 0)
    }
    get originalWidth() {
        return this.texture.orig.width
    }
    get originalHeight() {
        return this.texture.orig.height
    }
    get x() {
        return this.texture.frame.x
    }
    get y() {
        return this.texture.frame.y
    }
    get rotate() {
        return this.texture.rotate !== 0
    }
    get degrees() {
        return (360 - this.texture.rotate * 45) % 360
    }
}
class tue {
    constructor() {
        this.x = 0,
            this.y = 0,
            this.width = 0,
            this.height = 0,
            this.offsetX = 0,
            this.offsetY = 0,
            this.originalWidth = 0,
            this.originalHeight = 0,
            this.rotate = 0,
            this.index = 0
    }
}
class Nb {
    constructor(e, n, s) {
        this.pages = new Array,
            this.regions = new Array,
            e && this.addSpineAtlas(e, n, s)
    }
    addTexture(e, n) {
        const s = this.pages;
        let r = null;
        for (let o = 0; o < s.length; o++)
            if (s[o].baseTexture === n.baseTexture) {
                r = s[o];
                break
            }
        if (r === null) {
            r = new sA,
                r.name = "texturePage";
            const o = n.baseTexture;
            r.width = o.realWidth,
                r.height = o.realHeight,
                r.baseTexture = o,
                r.minFilter = r.magFilter = Hs.Nearest,
                r.uWrap = Nl.ClampToEdge,
                r.vWrap = Nl.ClampToEdge,
                s.push(r)
        }
        const i = new rA;
        return i.name = e,
            i.page = r,
            i.texture = n,
            i.index = -1,
            this.regions.push(i),
            i
    }
    addTextureHash(e, n) {
        for (const s in e)
            e.hasOwnProperty(s) && this.addTexture(n && s.indexOf(".") !== -1 ? s.substr(0, s.lastIndexOf(".")) : s, e[s])
    }
    addSpineAtlas(e, n, s) {
        return this.load(e, n, s)
    }
    load(e, n, s) {
        if (n == null)
            throw new Error("textureLoader cannot be null.");
        const r = new nue(e)
            , i = new Array(4);
        let o = null;
        const l = {};
        let a = null;
        l.size = () => {
            o.width = parseInt(i[1]),
                o.height = parseInt(i[2])
        }
            ,
            l.format = () => { }
            ,
            l.filter = () => {
                o.minFilter = nA(i[1]),
                    o.magFilter = nA(i[2])
            }
            ,
            l.repeat = () => {
                i[1].indexOf("x") != -1 && (o.uWrap = Nl.Repeat),
                    i[1].indexOf("y") != -1 && (o.vWrap = Nl.Repeat)
            }
            ,
            l.pma = () => {
                o.pma = i[1] == "true"
            }
            ;
        const c = {};
        c.xy = () => {
            a.x = parseInt(i[1]),
                a.y = parseInt(i[2])
        }
            ,
            c.size = () => {
                a.width = parseInt(i[1]),
                    a.height = parseInt(i[2])
            }
            ,
            c.bounds = () => {
                a.x = parseInt(i[1]),
                    a.y = parseInt(i[2]),
                    a.width = parseInt(i[3]),
                    a.height = parseInt(i[4])
            }
            ,
            c.offset = () => {
                a.offsetX = parseInt(i[1]),
                    a.offsetY = parseInt(i[2])
            }
            ,
            c.orig = () => {
                a.originalWidth = parseInt(i[1]),
                    a.originalHeight = parseInt(i[2])
            }
            ,
            c.offsets = () => {
                a.offsetX = parseInt(i[1]),
                    a.offsetY = parseInt(i[2]),
                    a.originalWidth = parseInt(i[3]),
                    a.originalHeight = parseInt(i[4])
            }
            ,
            c.rotate = () => {
                const d = i[1];
                let f = 0;
                d.toLocaleLowerCase() == "true" ? f = 6 : d.toLocaleLowerCase() == "false" ? f = 0 : f = (720 - parseFloat(d)) % 360 / 45,
                    a.rotate = f
            }
            ,
            c.index = () => {
                a.index = parseInt(i[1])
            }
            ;
        let u = r.readLine();
        for (; u != null && u.trim().length == 0;)
            u = r.readLine();
        for (; !(u == null || u.trim().length == 0 || r.readEntry(i, u) == 0);)
            u = r.readLine();
        const h = () => {
            for (; ;) {
                if (u == null)
                    return s && s(this);
                if (u.trim().length == 0)
                    o = null,
                        u = r.readLine();
                else if (o === null) {
                    for (o = new sA,
                        o.name = u.trim(); r.readEntry(i, u = r.readLine()) != 0;) {
                        const d = l[i[0]];
                        d && d()
                    }
                    this.pages.push(o),
                        n(o.name, d => {
                            if (d === null)
                                return this.pages.splice(this.pages.indexOf(o), 1),
                                    s && s(null);
                            o.baseTexture = d,
                                o.pma && (d.alphaMode = Is.PMA),
                                d.valid || d.setSize(o.width, o.height),
                                o.setFilters(),
                                (!o.width || !o.height) && (o.width = d.realWidth,
                                    o.height = d.realHeight,
                                    (!o.width || !o.height) && console.log(`ERROR spine atlas page ${o.name}: meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)`)),
                                h()
                        }
                        );
                    break
                } else {
                    a = new tue;
                    const d = new rA;
                    d.name = u,
                        d.page = o;
                    let f = null
                        , p = null;
                    for (; ;) {
                        const y = r.readEntry(i, u = r.readLine());
                        if (y == 0)
                            break;
                        const x = c[i[0]];
                        if (x)
                            x();
                        else {
                            f == null && (f = [],
                                p = []),
                                f.push(i[0]);
                            const w = [];
                            for (let S = 0; S < y; S++)
                                w.push(parseInt(i[S + 1]));
                            p.push(w)
                        }
                    }
                    a.originalWidth == 0 && a.originalHeight == 0 && (a.originalWidth = a.width,
                        a.originalHeight = a.height);
                    const m = o.baseTexture.resolution;
                    a.x /= m,
                        a.y /= m,
                        a.width /= m,
                        a.height /= m,
                        a.originalWidth /= m,
                        a.originalHeight /= m,
                        a.offsetX /= m,
                        a.offsetY /= m;
                    const g = a.rotate % 4 !== 0
                        , b = new nt(a.x, a.y, g ? a.height : a.width, g ? a.width : a.height)
                        , v = new nt(0, 0, a.originalWidth, a.originalHeight)
                        , _ = new nt(a.offsetX, a.originalHeight - a.height - a.offsetY, a.width, a.height);
                    d.texture = new $e(d.page.baseTexture, b, v, _, a.rotate),
                        d.index = a.index,
                        d.texture.updateUvs(),
                        this.regions.push(d)
                }
            }
        }
            ;
        h()
    }
    findRegion(e) {
        for (let n = 0; n < this.regions.length; n++)
            if (this.regions[n].name == e)
                return this.regions[n];
        return null
    }
    dispose() {
        for (let e = 0; e < this.pages.length; e++)
            this.pages[e].baseTexture.dispose()
    }
}
class nue {
    constructor(e) {
        this.index = 0,
            this.lines = e.split(/\r\n|\r|\n/)
    }
    readLine() {
        return this.index >= this.lines.length ? null : this.lines[this.index++]
    }
    readEntry(e, n) {
        if (n == null || (n = n.trim(),
            n.length == 0))
            return 0;
        const s = n.indexOf(":");
        if (s == -1)
            return 0;
        e[0] = n.substr(0, s).trim();
        for (let r = 1, i = s + 1; ; r++) {
            const o = n.indexOf(",", i);
            if (o == -1)
                return e[r] = n.substr(i).trim(),
                    r;
            if (e[r] = n.substr(i, o - i).trim(),
                i = o + 1,
                r == 4)
                return 4
        }
    }
}
class sA {
    constructor() {
        this.minFilter = Hs.Nearest,
            this.magFilter = Hs.Nearest,
            this.uWrap = Nl.ClampToEdge,
            this.vWrap = Nl.ClampToEdge
    }
    setFilters() {
        const e = this.baseTexture
            , n = this.minFilter;
        n == Hs.Linear ? e.scaleMode = ar.LINEAR : this.minFilter == Hs.Nearest ? e.scaleMode = ar.NEAREST : (e.mipmap = ci.POW2,
            n == Hs.MipMapNearestNearest ? e.scaleMode = ar.NEAREST : e.scaleMode = ar.LINEAR)
    }
}
class rA extends Ob {
}
class l5 {
    constructor() {
        this.array = new Array
    }
    add(e) {
        const n = this.contains(e);
        return this.array[e | 0] = e | 0,
            !n
    }
    contains(e) {
        return this.array[e | 0] != null
    }
    remove(e) {
        this.array[e | 0] = void 0
    }
    clear() {
        this.array.length = 0
    }
}
class c5 {
    constructor() {
        this.entries = {},
            this.size = 0
    }
    add(e) {
        const n = this.entries[e];
        return this.entries[e] = !0,
            n ? !1 : (this.size++,
                !0)
    }
    addAll(e) {
        const n = this.size;
        for (let s = 0, r = e.length; s < r; s++)
            this.add(e[s]);
        return n != this.size
    }
    contains(e) {
        return this.entries[e]
    }
    clear() {
        this.entries = {},
            this.size = 0
    }
}
const Ec = class {
    constructor(t = 0, e = 0, n = 0, s = 0) {
        this.r = t,
            this.g = e,
            this.b = n,
            this.a = s
    }
    set(t, e, n, s) {
        return this.r = t,
            this.g = e,
            this.b = n,
            this.a = s,
            this.clamp()
    }
    setFromColor(t) {
        return this.r = t.r,
            this.g = t.g,
            this.b = t.b,
            this.a = t.a,
            this
    }
    setFromString(t) {
        return t = t.charAt(0) == "#" ? t.substr(1) : t,
            this.r = parseInt(t.substr(0, 2), 16) / 255,
            this.g = parseInt(t.substr(2, 2), 16) / 255,
            this.b = parseInt(t.substr(4, 2), 16) / 255,
            this.a = t.length != 8 ? 1 : parseInt(t.substr(6, 2), 16) / 255,
            this
    }
    add(t, e, n, s) {
        return this.r += t,
            this.g += e,
            this.b += n,
            this.a += s,
            this.clamp()
    }
    clamp() {
        return this.r < 0 ? this.r = 0 : this.r > 1 && (this.r = 1),
            this.g < 0 ? this.g = 0 : this.g > 1 && (this.g = 1),
            this.b < 0 ? this.b = 0 : this.b > 1 && (this.b = 1),
            this.a < 0 ? this.a = 0 : this.a > 1 && (this.a = 1),
            this
    }
    static rgba8888ToColor(t, e) {
        t.r = ((e & 4278190080) >>> 24) / 255,
            t.g = ((e & 16711680) >>> 16) / 255,
            t.b = ((e & 65280) >>> 8) / 255,
            t.a = (e & 255) / 255
    }
    static rgb888ToColor(t, e) {
        t.r = ((e & 16711680) >>> 16) / 255,
            t.g = ((e & 65280) >>> 8) / 255,
            t.b = (e & 255) / 255
    }
    static fromString(t) {
        return new Ec().setFromString(t)
    }
}
    ;
let Se = Ec;
Se.WHITE = new Ec(1, 1, 1, 1);
Se.RED = new Ec(1, 0, 0, 1);
Se.GREEN = new Ec(0, 1, 0, 1);
Se.BLUE = new Ec(0, 0, 1, 1);
Se.MAGENTA = new Ec(1, 0, 1, 1);
const ko = class {
    static clamp(t, e, n) {
        return t < e ? e : t > n ? n : t
    }
    static cosDeg(t) {
        return Math.cos(t * ko.degRad)
    }
    static sinDeg(t) {
        return Math.sin(t * ko.degRad)
    }
    static signum(t) {
        return Math.sign(t)
    }
    static toInt(t) {
        return t > 0 ? Math.floor(t) : Math.ceil(t)
    }
    static cbrt(t) {
        const e = Math.pow(Math.abs(t), .3333333333333333);
        return t < 0 ? -e : e
    }
    static randomTriangular(t, e) {
        return ko.randomTriangularWith(t, e, (t + e) * .5)
    }
    static randomTriangularWith(t, e, n) {
        const s = Math.random()
            , r = e - t;
        return s <= (n - t) / r ? t + Math.sqrt(s * r * (n - t)) : e - Math.sqrt((1 - s) * r * (e - n))
    }
    static isPowerOfTwo(t) {
        return t && (t & t - 1) === 0
    }
}
    ;
let F = ko;
F.PI = 3.1415927;
F.PI2 = ko.PI * 2;
F.radiansToDegrees = 180 / ko.PI;
F.radDeg = ko.radiansToDegrees;
F.degreesToRadians = ko.PI / 180;
F.degRad = ko.degreesToRadians;
class sue {
    apply(e, n, s) {
        return e + (n - e) * this.applyInternal(s)
    }
}
class rue extends sue {
    constructor(e) {
        super(),
            this.power = 2,
            this.power = e
    }
    applyInternal(e) {
        return e <= .5 ? Math.pow(e * 2, this.power) / 2 : Math.pow((e - 1) * 2, this.power) / (this.power % 2 == 0 ? -2 : 2) + 1
    }
}
class u5 extends rue {
    applyInternal(e) {
        return Math.pow(e - 1, this.power) * (this.power % 2 == 0 ? -1 : 1) + 1
    }
}
const Wc = class {
    static arrayCopy(t, e, n, s, r) {
        for (let i = e, o = s; i < e + r; i++,
            o++)
            n[o] = t[i]
    }
    static arrayFill(t, e, n, s) {
        for (let r = e; r < n; r++)
            t[r] = s
    }
    static setArraySize(t, e, n = 0) {
        const s = t.length;
        if (s == e)
            return t;
        if (t.length = e,
            s < e)
            for (let r = s; r < e; r++)
                t[r] = n;
        return t
    }
    static ensureArrayCapacity(t, e, n = 0) {
        return t.length >= e ? t : Wc.setArraySize(t, e, n)
    }
    static newArray(t, e) {
        const n = new Array(t);
        for (let s = 0; s < t; s++)
            n[s] = e;
        return n
    }
    static newFloatArray(t) {
        if (Wc.SUPPORTS_TYPED_ARRAYS)
            return new Float32Array(t);
        const e = new Array(t);
        for (let n = 0; n < e.length; n++)
            e[n] = 0;
        return e
    }
    static newShortArray(t) {
        if (Wc.SUPPORTS_TYPED_ARRAYS)
            return new Int16Array(t);
        const e = new Array(t);
        for (let n = 0; n < e.length; n++)
            e[n] = 0;
        return e
    }
    static toFloatArray(t) {
        return Wc.SUPPORTS_TYPED_ARRAYS ? new Float32Array(t) : t
    }
    static toSinglePrecision(t) {
        return Wc.SUPPORTS_TYPED_ARRAYS ? Math.fround(t) : t
    }
    static webkit602BugfixHelper(t, e) { }
    static contains(t, e, n = !0) {
        for (let s = 0; s < t.length; s++)
            if (t[s] == e)
                return !0;
        return !1
    }
    static enumValue(t, e) {
        return t[e[0].toUpperCase() + e.slice(1)]
    }
}
    ;
let Q = Wc;
Q.SUPPORTS_TYPED_ARRAYS = typeof Float32Array < "u";
class N_ {
    constructor(e) {
        this.items = new Array,
            this.instantiator = e
    }
    obtain() {
        return this.items.length > 0 ? this.items.pop() : this.instantiator()
    }
    free(e) {
        e.reset && e.reset(),
            this.items.push(e)
    }
    freeAll(e) {
        for (let n = 0; n < e.length; n++)
            this.free(e[n])
    }
    clear() {
        this.items.length = 0
    }
}
class Fd {
    constructor(e = 0, n = 0) {
        this.x = e,
            this.y = n
    }
    set(e, n) {
        return this.x = e,
            this.y = n,
            this
    }
    length() {
        const e = this.x
            , n = this.y;
        return Math.sqrt(e * e + n * n)
    }
    normalize() {
        const e = this.length();
        return e != 0 && (this.x /= e,
            this.y /= e),
            this
    }
}
class aw {
    constructor() {
        this.minX = 0,
            this.minY = 0,
            this.maxX = 0,
            this.maxY = 0,
            this.boundingBoxes = new Array,
            this.polygons = new Array,
            this.polygonPool = new N_(() => Q.newFloatArray(16))
    }
    update(e, n) {
        if (!e)
            throw new Error("skeleton cannot be null.");
        const s = this.boundingBoxes
            , r = this.polygons
            , i = this.polygonPool
            , o = e.slots
            , l = o.length;
        s.length = 0,
            i.freeAll(r),
            r.length = 0;
        for (let a = 0; a < l; a++) {
            const c = o[a];
            if (!c.bone.active)
                continue;
            const u = c.getAttachment();
            if (u != null && u.type === ut.BoundingBox) {
                const h = u;
                s.push(h);
                let d = i.obtain();
                d.length != h.worldVerticesLength && (d = Q.newFloatArray(h.worldVerticesLength)),
                    r.push(d),
                    h.computeWorldVertices(c, 0, h.worldVerticesLength, d, 0, 2)
            }
        }
        n ? this.aabbCompute() : (this.minX = Number.POSITIVE_INFINITY,
            this.minY = Number.POSITIVE_INFINITY,
            this.maxX = Number.NEGATIVE_INFINITY,
            this.maxY = Number.NEGATIVE_INFINITY)
    }
    aabbCompute() {
        let e = Number.POSITIVE_INFINITY
            , n = Number.POSITIVE_INFINITY
            , s = Number.NEGATIVE_INFINITY
            , r = Number.NEGATIVE_INFINITY;
        const i = this.polygons;
        for (let o = 0, l = i.length; o < l; o++) {
            const a = i[o]
                , c = a;
            for (let u = 0, h = a.length; u < h; u += 2) {
                const d = c[u]
                    , f = c[u + 1];
                e = Math.min(e, d),
                    n = Math.min(n, f),
                    s = Math.max(s, d),
                    r = Math.max(r, f)
            }
        }
        this.minX = e,
            this.minY = n,
            this.maxX = s,
            this.maxY = r
    }
    aabbContainsPoint(e, n) {
        return e >= this.minX && e <= this.maxX && n >= this.minY && n <= this.maxY
    }
    aabbIntersectsSegment(e, n, s, r) {
        const i = this.minX
            , o = this.minY
            , l = this.maxX
            , a = this.maxY;
        if (e <= i && s <= i || n <= o && r <= o || e >= l && s >= l || n >= a && r >= a)
            return !1;
        const c = (r - n) / (s - e);
        let u = c * (i - e) + n;
        if (u > o && u < a || (u = c * (l - e) + n,
            u > o && u < a))
            return !0;
        let h = (o - n) / c + e;
        return h > i && h < l || (h = (a - n) / c + e,
            h > i && h < l)
    }
    aabbIntersectsSkeleton(e) {
        return this.minX < e.maxX && this.maxX > e.minX && this.minY < e.maxY && this.maxY > e.minY
    }
    containsPoint(e, n) {
        const s = this.polygons;
        for (let r = 0, i = s.length; r < i; r++)
            if (this.containsPointPolygon(s[r], e, n))
                return this.boundingBoxes[r];
        return null
    }
    containsPointPolygon(e, n, s) {
        const r = e
            , i = e.length;
        let o = i - 2
            , l = !1;
        for (let a = 0; a < i; a += 2) {
            const c = r[a + 1]
                , u = r[o + 1];
            if (c < s && u >= s || u < s && c >= s) {
                const h = r[a];
                h + (s - c) / (u - c) * (r[o] - h) < n && (l = !l)
            }
            o = a
        }
        return l
    }
    intersectsSegment(e, n, s, r) {
        const i = this.polygons;
        for (let o = 0, l = i.length; o < l; o++)
            if (this.intersectsSegmentPolygon(i[o], e, n, s, r))
                return this.boundingBoxes[o];
        return null
    }
    intersectsSegmentPolygon(e, n, s, r, i) {
        const o = e
            , l = e.length
            , a = n - r
            , c = s - i
            , u = n * i - s * r;
        let h = o[l - 2]
            , d = o[l - 1];
        for (let f = 0; f < l; f += 2) {
            const p = o[f]
                , m = o[f + 1]
                , g = h * m - d * p
                , b = h - p
                , v = d - m
                , _ = a * v - c * b
                , y = (u * b - a * g) / _;
            if ((y >= h && y <= p || y >= p && y <= h) && (y >= n && y <= r || y >= r && y <= n)) {
                const x = (u * v - c * g) / _;
                if ((x >= d && x <= m || x >= m && x <= d) && (x >= s && x <= i || x >= i && x <= s))
                    return !0
            }
            h = p,
                d = m
        }
        return !1
    }
    getPolygon(e) {
        if (!e)
            throw new Error("boundingBox cannot be null.");
        const n = this.boundingBoxes.indexOf(e);
        return n == -1 ? null : this.polygons[n]
    }
    getWidth() {
        return this.maxX - this.minX
    }
    getHeight() {
        return this.maxY - this.minY
    }
}
const iue = {
    yDown: !0,
    FAIL_ON_NON_EXISTING_SKIN: !1,
    GLOBAL_AUTO_UPDATE: !0,
    GLOBAL_DELAY_LIMIT: 0
};
class tg {
    constructor() {
        this.minX = 1 / 0,
            this.minY = 1 / 0,
            this.maxX = -1 / 0,
            this.maxY = -1 / 0,
            this.rect = null,
            this.updateID = -1
    }
    isEmpty() {
        return this.minX > this.maxX || this.minY > this.maxY
    }
    clear() {
        this.minX = 1 / 0,
            this.minY = 1 / 0,
            this.maxX = -1 / 0,
            this.maxY = -1 / 0
    }
    getRectangle(e) {
        return this.minX > this.maxX || this.minY > this.maxY ? nt.EMPTY : (e = e || new nt(0, 0, 1, 1),
            e.x = this.minX,
            e.y = this.minY,
            e.width = this.maxX - this.minX,
            e.height = this.maxY - this.minY,
            e)
    }
    addPoint(e) {
        this.minX = Math.min(this.minX, e.x),
            this.maxX = Math.max(this.maxX, e.x),
            this.minY = Math.min(this.minY, e.y),
            this.maxY = Math.max(this.maxY, e.y)
    }
    addPointMatrix(e, n) {
        const { a: s, b: r, c: i, d: o, tx: l, ty: a } = e
            , c = s * n.x + i * n.y + l
            , u = r * n.x + o * n.y + a;
        this.minX = Math.min(this.minX, c),
            this.maxX = Math.max(this.maxX, c),
            this.minY = Math.min(this.minY, u),
            this.maxY = Math.max(this.maxY, u)
    }
    addQuad(e) {
        let n = this.minX
            , s = this.minY
            , r = this.maxX
            , i = this.maxY
            , o = e[0]
            , l = e[1];
        n = o < n ? o : n,
            s = l < s ? l : s,
            r = o > r ? o : r,
            i = l > i ? l : i,
            o = e[2],
            l = e[3],
            n = o < n ? o : n,
            s = l < s ? l : s,
            r = o > r ? o : r,
            i = l > i ? l : i,
            o = e[4],
            l = e[5],
            n = o < n ? o : n,
            s = l < s ? l : s,
            r = o > r ? o : r,
            i = l > i ? l : i,
            o = e[6],
            l = e[7],
            n = o < n ? o : n,
            s = l < s ? l : s,
            r = o > r ? o : r,
            i = l > i ? l : i,
            this.minX = n,
            this.minY = s,
            this.maxX = r,
            this.maxY = i
    }
    addFrame(e, n, s, r, i) {
        this.addFrameMatrix(e.worldTransform, n, s, r, i)
    }
    addFrameMatrix(e, n, s, r, i) {
        const o = e.a
            , l = e.b
            , a = e.c
            , c = e.d
            , u = e.tx
            , h = e.ty;
        let d = this.minX
            , f = this.minY
            , p = this.maxX
            , m = this.maxY
            , g = o * n + a * s + u
            , b = l * n + c * s + h;
        d = g < d ? g : d,
            f = b < f ? b : f,
            p = g > p ? g : p,
            m = b > m ? b : m,
            g = o * r + a * s + u,
            b = l * r + c * s + h,
            d = g < d ? g : d,
            f = b < f ? b : f,
            p = g > p ? g : p,
            m = b > m ? b : m,
            g = o * n + a * i + u,
            b = l * n + c * i + h,
            d = g < d ? g : d,
            f = b < f ? b : f,
            p = g > p ? g : p,
            m = b > m ? b : m,
            g = o * r + a * i + u,
            b = l * r + c * i + h,
            d = g < d ? g : d,
            f = b < f ? b : f,
            p = g > p ? g : p,
            m = b > m ? b : m,
            this.minX = d,
            this.minY = f,
            this.maxX = p,
            this.maxY = m
    }
    addVertexData(e, n, s) {
        let r = this.minX
            , i = this.minY
            , o = this.maxX
            , l = this.maxY;
        for (let a = n; a < s; a += 2) {
            const c = e[a]
                , u = e[a + 1];
            r = c < r ? c : r,
                i = u < i ? u : i,
                o = c > o ? c : o,
                l = u > l ? u : l
        }
        this.minX = r,
            this.minY = i,
            this.maxX = o,
            this.maxY = l
    }
    addVertices(e, n, s, r) {
        this.addVerticesMatrix(e.worldTransform, n, s, r)
    }
    addVerticesMatrix(e, n, s, r, i = 0, o = i) {
        const l = e.a
            , a = e.b
            , c = e.c
            , u = e.d
            , h = e.tx
            , d = e.ty;
        let f = this.minX
            , p = this.minY
            , m = this.maxX
            , g = this.maxY;
        for (let b = s; b < r; b += 2) {
            const v = n[b]
                , _ = n[b + 1]
                , y = l * v + c * _ + h
                , x = u * _ + a * v + d;
            f = Math.min(f, y - i),
                m = Math.max(m, y + i),
                p = Math.min(p, x - o),
                g = Math.max(g, x + o)
        }
        this.minX = f,
            this.minY = p,
            this.maxX = m,
            this.maxY = g
    }
    addBounds(e) {
        const n = this.minX
            , s = this.minY
            , r = this.maxX
            , i = this.maxY;
        this.minX = e.minX < n ? e.minX : n,
            this.minY = e.minY < s ? e.minY : s,
            this.maxX = e.maxX > r ? e.maxX : r,
            this.maxY = e.maxY > i ? e.maxY : i
    }
    addBoundsMask(e, n) {
        const s = e.minX > n.minX ? e.minX : n.minX
            , r = e.minY > n.minY ? e.minY : n.minY
            , i = e.maxX < n.maxX ? e.maxX : n.maxX
            , o = e.maxY < n.maxY ? e.maxY : n.maxY;
        if (s <= i && r <= o) {
            const l = this.minX
                , a = this.minY
                , c = this.maxX
                , u = this.maxY;
            this.minX = s < l ? s : l,
                this.minY = r < a ? r : a,
                this.maxX = i > c ? i : c,
                this.maxY = o > u ? o : u
        }
    }
    addBoundsMatrix(e, n) {
        this.addFrameMatrix(n, e.minX, e.minY, e.maxX, e.maxY)
    }
    addBoundsArea(e, n) {
        const s = e.minX > n.x ? e.minX : n.x
            , r = e.minY > n.y ? e.minY : n.y
            , i = e.maxX < n.x + n.width ? e.maxX : n.x + n.width
            , o = e.maxY < n.y + n.height ? e.maxY : n.y + n.height;
        if (s <= i && r <= o) {
            const l = this.minX
                , a = this.minY
                , c = this.maxX
                , u = this.maxY;
            this.minX = s < l ? s : l,
                this.minY = r < a ? r : a,
                this.maxX = i > c ? i : c,
                this.maxY = o > u ? o : u
        }
    }
    pad(e = 0, n = e) {
        this.isEmpty() || (this.minX -= e,
            this.maxX += e,
            this.minY -= n,
            this.maxY += n)
    }
    addFramePad(e, n, s, r, i, o) {
        e -= i,
            n -= o,
            s += i,
            r += o,
            this.minX = this.minX < e ? this.minX : e,
            this.maxX = this.maxX > s ? this.maxX : s,
            this.minY = this.minY < n ? this.minY : n,
            this.maxY = this.maxY > r ? this.maxY : r
    }
}
class ln extends yf {
    constructor() {
        super(),
            this.tempDisplayObjectParent = null,
            this.transform = new L_,
            this.alpha = 1,
            this.visible = !0,
            this.renderable = !0,
            this.cullable = !1,
            this.cullArea = null,
            this.parent = null,
            this.worldAlpha = 1,
            this._lastSortedIndex = 0,
            this._zIndex = 0,
            this.filterArea = null,
            this.filters = null,
            this._enabledFilters = null,
            this._bounds = new tg,
            this._localBounds = null,
            this._boundsID = 0,
            this._boundsRect = null,
            this._localBoundsRect = null,
            this._mask = null,
            this._maskRefCount = 0,
            this._destroyed = !1,
            this.isSprite = !1,
            this.isMask = !1
    }
    static mixin(e) {
        const n = Object.keys(e);
        for (let s = 0; s < n.length; ++s) {
            const r = n[s];
            Object.defineProperty(ln.prototype, r, Object.getOwnPropertyDescriptor(e, r))
        }
    }
    get destroyed() {
        return this._destroyed
    }
    _recursivePostUpdateTransform() {
        this.parent ? (this.parent._recursivePostUpdateTransform(),
            this.transform.updateTransform(this.parent.transform)) : this.transform.updateTransform(this._tempDisplayObjectParent.transform)
    }
    updateTransform() {
        this._boundsID++,
            this.transform.updateTransform(this.parent.transform),
            this.worldAlpha = this.alpha * this.parent.worldAlpha
    }
    getBounds(e, n) {
        return e || (this.parent ? (this._recursivePostUpdateTransform(),
            this.updateTransform()) : (this.parent = this._tempDisplayObjectParent,
                this.updateTransform(),
                this.parent = null)),
            this._bounds.updateID !== this._boundsID && (this.calculateBounds(),
                this._bounds.updateID = this._boundsID),
            n || (this._boundsRect || (this._boundsRect = new nt),
                n = this._boundsRect),
            this._bounds.getRectangle(n)
    }
    getLocalBounds(e) {
        e || (this._localBoundsRect || (this._localBoundsRect = new nt),
            e = this._localBoundsRect),
            this._localBounds || (this._localBounds = new tg);
        const n = this.transform
            , s = this.parent;
        this.parent = null,
            this._tempDisplayObjectParent.worldAlpha = (s == null ? void 0 : s.worldAlpha) ?? 1,
            this.transform = this._tempDisplayObjectParent.transform;
        const r = this._bounds
            , i = this._boundsID;
        this._bounds = this._localBounds;
        const o = this.getBounds(!1, e);
        return this.parent = s,
            this.transform = n,
            this._bounds = r,
            this._bounds.updateID += this._boundsID - i,
            o
    }
    toGlobal(e, n, s = !1) {
        return s || (this._recursivePostUpdateTransform(),
            this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent,
                this.displayObjectUpdateTransform(),
                this.parent = null)),
            this.worldTransform.apply(e, n)
    }
    toLocal(e, n, s, r) {
        return n && (e = n.toGlobal(e, s, r)),
            r || (this._recursivePostUpdateTransform(),
                this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent,
                    this.displayObjectUpdateTransform(),
                    this.parent = null)),
            this.worldTransform.applyInverse(e, s)
    }
    setParent(e) {
        if (!e || !e.addChild)
            throw new Error("setParent: Argument must be a Container");
        return e.addChild(this),
            e
    }
    removeFromParent() {
        var e;
        (e = this.parent) == null || e.removeChild(this)
    }
    setTransform(e = 0, n = 0, s = 1, r = 1, i = 0, o = 0, l = 0, a = 0, c = 0) {
        return this.position.x = e,
            this.position.y = n,
            this.scale.x = s || 1,
            this.scale.y = r || 1,
            this.rotation = i,
            this.skew.x = o,
            this.skew.y = l,
            this.pivot.x = a,
            this.pivot.y = c,
            this
    }
    destroy(e) {
        this.removeFromParent(),
            this._destroyed = !0,
            this.transform = null,
            this.parent = null,
            this._bounds = null,
            this.mask = null,
            this.cullArea = null,
            this.filters = null,
            this.filterArea = null,
            this.hitArea = null,
            this.eventMode = "auto",
            this.interactiveChildren = !1,
            this.emit("destroyed"),
            this.removeAllListeners()
    }
    get _tempDisplayObjectParent() {
        return this.tempDisplayObjectParent === null && (this.tempDisplayObjectParent = new oue),
            this.tempDisplayObjectParent
    }
    enableTempParent() {
        const e = this.parent;
        return this.parent = this._tempDisplayObjectParent,
            e
    }
    disableTempParent(e) {
        this.parent = e
    }
    get x() {
        return this.position.x
    }
    set x(e) {
        this.transform.position.x = e
    }
    get y() {
        return this.position.y
    }
    set y(e) {
        this.transform.position.y = e
    }
    get worldTransform() {
        return this.transform.worldTransform
    }
    get localTransform() {
        return this.transform.localTransform
    }
    get position() {
        return this.transform.position
    }
    set position(e) {
        this.transform.position.copyFrom(e)
    }
    get scale() {
        return this.transform.scale
    }
    set scale(e) {
        this.transform.scale.copyFrom(e)
    }
    get pivot() {
        return this.transform.pivot
    }
    set pivot(e) {
        this.transform.pivot.copyFrom(e)
    }
    get skew() {
        return this.transform.skew
    }
    set skew(e) {
        this.transform.skew.copyFrom(e)
    }
    get rotation() {
        return this.transform.rotation
    }
    set rotation(e) {
        this.transform.rotation = e
    }
    get angle() {
        return this.transform.rotation * jle
    }
    set angle(e) {
        this.transform.rotation = e * zle
    }
    get zIndex() {
        return this._zIndex
    }
    set zIndex(e) {
        this._zIndex !== e && (this._zIndex = e,
            this.parent && (this.parent.sortDirty = !0))
    }
    get worldVisible() {
        let e = this;
        do {
            if (!e.visible)
                return !1;
            e = e.parent
        } while (e);
        return !0
    }
    get mask() {
        return this._mask
    }
    set mask(e) {
        if (this._mask !== e) {
            if (this._mask) {
                const n = this._mask.isMaskData ? this._mask.maskObject : this._mask;
                n && (n._maskRefCount--,
                    n._maskRefCount === 0 && (n.renderable = !0,
                        n.isMask = !1))
            }
            if (this._mask = e,
                this._mask) {
                const n = this._mask.isMaskData ? this._mask.maskObject : this._mask;
                n && (n._maskRefCount === 0 && (n.renderable = !1,
                    n.isMask = !0),
                    n._maskRefCount++)
            }
        }
    }
}
class oue extends ln {
    constructor() {
        super(...arguments),
            this.sortDirty = null
    }
}
ln.prototype.displayObjectUpdateTransform = ln.prototype.updateTransform;
const aue = new Bt;
function lue(t, e) {
    return t.zIndex === e.zIndex ? t._lastSortedIndex - e._lastSortedIndex : t.zIndex - e.zIndex
}
const h5 = class Db extends ln {
    constructor() {
        super(),
            this.children = [],
            this.sortableChildren = Db.defaultSortableChildren,
            this.sortDirty = !1
    }
    onChildrenChange(e) { }
    addChild(...e) {
        if (e.length > 1)
            for (let n = 0; n < e.length; n++)
                this.addChild(e[n]);
        else {
            const n = e[0];
            n.parent && n.parent.removeChild(n),
                n.parent = this,
                this.sortDirty = !0,
                n.transform._parentID = -1,
                this.children.push(n),
                this._boundsID++,
                this.onChildrenChange(this.children.length - 1),
                this.emit("childAdded", n, this, this.children.length - 1),
                n.emit("added", this)
        }
        return e[0]
    }
    addChildAt(e, n) {
        if (n < 0 || n > this.children.length)
            throw new Error(`${e}addChildAt: The index ${n} supplied is out of bounds ${this.children.length}`);
        return e.parent && e.parent.removeChild(e),
            e.parent = this,
            this.sortDirty = !0,
            e.transform._parentID = -1,
            this.children.splice(n, 0, e),
            this._boundsID++,
            this.onChildrenChange(n),
            e.emit("added", this),
            this.emit("childAdded", e, this, n),
            e
    }
    swapChildren(e, n) {
        if (e === n)
            return;
        const s = this.getChildIndex(e)
            , r = this.getChildIndex(n);
        this.children[s] = n,
            this.children[r] = e,
            this.onChildrenChange(s < r ? s : r)
    }
    getChildIndex(e) {
        const n = this.children.indexOf(e);
        if (n === -1)
            throw new Error("The supplied DisplayObject must be a child of the caller");
        return n
    }
    setChildIndex(e, n) {
        if (n < 0 || n >= this.children.length)
            throw new Error(`The index ${n} supplied is out of bounds ${this.children.length}`);
        const s = this.getChildIndex(e);
        wu(this.children, s, 1),
            this.children.splice(n, 0, e),
            this.onChildrenChange(n)
    }
    getChildAt(e) {
        if (e < 0 || e >= this.children.length)
            throw new Error(`getChildAt: Index (${e}) does not exist.`);
        return this.children[e]
    }
    removeChild(...e) {
        if (e.length > 1)
            for (let n = 0; n < e.length; n++)
                this.removeChild(e[n]);
        else {
            const n = e[0]
                , s = this.children.indexOf(n);
            if (s === -1)
                return null;
            n.parent = null,
                n.transform._parentID = -1,
                wu(this.children, s, 1),
                this._boundsID++,
                this.onChildrenChange(s),
                n.emit("removed", this),
                this.emit("childRemoved", n, this, s)
        }
        return e[0]
    }
    removeChildAt(e) {
        const n = this.getChildAt(e);
        return n.parent = null,
            n.transform._parentID = -1,
            wu(this.children, e, 1),
            this._boundsID++,
            this.onChildrenChange(e),
            n.emit("removed", this),
            this.emit("childRemoved", n, this, e),
            n
    }
    removeChildren(e = 0, n = this.children.length) {
        const s = e
            , r = n
            , i = r - s;
        let o;
        if (i > 0 && i <= r) {
            o = this.children.splice(s, i);
            for (let l = 0; l < o.length; ++l)
                o[l].parent = null,
                    o[l].transform && (o[l].transform._parentID = -1);
            this._boundsID++,
                this.onChildrenChange(e);
            for (let l = 0; l < o.length; ++l)
                o[l].emit("removed", this),
                    this.emit("childRemoved", o[l], this, l);
            return o
        } else if (i === 0 && this.children.length === 0)
            return [];
        throw new RangeError("removeChildren: numeric values are outside the acceptable range.")
    }
    sortChildren() {
        let e = !1;
        for (let n = 0, s = this.children.length; n < s; ++n) {
            const r = this.children[n];
            r._lastSortedIndex = n,
                !e && r.zIndex !== 0 && (e = !0)
        }
        e && this.children.length > 1 && this.children.sort(lue),
            this.sortDirty = !1
    }
    updateTransform() {
        this.sortableChildren && this.sortDirty && this.sortChildren(),
            this._boundsID++,
            this.transform.updateTransform(this.parent.transform),
            this.worldAlpha = this.alpha * this.parent.worldAlpha;
        for (let e = 0, n = this.children.length; e < n; ++e) {
            const s = this.children[e];
            s.visible && s.updateTransform()
        }
    }
    calculateBounds() {
        this._bounds.clear(),
            this._calculateBounds();
        for (let e = 0; e < this.children.length; e++) {
            const n = this.children[e];
            if (!(!n.visible || !n.renderable))
                if (n.calculateBounds(),
                    n._mask) {
                    const s = n._mask.isMaskData ? n._mask.maskObject : n._mask;
                    s ? (s.calculateBounds(),
                        this._bounds.addBoundsMask(n._bounds, s._bounds)) : this._bounds.addBounds(n._bounds)
                } else
                    n.filterArea ? this._bounds.addBoundsArea(n._bounds, n.filterArea) : this._bounds.addBounds(n._bounds)
        }
        this._bounds.updateID = this._boundsID
    }
    getLocalBounds(e, n = !1) {
        const s = super.getLocalBounds(e);
        if (!n)
            for (let r = 0, i = this.children.length; r < i; ++r) {
                const o = this.children[r];
                o.visible && o.updateTransform()
            }
        return s
    }
    _calculateBounds() { }
    _renderWithCulling(e) {
        const n = e.renderTexture.sourceFrame;
        if (!(n.width > 0 && n.height > 0))
            return;
        let s, r;
        this.cullArea ? (s = this.cullArea,
            r = this.worldTransform) : this._render !== Db.prototype._render && (s = this.getBounds(!0));
        const i = e.projection.transform;
        if (i && (r ? (r = aue.copyFrom(r),
            r.prepend(i)) : r = i),
            s && n.intersects(s, r))
            this._render(e);
        else if (this.cullArea)
            return;
        for (let o = 0, l = this.children.length; o < l; ++o) {
            const a = this.children[o]
                , c = a.cullable;
            a.cullable = c || !this.cullArea,
                a.render(e),
                a.cullable = c
        }
    }
    render(e) {
        var n;
        if (!(!this.visible || this.worldAlpha <= 0 || !this.renderable))
            if (this._mask || (n = this.filters) != null && n.length)
                this.renderAdvanced(e);
            else if (this.cullable)
                this._renderWithCulling(e);
            else {
                this._render(e);
                for (let s = 0, r = this.children.length; s < r; ++s)
                    this.children[s].render(e)
            }
    }
    renderAdvanced(e) {
        var i, o, l;
        const n = this.filters
            , s = this._mask;
        if (n) {
            this._enabledFilters || (this._enabledFilters = []),
                this._enabledFilters.length = 0;
            for (let a = 0; a < n.length; a++)
                n[a].enabled && this._enabledFilters.push(n[a])
        }
        const r = n && ((i = this._enabledFilters) == null ? void 0 : i.length) || s && (!s.isMaskData || s.enabled && (s.autoDetect || s.type !== An.NONE));
        if (r && e.batch.flush(),
            n && ((o = this._enabledFilters) != null && o.length) && e.filter.push(this, this._enabledFilters),
            s && e.mask.push(this, this._mask),
            this.cullable)
            this._renderWithCulling(e);
        else {
            this._render(e);
            for (let a = 0, c = this.children.length; a < c; ++a)
                this.children[a].render(e)
        }
        r && e.batch.flush(),
            s && e.mask.pop(this),
            n && ((l = this._enabledFilters) != null && l.length) && e.filter.pop()
    }
    _render(e) { }
    destroy(e) {
        super.destroy(),
            this.sortDirty = !1;
        const n = typeof e == "boolean" ? e : e == null ? void 0 : e.children
            , s = this.removeChildren(0, this.children.length);
        if (n)
            for (let r = 0; r < s.length; ++r)
                s[r].destroy(e)
    }
    get width() {
        return this.scale.x * this.getLocalBounds().width
    }
    set width(e) {
        const n = this.getLocalBounds().width;
        n !== 0 ? this.scale.x = e / n : this.scale.x = 1,
            this._width = e
    }
    get height() {
        return this.scale.y * this.getLocalBounds().height
    }
    set height(e) {
        const n = this.getLocalBounds().height;
        n !== 0 ? this.scale.y = e / n : this.scale.y = 1,
            this._height = e
    }
}
    ;
h5.defaultSortableChildren = !1;
let ks = h5;
ks.prototype.containerUpdateTransform = ks.prototype.updateTransform;
Object.defineProperties(Le, {
    SORTABLE_CHILDREN: {
        get() {
            return ks.defaultSortableChildren
        },
        set(t) {
            dt("7.1.0", "settings.SORTABLE_CHILDREN is deprecated, use Container.defaultSortableChildren"),
                ks.defaultSortableChildren = t
        }
    }
});
const Ph = new At
    , cue = new Uint16Array([0, 1, 2, 0, 2, 3]);
class Tc extends ks {
    constructor(e) {
        super(),
            this._anchor = new wo(this._onAnchorUpdate, this, e ? e.defaultAnchor.x : 0, e ? e.defaultAnchor.y : 0),
            this._texture = null,
            this._width = 0,
            this._height = 0,
            this._tintColor = new Yt(16777215),
            this._tintRGB = null,
            this.tint = 16777215,
            this.blendMode = Oe.NORMAL,
            this._cachedTint = 16777215,
            this.uvs = null,
            this.texture = e || $e.EMPTY,
            this.vertexData = new Float32Array(8),
            this.vertexTrimmedData = null,
            this._transformID = -1,
            this._textureID = -1,
            this._transformTrimmedID = -1,
            this._textureTrimmedID = -1,
            this.indices = cue,
            this.pluginName = "batch",
            this.isSprite = !0,
            this._roundPixels = Le.ROUND_PIXELS
    }
    _onTextureUpdate() {
        this._textureID = -1,
            this._textureTrimmedID = -1,
            this._cachedTint = 16777215,
            this._width && (this.scale.x = Ra(this.scale.x) * this._width / this._texture.orig.width),
            this._height && (this.scale.y = Ra(this.scale.y) * this._height / this._texture.orig.height)
    }
    _onAnchorUpdate() {
        this._transformID = -1,
            this._transformTrimmedID = -1
    }
    calculateVertices() {
        const e = this._texture;
        if (this._transformID === this.transform._worldID && this._textureID === e._updateID)
            return;
        this._textureID !== e._updateID && (this.uvs = this._texture._uvs.uvsFloat32),
            this._transformID = this.transform._worldID,
            this._textureID = e._updateID;
        const n = this.transform.worldTransform
            , s = n.a
            , r = n.b
            , i = n.c
            , o = n.d
            , l = n.tx
            , a = n.ty
            , c = this.vertexData
            , u = e.trim
            , h = e.orig
            , d = this._anchor;
        let f = 0
            , p = 0
            , m = 0
            , g = 0;
        if (u ? (p = u.x - d._x * h.width,
            f = p + u.width,
            g = u.y - d._y * h.height,
            m = g + u.height) : (p = -d._x * h.width,
                f = p + h.width,
                g = -d._y * h.height,
                m = g + h.height),
            c[0] = s * p + i * g + l,
            c[1] = o * g + r * p + a,
            c[2] = s * f + i * g + l,
            c[3] = o * g + r * f + a,
            c[4] = s * f + i * m + l,
            c[5] = o * m + r * f + a,
            c[6] = s * p + i * m + l,
            c[7] = o * m + r * p + a,
            this._roundPixels) {
            const b = Le.RESOLUTION;
            for (let v = 0; v < c.length; ++v)
                c[v] = Math.round(c[v] * b) / b
        }
    }
    calculateTrimmedVertices() {
        if (!this.vertexTrimmedData)
            this.vertexTrimmedData = new Float32Array(8);
        else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID)
            return;
        this._transformTrimmedID = this.transform._worldID,
            this._textureTrimmedID = this._texture._updateID;
        const e = this._texture
            , n = this.vertexTrimmedData
            , s = e.orig
            , r = this._anchor
            , i = this.transform.worldTransform
            , o = i.a
            , l = i.b
            , a = i.c
            , c = i.d
            , u = i.tx
            , h = i.ty
            , d = -r._x * s.width
            , f = d + s.width
            , p = -r._y * s.height
            , m = p + s.height;
        if (n[0] = o * d + a * p + u,
            n[1] = c * p + l * d + h,
            n[2] = o * f + a * p + u,
            n[3] = c * p + l * f + h,
            n[4] = o * f + a * m + u,
            n[5] = c * m + l * f + h,
            n[6] = o * d + a * m + u,
            n[7] = c * m + l * d + h,
            this._roundPixels) {
            const g = Le.RESOLUTION;
            for (let b = 0; b < n.length; ++b)
                n[b] = Math.round(n[b] * g) / g
        }
    }
    _render(e) {
        this.calculateVertices(),
            e.batch.setObjectRenderer(e.plugins[this.pluginName]),
            e.plugins[this.pluginName].render(this)
    }
    _calculateBounds() {
        const e = this._texture.trim
            , n = this._texture.orig;
        !e || e.width === n.width && e.height === n.height ? (this.calculateVertices(),
            this._bounds.addQuad(this.vertexData)) : (this.calculateTrimmedVertices(),
                this._bounds.addQuad(this.vertexTrimmedData))
    }
    getLocalBounds(e) {
        return this.children.length === 0 ? (this._localBounds || (this._localBounds = new tg),
            this._localBounds.minX = this._texture.orig.width * -this._anchor._x,
            this._localBounds.minY = this._texture.orig.height * -this._anchor._y,
            this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x),
            this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y),
            e || (this._localBoundsRect || (this._localBoundsRect = new nt),
                e = this._localBoundsRect),
            this._localBounds.getRectangle(e)) : super.getLocalBounds.call(this, e)
    }
    containsPoint(e) {
        this.worldTransform.applyInverse(e, Ph);
        const n = this._texture.orig.width
            , s = this._texture.orig.height
            , r = -n * this.anchor.x;
        let i = 0;
        return Ph.x >= r && Ph.x < r + n && (i = -s * this.anchor.y,
            Ph.y >= i && Ph.y < i + s)
    }
    destroy(e) {
        if (super.destroy(e),
            this._texture.off("update", this._onTextureUpdate, this),
            this._anchor = null,
            typeof e == "boolean" ? e : e == null ? void 0 : e.texture) {
            const n = typeof e == "boolean" ? e : e == null ? void 0 : e.baseTexture;
            this._texture.destroy(!!n)
        }
        this._texture = null
    }
    static from(e, n) {
        const s = e instanceof $e ? e : $e.from(e, n);
        return new Tc(s)
    }
    set roundPixels(e) {
        this._roundPixels !== e && (this._transformID = -1,
            this._transformTrimmedID = -1),
            this._roundPixels = e
    }
    get roundPixels() {
        return this._roundPixels
    }
    get width() {
        return Math.abs(this.scale.x) * this._texture.orig.width
    }
    set width(e) {
        const n = Ra(this.scale.x) || 1;
        this.scale.x = n * e / this._texture.orig.width,
            this._width = e
    }
    get height() {
        return Math.abs(this.scale.y) * this._texture.orig.height
    }
    set height(e) {
        const n = Ra(this.scale.y) || 1;
        this.scale.y = n * e / this._texture.orig.height,
            this._height = e
    }
    get anchor() {
        return this._anchor
    }
    set anchor(e) {
        this._anchor.copyFrom(e)
    }
    get tint() {
        return this._tintColor.value
    }
    set tint(e) {
        this._tintColor.setValue(e),
            this._tintRGB = this._tintColor.toLittleEndianNumber()
    }
    get tintValue() {
        return this._tintColor.toNumber()
    }
    get texture() {
        return this._texture
    }
    set texture(e) {
        this._texture !== e && (this._texture && this._texture.off("update", this._onTextureUpdate, this),
            this._texture = e || $e.EMPTY,
            this._cachedTint = 16777215,
            this._textureID = -1,
            this._textureTrimmedID = -1,
            e && (e.baseTexture.valid ? this._onTextureUpdate() : e.once("update", this._onTextureUpdate, this)))
    }
}
class uue {
    constructor(e, n) {
        this.uvBuffer = e,
            this.uvMatrix = n,
            this.data = null,
            this._bufferUpdateId = -1,
            this._textureUpdateId = -1,
            this._updateID = 0
    }
    update(e) {
        if (!e && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID)
            return;
        this._bufferUpdateId = this.uvBuffer._updateID,
            this._textureUpdateId = this.uvMatrix._updateID;
        const n = this.uvBuffer.data;
        (!this.data || this.data.length !== n.length) && (this.data = new Float32Array(n.length)),
            this.uvMatrix.multiplyUvs(n, this.data),
            this._updateID++
    }
}
const x1 = new At
    , iA = new Va
    , d5 = class f5 extends ks {
        constructor(e, n, s, r = ti.TRIANGLES) {
            super(),
                this.geometry = e,
                this.shader = n,
                this.state = s || Ji.for2d(),
                this.drawMode = r,
                this.start = 0,
                this.size = 0,
                this.uvs = null,
                this.indices = null,
                this.vertexData = new Float32Array(1),
                this.vertexDirty = -1,
                this._transformID = -1,
                this._roundPixels = Le.ROUND_PIXELS,
                this.batchUvs = null
        }
        get geometry() {
            return this._geometry
        }
        set geometry(e) {
            this._geometry !== e && (this._geometry && (this._geometry.refCount--,
                this._geometry.refCount === 0 && this._geometry.dispose()),
                this._geometry = e,
                this._geometry && this._geometry.refCount++,
                this.vertexDirty = -1)
        }
        get uvBuffer() {
            return this.geometry.buffers[1]
        }
        get verticesBuffer() {
            return this.geometry.buffers[0]
        }
        set material(e) {
            this.shader = e
        }
        get material() {
            return this.shader
        }
        set blendMode(e) {
            this.state.blendMode = e
        }
        get blendMode() {
            return this.state.blendMode
        }
        set roundPixels(e) {
            this._roundPixels !== e && (this._transformID = -1),
                this._roundPixels = e
        }
        get roundPixels() {
            return this._roundPixels
        }
        get tint() {
            return "tint" in this.shader ? this.shader.tint : null
        }
        set tint(e) {
            this.shader.tint = e
        }
        get tintValue() {
            return this.shader.tintValue
        }
        get texture() {
            return "texture" in this.shader ? this.shader.texture : null
        }
        set texture(e) {
            this.shader.texture = e
        }
        _render(e) {
            const n = this.geometry.buffers[0].data;
            this.shader.batchable && this.drawMode === ti.TRIANGLES && n.length < f5.BATCHABLE_SIZE * 2 ? this._renderToBatch(e) : this._renderDefault(e)
        }
        _renderDefault(e) {
            const n = this.shader;
            n.alpha = this.worldAlpha,
                n.update && n.update(),
                e.batch.flush(),
                n.uniforms.translationMatrix = this.transform.worldTransform.toArray(!0),
                e.shader.bind(n),
                e.state.set(this.state),
                e.geometry.bind(this.geometry, n),
                e.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount)
        }
        _renderToBatch(e) {
            const n = this.geometry
                , s = this.shader;
            s.uvMatrix && (s.uvMatrix.update(),
                this.calculateUvs()),
                this.calculateVertices(),
                this.indices = n.indexBuffer.data,
                this._tintRGB = s._tintRGB,
                this._texture = s.texture;
            const r = this.material.pluginName;
            e.batch.setObjectRenderer(e.plugins[r]),
                e.plugins[r].render(this)
        }
        calculateVertices() {
            const e = this.geometry.buffers[0]
                , n = e.data
                , s = e._updateID;
            if (s === this.vertexDirty && this._transformID === this.transform._worldID)
                return;
            this._transformID = this.transform._worldID,
                this.vertexData.length !== n.length && (this.vertexData = new Float32Array(n.length));
            const r = this.transform.worldTransform
                , i = r.a
                , o = r.b
                , l = r.c
                , a = r.d
                , c = r.tx
                , u = r.ty
                , h = this.vertexData;
            for (let d = 0; d < h.length / 2; d++) {
                const f = n[d * 2]
                    , p = n[d * 2 + 1];
                h[d * 2] = i * f + l * p + c,
                    h[d * 2 + 1] = o * f + a * p + u
            }
            if (this._roundPixels) {
                const d = Le.RESOLUTION;
                for (let f = 0; f < h.length; ++f)
                    h[f] = Math.round(h[f] * d) / d
            }
            this.vertexDirty = s
        }
        calculateUvs() {
            const e = this.geometry.buffers[1]
                , n = this.shader;
            n.uvMatrix.isSimple ? this.uvs = e.data : (this.batchUvs || (this.batchUvs = new uue(e, n.uvMatrix)),
                this.batchUvs.update(),
                this.uvs = this.batchUvs.data)
        }
        _calculateBounds() {
            this.calculateVertices(),
                this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length)
        }
        containsPoint(e) {
            if (!this.getBounds().contains(e.x, e.y))
                return !1;
            this.worldTransform.applyInverse(e, x1);
            const n = this.geometry.getBuffer("aVertexPosition").data
                , s = iA.points
                , r = this.geometry.getIndex().data
                , i = r.length
                , o = this.drawMode === 4 ? 3 : 1;
            for (let l = 0; l + 2 < i; l += o) {
                const a = r[l] * 2
                    , c = r[l + 1] * 2
                    , u = r[l + 2] * 2;
                if (s[0] = n[a],
                    s[1] = n[a + 1],
                    s[2] = n[c],
                    s[3] = n[c + 1],
                    s[4] = n[u],
                    s[5] = n[u + 1],
                    iA.contains(x1.x, x1.y))
                    return !0
            }
            return !1
        }
        destroy(e) {
            super.destroy(e),
                this._cachedTexture && (this._cachedTexture.destroy(),
                    this._cachedTexture = null),
                this.geometry = null,
                this.shader = null,
                this.state = null,
                this.uvs = null,
                this.indices = null,
                this.vertexData = null
        }
    }
    ;
d5.BATCHABLE_SIZE = 100;
let Bb = d5;
class p5 extends ja {
    constructor(e, n, s) {
        super();
        const r = new _n(e)
            , i = new _n(n, !0)
            , o = new _n(s, !0, !0);
        this.addAttribute("aVertexPosition", r, 2, !1, Ge.FLOAT).addAttribute("aTextureCoord", i, 2, !1, Ge.FLOAT).addIndex(o),
            this._updateId = -1
    }
    get vertexDirtyId() {
        return this.buffers[0]._updateID
    }
}
var hue = `varying vec2 vTextureCoord;
uniform vec4 uColor;

uniform sampler2D uSampler;

void main(void)
{
    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;
}
`
    , due = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTextureMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;
}
`;
class Fb extends Hi {
    constructor(e, n) {
        const s = {
            uSampler: e,
            alpha: 1,
            uTextureMatrix: Bt.IDENTITY,
            uColor: new Float32Array([1, 1, 1, 1])
        };
        n = Object.assign({
            tint: 16777215,
            alpha: 1,
            pluginName: "batch"
        }, n),
            n.uniforms && Object.assign(s, n.uniforms),
            super(n.program || So.from(due, hue), s),
            this._colorDirty = !1,
            this.uvMatrix = new F6(e),
            this.batchable = n.program === void 0,
            this.pluginName = n.pluginName,
            this._tintColor = new Yt(n.tint),
            this._tintRGB = this._tintColor.toLittleEndianNumber(),
            this._colorDirty = !0,
            this.alpha = n.alpha
    }
    get texture() {
        return this.uniforms.uSampler
    }
    set texture(e) {
        this.uniforms.uSampler !== e && (!this.uniforms.uSampler.baseTexture.alphaMode != !e.baseTexture.alphaMode && (this._colorDirty = !0),
            this.uniforms.uSampler = e,
            this.uvMatrix.texture = e)
    }
    set alpha(e) {
        e !== this._alpha && (this._alpha = e,
            this._colorDirty = !0)
    }
    get alpha() {
        return this._alpha
    }
    set tint(e) {
        e !== this.tint && (this._tintColor.setValue(e),
            this._tintRGB = this._tintColor.toLittleEndianNumber(),
            this._colorDirty = !0)
    }
    get tint() {
        return this._tintColor.value
    }
    get tintValue() {
        return this._tintColor.toNumber()
    }
    update() {
        if (this._colorDirty) {
            this._colorDirty = !1;
            const e = this.texture.baseTexture.alphaMode;
            Yt.shared.setValue(this._tintColor).premultiply(this._alpha, e).toArray(this.uniforms.uColor)
        }
        this.uvMatrix.update() && (this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord)
    }
}
class fue extends Bb {
    constructor(e = $e.EMPTY, n, s, r, i) {
        const o = new p5(n, s, r);
        o.getBuffer("aVertexPosition").static = !1;
        const l = new Fb(e);
        super(o, l, null, i),
            this.autoUpdate = !0
    }
    get vertices() {
        return this.geometry.getBuffer("aVertexPosition").data
    }
    set vertices(e) {
        this.geometry.getBuffer("aVertexPosition").data = e
    }
    _render(e) {
        this.autoUpdate && this.geometry.getBuffer("aVertexPosition").update(),
            super._render(e)
    }
}
const ng = {
    build(t) {
        const e = t.points;
        let n, s, r, i, o, l;
        if (t.type === ss.CIRC) {
            const p = t.shape;
            n = p.x,
                s = p.y,
                o = l = p.radius,
                r = i = 0
        } else if (t.type === ss.ELIP) {
            const p = t.shape;
            n = p.x,
                s = p.y,
                o = p.width,
                l = p.height,
                r = i = 0
        } else {
            const p = t.shape
                , m = p.width / 2
                , g = p.height / 2;
            n = p.x + m,
                s = p.y + g,
                o = l = Math.max(0, Math.min(p.radius, Math.min(m, g))),
                r = m - o,
                i = g - l
        }
        if (!(o >= 0 && l >= 0 && r >= 0 && i >= 0)) {
            e.length = 0;
            return
        }
        const a = Math.ceil(2.3 * Math.sqrt(o + l))
            , c = a * 8 + (r ? 4 : 0) + (i ? 4 : 0);
        if (e.length = c,
            c === 0)
            return;
        if (a === 0) {
            e.length = 8,
                e[0] = e[6] = n + r,
                e[1] = e[3] = s + i,
                e[2] = e[4] = n - r,
                e[5] = e[7] = s - i;
            return
        }
        let u = 0
            , h = a * 4 + (r ? 2 : 0) + 2
            , d = h
            , f = c;
        {
            const p = r + o
                , m = i
                , g = n + p
                , b = n - p
                , v = s + m;
            if (e[u++] = g,
                e[u++] = v,
                e[--h] = v,
                e[--h] = b,
                i) {
                const _ = s - m;
                e[d++] = b,
                    e[d++] = _,
                    e[--f] = _,
                    e[--f] = g
            }
        }
        for (let p = 1; p < a; p++) {
            const m = Math.PI / 2 * (p / a)
                , g = r + Math.cos(m) * o
                , b = i + Math.sin(m) * l
                , v = n + g
                , _ = n - g
                , y = s + b
                , x = s - b;
            e[u++] = v,
                e[u++] = y,
                e[--h] = y,
                e[--h] = _,
                e[d++] = _,
                e[d++] = x,
                e[--f] = x,
                e[--f] = v
        }
        {
            const p = r
                , m = i + l
                , g = n + p
                , b = n - p
                , v = s + m
                , _ = s - m;
            e[u++] = g,
                e[u++] = v,
                e[--f] = _,
                e[--f] = g,
                r && (e[u++] = b,
                    e[u++] = v,
                    e[--f] = _,
                    e[--f] = b)
        }
    },
    triangulate(t, e) {
        const n = t.points
            , s = e.points
            , r = e.indices;
        if (n.length === 0)
            return;
        let i = s.length / 2;
        const o = i;
        let l, a;
        if (t.type !== ss.RREC) {
            const u = t.shape;
            l = u.x,
                a = u.y
        } else {
            const u = t.shape;
            l = u.x + u.width / 2,
                a = u.y + u.height / 2
        }
        const c = t.matrix;
        s.push(t.matrix ? c.a * l + c.c * a + c.tx : l, t.matrix ? c.b * l + c.d * a + c.ty : a),
            i++,
            s.push(n[0], n[1]);
        for (let u = 2; u < n.length; u += 2)
            s.push(n[u], n[u + 1]),
                r.push(i++, o, i);
        r.push(o + 1, o, i)
    }
};
function oA(t, e = !1) {
    const n = t.length;
    if (n < 6)
        return;
    let s = 0;
    for (let r = 0, i = t[n - 2], o = t[n - 1]; r < n; r += 2) {
        const l = t[r]
            , a = t[r + 1];
        s += (l - i) * (a + o),
            i = l,
            o = a
    }
    if (!e && s > 0 || e && s <= 0) {
        const r = n / 2;
        for (let i = r + r % 2; i < n; i += 2) {
            const o = n - i - 2
                , l = n - i - 1
                , a = i
                , c = i + 1;
            [t[o], t[a]] = [t[a], t[o]],
                [t[l], t[c]] = [t[c], t[l]]
        }
    }
}
const m5 = {
    build(t) {
        t.points = t.shape.points.slice()
    },
    triangulate(t, e) {
        let n = t.points;
        const s = t.holes
            , r = e.points
            , i = e.indices;
        if (n.length >= 6) {
            oA(n, !1);
            const o = [];
            for (let c = 0; c < s.length; c++) {
                const u = s[c];
                oA(u.points, !0),
                    o.push(n.length / 2),
                    n = n.concat(u.points)
            }
            const l = $ie(n, o, 2);
            if (!l)
                return;
            const a = r.length / 2;
            for (let c = 0; c < l.length; c += 3)
                i.push(l[c] + a),
                    i.push(l[c + 1] + a),
                    i.push(l[c + 2] + a);
            for (let c = 0; c < n.length; c++)
                r.push(n[c])
        }
    }
}
    , pue = {
        build(t) {
            const e = t.shape
                , n = e.x
                , s = e.y
                , r = e.width
                , i = e.height
                , o = t.points;
            o.length = 0,
                r >= 0 && i >= 0 && o.push(n, s, n + r, s, n + r, s + i, n, s + i)
        },
        triangulate(t, e) {
            const n = t.points
                , s = e.points;
            if (n.length === 0)
                return;
            const r = s.length / 2;
            s.push(n[0], n[1], n[2], n[3], n[6], n[7], n[4], n[5]),
                e.indices.push(r, r + 1, r + 2, r + 1, r + 2, r + 3)
        }
    }
    , mue = {
        build(t) {
            ng.build(t)
        },
        triangulate(t, e) {
            ng.triangulate(t, e)
        }
    };
var vr = (t => (t.MITER = "miter",
    t.BEVEL = "bevel",
    t.ROUND = "round",
    t))(vr || {})
    , Ma = (t => (t.BUTT = "butt",
        t.ROUND = "round",
        t.SQUARE = "square",
        t))(Ma || {});
const Ku = {
    adaptive: !0,
    maxLength: 10,
    minSegments: 8,
    maxSegments: 2048,
    epsilon: 1e-4,
    _segmentsCount(t, e = 20) {
        if (!this.adaptive || !t || isNaN(t))
            return e;
        let n = Math.ceil(t / this.maxLength);
        return n < this.minSegments ? n = this.minSegments : n > this.maxSegments && (n = this.maxSegments),
            n
    }
};
class aA {
    static curveTo(e, n, s, r, i, o) {
        const l = o[o.length - 2]
            , a = o[o.length - 1] - n
            , c = l - e
            , u = r - n
            , h = s - e
            , d = Math.abs(a * h - c * u);
        if (d < 1e-8 || i === 0)
            return (o[o.length - 2] !== e || o[o.length - 1] !== n) && o.push(e, n),
                null;
        const f = a * a + c * c
            , p = u * u + h * h
            , m = a * u + c * h
            , g = i * Math.sqrt(f) / d
            , b = i * Math.sqrt(p) / d
            , v = g * m / f
            , _ = b * m / p
            , y = g * h + b * c
            , x = g * u + b * a
            , w = c * (b + v)
            , S = a * (b + v)
            , E = h * (g + _)
            , C = u * (g + _)
            , I = Math.atan2(S - x, w - y)
            , L = Math.atan2(C - x, E - y);
        return {
            cx: y + e,
            cy: x + n,
            radius: i,
            startAngle: I,
            endAngle: L,
            anticlockwise: c * u > h * a
        }
    }
    static arc(e, n, s, r, i, o, l, a, c) {
        const u = l - o
            , h = Ku._segmentsCount(Math.abs(u) * i, Math.ceil(Math.abs(u) / Km) * 40)
            , d = u / (h * 2)
            , f = d * 2
            , p = Math.cos(d)
            , m = Math.sin(d)
            , g = h - 1
            , b = g % 1 / g;
        for (let v = 0; v <= g; ++v) {
            const _ = v + b * v
                , y = d + o + f * _
                , x = Math.cos(y)
                , w = -Math.sin(y);
            c.push((p * x + m * w) * i + s, (p * -w + m * x) * i + r)
        }
    }
}
class gue {
    constructor() {
        this.reset()
    }
    begin(e, n, s) {
        this.reset(),
            this.style = e,
            this.start = n,
            this.attribStart = s
    }
    end(e, n) {
        this.attribSize = n - this.attribStart,
            this.size = e - this.start
    }
    reset() {
        this.style = null,
            this.size = 0,
            this.start = 0,
            this.attribStart = 0,
            this.attribSize = 0
    }
}
class lw {
    static curveLength(e, n, s, r, i, o, l, a) {
        let c = 0
            , u = 0
            , h = 0
            , d = 0
            , f = 0
            , p = 0
            , m = 0
            , g = 0
            , b = 0
            , v = 0
            , _ = 0
            , y = e
            , x = n;
        for (let w = 1; w <= 10; ++w)
            u = w / 10,
                h = u * u,
                d = h * u,
                f = 1 - u,
                p = f * f,
                m = p * f,
                g = m * e + 3 * p * u * s + 3 * f * h * i + d * l,
                b = m * n + 3 * p * u * r + 3 * f * h * o + d * a,
                v = y - g,
                _ = x - b,
                y = g,
                x = b,
                c += Math.sqrt(v * v + _ * _);
        return c
    }
    static curveTo(e, n, s, r, i, o, l) {
        const a = l[l.length - 2]
            , c = l[l.length - 1];
        l.length -= 2;
        const u = Ku._segmentsCount(lw.curveLength(a, c, e, n, s, r, i, o));
        let h = 0
            , d = 0
            , f = 0
            , p = 0
            , m = 0;
        l.push(a, c);
        for (let g = 1, b = 0; g <= u; ++g)
            b = g / u,
                h = 1 - b,
                d = h * h,
                f = d * h,
                p = b * b,
                m = p * b,
                l.push(f * a + 3 * d * b * e + 3 * h * p * s + m * i, f * c + 3 * d * b * n + 3 * h * p * r + m * o)
    }
}
function lA(t, e, n, s, r, i, o, l) {
    const a = t - n * r
        , c = e - s * r
        , u = t + n * i
        , h = e + s * i;
    let d, f;
    o ? (d = s,
        f = -n) : (d = -s,
            f = n);
    const p = a + d
        , m = c + f
        , g = u + d
        , b = h + f;
    return l.push(p, m, g, b),
        2
}
function yl(t, e, n, s, r, i, o, l) {
    const a = n - t
        , c = s - e;
    let u = Math.atan2(a, c)
        , h = Math.atan2(r - t, i - e);
    l && u < h ? u += Math.PI * 2 : !l && u > h && (h += Math.PI * 2);
    let d = u;
    const f = h - u
        , p = Math.abs(f)
        , m = Math.sqrt(a * a + c * c)
        , g = (15 * p * Math.sqrt(m) / Math.PI >> 0) + 1
        , b = f / g;
    if (d += b,
        l) {
        o.push(t, e, n, s);
        for (let v = 1, _ = d; v < g; v++,
            _ += b)
            o.push(t, e, t + Math.sin(_) * m, e + Math.cos(_) * m);
        o.push(t, e, r, i)
    } else {
        o.push(n, s, t, e);
        for (let v = 1, _ = d; v < g; v++,
            _ += b)
            o.push(t + Math.sin(_) * m, e + Math.cos(_) * m, t, e);
        o.push(r, i, t, e)
    }
    return g * 2
}
function _ue(t, e) {
    const n = t.shape;
    let s = t.points || n.points.slice();
    const r = e.closePointEps;
    if (s.length === 0)
        return;
    const i = t.lineStyle
        , o = new At(s[0], s[1])
        , l = new At(s[s.length - 2], s[s.length - 1])
        , a = n.type !== ss.POLY || n.closeStroke
        , c = Math.abs(o.x - l.x) < r && Math.abs(o.y - l.y) < r;
    if (a) {
        s = s.slice(),
            c && (s.pop(),
                s.pop(),
                l.set(s[s.length - 2], s[s.length - 1]));
        const j = (o.x + l.x) * .5
            , z = (l.y + o.y) * .5;
        s.unshift(j, z),
            s.push(j, z)
    }
    const u = e.points
        , h = s.length / 2;
    let d = s.length;
    const f = u.length / 2
        , p = i.width / 2
        , m = p * p
        , g = i.miterLimit * i.miterLimit;
    let b = s[0]
        , v = s[1]
        , _ = s[2]
        , y = s[3]
        , x = 0
        , w = 0
        , S = -(v - y)
        , E = b - _
        , C = 0
        , I = 0
        , L = Math.sqrt(S * S + E * E);
    S /= L,
        E /= L,
        S *= p,
        E *= p;
    const k = i.alignment
        , R = (1 - k) * 2
        , U = k * 2;
    a || (i.cap === Ma.ROUND ? d += yl(b - S * (R - U) * .5, v - E * (R - U) * .5, b - S * R, v - E * R, b + S * U, v + E * U, u, !0) + 2 : i.cap === Ma.SQUARE && (d += lA(b, v, S, E, R, U, !0, u))),
        u.push(b - S * R, v - E * R, b + S * U, v + E * U);
    for (let j = 1; j < h - 1; ++j) {
        b = s[(j - 1) * 2],
            v = s[(j - 1) * 2 + 1],
            _ = s[j * 2],
            y = s[j * 2 + 1],
            x = s[(j + 1) * 2],
            w = s[(j + 1) * 2 + 1],
            S = -(v - y),
            E = b - _,
            L = Math.sqrt(S * S + E * E),
            S /= L,
            E /= L,
            S *= p,
            E *= p,
            C = -(y - w),
            I = _ - x,
            L = Math.sqrt(C * C + I * I),
            C /= L,
            I /= L,
            C *= p,
            I *= p;
        const z = _ - b
            , ee = v - y
            , J = _ - x
            , Y = w - y
            , ne = z * J + ee * Y
            , oe = ee * J - Y * z
            , ce = oe < 0;
        if (Math.abs(oe) < .001 * Math.abs(ne)) {
            u.push(_ - S * R, y - E * R, _ + S * U, y + E * U),
                ne >= 0 && (i.join === vr.ROUND ? d += yl(_, y, _ - S * R, y - E * R, _ - C * R, y - I * R, u, !1) + 4 : d += 2,
                    u.push(_ - C * U, y - I * U, _ + C * R, y + I * R));
            continue
        }
        const ue = (-S + b) * (-E + y) - (-S + _) * (-E + v)
            , we = (-C + x) * (-I + y) - (-C + _) * (-I + w)
            , K = (z * we - J * ue) / oe
            , ge = (Y * ue - ee * we) / oe
            , he = (K - _) * (K - _) + (ge - y) * (ge - y)
            , be = _ + (K - _) * R
            , Pe = y + (ge - y) * R
            , De = _ - (K - _) * U
            , D = y - (ge - y) * U
            , M = Math.min(z * z + ee * ee, J * J + Y * Y)
            , X = ce ? R : U
            , ae = M + X * X * m
            , ie = he <= ae;
        let pe = i.join;
        if (pe === vr.MITER && he / m > g && (pe = vr.BEVEL),
            ie)
            switch (pe) {
                case vr.MITER:
                    {
                        u.push(be, Pe, De, D);
                        break
                    }
                case vr.BEVEL:
                    {
                        ce ? u.push(be, Pe, _ + S * U, y + E * U, be, Pe, _ + C * U, y + I * U) : u.push(_ - S * R, y - E * R, De, D, _ - C * R, y - I * R, De, D),
                            d += 2;
                        break
                    }
                case vr.ROUND:
                    {
                        ce ? (u.push(be, Pe, _ + S * U, y + E * U),
                            d += yl(_, y, _ + S * U, y + E * U, _ + C * U, y + I * U, u, !0) + 4,
                            u.push(be, Pe, _ + C * U, y + I * U)) : (u.push(_ - S * R, y - E * R, De, D),
                                d += yl(_, y, _ - S * R, y - E * R, _ - C * R, y - I * R, u, !1) + 4,
                                u.push(_ - C * R, y - I * R, De, D));
                        break
                    }
            }
        else {
            switch (u.push(_ - S * R, y - E * R, _ + S * U, y + E * U),
            pe) {
                case vr.MITER:
                    {
                        ce ? u.push(De, D, De, D) : u.push(be, Pe, be, Pe),
                            d += 2;
                        break
                    }
                case vr.ROUND:
                    {
                        ce ? d += yl(_, y, _ + S * U, y + E * U, _ + C * U, y + I * U, u, !0) + 2 : d += yl(_, y, _ - S * R, y - E * R, _ - C * R, y - I * R, u, !1) + 2;
                        break
                    }
            }
            u.push(_ - C * R, y - I * R, _ + C * U, y + I * U),
                d += 2
        }
    }
    b = s[(h - 2) * 2],
        v = s[(h - 2) * 2 + 1],
        _ = s[(h - 1) * 2],
        y = s[(h - 1) * 2 + 1],
        S = -(v - y),
        E = b - _,
        L = Math.sqrt(S * S + E * E),
        S /= L,
        E /= L,
        S *= p,
        E *= p,
        u.push(_ - S * R, y - E * R, _ + S * U, y + E * U),
        a || (i.cap === Ma.ROUND ? d += yl(_ - S * (R - U) * .5, y - E * (R - U) * .5, _ - S * R, y - E * R, _ + S * U, y + E * U, u, !1) + 2 : i.cap === Ma.SQUARE && (d += lA(_, y, S, E, R, U, !1, u)));
    const W = e.indices
        , H = Ku.epsilon * Ku.epsilon;
    for (let j = f; j < d + f - 2; ++j)
        b = u[j * 2],
            v = u[j * 2 + 1],
            _ = u[(j + 1) * 2],
            y = u[(j + 1) * 2 + 1],
            x = u[(j + 2) * 2],
            w = u[(j + 2) * 2 + 1],
            !(Math.abs(b * (y - w) + _ * (w - v) + x * (v - y)) < H) && W.push(j, j + 1, j + 2)
}
function yue(t, e) {
    let n = 0;
    const s = t.shape
        , r = t.points || s.points
        , i = s.type !== ss.POLY || s.closeStroke;
    if (r.length === 0)
        return;
    const o = e.points
        , l = e.indices
        , a = r.length / 2
        , c = o.length / 2;
    let u = c;
    for (o.push(r[0], r[1]),
        n = 1; n < a; n++)
        o.push(r[n * 2], r[n * 2 + 1]),
            l.push(u, u + 1),
            u++;
    i && l.push(u, c)
}
function cA(t, e) {
    t.lineStyle.native ? yue(t, e) : _ue(t, e)
}
class cw {
    static curveLength(e, n, s, r, i, o) {
        const l = e - 2 * s + i
            , a = n - 2 * r + o
            , c = 2 * s - 2 * e
            , u = 2 * r - 2 * n
            , h = 4 * (l * l + a * a)
            , d = 4 * (l * c + a * u)
            , f = c * c + u * u
            , p = 2 * Math.sqrt(h + d + f)
            , m = Math.sqrt(h)
            , g = 2 * h * m
            , b = 2 * Math.sqrt(f)
            , v = d / m;
        return (g * p + m * d * (p - b) + (4 * f * h - d * d) * Math.log((2 * m + v + p) / (v + b))) / (4 * g)
    }
    static curveTo(e, n, s, r, i) {
        const o = i[i.length - 2]
            , l = i[i.length - 1]
            , a = Ku._segmentsCount(cw.curveLength(o, l, e, n, s, r));
        let c = 0
            , u = 0;
        for (let h = 1; h <= a; ++h) {
            const d = h / a;
            c = o + (e - o) * d,
                u = l + (n - l) * d,
                i.push(c + (e + (s - e) * d - c) * d, u + (n + (r - n) * d - u) * d)
        }
    }
}
const w1 = {
    [ss.POLY]: m5,
    [ss.CIRC]: ng,
    [ss.ELIP]: ng,
    [ss.RECT]: pue,
    [ss.RREC]: mue
}
    , uA = []
    , _p = [];
class sg {
    constructor(e, n = null, s = null, r = null) {
        this.points = [],
            this.holes = [],
            this.shape = e,
            this.lineStyle = s,
            this.fillStyle = n,
            this.matrix = r,
            this.type = e.type
    }
    clone() {
        return new sg(this.shape, this.fillStyle, this.lineStyle, this.matrix)
    }
    destroy() {
        this.shape = null,
            this.holes.length = 0,
            this.holes = null,
            this.points.length = 0,
            this.points = null,
            this.lineStyle = null,
            this.fillStyle = null
    }
}
const Lc = new At
    , g5 = class _5 extends E6 {
        constructor() {
            super(),
                this.closePointEps = 1e-4,
                this.boundsPadding = 0,
                this.uvsFloat32 = null,
                this.indicesUint16 = null,
                this.batchable = !1,
                this.points = [],
                this.colors = [],
                this.uvs = [],
                this.indices = [],
                this.textureIds = [],
                this.graphicsData = [],
                this.drawCalls = [],
                this.batchDirty = -1,
                this.batches = [],
                this.dirty = 0,
                this.cacheDirty = -1,
                this.clearDirty = 0,
                this.shapeIndex = 0,
                this._bounds = new tg,
                this.boundsDirty = -1
        }
        get bounds() {
            return this.updateBatches(),
                this.boundsDirty !== this.dirty && (this.boundsDirty = this.dirty,
                    this.calculateBounds()),
                this._bounds
        }
        invalidate() {
            this.boundsDirty = -1,
                this.dirty++,
                this.batchDirty++,
                this.shapeIndex = 0,
                this.points.length = 0,
                this.colors.length = 0,
                this.uvs.length = 0,
                this.indices.length = 0,
                this.textureIds.length = 0;
            for (let e = 0; e < this.drawCalls.length; e++)
                this.drawCalls[e].texArray.clear(),
                    _p.push(this.drawCalls[e]);
            this.drawCalls.length = 0;
            for (let e = 0; e < this.batches.length; e++) {
                const n = this.batches[e];
                n.reset(),
                    uA.push(n)
            }
            this.batches.length = 0
        }
        clear() {
            return this.graphicsData.length > 0 && (this.invalidate(),
                this.clearDirty++,
                this.graphicsData.length = 0),
                this
        }
        drawShape(e, n = null, s = null, r = null) {
            const i = new sg(e, n, s, r);
            return this.graphicsData.push(i),
                this.dirty++,
                this
        }
        drawHole(e, n = null) {
            if (!this.graphicsData.length)
                return null;
            const s = new sg(e, null, null, n)
                , r = this.graphicsData[this.graphicsData.length - 1];
            return s.lineStyle = r.lineStyle,
                r.holes.push(s),
                this.dirty++,
                this
        }
        destroy() {
            super.destroy();
            for (let e = 0; e < this.graphicsData.length; ++e)
                this.graphicsData[e].destroy();
            this.points.length = 0,
                this.points = null,
                this.colors.length = 0,
                this.colors = null,
                this.uvs.length = 0,
                this.uvs = null,
                this.indices.length = 0,
                this.indices = null,
                this.indexBuffer.destroy(),
                this.indexBuffer = null,
                this.graphicsData.length = 0,
                this.graphicsData = null,
                this.drawCalls.length = 0,
                this.drawCalls = null,
                this.batches.length = 0,
                this.batches = null,
                this._bounds = null
        }
        containsPoint(e) {
            const n = this.graphicsData;
            for (let s = 0; s < n.length; ++s) {
                const r = n[s];
                if (r.fillStyle.visible && r.shape && (r.matrix ? r.matrix.applyInverse(e, Lc) : Lc.copyFrom(e),
                    r.shape.contains(Lc.x, Lc.y))) {
                    let i = !1;
                    if (r.holes) {
                        for (let o = 0; o < r.holes.length; o++)
                            if (r.holes[o].shape.contains(Lc.x, Lc.y)) {
                                i = !0;
                                break
                            }
                    }
                    if (!i)
                        return !0
                }
            }
            return !1
        }
        updateBatches() {
            if (!this.graphicsData.length) {
                this.batchable = !0;
                return
            }
            if (!this.validateBatching())
                return;
            this.cacheDirty = this.dirty;
            const e = this.uvs
                , n = this.graphicsData;
            let s = null
                , r = null;
            this.batches.length > 0 && (s = this.batches[this.batches.length - 1],
                r = s.style);
            for (let a = this.shapeIndex; a < n.length; a++) {
                this.shapeIndex++;
                const c = n[a]
                    , u = c.fillStyle
                    , h = c.lineStyle;
                w1[c.type].build(c),
                    c.matrix && this.transformPoints(c.points, c.matrix),
                    (u.visible || h.visible) && this.processHoles(c.holes);
                for (let d = 0; d < 2; d++) {
                    const f = d === 0 ? u : h;
                    if (!f.visible)
                        continue;
                    const p = f.texture.baseTexture
                        , m = this.indices.length
                        , g = this.points.length / 2;
                    p.wrapMode = Ua.REPEAT,
                        d === 0 ? this.processFill(c) : this.processLine(c);
                    const b = this.points.length / 2 - g;
                    b !== 0 && (s && !this._compareStyles(r, f) && (s.end(m, g),
                        s = null),
                        s || (s = uA.pop() || new gue,
                            s.begin(f, m, g),
                            this.batches.push(s),
                            r = f),
                        this.addUvs(this.points, e, f.texture, g, b, f.matrix))
                }
            }
            const i = this.indices.length
                , o = this.points.length / 2;
            if (s && s.end(i, o),
                this.batches.length === 0) {
                this.batchable = !0;
                return
            }
            const l = o > 65535;
            this.indicesUint16 && this.indices.length === this.indicesUint16.length && l === this.indicesUint16.BYTES_PER_ELEMENT > 2 ? this.indicesUint16.set(this.indices) : this.indicesUint16 = l ? new Uint32Array(this.indices) : new Uint16Array(this.indices),
                this.batchable = this.isBatchable(),
                this.batchable ? this.packBatches() : this.buildDrawCalls()
        }
        _compareStyles(e, n) {
            return !(!e || !n || e.texture.baseTexture !== n.texture.baseTexture || e.color + e.alpha !== n.color + n.alpha || !!e.native != !!n.native)
        }
        validateBatching() {
            if (this.dirty === this.cacheDirty || !this.graphicsData.length)
                return !1;
            for (let e = 0, n = this.graphicsData.length; e < n; e++) {
                const s = this.graphicsData[e]
                    , r = s.fillStyle
                    , i = s.lineStyle;
                if (r && !r.texture.baseTexture.valid || i && !i.texture.baseTexture.valid)
                    return !1
            }
            return !0
        }
        packBatches() {
            this.batchDirty++,
                this.uvsFloat32 = new Float32Array(this.uvs);
            const e = this.batches;
            for (let n = 0, s = e.length; n < s; n++) {
                const r = e[n];
                for (let i = 0; i < r.size; i++) {
                    const o = r.start + i;
                    this.indicesUint16[o] = this.indicesUint16[o] - r.attribStart
                }
            }
        }
        isBatchable() {
            if (this.points.length > 65535 * 2)
                return !1;
            const e = this.batches;
            for (let n = 0; n < e.length; n++)
                if (e[n].style.native)
                    return !1;
            return this.points.length < _5.BATCHABLE_SIZE * 2
        }
        buildDrawCalls() {
            let e = ++st._globalBatch;
            for (let h = 0; h < this.drawCalls.length; h++)
                this.drawCalls[h].texArray.clear(),
                    _p.push(this.drawCalls[h]);
            this.drawCalls.length = 0;
            const n = this.colors
                , s = this.textureIds;
            let r = _p.pop();
            r || (r = new xb,
                r.texArray = new Tb),
                r.texArray.count = 0,
                r.start = 0,
                r.size = 0,
                r.type = ti.TRIANGLES;
            let i = 0
                , o = null
                , l = 0
                , a = !1
                , c = ti.TRIANGLES
                , u = 0;
            this.drawCalls.push(r);
            for (let h = 0; h < this.batches.length; h++) {
                const d = this.batches[h]
                    , f = 8
                    , p = d.style
                    , m = p.texture.baseTexture;
                a !== !!p.native && (a = !!p.native,
                    c = a ? ti.LINES : ti.TRIANGLES,
                    o = null,
                    i = f,
                    e++),
                    o !== m && (o = m,
                        m._batchEnabled !== e && (i === f && (e++,
                            i = 0,
                            r.size > 0 && (r = _p.pop(),
                                r || (r = new xb,
                                    r.texArray = new Tb),
                                this.drawCalls.push(r)),
                            r.start = u,
                            r.size = 0,
                            r.texArray.count = 0,
                            r.type = c),
                            m.touched = 1,
                            m._batchEnabled = e,
                            m._batchLocation = i,
                            m.wrapMode = Ua.REPEAT,
                            r.texArray.elements[r.texArray.count++] = m,
                            i++)),
                    r.size += d.size,
                    u += d.size,
                    l = m._batchLocation,
                    this.addColors(n, p.color, p.alpha, d.attribSize, d.attribStart),
                    this.addTextureIds(s, l, d.attribSize, d.attribStart)
            }
            st._globalBatch = e,
                this.packAttributes()
        }
        packAttributes() {
            const e = this.points
                , n = this.uvs
                , s = this.colors
                , r = this.textureIds
                , i = new ArrayBuffer(e.length * 3 * 4)
                , o = new Float32Array(i)
                , l = new Uint32Array(i);
            let a = 0;
            for (let c = 0; c < e.length / 2; c++)
                o[a++] = e[c * 2],
                    o[a++] = e[c * 2 + 1],
                    o[a++] = n[c * 2],
                    o[a++] = n[c * 2 + 1],
                    l[a++] = s[c],
                    o[a++] = r[c];
            this._buffer.update(i),
                this._indexBuffer.update(this.indicesUint16)
        }
        processFill(e) {
            e.holes.length ? m5.triangulate(e, this) : w1[e.type].triangulate(e, this)
        }
        processLine(e) {
            cA(e, this);
            for (let n = 0; n < e.holes.length; n++)
                cA(e.holes[n], this)
        }
        processHoles(e) {
            for (let n = 0; n < e.length; n++) {
                const s = e[n];
                w1[s.type].build(s),
                    s.matrix && this.transformPoints(s.points, s.matrix)
            }
        }
        calculateBounds() {
            const e = this._bounds;
            e.clear(),
                e.addVertexData(this.points, 0, this.points.length),
                e.pad(this.boundsPadding, this.boundsPadding)
        }
        transformPoints(e, n) {
            for (let s = 0; s < e.length / 2; s++) {
                const r = e[s * 2]
                    , i = e[s * 2 + 1];
                e[s * 2] = n.a * r + n.c * i + n.tx,
                    e[s * 2 + 1] = n.b * r + n.d * i + n.ty
            }
        }
        addColors(e, n, s, r, i = 0) {
            const o = Yt.shared.setValue(n).toLittleEndianNumber()
                , l = Yt.shared.setValue(o).toPremultiplied(s);
            e.length = Math.max(e.length, i + r);
            for (let a = 0; a < r; a++)
                e[i + a] = l
        }
        addTextureIds(e, n, s, r = 0) {
            e.length = Math.max(e.length, r + s);
            for (let i = 0; i < s; i++)
                e[r + i] = n
        }
        addUvs(e, n, s, r, i, o = null) {
            let l = 0;
            const a = n.length
                , c = s.frame;
            for (; l < i;) {
                let h = e[(r + l) * 2]
                    , d = e[(r + l) * 2 + 1];
                if (o) {
                    const f = o.a * h + o.c * d + o.tx;
                    d = o.b * h + o.d * d + o.ty,
                        h = f
                }
                l++,
                    n.push(h / c.width, d / c.height)
            }
            const u = s.baseTexture;
            (c.width < u.width || c.height < u.height) && this.adjustUvs(n, s, a, i)
        }
        adjustUvs(e, n, s, r) {
            const i = n.baseTexture
                , o = 1e-6
                , l = s + r * 2
                , a = n.frame
                , c = a.width / i.width
                , u = a.height / i.height;
            let h = a.x / a.width
                , d = a.y / a.height
                , f = Math.floor(e[s] + o)
                , p = Math.floor(e[s + 1] + o);
            for (let m = s + 2; m < l; m += 2)
                f = Math.min(f, Math.floor(e[m] + o)),
                    p = Math.min(p, Math.floor(e[m + 1] + o));
            h -= f,
                d -= p;
            for (let m = s; m < l; m += 2)
                e[m] = (e[m] + h) * c,
                    e[m + 1] = (e[m + 1] + d) * u
        }
    }
    ;
g5.BATCHABLE_SIZE = 100;
let bue = g5;
class D_ {
    constructor() {
        this.color = 16777215,
            this.alpha = 1,
            this.texture = $e.WHITE,
            this.matrix = null,
            this.visible = !1,
            this.reset()
    }
    clone() {
        const e = new D_;
        return e.color = this.color,
            e.alpha = this.alpha,
            e.texture = this.texture,
            e.matrix = this.matrix,
            e.visible = this.visible,
            e
    }
    reset() {
        this.color = 16777215,
            this.alpha = 1,
            this.texture = $e.WHITE,
            this.matrix = null,
            this.visible = !1
    }
    destroy() {
        this.texture = null,
            this.matrix = null
    }
}
class uw extends D_ {
    constructor() {
        super(...arguments),
            this.width = 0,
            this.alignment = .5,
            this.native = !1,
            this.cap = Ma.BUTT,
            this.join = vr.MITER,
            this.miterLimit = 10
    }
    clone() {
        const e = new uw;
        return e.color = this.color,
            e.alpha = this.alpha,
            e.texture = this.texture,
            e.matrix = this.matrix,
            e.visible = this.visible,
            e.width = this.width,
            e.alignment = this.alignment,
            e.native = this.native,
            e.cap = this.cap,
            e.join = this.join,
            e.miterLimit = this.miterLimit,
            e
    }
    reset() {
        super.reset(),
            this.color = 0,
            this.alignment = .5,
            this.width = 0,
            this.native = !1,
            this.cap = Ma.BUTT,
            this.join = vr.MITER,
            this.miterLimit = 10
    }
}
const S1 = {}
    , $b = class tm extends ks {
        constructor(e = null) {
            super(),
                this.shader = null,
                this.pluginName = "batch",
                this.currentPath = null,
                this.batches = [],
                this.batchTint = -1,
                this.batchDirty = -1,
                this.vertexData = null,
                this._fillStyle = new D_,
                this._lineStyle = new uw,
                this._matrix = null,
                this._holeMode = !1,
                this.state = Ji.for2d(),
                this._geometry = e || new bue,
                this._geometry.refCount++,
                this._transformID = -1,
                this._tintColor = new Yt(16777215),
                this.blendMode = Oe.NORMAL
        }
        get geometry() {
            return this._geometry
        }
        clone() {
            return this.finishPoly(),
                new tm(this._geometry)
        }
        set blendMode(e) {
            this.state.blendMode = e
        }
        get blendMode() {
            return this.state.blendMode
        }
        get tint() {
            return this._tintColor.value
        }
        set tint(e) {
            this._tintColor.setValue(e)
        }
        get fill() {
            return this._fillStyle
        }
        get line() {
            return this._lineStyle
        }
        lineStyle(e = null, n = 0, s, r = .5, i = !1) {
            return typeof e == "number" && (e = {
                width: e,
                color: n,
                alpha: s,
                alignment: r,
                native: i
            }),
                this.lineTextureStyle(e)
        }
        lineTextureStyle(e) {
            const n = {
                width: 0,
                texture: $e.WHITE,
                color: e != null && e.texture ? 16777215 : 0,
                matrix: null,
                alignment: .5,
                native: !1,
                cap: Ma.BUTT,
                join: vr.MITER,
                miterLimit: 10
            };
            e = Object.assign(n, e),
                this.normalizeColor(e),
                this.currentPath && this.startPoly();
            const s = e.width > 0 && e.alpha > 0;
            return s ? (e.matrix && (e.matrix = e.matrix.clone(),
                e.matrix.invert()),
                Object.assign(this._lineStyle, {
                    visible: s
                }, e)) : this._lineStyle.reset(),
                this
        }
        startPoly() {
            if (this.currentPath) {
                const e = this.currentPath.points
                    , n = this.currentPath.points.length;
                n > 2 && (this.drawShape(this.currentPath),
                    this.currentPath = new Va,
                    this.currentPath.closeStroke = !1,
                    this.currentPath.points.push(e[n - 2], e[n - 1]))
            } else
                this.currentPath = new Va,
                    this.currentPath.closeStroke = !1
        }
        finishPoly() {
            this.currentPath && (this.currentPath.points.length > 2 ? (this.drawShape(this.currentPath),
                this.currentPath = null) : this.currentPath.points.length = 0)
        }
        moveTo(e, n) {
            return this.startPoly(),
                this.currentPath.points[0] = e,
                this.currentPath.points[1] = n,
                this
        }
        lineTo(e, n) {
            this.currentPath || this.moveTo(0, 0);
            const s = this.currentPath.points
                , r = s[s.length - 2]
                , i = s[s.length - 1];
            return (r !== e || i !== n) && s.push(e, n),
                this
        }
        _initCurve(e = 0, n = 0) {
            this.currentPath ? this.currentPath.points.length === 0 && (this.currentPath.points = [e, n]) : this.moveTo(e, n)
        }
        quadraticCurveTo(e, n, s, r) {
            this._initCurve();
            const i = this.currentPath.points;
            return i.length === 0 && this.moveTo(0, 0),
                cw.curveTo(e, n, s, r, i),
                this
        }
        bezierCurveTo(e, n, s, r, i, o) {
            return this._initCurve(),
                lw.curveTo(e, n, s, r, i, o, this.currentPath.points),
                this
        }
        arcTo(e, n, s, r, i) {
            this._initCurve(e, n);
            const o = this.currentPath.points
                , l = aA.curveTo(e, n, s, r, i, o);
            if (l) {
                const { cx: a, cy: c, radius: u, startAngle: h, endAngle: d, anticlockwise: f } = l;
                this.arc(a, c, u, h, d, f)
            }
            return this
        }
        arc(e, n, s, r, i, o = !1) {
            if (r === i)
                return this;
            if (!o && i <= r ? i += Km : o && r <= i && (r += Km),
                i - r === 0)
                return this;
            const l = e + Math.cos(r) * s
                , a = n + Math.sin(r) * s
                , c = this._geometry.closePointEps;
            let u = this.currentPath ? this.currentPath.points : null;
            if (u) {
                const h = Math.abs(u[u.length - 2] - l)
                    , d = Math.abs(u[u.length - 1] - a);
                h < c && d < c || u.push(l, a)
            } else
                this.moveTo(l, a),
                    u = this.currentPath.points;
            return aA.arc(l, a, e, n, s, r, i, o, u),
                this
        }
        beginFill(e = 0, n) {
            return this.beginTextureFill({
                texture: $e.WHITE,
                color: e,
                alpha: n
            })
        }
        normalizeColor(e) {
            const n = Yt.shared.setValue(e.color ?? 0);
            e.color = n.toNumber(),
                e.alpha ?? (e.alpha = n.alpha)
        }
        beginTextureFill(e) {
            const n = {
                texture: $e.WHITE,
                color: 16777215,
                matrix: null
            };
            e = Object.assign(n, e),
                this.normalizeColor(e),
                this.currentPath && this.startPoly();
            const s = e.alpha > 0;
            return s ? (e.matrix && (e.matrix = e.matrix.clone(),
                e.matrix.invert()),
                Object.assign(this._fillStyle, {
                    visible: s
                }, e)) : this._fillStyle.reset(),
                this
        }
        endFill() {
            return this.finishPoly(),
                this._fillStyle.reset(),
                this
        }
        drawRect(e, n, s, r) {
            return this.drawShape(new nt(e, n, s, r))
        }
        drawRoundedRect(e, n, s, r, i) {
            return this.drawShape(new P_(e, n, s, r, i))
        }
        drawCircle(e, n, s) {
            return this.drawShape(new R_(e, n, s))
        }
        drawEllipse(e, n, s, r) {
            return this.drawShape(new M_(e, n, s, r))
        }
        drawPolygon(...e) {
            let n, s = !0;
            const r = e[0];
            r.points ? (s = r.closeStroke,
                n = r.points) : Array.isArray(e[0]) ? n = e[0] : n = e;
            const i = new Va(n);
            return i.closeStroke = s,
                this.drawShape(i),
                this
        }
        drawShape(e) {
            return this._holeMode ? this._geometry.drawHole(e, this._matrix) : this._geometry.drawShape(e, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix),
                this
        }
        clear() {
            return this._geometry.clear(),
                this._lineStyle.reset(),
                this._fillStyle.reset(),
                this._boundsID++,
                this._matrix = null,
                this._holeMode = !1,
                this.currentPath = null,
                this
        }
        isFastRect() {
            const e = this._geometry.graphicsData;
            return e.length === 1 && e[0].shape.type === ss.RECT && !e[0].matrix && !e[0].holes.length && !(e[0].lineStyle.visible && e[0].lineStyle.width)
        }
        _render(e) {
            this.finishPoly();
            const n = this._geometry;
            n.updateBatches(),
                n.batchable ? (this.batchDirty !== n.batchDirty && this._populateBatches(),
                    this._renderBatched(e)) : (e.batch.flush(),
                        this._renderDirect(e))
        }
        _populateBatches() {
            const e = this._geometry
                , n = this.blendMode
                , s = e.batches.length;
            this.batchTint = -1,
                this._transformID = -1,
                this.batchDirty = e.batchDirty,
                this.batches.length = s,
                this.vertexData = new Float32Array(e.points);
            for (let r = 0; r < s; r++) {
                const i = e.batches[r]
                    , o = i.style.color
                    , l = new Float32Array(this.vertexData.buffer, i.attribStart * 4 * 2, i.attribSize * 2)
                    , a = new Float32Array(e.uvsFloat32.buffer, i.attribStart * 4 * 2, i.attribSize * 2)
                    , c = new Uint16Array(e.indicesUint16.buffer, i.start * 2, i.size)
                    , u = {
                        vertexData: l,
                        blendMode: n,
                        indices: c,
                        uvs: a,
                        _batchRGB: Yt.shared.setValue(o).toRgbArray(),
                        _tintRGB: o,
                        _texture: i.style.texture,
                        alpha: i.style.alpha,
                        worldAlpha: 1
                    };
                this.batches[r] = u
            }
        }
        _renderBatched(e) {
            if (this.batches.length) {
                e.batch.setObjectRenderer(e.plugins[this.pluginName]),
                    this.calculateVertices(),
                    this.calculateTints();
                for (let n = 0, s = this.batches.length; n < s; n++) {
                    const r = this.batches[n];
                    r.worldAlpha = this.worldAlpha * r.alpha,
                        e.plugins[this.pluginName].render(r)
                }
            }
        }
        _renderDirect(e) {
            const n = this._resolveDirectShader(e)
                , s = this._geometry
                , r = this.worldAlpha
                , i = n.uniforms
                , o = s.drawCalls;
            i.translationMatrix = this.transform.worldTransform,
                Yt.shared.setValue(this._tintColor).premultiply(r).toArray(i.tint),
                e.shader.bind(n),
                e.geometry.bind(s, n),
                e.state.set(this.state);
            for (let l = 0, a = o.length; l < a; l++)
                this._renderDrawCallDirect(e, s.drawCalls[l])
        }
        _renderDrawCallDirect(e, n) {
            const { texArray: s, type: r, size: i, start: o } = n
                , l = s.count;
            for (let a = 0; a < l; a++)
                e.texture.bind(s.elements[a], a);
            e.geometry.draw(r, i, o)
        }
        _resolveDirectShader(e) {
            let n = this.shader;
            const s = this.pluginName;
            if (!n) {
                if (!S1[s]) {
                    const { maxTextures: r } = e.plugins[s]
                        , i = new Int32Array(r);
                    for (let a = 0; a < r; a++)
                        i[a] = a;
                    const o = {
                        tint: new Float32Array([1, 1, 1, 1]),
                        translationMatrix: new Bt,
                        default: ii.from({
                            uSamplers: i
                        }, !0)
                    }
                        , l = e.plugins[s]._shader.program;
                    S1[s] = new Hi(l, o)
                }
                n = S1[s]
            }
            return n
        }
        _calculateBounds() {
            this.finishPoly();
            const e = this._geometry;
            if (!e.graphicsData.length)
                return;
            const { minX: n, minY: s, maxX: r, maxY: i } = e.bounds;
            this._bounds.addFrame(this.transform, n, s, r, i)
        }
        containsPoint(e) {
            return this.worldTransform.applyInverse(e, tm._TEMP_POINT),
                this._geometry.containsPoint(tm._TEMP_POINT)
        }
        calculateTints() {
            if (this.batchTint !== this.tint) {
                this.batchTint = this._tintColor.toNumber();
                for (let e = 0; e < this.batches.length; e++) {
                    const n = this.batches[e];
                    n._tintRGB = Yt.shared.setValue(this._tintColor).multiply(n._batchRGB).toLittleEndianNumber()
                }
            }
        }
        calculateVertices() {
            const e = this.transform._worldID;
            if (this._transformID === e)
                return;
            this._transformID = e;
            const n = this.transform.worldTransform
                , s = n.a
                , r = n.b
                , i = n.c
                , o = n.d
                , l = n.tx
                , a = n.ty
                , c = this._geometry.points
                , u = this.vertexData;
            let h = 0;
            for (let d = 0; d < c.length; d += 2) {
                const f = c[d]
                    , p = c[d + 1];
                u[h++] = s * f + i * p + l,
                    u[h++] = o * p + r * f + a
            }
        }
        closePath() {
            const e = this.currentPath;
            return e && (e.closeStroke = !0,
                this.finishPoly()),
                this
        }
        setMatrix(e) {
            return this._matrix = e,
                this
        }
        beginHole() {
            return this.finishPoly(),
                this._holeMode = !0,
                this
        }
        endHole() {
            return this.finishPoly(),
                this._holeMode = !1,
                this
        }
        destroy(e) {
            this._geometry.refCount--,
                this._geometry.refCount === 0 && this._geometry.dispose(),
                this._matrix = null,
                this.currentPath = null,
                this._lineStyle.destroy(),
                this._lineStyle = null,
                this._fillStyle.destroy(),
                this._fillStyle = null,
                this._geometry = null,
                this.shader = null,
                this.vertexData = null,
                this.batches.length = 0,
                this.batches = null,
                super.destroy(e)
        }
    }
    ;
$b.curves = Ku,
    $b._TEMP_POINT = new At;
let hw = $b;
const na = [0, 0, 0];
class vue extends Tc {
    constructor() {
        super(...arguments),
            this.region = null,
            this.attachment = null
    }
}
class xue extends fue {
    constructor(e, n, s, r, i) {
        super(e, n, s, r, i),
            this.region = null,
            this.attachment = null
    }
}
const y5 = class extends ks {
    constructor(t) {
        if (super(),
            !t)
            throw new Error("The spineData param is required.");
        if (typeof t == "string")
            throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas("YOUR_RESOURCE_NAME") from now on.');
        this.spineData = t,
            this.createSkeleton(t),
            this.slotContainers = [],
            this.tempClipContainers = [];
        for (let e = 0, n = this.skeleton.slots.length; e < n; e++) {
            const s = this.skeleton.slots[e]
                , r = s.getAttachment()
                , i = this.newContainer();
            if (this.slotContainers.push(i),
                this.addChild(i),
                this.tempClipContainers.push(null),
                !!r)
                if (r.type === ut.Region) {
                    const o = r.name
                        , l = this.createSprite(s, r, o);
                    s.currentSprite = l,
                        s.currentSpriteName = o,
                        i.addChild(l)
                } else if (r.type === ut.Mesh) {
                    const o = this.createMesh(s, r);
                    s.currentMesh = o,
                        s.currentMeshId = r.id,
                        s.currentMeshName = r.name,
                        i.addChild(o)
                } else
                    r.type === ut.Clipping && (this.createGraphics(s, r),
                        i.addChild(s.clippingContainer),
                        i.addChild(s.currentGraphics))
        }
        this.tintRgb = new Float32Array([1, 1, 1]),
            this.autoUpdate = !0,
            this.visible = !0
    }
    get debug() {
        return this._debug
    }
    set debug(t) {
        var e;
        t != this._debug && ((e = this._debug) == null || e.unregisterSpine(this),
            t == null || t.registerSpine(this),
            this._debug = t)
    }
    get autoUpdate() {
        return this._autoUpdate
    }
    set autoUpdate(t) {
        t !== this._autoUpdate && (this._autoUpdate = t,
            this.updateTransform = t ? y5.prototype.autoUpdateTransform : ks.prototype.updateTransform)
    }
    get tint() {
        return Kp(this.tintRgb)
    }
    set tint(t) {
        this.tintRgb = kle(t, this.tintRgb)
    }
    get delayLimit() {
        return (typeof this.localDelayLimit < "u" ? this.localDelayLimit : iue.GLOBAL_DELAY_LIMIT) || Number.MAX_VALUE
    }
    update(t) {
        var c;
        const e = this.delayLimit;
        if (t > e && (t = e),
            this.state.update(t),
            this.state.apply(this.skeleton),
            !this.skeleton)
            return;
        this.skeleton.updateWorldTransform();
        const n = this.skeleton.slots
            , s = this.color;
        let r = null
            , i = null;
        s ? (r = s.light,
            i = s.dark) : r = this.tintRgb;
        for (let u = 0, h = n.length; u < h; u++) {
            const d = n[u]
                , f = d.getAttachment()
                , p = this.slotContainers[u];
            if (!f) {
                p.visible = !1;
                continue
            }
            let m = null;
            f.sequence && f.sequence.apply(d, f);
            let g = f.region;
            const b = f.color;
            switch (f != null && f.type) {
                case ut.Region:
                    if (p.transform.setFromMatrix(d.bone.matrix),
                        g = f.region,
                        d.currentMesh && (d.currentMesh.visible = !1,
                            d.currentMesh = null,
                            d.currentMeshId = void 0,
                            d.currentMeshName = void 0),
                        !g) {
                        d.currentSprite && (d.currentSprite.renderable = !1);
                        break
                    }
                    if (!d.currentSpriteName || d.currentSpriteName !== f.name) {
                        const y = f.name;
                        if (d.currentSprite && (d.currentSprite.visible = !1),
                            d.sprites = d.sprites || {},
                            d.sprites[y] !== void 0)
                            d.sprites[y].visible = !0;
                        else {
                            const x = this.createSprite(d, f, y);
                            p.addChild(x)
                        }
                        d.currentSprite = d.sprites[y],
                            d.currentSpriteName = y
                    }
                    d.currentSprite.renderable = !0,
                        d.hackRegion || this.setSpriteRegion(f, d.currentSprite, g),
                        d.currentSprite.color ? m = d.currentSprite.color : (na[0] = r[0] * d.color.r * b.r,
                            na[1] = r[1] * d.color.g * b.g,
                            na[2] = r[2] * d.color.b * b.b,
                            d.currentSprite.tint = Kp(na)),
                        d.currentSprite.blendMode = d.blendMode;
                    break;
                case ut.Mesh:
                    if (d.currentSprite) {
                        d.currentSprite.visible = !1,
                            d.currentSprite = null,
                            d.currentSpriteName = void 0;
                        const y = new L_;
                        y._parentID = -1,
                            y._worldID = p.transform._worldID,
                            p.transform = y
                    }
                    if (!g) {
                        d.currentMesh && (d.currentMesh.renderable = !1);
                        break
                    }
                    const _ = f.id;
                    if (d.currentMeshId === void 0 || d.currentMeshId !== _) {
                        const y = _;
                        if (d.currentMesh && (d.currentMesh.visible = !1),
                            d.meshes = d.meshes || {},
                            d.meshes[y] !== void 0)
                            d.meshes[y].visible = !0;
                        else {
                            const x = this.createMesh(d, f);
                            p.addChild(x)
                        }
                        d.currentMesh = d.meshes[y],
                            d.currentMeshName = f.name,
                            d.currentMeshId = y
                    }
                    d.currentMesh.renderable = !0,
                        f.computeWorldVerticesOld(d, d.currentMesh.vertices),
                        d.currentMesh.color ? m = d.currentMesh.color : (na[0] = r[0] * d.color.r * b.r,
                            na[1] = r[1] * d.color.g * b.g,
                            na[2] = r[2] * d.color.b * b.b,
                            d.currentMesh.tint = Kp(na)),
                        d.currentMesh.blendMode = d.blendMode,
                        d.hackRegion || this.setMeshRegion(f, d.currentMesh, g);
                    break;
                case ut.Clipping:
                    d.currentGraphics || (this.createGraphics(d, f),
                        p.addChild(d.clippingContainer),
                        p.addChild(d.currentGraphics)),
                        this.updateGraphics(d, f),
                        p.alpha = 1,
                        p.visible = !0;
                    continue;
                default:
                    p.visible = !1;
                    continue
            }
            if (p.visible = !0,
                m) {
                let v = d.color.r * b.r
                    , _ = d.color.g * b.g
                    , y = d.color.b * b.b;
                m.setLight(r[0] * v + i[0] * (1 - v), r[1] * _ + i[1] * (1 - _), r[2] * y + i[2] * (1 - y)),
                    d.darkColor ? (v = d.darkColor.r,
                        _ = d.darkColor.g,
                        y = d.darkColor.b) : (v = 0,
                            _ = 0,
                            y = 0),
                    m.setDark(r[0] * v + i[0] * (1 - v), r[1] * _ + i[1] * (1 - _), r[2] * y + i[2] * (1 - y))
            }
            p.alpha = d.color.a
        }
        const o = this.skeleton.drawOrder;
        let l = null
            , a = null;
        for (let u = 0, h = o.length; u < h; u++) {
            const d = n[o[u].data.index]
                , f = this.slotContainers[o[u].data.index];
            if (a || f.parent !== null && f.parent !== this && (f.parent.removeChild(f),
                f.parent = this),
                d.currentGraphics && d.getAttachment())
                a = d.clippingContainer,
                    l = d.getAttachment(),
                    a.children.length = 0,
                    this.children[u] = f,
                    l.endSlot === d.data && (l.endSlot = null);
            else if (a) {
                let p = this.tempClipContainers[u];
                p || (p = this.tempClipContainers[u] = this.newContainer(),
                    p.visible = !1),
                    this.children[u] = p,
                    f.parent = null,
                    a.addChild(f),
                    l.endSlot == d.data && (a.renderable = !0,
                        a = null,
                        l = null)
            } else
                this.children[u] = f
        }
        (c = this._debug) == null || c.renderDebug(this)
    }
    setSpriteRegion(t, e, n) {
        e.attachment === t && e.region === n || (e.region = n,
            e.attachment = t,
            e.texture = n.texture,
            e.rotation = t.rotation * F.degRad,
            e.position.x = t.x,
            e.position.y = t.y,
            e.alpha = t.color.a,
            n.size ? (e.scale.x = n.size.width / n.originalWidth,
                e.scale.y = -n.size.height / n.originalHeight) : (e.scale.x = t.scaleX * t.width / n.originalWidth,
                    e.scale.y = -t.scaleY * t.height / n.originalHeight))
    }
    setMeshRegion(t, e, n) {
        e.attachment === t && e.region === n || (e.region = n,
            e.attachment = t,
            e.texture = n.texture,
            n.texture.updateUvs(),
            e.uvBuffer.update(t.regionUVs))
    }
    autoUpdateTransform() {
        {
            this.lastTime = this.lastTime || Date.now();
            const t = (Date.now() - this.lastTime) * .001;
            this.lastTime = Date.now(),
                this.update(t)
        }
        ks.prototype.updateTransform.call(this)
    }
    createSprite(t, e, n) {
        let s = e.region;
        t.hackAttachment === e && (s = t.hackRegion);
        const r = s ? s.texture : null
            , i = this.newSprite(r);
        return i.anchor.set(.5),
            s && this.setSpriteRegion(e, i, e.region),
            t.sprites = t.sprites || {},
            t.sprites[n] = i,
            i
    }
    createMesh(t, e) {
        let n = e.region;
        t.hackAttachment === e && (n = t.hackRegion,
            t.hackAttachment = null,
            t.hackRegion = null);
        const s = this.newMesh(n ? n.texture : null, new Float32Array(e.regionUVs.length), e.regionUVs, new Uint16Array(e.triangles), ti.TRIANGLES);
        return typeof s._canvasPadding < "u" && (s._canvasPadding = 1.5),
            s.alpha = e.color.a,
            s.region = e.region,
            n && this.setMeshRegion(e, s, n),
            t.meshes = t.meshes || {},
            t.meshes[e.id] = s,
            s
    }
    createGraphics(t, e) {
        const n = this.newGraphics()
            , s = new Va([]);
        return n.clear(),
            n.beginFill(16777215, 1),
            n.drawPolygon(s),
            n.renderable = !1,
            t.currentGraphics = n,
            t.clippingContainer = this.newContainer(),
            t.clippingContainer.mask = t.currentGraphics,
            n
    }
    updateGraphics(t, e) {
        const n = t.currentGraphics.geometry
            , s = n.graphicsData[0].shape.points
            , r = e.worldVerticesLength;
        s.length = r,
            e.computeWorldVertices(t, 0, r, s, 0, 2),
            n.invalidate()
    }
    hackTextureBySlotIndex(t, e = null, n = null) {
        const s = this.skeleton.slots[t];
        if (!s)
            return !1;
        const r = s.getAttachment();
        let i = r.region;
        return e ? (i = new Ob,
            i.texture = e,
            i.size = n,
            s.hackRegion = i,
            s.hackAttachment = r) : (s.hackRegion = null,
                s.hackAttachment = null),
            s.currentSprite ? this.setSpriteRegion(r, s.currentSprite, i) : s.currentMesh && this.setMeshRegion(r, s.currentMesh, i),
            !0
    }
    hackTextureBySlotName(t, e = null, n = null) {
        const s = this.skeleton.findSlotIndex(t);
        return s == -1 ? !1 : this.hackTextureBySlotIndex(s, e, n)
    }
    hackTextureAttachment(t, e, n, s = null) {
        const r = this.skeleton.findSlotIndex(t)
            , i = this.skeleton.getAttachmentByName(t, e);
        i.region.texture = n;
        const o = this.skeleton.slots[r];
        if (!o)
            return !1;
        const l = o.getAttachment();
        if (e === l.name) {
            let a = i.region;
            return n ? (a = new Ob,
                a.texture = n,
                a.size = s,
                o.hackRegion = a,
                o.hackAttachment = l) : (o.hackRegion = null,
                    o.hackAttachment = null),
                o.currentSprite && o.currentSprite.region != a ? (this.setSpriteRegion(l, o.currentSprite, a),
                    o.currentSprite.region = a) : o.currentMesh && o.currentMesh.region != a && this.setMeshRegion(l, o.currentMesh, a),
                !0
        }
        return !1
    }
    newContainer() {
        return new ks
    }
    newSprite(t) {
        return new vue(t)
    }
    newGraphics() {
        return new hw
    }
    newMesh(t, e, n, s, r) {
        return new xue(t, e, n, s, r)
    }
    transformHack() {
        return 1
    }
    hackAttachmentGroups(t, e, n) {
        if (!t)
            return;
        const s = []
            , r = [];
        for (let i = 0, o = this.skeleton.slots.length; i < o; i++) {
            const l = this.skeleton.slots[i]
                , a = l.currentSpriteName || l.currentMeshName || ""
                , c = l.currentSprite || l.currentMesh;
            a.endsWith(t) ? (c.parentGroup = e,
                r.push(c)) : n && c && (c.parentGroup = n,
                    s.push(c))
        }
        return [s, r]
    }
    destroy(t) {
        this.debug = null;
        for (let e = 0, n = this.skeleton.slots.length; e < n; e++) {
            const s = this.skeleton.slots[e];
            for (const r in s.meshes)
                s.meshes[r].destroy(t);
            s.meshes = null;
            for (const r in s.sprites)
                s.sprites[r].destroy(t);
            s.sprites = null
        }
        for (let e = 0, n = this.slotContainers.length; e < n; e++)
            this.slotContainers[e].destroy(t);
        this.spineData = null,
            this.skeleton = null,
            this.slotContainers = null,
            this.stateData = null,
            this.state = null,
            this.tempClipContainers = null,
            super.destroy(t)
    }
}
    ;
let ph = y5;
ph.clippingPolygon = [];
Object.defineProperty(ph.prototype, "visible", {
    get() {
        return this._visible
    },
    set(t) {
        t !== this._visible && (this._visible = t,
            t && (this.lastTime = 0))
    }
});
const hA = {
    loader: Ae.LoadParser,
    resolver: Ae.ResolveParser,
    cache: Ae.CacheParser,
    detection: Ae.DetectionParser
};
Ue.handle(Ae.Asset, t => {
    const e = t.ref;
    Object.entries(hA).filter(([n]) => !!e[n]).forEach(([n, s]) => Ue.add(Object.assign(e[n], {
        extension: e[n].extension ?? s
    })))
}
    , t => {
        const e = t.ref;
        Object.keys(hA).filter(n => !!e[n]).forEach(n => Ue.remove(e[n]))
    }
);
class wue {
    constructor(e, n = !1) {
        this._loader = e,
            this._assetList = [],
            this._isLoading = !1,
            this._maxConcurrent = 1,
            this.verbose = n
    }
    add(e) {
        e.forEach(n => {
            this._assetList.push(n)
        }
        ),
            this.verbose && console.log("[BackgroundLoader] assets: ", this._assetList),
            this._isActive && !this._isLoading && this._next()
    }
    async _next() {
        if (this._assetList.length && this._isActive) {
            this._isLoading = !0;
            const e = []
                , n = Math.min(this._assetList.length, this._maxConcurrent);
            for (let s = 0; s < n; s++)
                e.push(this._assetList.pop());
            await this._loader.load(e),
                this._isLoading = !1,
                this._next()
        }
    }
    get active() {
        return this._isActive
    }
    set active(e) {
        this._isActive !== e && (this._isActive = e,
            e && !this._isLoading && this._next())
    }
}
function mh(t, e) {
    if (Array.isArray(e)) {
        for (const n of e)
            if (t.startsWith(`data:${n}`))
                return !0;
        return !1
    }
    return t.startsWith(`data:${e}`)
}
function zs(t, e) {
    const n = t.split("?")[0]
        , s = zt.extname(n).toLowerCase();
    return Array.isArray(e) ? e.includes(s) : s === e
}
const Qr = (t, e, n = !1) => (Array.isArray(t) || (t = [t]),
    e ? t.map(s => typeof s == "string" || n ? e(s) : s) : t)
    , Ub = (t, e) => {
        const n = e.split("?")[1];
        return n && (t += `?${n}`),
            t
    }
    ;
function b5(t, e, n, s, r) {
    const i = e[n];
    for (let o = 0; o < i.length; o++) {
        const l = i[o];
        n < e.length - 1 ? b5(t.replace(s[n], l), e, n + 1, s, r) : r.push(t.replace(s[n], l))
    }
}
function Sue(t) {
    const e = /\{(.*?)\}/g
        , n = t.match(e)
        , s = [];
    if (n) {
        const r = [];
        n.forEach(i => {
            const o = i.substring(1, i.length - 1).split(",");
            r.push(o)
        }
        ),
            b5(t, r, 0, n, s)
    } else
        s.push(t);
    return s
}
const rg = t => !Array.isArray(t);
class Eue {
    constructor() {
        this._parsers = [],
            this._cache = new Map,
            this._cacheMap = new Map
    }
    reset() {
        this._cacheMap.clear(),
            this._cache.clear()
    }
    has(e) {
        return this._cache.has(e)
    }
    get(e) {
        const n = this._cache.get(e);
        return n || console.warn(`[Assets] Asset id ${e} was not found in the Cache`),
            n
    }
    set(e, n) {
        const s = Qr(e);
        let r;
        for (let l = 0; l < this.parsers.length; l++) {
            const a = this.parsers[l];
            if (a.test(n)) {
                r = a.getCacheableAssets(s, n);
                break
            }
        }
        r || (r = {},
            s.forEach(l => {
                r[l] = n
            }
            ));
        const i = Object.keys(r)
            , o = {
                cacheKeys: i,
                keys: s
            };
        if (s.forEach(l => {
            this._cacheMap.set(l, o)
        }
        ),
            i.forEach(l => {
                this._cache.has(l) && this._cache.get(l) !== n && console.warn("[Cache] already has key:", l),
                    this._cache.set(l, r[l])
            }
            ),
            n instanceof $e) {
            const l = n;
            s.forEach(a => {
                l.baseTexture !== $e.EMPTY.baseTexture && st.addToCache(l.baseTexture, a),
                    $e.addToCache(l, a)
            }
            )
        }
    }
    remove(e) {
        if (!this._cacheMap.has(e)) {
            console.warn(`[Assets] Asset id ${e} was not found in the Cache`);
            return
        }
        const n = this._cacheMap.get(e);
        n.cacheKeys.forEach(s => {
            this._cache.delete(s)
        }
        ),
            n.keys.forEach(s => {
                this._cacheMap.delete(s)
            }
            )
    }
    get parsers() {
        return this._parsers
    }
}
const Ml = new Eue;
class Tue {
    constructor() {
        this._parsers = [],
            this._parsersValidated = !1,
            this.parsers = new Proxy(this._parsers, {
                set: (e, n, s) => (this._parsersValidated = !1,
                    e[n] = s,
                    !0)
            }),
            this.promiseCache = {}
    }
    reset() {
        this._parsersValidated = !1,
            this.promiseCache = {}
    }
    _getLoadPromiseAndParser(e, n) {
        const s = {
            promise: null,
            parser: null
        };
        return s.promise = (async () => {
            var o, l;
            let r = null
                , i = null;
            if (n.loadParser && (i = this._parserHash[n.loadParser],
                i || console.warn(`[Assets] specified load parser "${n.loadParser}" not found while loading ${e}`)),
                !i) {
                for (let a = 0; a < this.parsers.length; a++) {
                    const c = this.parsers[a];
                    if (c.load && ((o = c.test) != null && o.call(c, e, n, this))) {
                        i = c;
                        break
                    }
                }
                if (!i)
                    return console.warn(`[Assets] ${e} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`),
                        null
            }
            r = await i.load(e, n, this),
                s.parser = i;
            for (let a = 0; a < this.parsers.length; a++) {
                const c = this.parsers[a];
                c.parse && c.parse && await ((l = c.testParse) == null ? void 0 : l.call(c, r, n, this)) && (r = await c.parse(r, n, this) || r,
                    s.parser = c)
            }
            return r
        }
        )(),
            s
    }
    async load(e, n) {
        this._parsersValidated || this._validateParsers();
        let s = 0;
        const r = {}
            , i = rg(e)
            , o = Qr(e, c => ({
                alias: [c],
                src: c
            }))
            , l = o.length
            , a = o.map(async c => {
                const u = zt.toAbsolute(c.src);
                if (!r[c.src])
                    try {
                        this.promiseCache[u] || (this.promiseCache[u] = this._getLoadPromiseAndParser(u, c)),
                            r[c.src] = await this.promiseCache[u].promise,
                            n && n(++s / l)
                    } catch (h) {
                        throw delete this.promiseCache[u],
                        delete r[c.src],
                        new Error(`[Loader.load] Failed to load ${u}.
${h}`)
                    }
            }
            );
        return await Promise.all(a),
            i ? r[o[0].src] : r
    }
    async unload(e) {
        const n = Qr(e, s => ({
            alias: [s],
            src: s
        })).map(async s => {
            var o, l;
            const r = zt.toAbsolute(s.src)
                , i = this.promiseCache[r];
            if (i) {
                const a = await i.promise;
                delete this.promiseCache[r],
                    (l = (o = i.parser) == null ? void 0 : o.unload) == null || l.call(o, a, s, this)
            }
        }
        );
        await Promise.all(n)
    }
    _validateParsers() {
        this._parsersValidated = !0,
            this._parserHash = this._parsers.filter(e => e.name).reduce((e, n) => (e[n.name] && console.warn(`[Assets] loadParser name conflict "${n.name}"`),
            {
                ...e,
                [n.name]: n
            }), {})
    }
}
var _r = (t => (t[t.Low = 0] = "Low",
    t[t.Normal = 1] = "Normal",
    t[t.High = 2] = "High",
    t))(_r || {});
const Cue = ".json"
    , Iue = "application/json"
    , Aue = {
        extension: {
            type: Ae.LoadParser,
            priority: _r.Low
        },
        name: "loadJson",
        test(t) {
            return mh(t, Iue) || zs(t, Cue)
        },
        async load(t) {
            return await (await Le.ADAPTER.fetch(t)).json()
        }
    };
Ue.add(Aue);
const kue = ".txt"
    , Rue = "text/plain"
    , Mue = {
        name: "loadTxt",
        extension: {
            type: Ae.LoadParser,
            priority: _r.Low
        },
        test(t) {
            return mh(t, Rue) || zs(t, kue)
        },
        async load(t) {
            return await (await Le.ADAPTER.fetch(t)).text()
        }
    };
Ue.add(Mue);
const Pue = ["normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900"]
    , Lue = [".ttf", ".otf", ".woff", ".woff2"]
    , Oue = ["font/ttf", "font/otf", "font/woff", "font/woff2"]
    , Nue = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;
function Due(t) {
    const e = zt.extname(t)
        , n = zt.basename(t, e).replace(/(-|_)/g, " ").toLowerCase().split(" ").map(i => i.charAt(0).toUpperCase() + i.slice(1));
    let s = n.length > 0;
    for (const i of n)
        if (!i.match(Nue)) {
            s = !1;
            break
        }
    let r = n.join(" ");
    return s || (r = `"${r.replace(/[\\"]/g, "\\$&")}"`),
        r
}
const Bue = /^[0-9A-Za-z%:/?#\[\]@!\$&'()\*\+,;=\-._~]*$/;
function Fue(t) {
    return Bue.test(t) ? t : encodeURI(t)
}
const $ue = {
    extension: {
        type: Ae.LoadParser,
        priority: _r.Low
    },
    name: "loadWebFont",
    test(t) {
        return mh(t, Oue) || zs(t, Lue)
    },
    async load(t, e) {
        var s, r, i;
        const n = Le.ADAPTER.getFontFaceSet();
        if (n) {
            const o = []
                , l = ((s = e.data) == null ? void 0 : s.family) ?? Due(t)
                , a = ((i = (r = e.data) == null ? void 0 : r.weights) == null ? void 0 : i.filter(u => Pue.includes(u))) ?? ["normal"]
                , c = e.data ?? {};
            for (let u = 0; u < a.length; u++) {
                const h = a[u]
                    , d = new FontFace(l, `url(${Fue(t)})`, {
                        ...c,
                        weight: h
                    });
                await d.load(),
                    n.add(d),
                    o.push(d)
            }
            return o.length === 1 ? o[0] : o
        }
        return console.warn("[loadWebFont] FontFace API is not supported. Skipping loading font"),
            null
    },
    unload(t) {
        (Array.isArray(t) ? t : [t]).forEach(e => Le.ADAPTER.getFontFaceSet().delete(e))
    }
};
Ue.add($ue);
const Uue = `(function() {
  "use strict";
  const WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";
  async function checkImageBitmap() {
    try {
      if (typeof createImageBitmap != "function")
        return !1;
      const imageBlob = await (await fetch(WHITE_PNG)).blob(), imageBitmap = await createImageBitmap(imageBlob);
      return imageBitmap.width === 1 && imageBitmap.height === 1;
    } catch {
      return !1;
    }
  }
  checkImageBitmap().then((result) => {
    self.postMessage(result);
  });
})();
`;
let Eu = null
    , Vb = class {
        constructor() {
            Eu || (Eu = URL.createObjectURL(new Blob([Uue], {
                type: "application/javascript"
            }))),
                this.worker = new Worker(Eu)
        }
    }
    ;
Vb.revokeObjectURL = function () {
    Eu && (URL.revokeObjectURL(Eu),
        Eu = null)
}
    ;
const Vue = `(function() {
  "use strict";
  async function loadImageBitmap(url) {
    const response = await fetch(url);
    if (!response.ok)
      throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \${response.status} \${response.statusText}\`);
    const imageBlob = await response.blob();
    return await createImageBitmap(imageBlob);
  }
  self.onmessage = async (event) => {
    try {
      const imageBitmap = await loadImageBitmap(event.data.data[0]);
      self.postMessage({
        data: imageBitmap,
        uuid: event.data.uuid,
        id: event.data.id
      }, [imageBitmap]);
    } catch (e) {
      self.postMessage({
        error: e,
        uuid: event.data.uuid,
        id: event.data.id
      });
    }
  };
})();
`;
let Tu = null;
class v5 {
    constructor() {
        Tu || (Tu = URL.createObjectURL(new Blob([Vue], {
            type: "application/javascript"
        }))),
            this.worker = new Worker(Tu)
    }
}
v5.revokeObjectURL = function () {
    Tu && (URL.revokeObjectURL(Tu),
        Tu = null)
}
    ;
let dA = 0, E1;
class Gue {
    constructor() {
        this._initialized = !1,
            this._createdWorkers = 0,
            this.workerPool = [],
            this.queue = [],
            this.resolveHash = {}
    }
    isImageBitmapSupported() {
        return this._isImageBitmapSupported !== void 0 ? this._isImageBitmapSupported : (this._isImageBitmapSupported = new Promise(e => {
            const { worker: n } = new Vb;
            n.addEventListener("message", s => {
                n.terminate(),
                    Vb.revokeObjectURL(),
                    e(s.data)
            }
            )
        }
        ),
            this._isImageBitmapSupported)
    }
    loadImageBitmap(e) {
        return this._run("loadImageBitmap", [e])
    }
    async _initWorkers() {
        this._initialized || (this._initialized = !0)
    }
    getWorker() {
        E1 === void 0 && (E1 = navigator.hardwareConcurrency || 4);
        let e = this.workerPool.pop();
        return !e && this._createdWorkers < E1 && (this._createdWorkers++,
            e = new v5().worker,
            e.addEventListener("message", n => {
                this.complete(n.data),
                    this.returnWorker(n.target),
                    this.next()
            }
            )),
            e
    }
    returnWorker(e) {
        this.workerPool.push(e)
    }
    complete(e) {
        e.error !== void 0 ? this.resolveHash[e.uuid].reject(e.error) : this.resolveHash[e.uuid].resolve(e.data),
            this.resolveHash[e.uuid] = null
    }
    async _run(e, n) {
        await this._initWorkers();
        const s = new Promise((r, i) => {
            this.queue.push({
                id: e,
                arguments: n,
                resolve: r,
                reject: i
            })
        }
        );
        return this.next(),
            s
    }
    next() {
        if (!this.queue.length)
            return;
        const e = this.getWorker();
        if (!e)
            return;
        const n = this.queue.pop()
            , s = n.id;
        this.resolveHash[dA] = {
            resolve: n.resolve,
            reject: n.reject
        },
            e.postMessage({
                data: n.arguments,
                uuid: dA++,
                id: s
            })
    }
}
const fA = new Gue;
function xf(t, e, n) {
    t.resource.internal = !0;
    const s = new $e(t)
        , r = () => {
            delete e.promiseCache[n],
                Ml.has(n) && Ml.remove(n)
        }
        ;
    return s.baseTexture.once("destroyed", () => {
        n in e.promiseCache && (console.warn("[Assets] A BaseTexture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the BaseTexture."),
            r())
    }
    ),
        s.once("destroyed", () => {
            t.destroyed || (console.warn("[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture."),
                r())
        }
        ),
        s
}
const Hue = [".jpeg", ".jpg", ".png", ".webp", ".avif"]
    , Wue = ["image/jpeg", "image/png", "image/webp", "image/avif"];
async function Yue(t) {
    const e = await Le.ADAPTER.fetch(t);
    if (!e.ok)
        throw new Error(`[loadImageBitmap] Failed to fetch ${t}: ${e.status} ${e.statusText}`);
    const n = await e.blob();
    return await createImageBitmap(n)
}
const B_ = {
    name: "loadTextures",
    extension: {
        type: Ae.LoadParser,
        priority: _r.High
    },
    config: {
        preferWorkers: !0,
        preferCreateImageBitmap: !0,
        crossOrigin: "anonymous"
    },
    test(t) {
        return mh(t, Wue) || zs(t, Hue)
    },
    async load(t, e, n) {
        var l;
        const s = globalThis.createImageBitmap && this.config.preferCreateImageBitmap;
        let r;
        s ? this.config.preferWorkers && await fA.isImageBitmapSupported() ? r = await fA.loadImageBitmap(t) : r = await Yue(t) : r = await new Promise((a, c) => {
            const u = new Image;
            u.crossOrigin = this.config.crossOrigin,
                u.src = t,
                u.complete ? a(u) : (u.onload = () => a(u),
                    u.onerror = h => c(h))
        }
        );
        const i = {
            ...e.data
        };
        i.resolution ?? (i.resolution = Vo(t)),
            s && ((l = i.resourceOptions) == null ? void 0 : l.ownsImageBitmap) === void 0 && (i.resourceOptions = {
                ...i.resourceOptions
            },
                i.resourceOptions.ownsImageBitmap = !0);
        const o = new st(r, i);
        return o.resource.src = t,
            xf(o, n, t)
    },
    unload(t) {
        t.destroy(!0)
    }
};
Ue.add(B_);
const Xue = ".svg"
    , jue = "image/svg+xml"
    , zue = {
        extension: {
            type: Ae.LoadParser,
            priority: _r.High
        },
        name: "loadSVG",
        test(t) {
            return mh(t, jue) || zs(t, Xue)
        },
        async testParse(t) {
            return Mb.test(t)
        },
        async parse(t, e, n) {
            var i;
            const s = new Mb(t, (i = e == null ? void 0 : e.data) == null ? void 0 : i.resourceOptions);
            await s.load();
            const r = new st(s, {
                resolution: Vo(t),
                ...e == null ? void 0 : e.data
            });
            return r.resource.src = e.src,
                xf(r, n, e.src)
        },
        async load(t, e) {
            return (await Le.ADAPTER.fetch(t)).text()
        },
        unload: B_.unload
    };
Ue.add(zue);
const que = [".mp4", ".m4v", ".webm", ".ogv"]
    , Kue = ["video/mp4", "video/webm", "video/ogg"]
    , Jue = {
        name: "loadVideo",
        extension: {
            type: Ae.LoadParser,
            priority: _r.High
        },
        config: {
            defaultAutoPlay: !0,
            defaultUpdateFPS: 0,
            defaultLoop: !1,
            defaultMuted: !1,
            defaultPlaysinline: !0
        },
        test(t) {
            return mh(t, Kue) || zs(t, que)
        },
        async load(t, e, n) {
            var o;
            let s;
            const r = await (await Le.ADAPTER.fetch(t)).blob()
                , i = URL.createObjectURL(r);
            try {
                const l = {
                    autoPlay: this.config.defaultAutoPlay,
                    updateFPS: this.config.defaultUpdateFPS,
                    loop: this.config.defaultLoop,
                    muted: this.config.defaultMuted,
                    playsinline: this.config.defaultPlaysinline,
                    ...(o = e == null ? void 0 : e.data) == null ? void 0 : o.resourceOptions,
                    autoLoad: !0
                }
                    , a = new a5(i, l);
                await a.load();
                const c = new st(a, {
                    alphaMode: await yle(),
                    resolution: Vo(t),
                    ...e == null ? void 0 : e.data
                });
                c.resource.src = t,
                    s = xf(c, n, t),
                    s.baseTexture.once("destroyed", () => {
                        URL.revokeObjectURL(i)
                    }
                    )
            } catch (l) {
                throw URL.revokeObjectURL(i),
                l
            }
            return s
        },
        unload(t) {
            t.destroy(!0)
        }
    };
Ue.add(Jue);
class Zue {
    constructor() {
        this._defaultBundleIdentifierOptions = {
            connector: "-",
            createBundleAssetId: (e, n) => `${e}${this._bundleIdConnector}${n}`,
            extractAssetIdFromBundle: (e, n) => n.replace(`${e}${this._bundleIdConnector}`, "")
        },
            this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector,
            this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId,
            this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle,
            this._assetMap = {},
            this._preferredOrder = [],
            this._parsers = [],
            this._resolverHash = {},
            this._bundles = {}
    }
    setBundleIdentifier(e) {
        if (this._bundleIdConnector = e.connector ?? this._bundleIdConnector,
            this._createBundleAssetId = e.createBundleAssetId ?? this._createBundleAssetId,
            this._extractAssetIdFromBundle = e.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle,
            this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar")
            throw new Error("[Resolver] GenerateBundleAssetId are not working correctly")
    }
    prefer(...e) {
        e.forEach(n => {
            this._preferredOrder.push(n),
                n.priority || (n.priority = Object.keys(n.params))
        }
        ),
            this._resolverHash = {}
    }
    set basePath(e) {
        this._basePath = e
    }
    get basePath() {
        return this._basePath
    }
    set rootPath(e) {
        this._rootPath = e
    }
    get rootPath() {
        return this._rootPath
    }
    get parsers() {
        return this._parsers
    }
    reset() {
        this.setBundleIdentifier(this._defaultBundleIdentifierOptions),
            this._assetMap = {},
            this._preferredOrder = [],
            this._resolverHash = {},
            this._rootPath = null,
            this._basePath = null,
            this._manifest = null,
            this._bundles = {},
            this._defaultSearchParams = null
    }
    setDefaultSearchParams(e) {
        if (typeof e == "string")
            this._defaultSearchParams = e;
        else {
            const n = e;
            this._defaultSearchParams = Object.keys(n).map(s => `${encodeURIComponent(s)}=${encodeURIComponent(n[s])}`).join("&")
        }
    }
    getAlias(e) {
        const { alias: n, name: s, src: r, srcs: i } = e;
        return Qr(n || s || r || i, o => typeof o == "string" ? o : Array.isArray(o) ? o.map(l => (l == null ? void 0 : l.src) ?? (l == null ? void 0 : l.srcs) ?? l) : o != null && o.src || o != null && o.srcs ? o.src ?? o.srcs : o, !0)
    }
    addManifest(e) {
        this._manifest && console.warn("[Resolver] Manifest already exists, this will be overwritten"),
            this._manifest = e,
            e.bundles.forEach(n => {
                this.addBundle(n.name, n.assets)
            }
            )
    }
    addBundle(e, n) {
        const s = [];
        Array.isArray(n) ? n.forEach(r => {
            const i = r.src ?? r.srcs
                , o = r.alias ?? r.name;
            let l;
            if (typeof o == "string") {
                const a = this._createBundleAssetId(e, o);
                s.push(a),
                    l = [o, a]
            } else {
                const a = o.map(c => this._createBundleAssetId(e, c));
                s.push(...a),
                    l = [...o, ...a]
            }
            this.add({
                ...r,
                alias: l,
                src: i
            })
        }
        ) : Object.keys(n).forEach(r => {
            const i = [r, this._createBundleAssetId(e, r)];
            if (typeof n[r] == "string")
                this.add({
                    alias: i,
                    src: n[r]
                });
            else if (Array.isArray(n[r]))
                this.add({
                    alias: i,
                    src: n[r]
                });
            else {
                const o = n[r]
                    , l = o.src ?? o.srcs;
                this.add({
                    ...o,
                    alias: i,
                    src: Array.isArray(l) ? l : [l]
                })
            }
            s.push(...i)
        }
        ),
            this._bundles[e] = s
    }
    add(e, n, s, r, i) {
        const o = [];
        typeof e == "string" || Array.isArray(e) && typeof e[0] == "string" ? (dt("7.2.0", `Assets.add now uses an object instead of individual parameters.
Please use Assets.add({ alias, src, data, format, loadParser }) instead.`),
            o.push({
                alias: e,
                src: n,
                data: s,
                format: r,
                loadParser: i
            })) : Array.isArray(e) ? o.push(...e) : o.push(e);
        let l;
        l = a => {
            this.hasKey(a) && console.warn(`[Resolver] already has key: ${a} overwriting`)
        }
            ,
            Qr(o).forEach(a => {
                const { src: c, srcs: u } = a;
                let { data: h, format: d, loadParser: f } = a;
                const p = Qr(c || u).map(b => typeof b == "string" ? Sue(b) : Array.isArray(b) ? b : [b])
                    , m = this.getAlias(a);
                Array.isArray(m) ? m.forEach(l) : l(m);
                const g = [];
                p.forEach(b => {
                    b.forEach(v => {
                        let _ = {};
                        if (typeof v != "object") {
                            _.src = v;
                            for (let y = 0; y < this._parsers.length; y++) {
                                const x = this._parsers[y];
                                if (x.test(v)) {
                                    _ = x.parse(v);
                                    break
                                }
                            }
                        } else
                            h = v.data ?? h,
                                d = v.format ?? d,
                                f = v.loadParser ?? f,
                                _ = {
                                    ..._,
                                    ...v
                                };
                        if (!m)
                            throw new Error(`[Resolver] alias is undefined for this asset: ${_.src}`);
                        _ = this.buildResolvedAsset(_, {
                            aliases: m,
                            data: h,
                            format: d,
                            loadParser: f
                        }),
                            g.push(_)
                    }
                    )
                }
                ),
                    m.forEach(b => {
                        this._assetMap[b] = g
                    }
                    )
            }
            )
    }
    resolveBundle(e) {
        const n = rg(e);
        e = Qr(e);
        const s = {};
        return e.forEach(r => {
            const i = this._bundles[r];
            if (i) {
                const o = this.resolve(i)
                    , l = {};
                for (const a in o) {
                    const c = o[a];
                    l[this._extractAssetIdFromBundle(r, a)] = c
                }
                s[r] = l
            }
        }
        ),
            n ? s[e[0]] : s
    }
    resolveUrl(e) {
        const n = this.resolve(e);
        if (typeof e != "string") {
            const s = {};
            for (const r in n)
                s[r] = n[r].src;
            return s
        }
        return n.src
    }
    resolve(e) {
        const n = rg(e);
        e = Qr(e);
        const s = {};
        return e.forEach(r => {
            if (!this._resolverHash[r])
                if (this._assetMap[r]) {
                    let i = this._assetMap[r];
                    const o = i[0]
                        , l = this._getPreferredOrder(i);
                    l == null || l.priority.forEach(a => {
                        l.params[a].forEach(c => {
                            const u = i.filter(h => h[a] ? h[a] === c : !1);
                            u.length && (i = u)
                        }
                        )
                    }
                    ),
                        this._resolverHash[r] = i[0] ?? o
                } else
                    this._resolverHash[r] = this.buildResolvedAsset({
                        alias: [r],
                        src: r
                    }, {});
            s[r] = this._resolverHash[r]
        }
        ),
            n ? s[e[0]] : s
    }
    hasKey(e) {
        return !!this._assetMap[e]
    }
    hasBundle(e) {
        return !!this._bundles[e]
    }
    _getPreferredOrder(e) {
        for (let n = 0; n < e.length; n++) {
            const s = e[0]
                , r = this._preferredOrder.find(i => i.params.format.includes(s.format));
            if (r)
                return r
        }
        return this._preferredOrder[0]
    }
    _appendDefaultSearchParams(e) {
        if (!this._defaultSearchParams)
            return e;
        const n = /\?/.test(e) ? "&" : "?";
        return `${e}${n}${this._defaultSearchParams}`
    }
    buildResolvedAsset(e, n) {
        const { aliases: s, data: r, loadParser: i, format: o } = n;
        return (this._basePath || this._rootPath) && (e.src = zt.toAbsolute(e.src, this._basePath, this._rootPath)),
            e.alias = s ?? e.alias ?? [e.src],
            e.src = this._appendDefaultSearchParams(e.src),
            e.data = {
                ...r || {},
                ...e.data
            },
            e.loadParser = i ?? e.loadParser,
            e.format = o ?? e.format ?? zt.extname(e.src).slice(1),
            e.srcs = e.src,
            e.name = e.alias,
            e
    }
}
class Que {
    constructor() {
        this._detections = [],
            this._initialized = !1,
            this.resolver = new Zue,
            this.loader = new Tue,
            this.cache = Ml,
            this._backgroundLoader = new wue(this.loader),
            this._backgroundLoader.active = !0,
            this.reset()
    }
    async init(e = {}) {
        var i, o;
        if (this._initialized) {
            console.warn("[Assets]AssetManager already initialized, did you load before calling this Assets.init()?");
            return
        }
        if (this._initialized = !0,
            e.defaultSearchParams && this.resolver.setDefaultSearchParams(e.defaultSearchParams),
            e.basePath && (this.resolver.basePath = e.basePath),
            e.bundleIdentifier && this.resolver.setBundleIdentifier(e.bundleIdentifier),
            e.manifest) {
            let l = e.manifest;
            typeof l == "string" && (l = await this.load(l)),
                this.resolver.addManifest(l)
        }
        const n = ((i = e.texturePreference) == null ? void 0 : i.resolution) ?? 1
            , s = typeof n == "number" ? [n] : n
            , r = await this._detectFormats({
                preferredFormats: (o = e.texturePreference) == null ? void 0 : o.format,
                skipDetections: e.skipDetections,
                detections: this._detections
            });
        this.resolver.prefer({
            params: {
                format: r,
                resolution: s
            }
        }),
            e.preferences && this.setPreferences(e.preferences)
    }
    add(e, n, s, r, i) {
        this.resolver.add(e, n, s, r, i)
    }
    async load(e, n) {
        this._initialized || await this.init();
        const s = rg(e)
            , r = Qr(e).map(l => {
                if (typeof l != "string") {
                    const a = this.resolver.getAlias(l);
                    return a.some(c => !this.resolver.hasKey(c)) && this.add(l),
                        Array.isArray(a) ? a[0] : a
                }
                return this.resolver.hasKey(l) || this.add({
                    alias: l,
                    src: l
                }),
                    l
            }
            )
            , i = this.resolver.resolve(r)
            , o = await this._mapLoadToResolve(i, n);
        return s ? o[r[0]] : o
    }
    addBundle(e, n) {
        this.resolver.addBundle(e, n)
    }
    async loadBundle(e, n) {
        this._initialized || await this.init();
        let s = !1;
        typeof e == "string" && (s = !0,
            e = [e]);
        const r = this.resolver.resolveBundle(e)
            , i = {}
            , o = Object.keys(r);
        let l = 0
            , a = 0;
        const c = () => {
            n == null || n(++l / a)
        }
            , u = o.map(h => {
                const d = r[h];
                return a += Object.keys(d).length,
                    this._mapLoadToResolve(d, c).then(f => {
                        i[h] = f
                    }
                    )
            }
            );
        return await Promise.all(u),
            s ? i[e[0]] : i
    }
    async backgroundLoad(e) {
        this._initialized || await this.init(),
            typeof e == "string" && (e = [e]);
        const n = this.resolver.resolve(e);
        this._backgroundLoader.add(Object.values(n))
    }
    async backgroundLoadBundle(e) {
        this._initialized || await this.init(),
            typeof e == "string" && (e = [e]);
        const n = this.resolver.resolveBundle(e);
        Object.values(n).forEach(s => {
            this._backgroundLoader.add(Object.values(s))
        }
        )
    }
    reset() {
        this.resolver.reset(),
            this.loader.reset(),
            this.cache.reset(),
            this._initialized = !1
    }
    get(e) {
        if (typeof e == "string")
            return Ml.get(e);
        const n = {};
        for (let s = 0; s < e.length; s++)
            n[s] = Ml.get(e[s]);
        return n
    }
    async _mapLoadToResolve(e, n) {
        const s = Object.values(e)
            , r = Object.keys(e);
        this._backgroundLoader.active = !1;
        const i = await this.loader.load(s, n);
        this._backgroundLoader.active = !0;
        const o = {};
        return s.forEach((l, a) => {
            const c = i[l.src]
                , u = [l.src];
            l.alias && u.push(...l.alias),
                o[r[a]] = c,
                Ml.set(u, c)
        }
        ),
            o
    }
    async unload(e) {
        this._initialized || await this.init();
        const n = Qr(e).map(r => typeof r != "string" ? r.src : r)
            , s = this.resolver.resolve(n);
        await this._unloadFromResolved(s)
    }
    async unloadBundle(e) {
        this._initialized || await this.init(),
            e = Qr(e);
        const n = this.resolver.resolveBundle(e)
            , s = Object.keys(n).map(r => this._unloadFromResolved(n[r]));
        await Promise.all(s)
    }
    async _unloadFromResolved(e) {
        const n = Object.values(e);
        n.forEach(s => {
            Ml.remove(s.src)
        }
        ),
            await this.loader.unload(n)
    }
    async _detectFormats(e) {
        let n = [];
        e.preferredFormats && (n = Array.isArray(e.preferredFormats) ? e.preferredFormats : [e.preferredFormats]);
        for (const s of e.detections)
            e.skipDetections || await s.test() ? n = await s.add(n) : e.skipDetections || (n = await s.remove(n));
        return n = n.filter((s, r) => n.indexOf(s) === r),
            n
    }
    get detections() {
        return this._detections
    }
    get preferWorkers() {
        return B_.config.preferWorkers
    }
    set preferWorkers(e) {
        dt("7.2.0", "Assets.prefersWorkers is deprecated, use Assets.setPreferences({ preferWorkers: true }) instead."),
            this.setPreferences({
                preferWorkers: e
            })
    }
    setPreferences(e) {
        this.loader.parsers.forEach(n => {
            n.config && Object.keys(n.config).filter(s => s in e).forEach(s => {
                n.config[s] = e[s]
            }
            )
        }
        )
    }
}
const ru = new Que;
Ue.handleByList(Ae.LoadParser, ru.loader.parsers).handleByList(Ae.ResolveParser, ru.resolver.parsers).handleByList(Ae.CacheParser, ru.cache.parsers).handleByList(Ae.DetectionParser, ru.detections);
const ehe = {
    extension: Ae.CacheParser,
    test: t => Array.isArray(t) && t.every(e => e instanceof $e),
    getCacheableAssets: (t, e) => {
        const n = {};
        return t.forEach(s => {
            e.forEach((r, i) => {
                n[s + (i === 0 ? "" : i + 1)] = r
            }
            )
        }
        ),
            n
    }
};
Ue.add(ehe);
async function x5(t) {
    if ("Image" in globalThis)
        return new Promise(e => {
            const n = new Image;
            n.onload = () => {
                e(!0)
            }
                ,
                n.onerror = () => {
                    e(!1)
                }
                ,
                n.src = t
        }
        );
    if ("createImageBitmap" in globalThis && "fetch" in globalThis) {
        try {
            const e = await (await fetch(t)).blob();
            await createImageBitmap(e)
        } catch {
            return !1
        }
        return !0
    }
    return !1
}
const the = {
    extension: {
        type: Ae.DetectionParser,
        priority: 1
    },
    test: async () => x5("data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A="),
    add: async t => [...t, "avif"],
    remove: async t => t.filter(e => e !== "avif")
};
Ue.add(the);
const nhe = {
    extension: {
        type: Ae.DetectionParser,
        priority: 0
    },
    test: async () => x5("data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA="),
    add: async t => [...t, "webp"],
    remove: async t => t.filter(e => e !== "webp")
};
Ue.add(nhe);
const pA = ["png", "jpg", "jpeg"]
    , she = {
        extension: {
            type: Ae.DetectionParser,
            priority: -1
        },
        test: () => Promise.resolve(!0),
        add: async t => [...t, ...pA],
        remove: async t => t.filter(e => !pA.includes(e))
    };
Ue.add(she);
const rhe = "WorkerGlobalScope" in globalThis && globalThis instanceof globalThis.WorkerGlobalScope;
function dw(t) {
    return rhe ? !1 : document.createElement("video").canPlayType(t) !== ""
}
const ihe = {
    extension: {
        type: Ae.DetectionParser,
        priority: 0
    },
    test: async () => dw("video/webm"),
    add: async t => [...t, "webm"],
    remove: async t => t.filter(e => e !== "webm")
};
Ue.add(ihe);
const ohe = {
    extension: {
        type: Ae.DetectionParser,
        priority: 0
    },
    test: async () => dw("video/mp4"),
    add: async t => [...t, "mp4", "m4v"],
    remove: async t => t.filter(e => e !== "mp4" && e !== "m4v")
};
Ue.add(ohe);
const ahe = {
    extension: {
        type: Ae.DetectionParser,
        priority: 0
    },
    test: async () => dw("video/ogg"),
    add: async t => [...t, "ogv"],
    remove: async t => t.filter(e => e !== "ogv")
};
Ue.add(ahe);
const lhe = {
    extension: Ae.ResolveParser,
    test: B_.test,
    parse: t => {
        var e;
        return {
            resolution: parseFloat(((e = Le.RETINA_PREFIX.exec(t)) == null ? void 0 : e[1]) ?? "1"),
            format: zt.extname(t).slice(1),
            src: t
        }
    }
};
Ue.add(lhe);
const che = {
    extension: Ae.Asset,
    loader: {
        extension: {
            type: Ae.LoadParser,
            priority: _r.Normal
        },
        test(t) {
            return zs(t, ".atlas")
        },
        async load(t) {
            return await (await Le.ADAPTER.fetch(t)).text()
        },
        testParse(t, e) {
            const n = zs(e.src, ".atlas")
                , s = typeof t == "string";
            return Promise.resolve(n && s)
        },
        async parse(t, e, n) {
            const s = e.data;
            let r = zt.dirname(e.src);
            r && r.lastIndexOf("/") !== r.length - 1 && (r += "/");
            let i = null
                , o = null;
            const l = new Promise((u, h) => {
                i = u,
                    o = h
            }
            );
            let a;
            const c = u => {
                u || o(`Something went terribly wrong loading a spine .atlas file
Most likely your texture failed to load.`),
                    i(a)
            }
                ;
            if (s.image || s.images) {
                const u = Object.assign(s.image ? {
                    default: s.image
                } : {}, s.images);
                a = new Nb(t, (h, d) => {
                    const f = u[h] || u.default;
                    f && f.baseTexture ? d(f.baseTexture) : d(f)
                }
                    , c)
            } else
                a = new Nb(t, w5(n, r, s.imageMetadata), c);
            return await l
        },
        unload(t) {
            t.dispose()
        }
    }
}
    , w5 = (t, e, n) => async (s, r) => {
        const i = zt.normalize([...e.split(zt.sep), s].join(zt.sep))
            , o = await t.load({
                src: i,
                data: n
            });
        r(o.baseTexture)
    }
    ;
Ue.add(che);
function mA(t) {
    return t.hasOwnProperty("bones")
}
function uhe(t) {
    return t instanceof ArrayBuffer
}
class hhe {
    constructor() { }
    installLoader() {
        const e = this
            , n = {
                extension: Ae.Asset,
                loader: {
                    extension: {
                        type: Ae.LoadParser,
                        priority: _r.Normal
                    },
                    test(s) {
                        return zs(s, ".skel")
                    },
                    async load(s) {
                        return await (await Le.ADAPTER.fetch(s)).arrayBuffer()
                    },
                    testParse(s, r) {
                        var a;
                        const i = zs(r.src, ".json") && mA(s)
                            , o = zs(r.src, ".skel") && uhe(s)
                            , l = ((a = r.data) == null ? void 0 : a.spineAtlas) === !1;
                        return Promise.resolve(i && !l || o)
                    },
                    async parse(s, r, i) {
                        const o = zt.extname(r.src).toLowerCase()
                            , l = zt.basename(r.src, o);
                        let a = zt.dirname(r.src);
                        a && a.lastIndexOf("/") !== a.length - 1 && (a += "/");
                        const c = zs(r.src, ".json") && mA(s);
                        let u = null
                            , h = s;
                        c ? u = e.createJsonParser() : (u = e.createBinaryParser(),
                            h = new Uint8Array(s));
                        const d = r.data || {}
                            , f = (d == null ? void 0 : d.spineSkeletonScale) ?? null;
                        f && (u.scale = f);
                        const p = d.spineAtlas;
                        if (p && p.pages)
                            return e.parseData(u, p, h);
                        const m = d.atlasRawData;
                        if (m) {
                            let v = null
                                , _ = null;
                            const y = new Promise((S, E) => {
                                v = S,
                                    _ = E
                            }
                            )
                                , x = new Nb(m, w5(i, a, d.imageMetadata), S => {
                                    S || _(`Something went terribly wrong loading a spine .atlas file
Most likely your texture failed to load.`),
                                        v(x)
                                }
                                )
                                , w = await y;
                            return e.parseData(u, w, h)
                        }
                        let g = d.spineAtlasFile;
                        g || (g = `${a + l}.atlas`);
                        const b = await i.load({
                            src: g,
                            data: d,
                            alias: d.spineAtlasAlias
                        });
                        return e.parseData(u, b, h)
                    }
                }
            };
        return Ue.add(n),
            n
    }
}
let fw = class {
    constructor(e) {
        if (e == null)
            throw new Error("name cannot be null.");
        this.name = e
    }
}
    ;
const S5 = class extends fw {
    constructor(e) {
        super(e),
            this.id = (S5.nextID++ & 65535) << 11,
            this.worldVerticesLength = 0,
            this.deformAttachment = this
    }
    computeWorldVerticesOld(e, n) {
        this.computeWorldVertices(e, 0, this.worldVerticesLength, n, 0, 2)
    }
    computeWorldVertices(e, n, s, r, i, o) {
        s = i + (s >> 1) * o;
        const l = e.bone.skeleton
            , a = e.deform;
        let c = this.vertices;
        const u = this.bones;
        if (u == null) {
            a.length > 0 && (c = a);
            const p = e.bone.matrix
                , m = p.tx
                , g = p.ty
                , b = p.a
                , v = p.c
                , _ = p.b
                , y = p.d;
            for (let x = n, w = i; w < s; x += 2,
                w += o) {
                const S = c[x]
                    , E = c[x + 1];
                r[w] = S * b + E * v + m,
                    r[w + 1] = S * _ + E * y + g
            }
            return
        }
        let h = 0
            , d = 0;
        for (let p = 0; p < n; p += 2) {
            const m = u[h];
            h += m + 1,
                d += m
        }
        const f = l.bones;
        if (a.length == 0)
            for (let p = i, m = d * 3; p < s; p += o) {
                let g = 0
                    , b = 0
                    , v = u[h++];
                for (v += h; h < v; h++,
                    m += 3) {
                    const _ = f[u[h]].matrix
                        , y = c[m]
                        , x = c[m + 1]
                        , w = c[m + 2];
                    g += (y * _.a + x * _.c + _.tx) * w,
                        b += (y * _.b + x * _.d + _.ty) * w
                }
                r[p] = g,
                    r[p + 1] = b
            }
        else {
            const p = a;
            for (let m = i, g = d * 3, b = d << 1; m < s; m += o) {
                let v = 0
                    , _ = 0
                    , y = u[h++];
                for (y += h; h < y; h++,
                    g += 3,
                    b += 2) {
                    const x = f[u[h]].matrix
                        , w = c[g] + p[b]
                        , S = c[g + 1] + p[b + 1]
                        , E = c[g + 2];
                    v += (w * x.a + S * x.c + x.tx) * E,
                        _ += (w * x.b + S * x.d + x.ty) * E
                }
                r[m] = v,
                    r[m + 1] = _
            }
        }
    }
    copyTo(e) {
        this.bones != null ? (e.bones = new Array(this.bones.length),
            Q.arrayCopy(this.bones, 0, e.bones, 0, this.bones.length)) : e.bones = null,
            this.vertices != null ? (e.vertices = Q.newFloatArray(this.vertices.length),
                Q.arrayCopy(this.vertices, 0, e.vertices, 0, this.vertices.length)) : e.vertices = null,
            e.worldVerticesLength = this.worldVerticesLength,
            e.deformAttachment = this.deformAttachment
    }
}
    ;
let cl = S5;
cl.nextID = 0;
let E5 = class T5 extends cl {
    constructor(e) {
        super(e),
            this.type = ut.BoundingBox,
            this.color = new Se(1, 1, 1, 1)
    }
    copy() {
        const e = new T5(this.name);
        return this.copyTo(e),
            e.color.setFromColor(this.color),
            e
    }
}
    , C5 = class I5 extends cl {
        constructor(e) {
            super(e),
                this.type = ut.Clipping,
                this.color = new Se(.2275, .2275, .8078, 1)
        }
        copy() {
            const e = new I5(this.name);
            return this.copyTo(e),
                e.endSlot = this.endSlot,
                e.color.setFromColor(this.color),
                e
        }
    }
    , F_ = class Gb extends cl {
        constructor(e) {
            super(e),
                this.type = ut.Mesh,
                this.color = new Se(1, 1, 1, 1),
                this.tempColor = new Se(0, 0, 0, 0)
        }
        getParentMesh() {
            return this.parentMesh
        }
        setParentMesh(e) {
            this.parentMesh = e,
                e != null && (this.bones = e.bones,
                    this.vertices = e.vertices,
                    this.worldVerticesLength = e.worldVerticesLength,
                    this.regionUVs = e.regionUVs,
                    this.triangles = e.triangles,
                    this.hullLength = e.hullLength,
                    this.worldVerticesLength = e.worldVerticesLength)
        }
        copy() {
            if (this.parentMesh != null)
                return this.newLinkedMesh();
            const e = new Gb(this.name);
            return e.region = this.region,
                e.path = this.path,
                e.color.setFromColor(this.color),
                this.copyTo(e),
                e.regionUVs = new Float32Array(this.regionUVs.length),
                Q.arrayCopy(this.regionUVs, 0, e.regionUVs, 0, this.regionUVs.length),
                e.triangles = new Array(this.triangles.length),
                Q.arrayCopy(this.triangles, 0, e.triangles, 0, this.triangles.length),
                e.hullLength = this.hullLength,
                this.edges != null && (e.edges = new Array(this.edges.length),
                    Q.arrayCopy(this.edges, 0, e.edges, 0, this.edges.length)),
                e.width = this.width,
                e.height = this.height,
                e
        }
        newLinkedMesh() {
            const e = new Gb(this.name);
            return e.region = this.region,
                e.path = this.path,
                e.color.setFromColor(this.color),
                e.deformAttachment = this.deformAttachment,
                e.setParentMesh(this.parentMesh != null ? this.parentMesh : this),
                e
        }
    }
    , $d = class A5 extends cl {
        constructor(e) {
            super(e),
                this.type = ut.Path,
                this.closed = !1,
                this.constantSpeed = !1,
                this.color = new Se(1, 1, 1, 1)
        }
        copy() {
            const e = new A5(this.name);
            return this.copyTo(e),
                e.lengths = new Array(this.lengths.length),
                Q.arrayCopy(this.lengths, 0, e.lengths, 0, this.lengths.length),
                e.closed = closed,
                e.constantSpeed = this.constantSpeed,
                e.color.setFromColor(this.color),
                e
        }
    }
    , k5 = class R5 extends cl {
        constructor(e) {
            super(e),
                this.type = ut.Point,
                this.color = new Se(.38, .94, 0, 1)
        }
        computeWorldPosition(e, n) {
            const s = e.matrix;
            return n.x = this.x * s.a + this.y * s.c + e.worldX,
                n.y = this.x * s.b + this.y * s.d + e.worldY,
                n
        }
        computeWorldRotation(e) {
            const n = e.matrix
                , s = F.cosDeg(this.rotation)
                , r = F.sinDeg(this.rotation)
                , i = s * n.a + r * n.c
                , o = s * n.b + r * n.d;
            return Math.atan2(o, i) * F.radDeg
        }
        copy() {
            const e = new R5(this.name);
            return e.x = this.x,
                e.y = this.y,
                e.rotation = this.rotation,
                e.color.setFromColor(this.color),
                e
        }
    }
    , pw = class {
        constructor(e, n) {
            if (this.deform = new Array,
                e == null)
                throw new Error("data cannot be null.");
            if (n == null)
                throw new Error("bone cannot be null.");
            this.data = e,
                this.bone = n,
                this.color = new Se,
                this.darkColor = e.darkColor == null ? null : new Se,
                this.setToSetupPose(),
                this.blendMode = this.data.blendMode
        }
        getAttachment() {
            return this.attachment
        }
        setAttachment(e) {
            this.attachment != e && (this.attachment = e,
                this.attachmentTime = this.bone.skeleton.time,
                this.deform.length = 0)
        }
        setAttachmentTime(e) {
            this.attachmentTime = this.bone.skeleton.time - e
        }
        getAttachmentTime() {
            return this.bone.skeleton.time - this.attachmentTime
        }
        setToSetupPose() {
            this.color.setFromColor(this.data.color),
                this.darkColor != null && this.darkColor.setFromColor(this.data.darkColor),
                this.data.attachmentName == null ? this.attachment = null : (this.attachment = null,
                    this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName)))
        }
    }
    ;
const Vn = class extends fw {
    constructor(e) {
        super(e),
            this.type = ut.Region,
            this.x = 0,
            this.y = 0,
            this.scaleX = 1,
            this.scaleY = 1,
            this.rotation = 0,
            this.width = 0,
            this.height = 0,
            this.color = new Se(1, 1, 1, 1),
            this.offset = Q.newFloatArray(8),
            this.uvs = Q.newFloatArray(8),
            this.tempColor = new Se(1, 1, 1, 1)
    }
    updateOffset() {
        const e = this.width / this.region.originalWidth * this.scaleX
            , n = this.height / this.region.originalHeight * this.scaleY
            , s = -this.width / 2 * this.scaleX + this.region.offsetX * e
            , r = -this.height / 2 * this.scaleY + this.region.offsetY * n
            , i = s + this.region.width * e
            , o = r + this.region.height * n
            , l = this.rotation * Math.PI / 180
            , a = Math.cos(l)
            , c = Math.sin(l)
            , u = s * a + this.x
            , h = s * c
            , d = r * a + this.y
            , f = r * c
            , p = i * a + this.x
            , m = i * c
            , g = o * a + this.y
            , b = o * c
            , v = this.offset;
        v[Vn.OX1] = u - f,
            v[Vn.OY1] = d + h,
            v[Vn.OX2] = u - b,
            v[Vn.OY2] = g + h,
            v[Vn.OX3] = p - b,
            v[Vn.OY3] = g + m,
            v[Vn.OX4] = p - f,
            v[Vn.OY4] = d + m
    }
    setRegion(e) {
        this.region = e;
        const n = this.uvs;
        e.rotate ? (n[2] = e.u,
            n[3] = e.v2,
            n[4] = e.u,
            n[5] = e.v,
            n[6] = e.u2,
            n[7] = e.v,
            n[0] = e.u2,
            n[1] = e.v2) : (n[0] = e.u,
                n[1] = e.v2,
                n[2] = e.u,
                n[3] = e.v,
                n[4] = e.u2,
                n[5] = e.v,
                n[6] = e.u2,
                n[7] = e.v2)
    }
    computeWorldVertices(e, n, s, r) {
        const i = this.offset
            , o = e instanceof pw ? e.bone.matrix : e.matrix
            , l = o.tx
            , a = o.ty
            , c = o.a
            , u = o.c
            , h = o.b
            , d = o.d;
        let f = 0
            , p = 0;
        f = i[Vn.OX1],
            p = i[Vn.OY1],
            n[s] = f * c + p * u + l,
            n[s + 1] = f * h + p * d + a,
            s += r,
            f = i[Vn.OX2],
            p = i[Vn.OY2],
            n[s] = f * c + p * u + l,
            n[s + 1] = f * h + p * d + a,
            s += r,
            f = i[Vn.OX3],
            p = i[Vn.OY3],
            n[s] = f * c + p * u + l,
            n[s + 1] = f * h + p * d + a,
            s += r,
            f = i[Vn.OX4],
            p = i[Vn.OY4],
            n[s] = f * c + p * u + l,
            n[s + 1] = f * h + p * d + a
    }
    copy() {
        const e = new Vn(this.name);
        return e.region = this.region,
            e.rendererObject = this.rendererObject,
            e.path = this.path,
            e.x = this.x,
            e.y = this.y,
            e.scaleX = this.scaleX,
            e.scaleY = this.scaleY,
            e.rotation = this.rotation,
            e.width = this.width,
            e.height = this.height,
            Q.arrayCopy(this.uvs, 0, e.uvs, 0, 8),
            Q.arrayCopy(this.offset, 0, e.offset, 0, 8),
            e.color.setFromColor(this.color),
            e
    }
}
    ;
let ot = Vn;
ot.OX1 = 0;
ot.OY1 = 1;
ot.OX2 = 2;
ot.OY2 = 3;
ot.OX3 = 4;
ot.OY3 = 5;
ot.OX4 = 6;
ot.OY4 = 7;
ot.X1 = 0;
ot.Y1 = 1;
ot.C1R = 2;
ot.C1G = 3;
ot.C1B = 4;
ot.C1A = 5;
ot.U1 = 6;
ot.V1 = 7;
ot.X2 = 8;
ot.Y2 = 9;
ot.C2R = 10;
ot.C2G = 11;
ot.C2B = 12;
ot.C2A = 13;
ot.U2 = 14;
ot.V2 = 15;
ot.X3 = 16;
ot.Y3 = 17;
ot.C3R = 18;
ot.C3G = 19;
ot.C3B = 20;
ot.C3A = 21;
ot.U3 = 22;
ot.V3 = 23;
ot.X4 = 24;
ot.Y4 = 25;
ot.C4R = 26;
ot.C4G = 27;
ot.C4B = 28;
ot.C4A = 29;
ot.U4 = 30;
ot.V4 = 31;
let dhe = class {
    constructor(e, n) {
        this.jitterX = 0,
            this.jitterY = 0,
            this.jitterX = e,
            this.jitterY = n
    }
    begin(e) { }
    transform(e, n, s, r) {
        e.x += F.randomTriangular(-this.jitterX, this.jitterY),
            e.y += F.randomTriangular(-this.jitterX, this.jitterY)
    }
    end() { }
}
    ;
const M5 = class {
    constructor(e) {
        this.centerX = 0,
            this.centerY = 0,
            this.radius = 0,
            this.angle = 0,
            this.worldX = 0,
            this.worldY = 0,
            this.radius = e
    }
    begin(e) {
        this.worldX = e.x + this.centerX,
            this.worldY = e.y + this.centerY
    }
    transform(e, n, s, r) {
        const i = this.angle * F.degreesToRadians
            , o = e.x - this.worldX
            , l = e.y - this.worldY
            , a = Math.sqrt(o * o + l * l);
        if (a < this.radius) {
            const c = M5.interpolation.apply(0, i, (this.radius - a) / this.radius)
                , u = Math.cos(c)
                , h = Math.sin(c);
            e.x = u * o - h * l + this.worldX,
                e.y = h * o + u * l + this.worldY
        }
    }
    end() { }
}
    ;
let P5 = M5;
P5.interpolation = new u5(2);
let xn = class {
    constructor(e, n, s) {
        if (e == null)
            throw new Error("name cannot be null.");
        if (n == null)
            throw new Error("timelines cannot be null.");
        this.name = e,
            this.timelines = n,
            this.timelineIds = [];
        for (let r = 0; r < n.length; r++)
            this.timelineIds[n[r].getPropertyId()] = !0;
        this.duration = s
    }
    hasTimeline(e) {
        return this.timelineIds[e] == !0
    }
    apply(e, n, s, r, i, o, l, a) {
        if (e == null)
            throw new Error("skeleton cannot be null.");
        r && this.duration != 0 && (s %= this.duration,
            n > 0 && (n %= this.duration));
        const c = this.timelines;
        for (let u = 0, h = c.length; u < h; u++)
            c[u].apply(e, n, s, i, o, l, a)
    }
    static binarySearch(e, n, s = 1) {
        let r = 0
            , i = e.length / s - 2;
        if (i == 0)
            return s;
        let o = i >>> 1;
        for (; ;) {
            if (e[(o + 1) * s] <= n ? r = o + 1 : i = o,
                r == i)
                return (r + 1) * s;
            o = r + i >>> 1
        }
    }
    static linearSearch(e, n, s) {
        for (let r = 0, i = e.length - s; r <= i; r += s)
            if (e[r] > n)
                return r;
        return -1
    }
}
    ;
var L5 = (t => (t[t.rotate = 0] = "rotate",
    t[t.translate = 1] = "translate",
    t[t.scale = 2] = "scale",
    t[t.shear = 3] = "shear",
    t[t.attachment = 4] = "attachment",
    t[t.color = 5] = "color",
    t[t.deform = 6] = "deform",
    t[t.event = 7] = "event",
    t[t.drawOrder = 8] = "drawOrder",
    t[t.ikConstraint = 9] = "ikConstraint",
    t[t.transformConstraint = 10] = "transformConstraint",
    t[t.pathConstraintPosition = 11] = "pathConstraintPosition",
    t[t.pathConstraintSpacing = 12] = "pathConstraintSpacing",
    t[t.pathConstraintMix = 13] = "pathConstraintMix",
    t[t.twoColor = 14] = "twoColor",
    t))(L5 || {});
const pn = class {
    constructor(e) {
        if (e <= 0)
            throw new Error(`frameCount must be > 0: ${e}`);
        this.curves = Q.newFloatArray((e - 1) * pn.BEZIER_SIZE)
    }
    getFrameCount() {
        return this.curves.length / pn.BEZIER_SIZE + 1
    }
    setLinear(e) {
        this.curves[e * pn.BEZIER_SIZE] = pn.LINEAR
    }
    setStepped(e) {
        this.curves[e * pn.BEZIER_SIZE] = pn.STEPPED
    }
    getCurveType(e) {
        const n = e * pn.BEZIER_SIZE;
        if (n == this.curves.length)
            return pn.LINEAR;
        const s = this.curves[n];
        return s == pn.LINEAR ? pn.LINEAR : s == pn.STEPPED ? pn.STEPPED : pn.BEZIER
    }
    setCurve(e, n, s, r, i) {
        const o = (-n * 2 + r) * .03
            , l = (-s * 2 + i) * .03
            , a = ((n - r) * 3 + 1) * .006
            , c = ((s - i) * 3 + 1) * .006;
        let u = o * 2 + a
            , h = l * 2 + c
            , d = n * .3 + o + a * .16666667
            , f = s * .3 + l + c * .16666667
            , p = e * pn.BEZIER_SIZE;
        const m = this.curves;
        m[p++] = pn.BEZIER;
        let g = d
            , b = f;
        for (let v = p + pn.BEZIER_SIZE - 1; p < v; p += 2)
            m[p] = g,
                m[p + 1] = b,
                d += u,
                f += h,
                u += a,
                h += c,
                g += d,
                b += f
    }
    getCurvePercent(e, n) {
        n = F.clamp(n, 0, 1);
        const s = this.curves;
        let r = e * pn.BEZIER_SIZE;
        const i = s[r];
        if (i == pn.LINEAR)
            return n;
        if (i == pn.STEPPED)
            return 0;
        r++;
        let o = 0;
        for (let a = r, c = r + pn.BEZIER_SIZE - 1; r < c; r += 2)
            if (o = s[r],
                o >= n) {
                let u, h;
                return r == a ? (u = 0,
                    h = 0) : (u = s[r - 2],
                        h = s[r - 1]),
                    h + (s[r + 1] - h) * (n - u) / (o - u)
            }
        const l = s[r - 1];
        return l + (1 - l) * (n - o) / (1 - o)
    }
}
    ;
let Ks = pn;
Ks.LINEAR = 0;
Ks.STEPPED = 1;
Ks.BEZIER = 2;
Ks.BEZIER_SIZE = 10 * 2 - 1;
const ia = class extends Ks {
    constructor(e) {
        super(e),
            this.frames = Q.newFloatArray(e << 1)
    }
    getPropertyId() {
        return 0 + this.boneIndex
    }
    setFrame(e, n, s) {
        e <<= 1,
            this.frames[e] = n,
            this.frames[e + ia.ROTATION] = s
    }
    apply(e, n, s, r, i, o, l) {
        const a = this.frames
            , c = e.bones[this.boneIndex];
        if (!c.active)
            return;
        if (s < a[0]) {
            switch (o) {
                case O.setup:
                    c.rotation = c.data.rotation;
                    return;
                case O.first:
                    const m = c.data.rotation - c.rotation;
                    c.rotation += (m - (16384 - (16384.499999999996 - m / 360 | 0)) * 360) * i
            }
            return
        }
        if (s >= a[a.length - ia.ENTRIES]) {
            let m = a[a.length + ia.PREV_ROTATION];
            switch (o) {
                case O.setup:
                    c.rotation = c.data.rotation + m * i;
                    break;
                case O.first:
                case O.replace:
                    m += c.data.rotation - c.rotation,
                        m -= (16384 - (16384.499999999996 - m / 360 | 0)) * 360;
                case O.add:
                    c.rotation += m * i
            }
            return
        }
        const u = xn.binarySearch(a, s, ia.ENTRIES)
            , h = a[u + ia.PREV_ROTATION]
            , d = a[u]
            , f = this.getCurvePercent((u >> 1) - 1, 1 - (s - d) / (a[u + ia.PREV_TIME] - d));
        let p = a[u + ia.ROTATION] - h;
        switch (p = h + (p - (16384 - (16384.499999999996 - p / 360 | 0)) * 360) * f,
        o) {
            case O.setup:
                c.rotation = c.data.rotation + (p - (16384 - (16384.499999999996 - p / 360 | 0)) * 360) * i;
                break;
            case O.first:
            case O.replace:
                p += c.data.rotation - c.rotation;
            case O.add:
                c.rotation += (p - (16384 - (16384.499999999996 - p / 360 | 0)) * 360) * i
        }
    }
}
    ;
let ts = ia;
ts.ENTRIES = 2;
ts.PREV_TIME = -2;
ts.PREV_ROTATION = -1;
ts.ROTATION = 1;
const bs = class extends Ks {
    constructor(e) {
        super(e),
            this.frames = Q.newFloatArray(e * bs.ENTRIES)
    }
    getPropertyId() {
        return (1 << 24) + this.boneIndex
    }
    setFrame(e, n, s, r) {
        e *= bs.ENTRIES,
            this.frames[e] = n,
            this.frames[e + bs.X] = s,
            this.frames[e + bs.Y] = r
    }
    apply(e, n, s, r, i, o, l) {
        const a = this.frames
            , c = e.bones[this.boneIndex];
        if (!c.active)
            return;
        if (s < a[0]) {
            switch (o) {
                case O.setup:
                    c.x = c.data.x,
                        c.y = c.data.y;
                    return;
                case O.first:
                    c.x += (c.data.x - c.x) * i,
                        c.y += (c.data.y - c.y) * i
            }
            return
        }
        let u = 0
            , h = 0;
        if (s >= a[a.length - bs.ENTRIES])
            u = a[a.length + bs.PREV_X],
                h = a[a.length + bs.PREV_Y];
        else {
            const d = xn.binarySearch(a, s, bs.ENTRIES);
            u = a[d + bs.PREV_X],
                h = a[d + bs.PREV_Y];
            const f = a[d]
                , p = this.getCurvePercent(d / bs.ENTRIES - 1, 1 - (s - f) / (a[d + bs.PREV_TIME] - f));
            u += (a[d + bs.X] - u) * p,
                h += (a[d + bs.Y] - h) * p
        }
        switch (o) {
            case O.setup:
                c.x = c.data.x + u * i,
                    c.y = c.data.y + h * i;
                break;
            case O.first:
            case O.replace:
                c.x += (c.data.x + u - c.x) * i,
                    c.y += (c.data.y + h - c.y) * i;
                break;
            case O.add:
                c.x += u * i,
                    c.y += h * i
        }
    }
}
    ;
let hr = bs;
hr.ENTRIES = 3;
hr.PREV_TIME = -3;
hr.PREV_X = -2;
hr.PREV_Y = -1;
hr.X = 1;
hr.Y = 2;
let mw = class Gr extends hr {
    constructor(e) {
        super(e)
    }
    getPropertyId() {
        return (2 << 24) + this.boneIndex
    }
    apply(e, n, s, r, i, o, l) {
        const a = this.frames
            , c = e.bones[this.boneIndex];
        if (!c.active)
            return;
        if (s < a[0]) {
            switch (o) {
                case O.setup:
                    c.scaleX = c.data.scaleX,
                        c.scaleY = c.data.scaleY;
                    return;
                case O.first:
                    c.scaleX += (c.data.scaleX - c.scaleX) * i,
                        c.scaleY += (c.data.scaleY - c.scaleY) * i
            }
            return
        }
        let u = 0
            , h = 0;
        if (s >= a[a.length - Gr.ENTRIES])
            u = a[a.length + Gr.PREV_X] * c.data.scaleX,
                h = a[a.length + Gr.PREV_Y] * c.data.scaleY;
        else {
            const d = xn.binarySearch(a, s, Gr.ENTRIES);
            u = a[d + Gr.PREV_X],
                h = a[d + Gr.PREV_Y];
            const f = a[d]
                , p = this.getCurvePercent(d / Gr.ENTRIES - 1, 1 - (s - f) / (a[d + Gr.PREV_TIME] - f));
            u = (u + (a[d + Gr.X] - u) * p) * c.data.scaleX,
                h = (h + (a[d + Gr.Y] - h) * p) * c.data.scaleY
        }
        if (i == 1)
            o == O.add ? (c.scaleX += u - c.data.scaleX,
                c.scaleY += h - c.data.scaleY) : (c.scaleX = u,
                    c.scaleY = h);
        else {
            let d = 0
                , f = 0;
            if (l == ct.mixOut)
                switch (o) {
                    case O.setup:
                        d = c.data.scaleX,
                            f = c.data.scaleY,
                            c.scaleX = d + (Math.abs(u) * F.signum(d) - d) * i,
                            c.scaleY = f + (Math.abs(h) * F.signum(f) - f) * i;
                        break;
                    case O.first:
                    case O.replace:
                        d = c.scaleX,
                            f = c.scaleY,
                            c.scaleX = d + (Math.abs(u) * F.signum(d) - d) * i,
                            c.scaleY = f + (Math.abs(h) * F.signum(f) - f) * i;
                        break;
                    case O.add:
                        d = c.scaleX,
                            f = c.scaleY,
                            c.scaleX = d + (Math.abs(u) * F.signum(d) - c.data.scaleX) * i,
                            c.scaleY = f + (Math.abs(h) * F.signum(f) - c.data.scaleY) * i
                }
            else
                switch (o) {
                    case O.setup:
                        d = Math.abs(c.data.scaleX) * F.signum(u),
                            f = Math.abs(c.data.scaleY) * F.signum(h),
                            c.scaleX = d + (u - d) * i,
                            c.scaleY = f + (h - f) * i;
                        break;
                    case O.first:
                    case O.replace:
                        d = Math.abs(c.scaleX) * F.signum(u),
                            f = Math.abs(c.scaleY) * F.signum(h),
                            c.scaleX = d + (u - d) * i,
                            c.scaleY = f + (h - f) * i;
                        break;
                    case O.add:
                        d = F.signum(u),
                            f = F.signum(h),
                            c.scaleX = Math.abs(c.scaleX) * d + (u - Math.abs(c.data.scaleX) * d) * i,
                            c.scaleY = Math.abs(c.scaleY) * f + (h - Math.abs(c.data.scaleY) * f) * i
                }
        }
    }
}
    , gw = class Hr extends hr {
        constructor(e) {
            super(e)
        }
        getPropertyId() {
            return (3 << 24) + this.boneIndex
        }
        apply(e, n, s, r, i, o, l) {
            const a = this.frames
                , c = e.bones[this.boneIndex];
            if (!c.active)
                return;
            if (s < a[0]) {
                switch (o) {
                    case O.setup:
                        c.shearX = c.data.shearX,
                            c.shearY = c.data.shearY;
                        return;
                    case O.first:
                        c.shearX += (c.data.shearX - c.shearX) * i,
                            c.shearY += (c.data.shearY - c.shearY) * i
                }
                return
            }
            let u = 0
                , h = 0;
            if (s >= a[a.length - Hr.ENTRIES])
                u = a[a.length + Hr.PREV_X],
                    h = a[a.length + Hr.PREV_Y];
            else {
                const d = xn.binarySearch(a, s, Hr.ENTRIES);
                u = a[d + Hr.PREV_X],
                    h = a[d + Hr.PREV_Y];
                const f = a[d]
                    , p = this.getCurvePercent(d / Hr.ENTRIES - 1, 1 - (s - f) / (a[d + Hr.PREV_TIME] - f));
                u = u + (a[d + Hr.X] - u) * p,
                    h = h + (a[d + Hr.Y] - h) * p
            }
            switch (o) {
                case O.setup:
                    c.shearX = c.data.shearX + u * i,
                        c.shearY = c.data.shearY + h * i;
                    break;
                case O.first:
                case O.replace:
                    c.shearX += (c.data.shearX + u - c.shearX) * i,
                        c.shearY += (c.data.shearY + h - c.shearY) * i;
                    break;
                case O.add:
                    c.shearX += u * i,
                        c.shearY += h * i
            }
        }
    }
    ;
const Zt = class extends Ks {
    constructor(e) {
        super(e),
            this.frames = Q.newFloatArray(e * Zt.ENTRIES)
    }
    getPropertyId() {
        return (5 << 24) + this.slotIndex
    }
    setFrame(e, n, s, r, i, o) {
        e *= Zt.ENTRIES,
            this.frames[e] = n,
            this.frames[e + Zt.R] = s,
            this.frames[e + Zt.G] = r,
            this.frames[e + Zt.B] = i,
            this.frames[e + Zt.A] = o
    }
    apply(e, n, s, r, i, o, l) {
        const a = e.slots[this.slotIndex];
        if (!a.bone.active)
            return;
        const c = this.frames;
        if (s < c[0]) {
            switch (o) {
                case O.setup:
                    a.color.setFromColor(a.data.color);
                    return;
                case O.first:
                    const p = a.color
                        , m = a.data.color;
                    p.add((m.r - p.r) * i, (m.g - p.g) * i, (m.b - p.b) * i, (m.a - p.a) * i)
            }
            return
        }
        let u = 0
            , h = 0
            , d = 0
            , f = 0;
        if (s >= c[c.length - Zt.ENTRIES]) {
            const p = c.length;
            u = c[p + Zt.PREV_R],
                h = c[p + Zt.PREV_G],
                d = c[p + Zt.PREV_B],
                f = c[p + Zt.PREV_A]
        } else {
            const p = xn.binarySearch(c, s, Zt.ENTRIES);
            u = c[p + Zt.PREV_R],
                h = c[p + Zt.PREV_G],
                d = c[p + Zt.PREV_B],
                f = c[p + Zt.PREV_A];
            const m = c[p]
                , g = this.getCurvePercent(p / Zt.ENTRIES - 1, 1 - (s - m) / (c[p + Zt.PREV_TIME] - m));
            u += (c[p + Zt.R] - u) * g,
                h += (c[p + Zt.G] - h) * g,
                d += (c[p + Zt.B] - d) * g,
                f += (c[p + Zt.A] - f) * g
        }
        if (i == 1)
            a.color.set(u, h, d, f);
        else {
            const p = a.color;
            o == O.setup && p.setFromColor(a.data.color),
                p.add((u - p.r) * i, (h - p.g) * i, (d - p.b) * i, (f - p.a) * i)
        }
    }
}
    ;
let Os = Zt;
Os.ENTRIES = 5;
Os.PREV_TIME = -5;
Os.PREV_R = -4;
Os.PREV_G = -3;
Os.PREV_B = -2;
Os.PREV_A = -1;
Os.R = 1;
Os.G = 2;
Os.B = 3;
Os.A = 4;
const vt = class extends Ks {
    constructor(e) {
        super(e),
            this.frames = Q.newFloatArray(e * vt.ENTRIES)
    }
    getPropertyId() {
        return (14 << 24) + this.slotIndex
    }
    setFrame(e, n, s, r, i, o, l, a, c) {
        e *= vt.ENTRIES,
            this.frames[e] = n,
            this.frames[e + vt.R] = s,
            this.frames[e + vt.G] = r,
            this.frames[e + vt.B] = i,
            this.frames[e + vt.A] = o,
            this.frames[e + vt.R2] = l,
            this.frames[e + vt.G2] = a,
            this.frames[e + vt.B2] = c
    }
    apply(e, n, s, r, i, o, l) {
        const a = e.slots[this.slotIndex];
        if (!a.bone.active)
            return;
        const c = this.frames;
        if (s < c[0]) {
            switch (o) {
                case O.setup:
                    a.color.setFromColor(a.data.color),
                        a.darkColor.setFromColor(a.data.darkColor);
                    return;
                case O.first:
                    const b = a.color
                        , v = a.darkColor
                        , _ = a.data.color
                        , y = a.data.darkColor;
                    b.add((_.r - b.r) * i, (_.g - b.g) * i, (_.b - b.b) * i, (_.a - b.a) * i),
                        v.add((y.r - v.r) * i, (y.g - v.g) * i, (y.b - v.b) * i, 0)
            }
            return
        }
        let u = 0
            , h = 0
            , d = 0
            , f = 0
            , p = 0
            , m = 0
            , g = 0;
        if (s >= c[c.length - vt.ENTRIES]) {
            const b = c.length;
            u = c[b + vt.PREV_R],
                h = c[b + vt.PREV_G],
                d = c[b + vt.PREV_B],
                f = c[b + vt.PREV_A],
                p = c[b + vt.PREV_R2],
                m = c[b + vt.PREV_G2],
                g = c[b + vt.PREV_B2]
        } else {
            const b = xn.binarySearch(c, s, vt.ENTRIES);
            u = c[b + vt.PREV_R],
                h = c[b + vt.PREV_G],
                d = c[b + vt.PREV_B],
                f = c[b + vt.PREV_A],
                p = c[b + vt.PREV_R2],
                m = c[b + vt.PREV_G2],
                g = c[b + vt.PREV_B2];
            const v = c[b]
                , _ = this.getCurvePercent(b / vt.ENTRIES - 1, 1 - (s - v) / (c[b + vt.PREV_TIME] - v));
            u += (c[b + vt.R] - u) * _,
                h += (c[b + vt.G] - h) * _,
                d += (c[b + vt.B] - d) * _,
                f += (c[b + vt.A] - f) * _,
                p += (c[b + vt.R2] - p) * _,
                m += (c[b + vt.G2] - m) * _,
                g += (c[b + vt.B2] - g) * _
        }
        if (i == 1)
            a.color.set(u, h, d, f),
                a.darkColor.set(p, m, g, 1);
        else {
            const b = a.color
                , v = a.darkColor;
            o == O.setup && (b.setFromColor(a.data.color),
                v.setFromColor(a.data.darkColor)),
                b.add((u - b.r) * i, (h - b.g) * i, (d - b.b) * i, (f - b.a) * i),
                v.add((p - v.r) * i, (m - v.g) * i, (g - v.b) * i, 0)
        }
    }
}
    ;
let wn = vt;
wn.ENTRIES = 8;
wn.PREV_TIME = -8;
wn.PREV_R = -7;
wn.PREV_G = -6;
wn.PREV_B = -5;
wn.PREV_A = -4;
wn.PREV_R2 = -3;
wn.PREV_G2 = -2;
wn.PREV_B2 = -1;
wn.R = 1;
wn.G = 2;
wn.B = 3;
wn.A = 4;
wn.R2 = 5;
wn.G2 = 6;
wn.B2 = 7;
let Dl = class {
    constructor(e) {
        this.frames = Q.newFloatArray(e),
            this.attachmentNames = new Array(e)
    }
    getPropertyId() {
        return (4 << 24) + this.slotIndex
    }
    getFrameCount() {
        return this.frames.length
    }
    setFrame(e, n, s) {
        this.frames[e] = n,
            this.attachmentNames[e] = s
    }
    apply(e, n, s, r, i, o, l) {
        const a = e.slots[this.slotIndex];
        if (!a.bone.active)
            return;
        if (l == ct.mixOut) {
            o == O.setup && this.setAttachment(e, a, a.data.attachmentName);
            return
        }
        const c = this.frames;
        if (s < c[0]) {
            (o == O.setup || o == O.first) && this.setAttachment(e, a, a.data.attachmentName);
            return
        }
        let u = 0;
        s >= c[c.length - 1] ? u = c.length - 1 : u = xn.binarySearch(c, s, 1) - 1;
        const h = this.attachmentNames[u];
        e.slots[this.slotIndex].setAttachment(h == null ? null : e.getAttachment(this.slotIndex, h))
    }
    setAttachment(e, n, s) {
        n.setAttachment(s == null ? null : e.getAttachment(this.slotIndex, s))
    }
}
    , gA = null
    , _w = class extends Ks {
        constructor(e) {
            super(e),
                this.frames = Q.newFloatArray(e),
                this.frameVertices = new Array(e),
                gA == null && (gA = Q.newFloatArray(64))
        }
        getPropertyId() {
            return (6 << 27) + Number(this.attachment.id) + this.slotIndex
        }
        setFrame(e, n, s) {
            this.frames[e] = n,
                this.frameVertices[e] = s
        }
        apply(e, n, s, r, i, o, l) {
            const a = e.slots[this.slotIndex];
            if (!a.bone.active)
                return;
            const c = a.getAttachment();
            if (!(c instanceof cl) || c.deformAttachment != this.attachment)
                return;
            const u = a.deform;
            u.length == 0 && (o = O.setup);
            const h = this.frameVertices
                , d = h[0].length
                , f = this.frames;
            if (s < f[0]) {
                const y = c;
                switch (o) {
                    case O.setup:
                        u.length = 0;
                        return;
                    case O.first:
                        if (i == 1) {
                            u.length = 0;
                            break
                        }
                        const x = Q.setArraySize(u, d);
                        if (y.bones == null) {
                            const w = y.vertices;
                            for (let S = 0; S < d; S++)
                                x[S] += (w[S] - x[S]) * i
                        } else {
                            i = 1 - i;
                            for (let w = 0; w < d; w++)
                                x[w] *= i
                        }
                }
                return
            }
            const p = Q.setArraySize(u, d);
            if (s >= f[f.length - 1]) {
                const y = h[f.length - 1];
                if (i == 1)
                    if (o == O.add) {
                        const x = c;
                        if (x.bones == null) {
                            const w = x.vertices;
                            for (let S = 0; S < d; S++)
                                p[S] += y[S] - w[S]
                        } else
                            for (let w = 0; w < d; w++)
                                p[w] += y[w]
                    } else
                        Q.arrayCopy(y, 0, p, 0, d);
                else
                    switch (o) {
                        case O.setup:
                            {
                                const w = c;
                                if (w.bones == null) {
                                    const S = w.vertices;
                                    for (let E = 0; E < d; E++) {
                                        const C = S[E];
                                        p[E] = C + (y[E] - C) * i
                                    }
                                } else
                                    for (let S = 0; S < d; S++)
                                        p[S] = y[S] * i;
                                break
                            }
                        case O.first:
                        case O.replace:
                            for (let w = 0; w < d; w++)
                                p[w] += (y[w] - p[w]) * i;
                            break;
                        case O.add:
                            const x = c;
                            if (x.bones == null) {
                                const w = x.vertices;
                                for (let S = 0; S < d; S++)
                                    p[S] += (y[S] - w[S]) * i
                            } else
                                for (let w = 0; w < d; w++)
                                    p[w] += y[w] * i
                    }
                return
            }
            const m = xn.binarySearch(f, s)
                , g = h[m - 1]
                , b = h[m]
                , v = f[m]
                , _ = this.getCurvePercent(m - 1, 1 - (s - v) / (f[m - 1] - v));
            if (i == 1)
                if (o == O.add) {
                    const y = c;
                    if (y.bones == null) {
                        const x = y.vertices;
                        for (let w = 0; w < d; w++) {
                            const S = g[w];
                            p[w] += S + (b[w] - S) * _ - x[w]
                        }
                    } else
                        for (let x = 0; x < d; x++) {
                            const w = g[x];
                            p[x] += w + (b[x] - w) * _
                        }
                } else
                    for (let y = 0; y < d; y++) {
                        const x = g[y];
                        p[y] = x + (b[y] - x) * _
                    }
            else
                switch (o) {
                    case O.setup:
                        {
                            const x = c;
                            if (x.bones == null) {
                                const w = x.vertices;
                                for (let S = 0; S < d; S++) {
                                    const E = g[S]
                                        , C = w[S];
                                    p[S] = C + (E + (b[S] - E) * _ - C) * i
                                }
                            } else
                                for (let w = 0; w < d; w++) {
                                    const S = g[w];
                                    p[w] = (S + (b[w] - S) * _) * i
                                }
                            break
                        }
                    case O.first:
                    case O.replace:
                        for (let x = 0; x < d; x++) {
                            const w = g[x];
                            p[x] += (w + (b[x] - w) * _ - p[x]) * i
                        }
                        break;
                    case O.add:
                        const y = c;
                        if (y.bones == null) {
                            const x = y.vertices;
                            for (let w = 0; w < d; w++) {
                                const S = g[w];
                                p[w] += (S + (b[w] - S) * _ - x[w]) * i
                            }
                        } else
                            for (let x = 0; x < d; x++) {
                                const w = g[x];
                                p[x] += (w + (b[x] - w) * _) * i
                            }
                }
        }
    }
    , $_ = class {
        constructor(e) {
            this.frames = Q.newFloatArray(e),
                this.events = new Array(e)
        }
        getPropertyId() {
            return 7 << 24
        }
        getFrameCount() {
            return this.frames.length
        }
        setFrame(e, n) {
            this.frames[e] = n.time,
                this.events[e] = n
        }
        apply(e, n, s, r, i, o, l) {
            if (r == null)
                return;
            const a = this.frames
                , c = this.frames.length;
            if (n > s)
                this.apply(e, n, Number.MAX_VALUE, r, i, o, l),
                    n = -1;
            else if (n >= a[c - 1])
                return;
            if (s < a[0])
                return;
            let u = 0;
            if (n < a[0])
                u = 0;
            else {
                u = xn.binarySearch(a, n);
                const h = a[u];
                for (; u > 0 && a[u - 1] == h;)
                    u--
            }
            for (; u < c && s >= a[u]; u++)
                r.push(this.events[u])
        }
    }
    , Cu = class {
        constructor(e) {
            this.frames = Q.newFloatArray(e),
                this.drawOrders = new Array(e)
        }
        getPropertyId() {
            return 8 << 24
        }
        getFrameCount() {
            return this.frames.length
        }
        setFrame(e, n, s) {
            this.frames[e] = n,
                this.drawOrders[e] = s
        }
        apply(e, n, s, r, i, o, l) {
            const a = e.drawOrder
                , c = e.slots;
            if (l == ct.mixOut && o == O.setup) {
                Q.arrayCopy(e.slots, 0, e.drawOrder, 0, e.slots.length);
                return
            }
            const u = this.frames;
            if (s < u[0]) {
                (o == O.setup || o == O.first) && Q.arrayCopy(e.slots, 0, e.drawOrder, 0, e.slots.length);
                return
            }
            let h = 0;
            s >= u[u.length - 1] ? h = u.length - 1 : h = xn.binarySearch(u, s) - 1;
            const d = this.drawOrders[h];
            if (d == null)
                Q.arrayCopy(c, 0, a, 0, c.length);
            else
                for (let f = 0, p = d.length; f < p; f++)
                    a[f] = c[d[f]]
        }
    }
    ;
const Tt = class extends Ks {
    constructor(e) {
        super(e),
            this.frames = Q.newFloatArray(e * Tt.ENTRIES)
    }
    getPropertyId() {
        return (9 << 24) + this.ikConstraintIndex
    }
    setFrame(e, n, s, r, i, o, l) {
        e *= Tt.ENTRIES,
            this.frames[e] = n,
            this.frames[e + Tt.MIX] = s,
            this.frames[e + Tt.SOFTNESS] = r,
            this.frames[e + Tt.BEND_DIRECTION] = i,
            this.frames[e + Tt.COMPRESS] = o ? 1 : 0,
            this.frames[e + Tt.STRETCH] = l ? 1 : 0
    }
    apply(e, n, s, r, i, o, l) {
        const a = this.frames
            , c = e.ikConstraints[this.ikConstraintIndex];
        if (!c.active)
            return;
        if (s < a[0]) {
            switch (o) {
                case O.setup:
                    c.mix = c.data.mix,
                        c.softness = c.data.softness,
                        c.bendDirection = c.data.bendDirection,
                        c.compress = c.data.compress,
                        c.stretch = c.data.stretch;
                    return;
                case O.first:
                    c.mix += (c.data.mix - c.mix) * i,
                        c.softness += (c.data.softness - c.softness) * i,
                        c.bendDirection = c.data.bendDirection,
                        c.compress = c.data.compress,
                        c.stretch = c.data.stretch
            }
            return
        }
        if (s >= a[a.length - Tt.ENTRIES]) {
            o == O.setup ? (c.mix = c.data.mix + (a[a.length + Tt.PREV_MIX] - c.data.mix) * i,
                c.softness = c.data.softness + (a[a.length + Tt.PREV_SOFTNESS] - c.data.softness) * i,
                l == ct.mixOut ? (c.bendDirection = c.data.bendDirection,
                    c.compress = c.data.compress,
                    c.stretch = c.data.stretch) : (c.bendDirection = a[a.length + Tt.PREV_BEND_DIRECTION],
                        c.compress = a[a.length + Tt.PREV_COMPRESS] != 0,
                        c.stretch = a[a.length + Tt.PREV_STRETCH] != 0)) : (c.mix += (a[a.length + Tt.PREV_MIX] - c.mix) * i,
                            c.softness += (a[a.length + Tt.PREV_SOFTNESS] - c.softness) * i,
                            l == ct.mixIn && (c.bendDirection = a[a.length + Tt.PREV_BEND_DIRECTION],
                                c.compress = a[a.length + Tt.PREV_COMPRESS] != 0,
                                c.stretch = a[a.length + Tt.PREV_STRETCH] != 0));
            return
        }
        const u = xn.binarySearch(a, s, Tt.ENTRIES)
            , h = a[u + Tt.PREV_MIX]
            , d = a[u + Tt.PREV_SOFTNESS]
            , f = a[u]
            , p = this.getCurvePercent(u / Tt.ENTRIES - 1, 1 - (s - f) / (a[u + Tt.PREV_TIME] - f));
        o == O.setup ? (c.mix = c.data.mix + (h + (a[u + Tt.MIX] - h) * p - c.data.mix) * i,
            c.softness = c.data.softness + (d + (a[u + Tt.SOFTNESS] - d) * p - c.data.softness) * i,
            l == ct.mixOut ? (c.bendDirection = c.data.bendDirection,
                c.compress = c.data.compress,
                c.stretch = c.data.stretch) : (c.bendDirection = a[u + Tt.PREV_BEND_DIRECTION],
                    c.compress = a[u + Tt.PREV_COMPRESS] != 0,
                    c.stretch = a[u + Tt.PREV_STRETCH] != 0)) : (c.mix += (h + (a[u + Tt.MIX] - h) * p - c.mix) * i,
                        c.softness += (d + (a[u + Tt.SOFTNESS] - d) * p - c.softness) * i,
                        l == ct.mixIn && (c.bendDirection = a[u + Tt.PREV_BEND_DIRECTION],
                            c.compress = a[u + Tt.PREV_COMPRESS] != 0,
                            c.stretch = a[u + Tt.PREV_STRETCH] != 0))
    }
}
    ;
let as = Tt;
as.ENTRIES = 6;
as.PREV_TIME = -6;
as.PREV_MIX = -5;
as.PREV_SOFTNESS = -4;
as.PREV_BEND_DIRECTION = -3;
as.PREV_COMPRESS = -2;
as.PREV_STRETCH = -1;
as.MIX = 1;
as.SOFTNESS = 2;
as.BEND_DIRECTION = 3;
as.COMPRESS = 4;
as.STRETCH = 5;
const Qt = class extends Ks {
    constructor(e) {
        super(e),
            this.frames = Q.newFloatArray(e * Qt.ENTRIES)
    }
    getPropertyId() {
        return (10 << 24) + this.transformConstraintIndex
    }
    setFrame(e, n, s, r, i, o) {
        e *= Qt.ENTRIES,
            this.frames[e] = n,
            this.frames[e + Qt.ROTATE] = s,
            this.frames[e + Qt.TRANSLATE] = r,
            this.frames[e + Qt.SCALE] = i,
            this.frames[e + Qt.SHEAR] = o
    }
    apply(e, n, s, r, i, o, l) {
        const a = this.frames
            , c = e.transformConstraints[this.transformConstraintIndex];
        if (!c.active)
            return;
        if (s < a[0]) {
            const p = c.data;
            switch (o) {
                case O.setup:
                    c.rotateMix = p.rotateMix,
                        c.translateMix = p.translateMix,
                        c.scaleMix = p.scaleMix,
                        c.shearMix = p.shearMix;
                    return;
                case O.first:
                    c.rotateMix += (p.rotateMix - c.rotateMix) * i,
                        c.translateMix += (p.translateMix - c.translateMix) * i,
                        c.scaleMix += (p.scaleMix - c.scaleMix) * i,
                        c.shearMix += (p.shearMix - c.shearMix) * i
            }
            return
        }
        let u = 0
            , h = 0
            , d = 0
            , f = 0;
        if (s >= a[a.length - Qt.ENTRIES]) {
            const p = a.length;
            u = a[p + Qt.PREV_ROTATE],
                h = a[p + Qt.PREV_TRANSLATE],
                d = a[p + Qt.PREV_SCALE],
                f = a[p + Qt.PREV_SHEAR]
        } else {
            const p = xn.binarySearch(a, s, Qt.ENTRIES);
            u = a[p + Qt.PREV_ROTATE],
                h = a[p + Qt.PREV_TRANSLATE],
                d = a[p + Qt.PREV_SCALE],
                f = a[p + Qt.PREV_SHEAR];
            const m = a[p]
                , g = this.getCurvePercent(p / Qt.ENTRIES - 1, 1 - (s - m) / (a[p + Qt.PREV_TIME] - m));
            u += (a[p + Qt.ROTATE] - u) * g,
                h += (a[p + Qt.TRANSLATE] - h) * g,
                d += (a[p + Qt.SCALE] - d) * g,
                f += (a[p + Qt.SHEAR] - f) * g
        }
        if (o == O.setup) {
            const p = c.data;
            c.rotateMix = p.rotateMix + (u - p.rotateMix) * i,
                c.translateMix = p.translateMix + (h - p.translateMix) * i,
                c.scaleMix = p.scaleMix + (d - p.scaleMix) * i,
                c.shearMix = p.shearMix + (f - p.shearMix) * i
        } else
            c.rotateMix += (u - c.rotateMix) * i,
                c.translateMix += (h - c.translateMix) * i,
                c.scaleMix += (d - c.scaleMix) * i,
                c.shearMix += (f - c.shearMix) * i
    }
}
    ;
let Ns = Qt;
Ns.ENTRIES = 5;
Ns.PREV_TIME = -5;
Ns.PREV_ROTATE = -4;
Ns.PREV_TRANSLATE = -3;
Ns.PREV_SCALE = -2;
Ns.PREV_SHEAR = -1;
Ns.ROTATE = 1;
Ns.TRANSLATE = 2;
Ns.SCALE = 3;
Ns.SHEAR = 4;
const Wr = class extends Ks {
    constructor(e) {
        super(e),
            this.frames = Q.newFloatArray(e * Wr.ENTRIES)
    }
    getPropertyId() {
        return (11 << 24) + this.pathConstraintIndex
    }
    setFrame(e, n, s) {
        e *= Wr.ENTRIES,
            this.frames[e] = n,
            this.frames[e + Wr.VALUE] = s
    }
    apply(e, n, s, r, i, o, l) {
        const a = this.frames
            , c = e.pathConstraints[this.pathConstraintIndex];
        if (!c.active)
            return;
        if (s < a[0]) {
            switch (o) {
                case O.setup:
                    c.position = c.data.position;
                    return;
                case O.first:
                    c.position += (c.data.position - c.position) * i
            }
            return
        }
        let u = 0;
        if (s >= a[a.length - Wr.ENTRIES])
            u = a[a.length + Wr.PREV_VALUE];
        else {
            const h = xn.binarySearch(a, s, Wr.ENTRIES);
            u = a[h + Wr.PREV_VALUE];
            const d = a[h]
                , f = this.getCurvePercent(h / Wr.ENTRIES - 1, 1 - (s - d) / (a[h + Wr.PREV_TIME] - d));
            u += (a[h + Wr.VALUE] - u) * f
        }
        o == O.setup ? c.position = c.data.position + (u - c.data.position) * i : c.position += (u - c.position) * i
    }
}
    ;
let zi = Wr;
zi.ENTRIES = 2;
zi.PREV_TIME = -2;
zi.PREV_VALUE = -1;
zi.VALUE = 1;
let yw = class oa extends zi {
    constructor(e) {
        super(e)
    }
    getPropertyId() {
        return (12 << 24) + this.pathConstraintIndex
    }
    apply(e, n, s, r, i, o, l) {
        const a = this.frames
            , c = e.pathConstraints[this.pathConstraintIndex];
        if (!c.active)
            return;
        if (s < a[0]) {
            switch (o) {
                case O.setup:
                    c.spacing = c.data.spacing;
                    return;
                case O.first:
                    c.spacing += (c.data.spacing - c.spacing) * i
            }
            return
        }
        let u = 0;
        if (s >= a[a.length - oa.ENTRIES])
            u = a[a.length + oa.PREV_VALUE];
        else {
            const h = xn.binarySearch(a, s, oa.ENTRIES);
            u = a[h + oa.PREV_VALUE];
            const d = a[h]
                , f = this.getCurvePercent(h / oa.ENTRIES - 1, 1 - (s - d) / (a[h + oa.PREV_TIME] - d));
            u += (a[h + oa.VALUE] - u) * f
        }
        o == O.setup ? c.spacing = c.data.spacing + (u - c.data.spacing) * i : c.spacing += (u - c.spacing) * i
    }
}
    ;
const vs = class extends Ks {
    constructor(e) {
        super(e),
            this.frames = Q.newFloatArray(e * vs.ENTRIES)
    }
    getPropertyId() {
        return (13 << 24) + this.pathConstraintIndex
    }
    setFrame(e, n, s, r) {
        e *= vs.ENTRIES,
            this.frames[e] = n,
            this.frames[e + vs.ROTATE] = s,
            this.frames[e + vs.TRANSLATE] = r
    }
    apply(e, n, s, r, i, o, l) {
        const a = this.frames
            , c = e.pathConstraints[this.pathConstraintIndex];
        if (!c.active)
            return;
        if (s < a[0]) {
            switch (o) {
                case O.setup:
                    c.rotateMix = c.data.rotateMix,
                        c.translateMix = c.data.translateMix;
                    return;
                case O.first:
                    c.rotateMix += (c.data.rotateMix - c.rotateMix) * i,
                        c.translateMix += (c.data.translateMix - c.translateMix) * i
            }
            return
        }
        let u = 0
            , h = 0;
        if (s >= a[a.length - vs.ENTRIES])
            u = a[a.length + vs.PREV_ROTATE],
                h = a[a.length + vs.PREV_TRANSLATE];
        else {
            const d = xn.binarySearch(a, s, vs.ENTRIES);
            u = a[d + vs.PREV_ROTATE],
                h = a[d + vs.PREV_TRANSLATE];
            const f = a[d]
                , p = this.getCurvePercent(d / vs.ENTRIES - 1, 1 - (s - f) / (a[d + vs.PREV_TIME] - f));
            u += (a[d + vs.ROTATE] - u) * p,
                h += (a[d + vs.TRANSLATE] - h) * p
        }
        o == O.setup ? (c.rotateMix = c.data.rotateMix + (u - c.data.rotateMix) * i,
            c.translateMix = c.data.translateMix + (h - c.data.translateMix) * i) : (c.rotateMix += (u - c.rotateMix) * i,
                c.translateMix += (h - c.translateMix) * i)
    }
}
    ;
let ui = vs;
ui.ENTRIES = 3;
ui.PREV_TIME = -3;
ui.PREV_ROTATE = -2;
ui.PREV_TRANSLATE = -1;
ui.ROTATE = 1;
ui.TRANSLATE = 2;
const en = class {
    constructor(e) {
        this.tracks = new Array,
            this.timeScale = 1,
            this.unkeyedState = 0,
            this.events = new Array,
            this.listeners = new Array,
            this.queue = new bw(this),
            this.propertyIDs = new l5,
            this.animationsChanged = !1,
            this.trackEntryPool = new N_(() => new U_),
            this.data = e
    }
    update(e) {
        e *= this.timeScale;
        const n = this.tracks;
        for (let s = 0, r = n.length; s < r; s++) {
            const i = n[s];
            if (i == null)
                continue;
            i.animationLast = i.nextAnimationLast,
                i.trackLast = i.nextTrackLast;
            let o = e * i.timeScale;
            if (i.delay > 0) {
                if (i.delay -= o,
                    i.delay > 0)
                    continue;
                o = -i.delay,
                    i.delay = 0
            }
            let l = i.next;
            if (l != null) {
                const a = i.trackLast - l.delay;
                if (a >= 0) {
                    for (l.delay = 0,
                        l.trackTime += i.timeScale == 0 ? 0 : (a / i.timeScale + e) * l.timeScale,
                        i.trackTime += o,
                        this.setCurrent(s, l, !0); l.mixingFrom != null;)
                        l.mixTime += e,
                            l = l.mixingFrom;
                    continue
                }
            } else if (i.trackLast >= i.trackEnd && i.mixingFrom == null) {
                n[s] = null,
                    this.queue.end(i),
                    this.disposeNext(i);
                continue
            }
            if (i.mixingFrom != null && this.updateMixingFrom(i, e)) {
                let a = i.mixingFrom;
                for (i.mixingFrom = null,
                    a != null && (a.mixingTo = null); a != null;)
                    this.queue.end(a),
                        a = a.mixingFrom
            }
            i.trackTime += o
        }
        this.queue.drain()
    }
    updateMixingFrom(e, n) {
        const s = e.mixingFrom;
        if (s == null)
            return !0;
        const r = this.updateMixingFrom(s, n);
        return s.animationLast = s.nextAnimationLast,
            s.trackLast = s.nextTrackLast,
            e.mixTime > 0 && e.mixTime >= e.mixDuration ? ((s.totalAlpha == 0 || e.mixDuration == 0) && (e.mixingFrom = s.mixingFrom,
                s.mixingFrom != null && (s.mixingFrom.mixingTo = e),
                e.interruptAlpha = s.interruptAlpha,
                this.queue.end(s)),
                r) : (s.trackTime += n * s.timeScale,
                    e.mixTime += n,
                    !1)
    }
    apply(e) {
        if (e == null)
            throw new Error("skeleton cannot be null.");
        this.animationsChanged && this._animationsChanged();
        const n = this.events
            , s = this.tracks;
        let r = !1;
        for (let l = 0, a = s.length; l < a; l++) {
            const c = s[l];
            if (c == null || c.delay > 0)
                continue;
            r = !0;
            const u = l == 0 ? O.first : c.mixBlend;
            let h = c.alpha;
            c.mixingFrom != null ? h *= this.applyMixingFrom(c, e, u) : c.trackTime >= c.trackEnd && c.next == null && (h = 0);
            const d = c.animationLast
                , f = c.getAnimationTime()
                , p = c.animation.timelines.length
                , m = c.animation.timelines;
            if (l == 0 && h == 1 || u == O.add)
                for (let g = 0; g < p; g++) {
                    const b = m[g];
                    b instanceof Dl ? this.applyAttachmentTimeline(b, e, f, u, !0) : b.apply(e, d, f, n, h, u, ct.mixIn)
                }
            else {
                const g = c.timelineMode
                    , b = c.timelinesRotation.length == 0;
                b && Q.setArraySize(c.timelinesRotation, p << 1, null);
                const v = c.timelinesRotation;
                for (let _ = 0; _ < p; _++) {
                    const y = m[_]
                        , x = g[_] == en.SUBSEQUENT ? u : O.setup;
                    y instanceof ts ? this.applyRotateTimeline(y, e, f, h, x, v, _ << 1, b) : y instanceof Dl ? this.applyAttachmentTimeline(y, e, f, u, !0) : y.apply(e, d, f, n, h, x, ct.mixIn)
                }
            }
            this.queueEvents(c, f),
                n.length = 0,
                c.nextAnimationLast = f,
                c.nextTrackLast = c.trackTime
        }
        const i = this.unkeyedState + en.SETUP
            , o = e.slots;
        for (let l = 0, a = e.slots.length; l < a; l++) {
            const c = o[l];
            if (c.attachmentState == i) {
                const u = c.data.attachmentName;
                c.setAttachment(u == null ? null : e.getAttachment(c.data.index, u))
            }
        }
        return this.unkeyedState += 2,
            this.queue.drain(),
            r
    }
    applyMixingFrom(e, n, s) {
        const r = e.mixingFrom;
        r.mixingFrom != null && this.applyMixingFrom(r, n, s);
        let i = 0;
        e.mixDuration == 0 ? (i = 1,
            s == O.first && (s = O.setup)) : (i = e.mixTime / e.mixDuration,
                i > 1 && (i = 1),
                s != O.first && (s = r.mixBlend));
        const o = i < r.eventThreshold ? this.events : null
            , l = i < r.attachmentThreshold
            , a = i < r.drawOrderThreshold
            , c = r.animationLast
            , u = r.getAnimationTime()
            , h = r.animation.timelines.length
            , d = r.animation.timelines
            , f = r.alpha * e.interruptAlpha
            , p = f * (1 - i);
        if (s == O.add)
            for (let m = 0; m < h; m++)
                d[m].apply(n, c, u, o, p, s, ct.mixOut);
        else {
            const m = r.timelineMode
                , g = r.timelineHoldMix
                , b = r.timelinesRotation.length == 0;
            b && Q.setArraySize(r.timelinesRotation, h << 1, null);
            const v = r.timelinesRotation;
            r.totalAlpha = 0;
            for (let _ = 0; _ < h; _++) {
                const y = d[_];
                let x = ct.mixOut, w, S = 0;
                switch (m[_]) {
                    case en.SUBSEQUENT:
                        if (!a && y instanceof Cu)
                            continue;
                        w = s,
                            S = p;
                        break;
                    case en.FIRST:
                        w = O.setup,
                            S = p;
                        break;
                    case en.HOLD_SUBSEQUENT:
                        w = s,
                            S = f;
                        break;
                    case en.HOLD_FIRST:
                        w = O.setup,
                            S = f;
                        break;
                    default:
                        w = O.setup;
                        const E = g[_];
                        S = f * Math.max(0, 1 - E.mixTime / E.mixDuration);
                        break
                }
                r.totalAlpha += S,
                    y instanceof ts ? this.applyRotateTimeline(y, n, u, S, w, v, _ << 1, b) : y instanceof Dl ? this.applyAttachmentTimeline(y, n, u, w, l) : (a && y instanceof Cu && w == O.setup && (x = ct.mixIn),
                        y.apply(n, c, u, o, S, w, x))
            }
        }
        return e.mixDuration > 0 && this.queueEvents(r, u),
            this.events.length = 0,
            r.nextAnimationLast = u,
            r.nextTrackLast = r.trackTime,
            i
    }
    applyAttachmentTimeline(e, n, s, r, i) {
        const o = n.slots[e.slotIndex];
        if (!o.bone.active)
            return;
        const l = e.frames;
        if (s < l[0])
            (r == O.setup || r == O.first) && this.setAttachment(n, o, o.data.attachmentName, i);
        else {
            let a;
            s >= l[l.length - 1] ? a = l.length - 1 : a = xn.binarySearch(l, s) - 1,
                this.setAttachment(n, o, e.attachmentNames[a], i)
        }
        o.attachmentState <= this.unkeyedState && (o.attachmentState = this.unkeyedState + en.SETUP)
    }
    setAttachment(e, n, s, r) {
        n.setAttachment(s == null ? null : e.getAttachment(n.data.index, s)),
            r && (n.attachmentState = this.unkeyedState + en.CURRENT)
    }
    applyRotateTimeline(e, n, s, r, i, o, l, a) {
        if (a && (o[l] = 0),
            r == 1) {
            e.apply(n, 0, s, null, 1, i, ct.mixIn);
            return
        }
        const c = e
            , u = c.frames
            , h = n.bones[c.boneIndex];
        if (!h.active)
            return;
        let d = 0
            , f = 0;
        if (s < u[0])
            switch (i) {
                case O.setup:
                    h.rotation = h.data.rotation;
                default:
                    return;
                case O.first:
                    d = h.rotation,
                        f = h.data.rotation
            }
        else if (d = i == O.setup ? h.data.rotation : h.rotation,
            s >= u[u.length - ts.ENTRIES])
            f = h.data.rotation + u[u.length + ts.PREV_ROTATION];
        else {
            const g = xn.binarySearch(u, s, ts.ENTRIES)
                , b = u[g + ts.PREV_ROTATION]
                , v = u[g]
                , _ = c.getCurvePercent((g >> 1) - 1, 1 - (s - v) / (u[g + ts.PREV_TIME] - v));
            f = u[g + ts.ROTATION] - b,
                f -= (16384 - (16384.499999999996 - f / 360 | 0)) * 360,
                f = b + f * _ + h.data.rotation,
                f -= (16384 - (16384.499999999996 - f / 360 | 0)) * 360
        }
        let p = 0
            , m = f - d;
        if (m -= (16384 - (16384.499999999996 - m / 360 | 0)) * 360,
            m == 0)
            p = o[l];
        else {
            let g = 0
                , b = 0;
            a ? (g = 0,
                b = m) : (g = o[l],
                    b = o[l + 1]);
            const v = m > 0;
            let _ = g >= 0;
            F.signum(b) != F.signum(m) && Math.abs(b) <= 90 && (Math.abs(g) > 180 && (g += 360 * F.signum(g)),
                _ = v),
                p = m + g - g % 360,
                _ != v && (p += 360 * F.signum(g)),
                o[l] = p
        }
        o[l + 1] = m,
            d += p * r,
            h.rotation = d - (16384 - (16384.499999999996 - d / 360 | 0)) * 360
    }
    queueEvents(e, n) {
        const s = e.animationStart
            , r = e.animationEnd
            , i = r - s
            , o = e.trackLast % i
            , l = this.events;
        let a = 0;
        const c = l.length;
        for (; a < c; a++) {
            const h = l[a];
            if (h.time < o)
                break;
            h.time > r || this.queue.event(e, h)
        }
        let u = !1;
        for (e.loop ? u = i == 0 || o > e.trackTime % i : u = n >= r && e.animationLast < r,
            u && this.queue.complete(e); a < c; a++)
            l[a].time < s || this.queue.event(e, l[a])
    }
    clearTracks() {
        const e = this.queue.drainDisabled;
        this.queue.drainDisabled = !0;
        for (let n = 0, s = this.tracks.length; n < s; n++)
            this.clearTrack(n);
        this.tracks.length = 0,
            this.queue.drainDisabled = e,
            this.queue.drain()
    }
    clearTrack(e) {
        if (e >= this.tracks.length)
            return;
        const n = this.tracks[e];
        if (n == null)
            return;
        this.queue.end(n),
            this.disposeNext(n);
        let s = n;
        for (; ;) {
            const r = s.mixingFrom;
            if (r == null)
                break;
            this.queue.end(r),
                s.mixingFrom = null,
                s.mixingTo = null,
                s = r
        }
        this.tracks[n.trackIndex] = null,
            this.queue.drain()
    }
    setCurrent(e, n, s) {
        const r = this.expandToIndex(e);
        this.tracks[e] = n,
            r != null && (s && this.queue.interrupt(r),
                n.mixingFrom = r,
                r.mixingTo = n,
                n.mixTime = 0,
                r.mixingFrom != null && r.mixDuration > 0 && (n.interruptAlpha *= Math.min(1, r.mixTime / r.mixDuration)),
                r.timelinesRotation.length = 0),
            this.queue.start(n)
    }
    setAnimation(e, n, s) {
        const r = this.data.skeletonData.findAnimation(n);
        if (r == null)
            throw new Error(`Animation not found: ${n}`);
        return this.setAnimationWith(e, r, s)
    }
    setAnimationWith(e, n, s) {
        if (n == null)
            throw new Error("animation cannot be null.");
        let r = !0
            , i = this.expandToIndex(e);
        i != null && (i.nextTrackLast == -1 ? (this.tracks[e] = i.mixingFrom,
            this.queue.interrupt(i),
            this.queue.end(i),
            this.disposeNext(i),
            i = i.mixingFrom,
            r = !1) : this.disposeNext(i));
        const o = this.trackEntry(e, n, s, i);
        return this.setCurrent(e, o, r),
            this.queue.drain(),
            o
    }
    addAnimation(e, n, s, r) {
        const i = this.data.skeletonData.findAnimation(n);
        if (i == null)
            throw new Error(`Animation not found: ${n}`);
        return this.addAnimationWith(e, i, s, r)
    }
    addAnimationWith(e, n, s, r) {
        if (n == null)
            throw new Error("animation cannot be null.");
        let i = this.expandToIndex(e);
        if (i != null)
            for (; i.next != null;)
                i = i.next;
        const o = this.trackEntry(e, n, s, i);
        if (i == null)
            this.setCurrent(e, o, !0),
                this.queue.drain();
        else if (i.next = o,
            r <= 0) {
            const l = i.animationEnd - i.animationStart;
            l != 0 ? (i.loop ? r += l * (1 + (i.trackTime / l | 0)) : r += Math.max(l, i.trackTime),
                r -= this.data.getMix(i.animation, n)) : r = i.trackTime
        }
        return o.delay = r,
            o
    }
    setEmptyAnimation(e, n) {
        const s = this.setAnimationWith(e, en.emptyAnimation, !1);
        return s.mixDuration = n,
            s.trackEnd = n,
            s
    }
    addEmptyAnimation(e, n, s) {
        s <= 0 && (s -= n);
        const r = this.addAnimationWith(e, en.emptyAnimation, !1, s);
        return r.mixDuration = n,
            r.trackEnd = n,
            r
    }
    setEmptyAnimations(e) {
        const n = this.queue.drainDisabled;
        this.queue.drainDisabled = !0;
        for (let s = 0, r = this.tracks.length; s < r; s++) {
            const i = this.tracks[s];
            i != null && this.setEmptyAnimation(i.trackIndex, e)
        }
        this.queue.drainDisabled = n,
            this.queue.drain()
    }
    expandToIndex(e) {
        return e < this.tracks.length ? this.tracks[e] : (Q.ensureArrayCapacity(this.tracks, e + 1, null),
            this.tracks.length = e + 1,
            null)
    }
    trackEntry(e, n, s, r) {
        const i = this.trackEntryPool.obtain();
        return i.trackIndex = e,
            i.animation = n,
            i.loop = s,
            i.holdPrevious = !1,
            i.eventThreshold = 0,
            i.attachmentThreshold = 0,
            i.drawOrderThreshold = 0,
            i.animationStart = 0,
            i.animationEnd = n.duration,
            i.animationLast = -1,
            i.nextAnimationLast = -1,
            i.delay = 0,
            i.trackTime = 0,
            i.trackLast = -1,
            i.nextTrackLast = -1,
            i.trackEnd = Number.MAX_VALUE,
            i.timeScale = 1,
            i.alpha = 1,
            i.interruptAlpha = 1,
            i.mixTime = 0,
            i.mixDuration = r == null ? 0 : this.data.getMix(r.animation, n),
            i.mixBlend = O.replace,
            i
    }
    disposeNext(e) {
        let n = e.next;
        for (; n != null;)
            this.queue.dispose(n),
                n = n.next;
        e.next = null
    }
    _animationsChanged() {
        this.animationsChanged = !1,
            this.propertyIDs.clear();
        for (let e = 0, n = this.tracks.length; e < n; e++) {
            let s = this.tracks[e];
            if (s != null) {
                for (; s.mixingFrom != null;)
                    s = s.mixingFrom;
                do
                    (s.mixingFrom == null || s.mixBlend != O.add) && this.computeHold(s),
                        s = s.mixingTo;
                while (s != null)
            }
        }
    }
    computeHold(e) {
        const n = e.mixingTo
            , s = e.animation.timelines
            , r = e.animation.timelines.length
            , i = Q.setArraySize(e.timelineMode, r);
        e.timelineHoldMix.length = 0;
        const o = Q.setArraySize(e.timelineHoldMix, r)
            , l = this.propertyIDs;
        if (n != null && n.holdPrevious) {
            for (let a = 0; a < r; a++)
                i[a] = l.add(s[a].getPropertyId()) ? en.HOLD_FIRST : en.HOLD_SUBSEQUENT;
            return
        }
        e: for (let a = 0; a < r; a++) {
            const c = s[a]
                , u = c.getPropertyId();
            if (!l.add(u))
                i[a] = en.SUBSEQUENT;
            else if (n == null || c instanceof Dl || c instanceof Cu || c instanceof $_ || !n.animation.hasTimeline(u))
                i[a] = en.FIRST;
            else {
                for (let h = n.mixingTo; h != null; h = h.mixingTo)
                    if (!h.animation.hasTimeline(u)) {
                        if (e.mixDuration > 0) {
                            i[a] = en.HOLD_MIX,
                                o[a] = h;
                            continue e
                        }
                        break
                    }
                i[a] = en.HOLD_FIRST
            }
        }
    }
    getCurrent(e) {
        return e >= this.tracks.length ? null : this.tracks[e]
    }
    addListener(e) {
        if (e == null)
            throw new Error("listener cannot be null.");
        this.listeners.push(e)
    }
    removeListener(e) {
        const n = this.listeners.indexOf(e);
        n >= 0 && this.listeners.splice(n, 1)
    }
    clearListeners() {
        this.listeners.length = 0
    }
    clearListenerNotifications() {
        this.queue.clear()
    }
    setAnimationByName(e, n, s) {
        en.deprecatedWarning1 || (en.deprecatedWarning1 = !0,
            console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.")),
            this.setAnimation(e, n, s)
    }
    addAnimationByName(e, n, s, r) {
        en.deprecatedWarning2 || (en.deprecatedWarning2 = !0,
            console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.")),
            this.addAnimation(e, n, s, r)
    }
    hasAnimation(e) {
        return this.data.skeletonData.findAnimation(e) !== null
    }
    hasAnimationByName(e) {
        return en.deprecatedWarning3 || (en.deprecatedWarning3 = !0,
            console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.")),
            this.hasAnimation(e)
    }
}
    ;
let yr = en;
yr.emptyAnimation = new xn("<empty>", [], 0);
yr.SUBSEQUENT = 0;
yr.FIRST = 1;
yr.HOLD_SUBSEQUENT = 2;
yr.HOLD_FIRST = 3;
yr.HOLD_MIX = 4;
yr.SETUP = 1;
yr.CURRENT = 2;
yr.deprecatedWarning1 = !1;
yr.deprecatedWarning2 = !1;
yr.deprecatedWarning3 = !1;
const oo = class {
    constructor() {
        this.mixBlend = O.replace,
            this.timelineMode = new Array,
            this.timelineHoldMix = new Array,
            this.timelinesRotation = new Array
    }
    reset() {
        this.next = null,
            this.mixingFrom = null,
            this.mixingTo = null,
            this.animation = null,
            this.listener = null,
            this.timelineMode.length = 0,
            this.timelineHoldMix.length = 0,
            this.timelinesRotation.length = 0
    }
    getAnimationTime() {
        if (this.loop) {
            const e = this.animationEnd - this.animationStart;
            return e == 0 ? this.animationStart : this.trackTime % e + this.animationStart
        }
        return Math.min(this.trackTime + this.animationStart, this.animationEnd)
    }
    setAnimationLast(e) {
        this.animationLast = e,
            this.nextAnimationLast = e
    }
    isComplete() {
        return this.trackTime >= this.animationEnd - this.animationStart
    }
    resetRotationDirections() {
        this.timelinesRotation.length = 0
    }
    get time() {
        return oo.deprecatedWarning1 || (oo.deprecatedWarning1 = !0,
            console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),
            this.trackTime
    }
    set time(e) {
        oo.deprecatedWarning1 || (oo.deprecatedWarning1 = !0,
            console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),
            this.trackTime = e
    }
    get endTime() {
        return oo.deprecatedWarning2 || (oo.deprecatedWarning2 = !0,
            console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),
            this.trackTime
    }
    set endTime(e) {
        oo.deprecatedWarning2 || (oo.deprecatedWarning2 = !0,
            console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),
            this.trackTime = e
    }
    loopsCount() {
        return Math.floor(this.trackTime / this.trackEnd)
    }
}
    ;
let U_ = oo;
U_.deprecatedWarning1 = !1;
U_.deprecatedWarning2 = !1;
const Hb = class {
    constructor(e) {
        this.objects = [],
            this.drainDisabled = !1,
            this.animState = e
    }
    start(e) {
        this.objects.push($s.start),
            this.objects.push(e),
            this.animState.animationsChanged = !0
    }
    interrupt(e) {
        this.objects.push($s.interrupt),
            this.objects.push(e)
    }
    end(e) {
        this.objects.push($s.end),
            this.objects.push(e),
            this.animState.animationsChanged = !0
    }
    dispose(e) {
        this.objects.push($s.dispose),
            this.objects.push(e)
    }
    complete(e) {
        this.objects.push($s.complete),
            this.objects.push(e)
    }
    event(e, n) {
        this.objects.push($s.event),
            this.objects.push(e),
            this.objects.push(n)
    }
    deprecateStuff() {
        return Hb.deprecatedWarning1 || (Hb.deprecatedWarning1 = !0,
            console.warn("Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'")),
            !0
    }
    drain() {
        if (this.drainDisabled)
            return;
        this.drainDisabled = !0;
        const e = this.objects
            , n = this.animState.listeners;
        for (let s = 0; s < e.length; s += 2) {
            const r = e[s]
                , i = e[s + 1];
            switch (r) {
                case $s.start:
                    i.listener != null && i.listener.start && i.listener.start(i);
                    for (let a = 0; a < n.length; a++)
                        n[a].start && n[a].start(i);
                    i.onStart && this.deprecateStuff() && i.onStart(i.trackIndex),
                        this.animState.onStart && this.deprecateStuff() && this.deprecateStuff && this.animState.onStart(i.trackIndex);
                    break;
                case $s.interrupt:
                    i.listener != null && i.listener.interrupt && i.listener.interrupt(i);
                    for (let a = 0; a < n.length; a++)
                        n[a].interrupt && n[a].interrupt(i);
                    break;
                case $s.end:
                    i.listener != null && i.listener.end && i.listener.end(i);
                    for (let a = 0; a < n.length; a++)
                        n[a].end && n[a].end(i);
                    i.onEnd && this.deprecateStuff() && i.onEnd(i.trackIndex),
                        this.animState.onEnd && this.deprecateStuff() && this.animState.onEnd(i.trackIndex);
                case $s.dispose:
                    i.listener != null && i.listener.dispose && i.listener.dispose(i);
                    for (let a = 0; a < n.length; a++)
                        n[a].dispose && n[a].dispose(i);
                    this.animState.trackEntryPool.free(i);
                    break;
                case $s.complete:
                    i.listener != null && i.listener.complete && i.listener.complete(i);
                    for (let a = 0; a < n.length; a++)
                        n[a].complete && n[a].complete(i);
                    const o = F.toInt(i.loopsCount());
                    i.onComplete && this.deprecateStuff() && i.onComplete(i.trackIndex, o),
                        this.animState.onComplete && this.deprecateStuff() && this.animState.onComplete(i.trackIndex, o);
                    break;
                case $s.event:
                    const l = e[s++ + 2];
                    i.listener != null && i.listener.event && i.listener.event(i, l);
                    for (let a = 0; a < n.length; a++)
                        n[a].event && n[a].event(i, l);
                    i.onEvent && this.deprecateStuff() && i.onEvent(i.trackIndex, l),
                        this.animState.onEvent && this.deprecateStuff() && this.animState.onEvent(i.trackIndex, l);
                    break
            }
        }
        this.clear(),
            this.drainDisabled = !1
    }
    clear() {
        this.objects.length = 0
    }
}
    ;
let bw = Hb;
bw.deprecatedWarning1 = !1;
var $s = (t => (t[t.start = 0] = "start",
    t[t.interrupt = 1] = "interrupt",
    t[t.end = 2] = "end",
    t[t.dispose = 3] = "dispose",
    t[t.complete = 4] = "complete",
    t[t.event = 5] = "event",
    t))($s || {});
let fhe = class {
    start(e) { }
    interrupt(e) { }
    end(e) { }
    dispose(e) { }
    complete(e) { }
    event(e, n) { }
}
    ;
const Wb = class {
    constructor(e) {
        if (this.animationToMixTime = {},
            this.defaultMix = 0,
            e == null)
            throw new Error("skeletonData cannot be null.");
        this.skeletonData = e
    }
    setMix(e, n, s) {
        const r = this.skeletonData.findAnimation(e);
        if (r == null)
            throw new Error(`Animation not found: ${e}`);
        const i = this.skeletonData.findAnimation(n);
        if (i == null)
            throw new Error(`Animation not found: ${n}`);
        this.setMixWith(r, i, s)
    }
    setMixByName(e, n, s) {
        Wb.deprecatedWarning1 || (Wb.deprecatedWarning1 = !0,
            console.warn("Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.")),
            this.setMix(e, n, s)
    }
    setMixWith(e, n, s) {
        if (e == null)
            throw new Error("from cannot be null.");
        if (n == null)
            throw new Error("to cannot be null.");
        const r = `${e.name}.${n.name}`;
        this.animationToMixTime[r] = s
    }
    getMix(e, n) {
        const s = `${e.name}.${n.name}`
            , r = this.animationToMixTime[s];
        return r === void 0 ? this.defaultMix : r
    }
}
    ;
let vw = Wb;
vw.deprecatedWarning1 = !1;
let xw = class {
    constructor(e) {
        this.atlas = e
    }
    newRegionAttachment(e, n, s) {
        const r = this.atlas.findRegion(s);
        if (r == null)
            throw new Error(`Region not found in atlas: ${s} (region attachment: ${n})`);
        const i = new ot(n);
        return i.region = r,
            i
    }
    newMeshAttachment(e, n, s) {
        const r = this.atlas.findRegion(s);
        if (r == null)
            throw new Error(`Region not found in atlas: ${s} (mesh attachment: ${n})`);
        const i = new F_(n);
        return i.region = r,
            i
    }
    newBoundingBoxAttachment(e, n) {
        return new E5(n)
    }
    newPathAttachment(e, n) {
        return new $d(n)
    }
    newPointAttachment(e, n) {
        return new k5(n)
    }
    newClippingAttachment(e, n) {
        return new C5(n)
    }
}
    , Yb = class {
        constructor(e, n, s) {
            if (this.matrix = new Bt,
                this.children = new Array,
                this.x = 0,
                this.y = 0,
                this.rotation = 0,
                this.scaleX = 0,
                this.scaleY = 0,
                this.shearX = 0,
                this.shearY = 0,
                this.ax = 0,
                this.ay = 0,
                this.arotation = 0,
                this.ascaleX = 0,
                this.ascaleY = 0,
                this.ashearX = 0,
                this.ashearY = 0,
                this.appliedValid = !1,
                this.sorted = !1,
                this.active = !1,
                e == null)
                throw new Error("data cannot be null.");
            if (n == null)
                throw new Error("skeleton cannot be null.");
            this.data = e,
                this.skeleton = n,
                this.parent = s,
                this.setToSetupPose()
        }
        get worldX() {
            return this.matrix.tx
        }
        get worldY() {
            return this.matrix.ty
        }
        isActive() {
            return this.active
        }
        update() {
            this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY)
        }
        updateWorldTransform() {
            this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY)
        }
        updateWorldTransformWith(e, n, s, r, i, o, l) {
            this.ax = e,
                this.ay = n,
                this.arotation = s,
                this.ascaleX = r,
                this.ascaleY = i,
                this.ashearX = o,
                this.ashearY = l,
                this.appliedValid = !0;
            const a = this.parent
                , c = this.matrix
                , u = this.skeleton.scaleX
                , h = -this.skeleton.scaleY;
            if (a == null) {
                const g = this.skeleton
                    , b = s + 90 + l;
                c.a = F.cosDeg(s + o) * r * u,
                    c.c = F.cosDeg(b) * i * u,
                    c.b = F.sinDeg(s + o) * r * h,
                    c.d = F.sinDeg(b) * i * h,
                    c.tx = e * u + g.x,
                    c.ty = n * h + g.y;
                return
            }
            let d = a.matrix.a
                , f = a.matrix.c
                , p = a.matrix.b
                , m = a.matrix.d;
            switch (c.tx = d * e + f * n + a.matrix.tx,
            c.ty = p * e + m * n + a.matrix.ty,
            this.data.transformMode) {
                case Qe.Normal:
                    {
                        const g = s + 90 + l
                            , b = F.cosDeg(s + o) * r
                            , v = F.cosDeg(g) * i
                            , _ = F.sinDeg(s + o) * r
                            , y = F.sinDeg(g) * i;
                        c.a = d * b + f * _,
                            c.c = d * v + f * y,
                            c.b = p * b + m * _,
                            c.d = p * v + m * y;
                        return
                    }
                case Qe.OnlyTranslation:
                    {
                        const g = s + 90 + l;
                        c.a = F.cosDeg(s + o) * r,
                            c.c = F.cosDeg(g) * i,
                            c.b = F.sinDeg(s + o) * r,
                            c.d = F.sinDeg(g) * i;
                        break
                    }
                case Qe.NoRotationOrReflection:
                    {
                        let g = d * d + p * p
                            , b = 0;
                        g > 1e-4 ? (g = Math.abs(d * m - f * p) / g,
                            d /= this.skeleton.scaleX,
                            p /= this.skeleton.scaleY,
                            f = p * g,
                            m = d * g,
                            b = Math.atan2(p, d) * F.radDeg) : (d = 0,
                                p = 0,
                                b = 90 - Math.atan2(m, f) * F.radDeg);
                        const v = s + o - b
                            , _ = s + l - b + 90
                            , y = F.cosDeg(v) * r
                            , x = F.cosDeg(_) * i
                            , w = F.sinDeg(v) * r
                            , S = F.sinDeg(_) * i;
                        c.a = d * y - f * w,
                            c.c = d * x - f * S,
                            c.b = p * y + m * w,
                            c.d = p * x + m * S;
                        break
                    }
                case Qe.NoScale:
                case Qe.NoScaleOrReflection:
                    {
                        const g = F.cosDeg(s)
                            , b = F.sinDeg(s);
                        let v = (d * g + f * b) / u
                            , _ = (p * g + m * b) / h
                            , y = Math.sqrt(v * v + _ * _);
                        y > 1e-5 && (y = 1 / y),
                            v *= y,
                            _ *= y,
                            y = Math.sqrt(v * v + _ * _),
                            this.data.transformMode == Qe.NoScale && d * m - f * p < 0 != (this.skeleton.scaleX < 0 != this.skeleton.scaleY > 0) && (y = -y);
                        const x = Math.PI / 2 + Math.atan2(_, v)
                            , w = Math.cos(x) * y
                            , S = Math.sin(x) * y
                            , E = F.cosDeg(o) * r
                            , C = F.cosDeg(90 + l) * i
                            , I = F.sinDeg(o) * r
                            , L = F.sinDeg(90 + l) * i;
                        c.a = v * E + w * I,
                            c.c = v * C + w * L,
                            c.b = _ * E + S * I,
                            c.d = _ * C + S * L;
                        break
                    }
            }
            c.a *= u,
                c.c *= u,
                c.b *= h,
                c.d *= h
        }
        setToSetupPose() {
            const e = this.data;
            this.x = e.x,
                this.y = e.y,
                this.rotation = e.rotation,
                this.scaleX = e.scaleX,
                this.scaleY = e.scaleY,
                this.shearX = e.shearX,
                this.shearY = e.shearY
        }
        getWorldRotationX() {
            return Math.atan2(this.matrix.b, this.matrix.a) * F.radDeg
        }
        getWorldRotationY() {
            return Math.atan2(this.matrix.d, this.matrix.c) * F.radDeg
        }
        getWorldScaleX() {
            const e = this.matrix;
            return Math.sqrt(e.a * e.a + e.c * e.c)
        }
        getWorldScaleY() {
            const e = this.matrix;
            return Math.sqrt(e.b * e.b + e.d * e.d)
        }
        updateAppliedTransform() {
            this.appliedValid = !0;
            const e = this.parent
                , n = this.matrix;
            if (e == null) {
                this.ax = n.tx,
                    this.ay = n.ty,
                    this.arotation = Math.atan2(n.b, n.a) * F.radDeg,
                    this.ascaleX = Math.sqrt(n.a * n.a + n.b * n.b),
                    this.ascaleY = Math.sqrt(n.c * n.c + n.d * n.d),
                    this.ashearX = 0,
                    this.ashearY = Math.atan2(n.a * n.c + n.b * n.d, n.a * n.d - n.b * n.c) * F.radDeg;
                return
            }
            const s = e.matrix
                , r = 1 / (s.a * s.d - s.b * s.c)
                , i = n.tx - s.tx
                , o = n.ty - s.ty;
            this.ax = i * s.d * r - o * s.c * r,
                this.ay = o * s.a * r - i * s.b * r;
            const l = r * s.d
                , a = r * s.a
                , c = r * s.c
                , u = r * s.b
                , h = l * n.a - c * n.b
                , d = l * n.c - c * n.d
                , f = a * n.b - u * n.a
                , p = a * n.d - u * n.c;
            if (this.ashearX = 0,
                this.ascaleX = Math.sqrt(h * h + f * f),
                this.ascaleX > 1e-4) {
                const m = h * p - d * f;
                this.ascaleY = m / this.ascaleX,
                    this.ashearY = Math.atan2(h * d + f * p, m) * F.radDeg,
                    this.arotation = Math.atan2(f, h) * F.radDeg
            } else
                this.ascaleX = 0,
                    this.ascaleY = Math.sqrt(d * d + p * p),
                    this.ashearY = 0,
                    this.arotation = 90 - Math.atan2(p, d) * F.radDeg
        }
        worldToLocal(e) {
            const n = this.matrix
                , s = n.a
                , r = n.c
                , i = n.b
                , o = n.d
                , l = 1 / (s * o - r * i)
                , a = e.x - n.tx
                , c = e.y - n.ty;
            return e.x = a * o * l - c * r * l,
                e.y = c * s * l - a * i * l,
                e
        }
        localToWorld(e) {
            const n = this.matrix
                , s = e.x
                , r = e.y;
            return e.x = s * n.a + r * n.c + n.tx,
                e.y = s * n.b + r * n.d + n.ty,
                e
        }
        worldToLocalRotation(e) {
            const n = F.sinDeg(e)
                , s = F.cosDeg(e)
                , r = this.matrix;
            return Math.atan2(r.a * n - r.b * s, r.d * s - r.c * n) * F.radDeg
        }
        localToWorldRotation(e) {
            const n = F.sinDeg(e)
                , s = F.cosDeg(e)
                , r = this.matrix;
            return Math.atan2(s * r.b + n * r.d, s * r.a + n * r.c) * F.radDeg
        }
        rotateWorld(e) {
            const n = this.matrix
                , s = n.a
                , r = n.c
                , i = n.b
                , o = n.d
                , l = F.cosDeg(e)
                , a = F.sinDeg(e);
            n.a = l * s - a * i,
                n.c = l * r - a * o,
                n.b = a * s + l * i,
                n.d = a * r + l * o,
                this.appliedValid = !1
        }
    }
    , ww = class {
        constructor(e, n, s) {
            if (this.x = 0,
                this.y = 0,
                this.rotation = 0,
                this.scaleX = 1,
                this.scaleY = 1,
                this.shearX = 0,
                this.shearY = 0,
                this.transformMode = Qe.Normal,
                this.skinRequired = !1,
                this.color = new Se,
                e < 0)
                throw new Error("index must be >= 0.");
            if (n == null)
                throw new Error("name cannot be null.");
            this.index = e,
                this.name = n,
                this.parent = s
        }
    }
    , V_ = class {
        constructor(e, n, s) {
            this.name = e,
                this.order = n,
                this.skinRequired = s
        }
    }
    , Sw = class {
        constructor(e, n) {
            if (n == null)
                throw new Error("data cannot be null.");
            this.time = e,
                this.data = n
        }
    }
    , Ew = class {
        constructor(e) {
            this.name = e
        }
    }
    , O5 = class {
        constructor(e, n) {
            if (this.bendDirection = 0,
                this.compress = !1,
                this.stretch = !1,
                this.mix = 1,
                this.softness = 0,
                this.active = !1,
                e == null)
                throw new Error("data cannot be null.");
            if (n == null)
                throw new Error("skeleton cannot be null.");
            this.data = e,
                this.mix = e.mix,
                this.softness = e.softness,
                this.bendDirection = e.bendDirection,
                this.compress = e.compress,
                this.stretch = e.stretch,
                this.bones = new Array;
            for (let s = 0; s < e.bones.length; s++)
                this.bones.push(n.findBone(e.bones[s].name));
            this.target = n.findBone(e.target.name)
        }
        isActive() {
            return this.active
        }
        apply() {
            this.update()
        }
        update() {
            const e = this.target
                , n = this.bones;
            switch (n.length) {
                case 1:
                    this.apply1(n[0], e.worldX, e.worldY, this.compress, this.stretch, this.data.uniform, this.mix);
                    break;
                case 2:
                    this.apply2(n[0], n[1], e.worldX, e.worldY, this.bendDirection, this.stretch, this.softness, this.mix);
                    break
            }
        }
        apply1(e, n, s, r, i, o, l) {
            e.appliedValid || e.updateAppliedTransform();
            const a = e.parent.matrix
                , c = a.a;
            let u = a.c;
            const h = a.b;
            let d = a.d
                , f = -e.ashearX - e.arotation
                , p = 0
                , m = 0;
            switch (e.data.transformMode) {
                case Qe.OnlyTranslation:
                    p = n - e.worldX,
                        m = s - e.worldY;
                    break;
                case Qe.NoRotationOrReflection:
                    const v = Math.abs(c * d - u * h) / (c * c + h * h)
                        , _ = c / e.skeleton.scaleX
                        , y = h / e.skeleton.scaleY;
                    u = -y * v * e.skeleton.scaleX,
                        d = _ * v * e.skeleton.scaleY,
                        f += Math.atan2(y, _) * F.radDeg;
                default:
                    const x = n - a.tx
                        , w = s - a.ty
                        , S = c * d - u * h;
                    p = (x * d - w * u) / S - e.ax,
                        m = (w * c - x * h) / S - e.ay
            }
            f += Math.atan2(m, p) * F.radDeg,
                e.ascaleX < 0 && (f += 180),
                f > 180 ? f -= 360 : f < -180 && (f += 360);
            let g = e.ascaleX
                , b = e.ascaleY;
            if (r || i) {
                switch (e.data.transformMode) {
                    case Qe.NoScale:
                    case Qe.NoScaleOrReflection:
                        p = n - e.worldX,
                            m = s - e.worldY
                }
                const v = e.data.length * g
                    , _ = Math.sqrt(p * p + m * m);
                if (r && _ < v || i && _ > v && v > 1e-4) {
                    const y = (_ / v - 1) * l + 1;
                    g *= y,
                        o && (b *= y)
                }
            }
            e.updateWorldTransformWith(e.ax, e.ay, e.arotation + f * l, g, b, e.ashearX, e.ashearY)
        }
        apply2(e, n, s, r, i, o, l, a) {
            if (a == 0) {
                n.updateWorldTransform();
                return
            }
            e.appliedValid || e.updateAppliedTransform(),
                n.appliedValid || n.updateAppliedTransform();
            const c = e.ax
                , u = e.ay;
            let h = e.ascaleX
                , d = h
                , f = e.ascaleY
                , p = n.ascaleX;
            const m = e.matrix;
            let g = 0
                , b = 0
                , v = 0;
            h < 0 ? (h = -h,
                g = 180,
                v = -1) : (g = 0,
                    v = 1),
                f < 0 && (f = -f,
                    v = -v),
                p < 0 ? (p = -p,
                    b = 180) : b = 0;
            const _ = n.ax;
            let y = 0
                , x = 0
                , w = 0
                , S = m.a
                , E = m.c
                , C = m.b
                , I = m.d;
            const L = Math.abs(h - f) <= 1e-4;
            L ? (y = n.ay,
                x = S * _ + E * y + m.tx,
                w = C * _ + I * y + m.ty) : (y = 0,
                    x = S * _ + m.tx,
                    w = C * _ + m.ty);
            const k = e.parent.matrix;
            S = k.a,
                E = k.c,
                C = k.b,
                I = k.d;
            const R = 1 / (S * I - E * C);
            let U = x - k.tx
                , W = w - k.ty;
            const H = (U * I - W * E) * R - c
                , j = (W * S - U * C) * R - u
                , z = Math.sqrt(H * H + j * j);
            let ee = n.data.length * p, J, Y;
            if (z < 1e-4) {
                this.apply1(e, s, r, !1, o, !1, a),
                    n.updateWorldTransformWith(_, y, 0, n.ascaleX, n.ascaleY, n.ashearX, n.ashearY);
                return
            }
            U = s - k.tx,
                W = r - k.ty;
            let ne = (U * I - W * E) * R - c
                , oe = (W * S - U * C) * R - u
                , ce = ne * ne + oe * oe;
            if (l != 0) {
                l *= h * (p + 1) / 2;
                const K = Math.sqrt(ce)
                    , ge = K - z - ee * h + l;
                if (ge > 0) {
                    let he = Math.min(1, ge / (l * 2)) - 1;
                    he = (ge - l * (1 - he * he)) / K,
                        ne -= he * ne,
                        oe -= he * oe,
                        ce = ne * ne + oe * oe
                }
            }
            e: if (L) {
                ee *= h;
                let K = (ce - z * z - ee * ee) / (2 * z * ee);
                K < -1 ? K = -1 : K > 1 && (K = 1,
                    o && (d *= (Math.sqrt(ce) / (z + ee) - 1) * a + 1)),
                    Y = Math.acos(K) * i,
                    S = z + ee * K,
                    E = ee * Math.sin(Y),
                    J = Math.atan2(oe * S - ne * E, ne * S + oe * E)
            } else {
                S = h * ee,
                    E = f * ee;
                const K = S * S
                    , ge = E * E
                    , he = Math.atan2(oe, ne);
                C = ge * z * z + K * ce - K * ge;
                const be = -2 * ge * z
                    , Pe = ge - K;
                if (I = be * be - 4 * Pe * C,
                    I >= 0) {
                    let P = Math.sqrt(I);
                    be < 0 && (P = -P),
                        P = -(be + P) / 2;
                    const B = P / Pe
                        , V = C / P
                        , re = Math.abs(B) < Math.abs(V) ? B : V;
                    if (re * re <= ce) {
                        W = Math.sqrt(ce - re * re) * i,
                            J = he - Math.atan2(W, re),
                            Y = Math.atan2(W / f, (re - z) / h);
                        break e
                    }
                }
                let De = F.PI
                    , D = z - S
                    , M = D * D
                    , X = 0
                    , ae = 0
                    , ie = z + S
                    , pe = ie * ie
                    , xe = 0;
                C = -S * z / (K - ge),
                    C >= -1 && C <= 1 && (C = Math.acos(C),
                        U = S * Math.cos(C) + z,
                        W = E * Math.sin(C),
                        I = U * U + W * W,
                        I < M && (De = C,
                            M = I,
                            D = U,
                            X = W),
                        I > pe && (ae = C,
                            pe = I,
                            ie = U,
                            xe = W)),
                    ce <= (M + pe) / 2 ? (J = he - Math.atan2(X * i, D),
                        Y = De * i) : (J = he - Math.atan2(xe * i, ie),
                            Y = ae * i)
            }
            const ue = Math.atan2(y, _) * v;
            let we = e.arotation;
            J = (J - ue) * F.radDeg + g - we,
                J > 180 ? J -= 360 : J < -180 && (J += 360),
                e.updateWorldTransformWith(c, u, we + J * a, d, e.ascaleY, 0, 0),
                we = n.arotation,
                Y = ((Y + ue) * F.radDeg - n.ashearX) * v + b - we,
                Y > 180 ? Y -= 360 : Y < -180 && (Y += 360),
                n.updateWorldTransformWith(_, y, we + Y * a, n.ascaleX, n.ascaleY, n.ashearX, n.ashearY)
        }
    }
    , Tw = class extends V_ {
        constructor(e) {
            super(e, 0, !1),
                this.bones = new Array,
                this.bendDirection = 1,
                this.compress = !1,
                this.stretch = !1,
                this.uniform = !1,
                this.mix = 1,
                this.softness = 0
        }
    }
    , Cw = class extends V_ {
        constructor(e) {
            super(e, 0, !1),
                this.bones = new Array
        }
    }
    ;
var Xn = (t => (t[t.Length = 0] = "Length",
    t[t.Fixed = 1] = "Fixed",
    t[t.Percent = 2] = "Percent",
    t))(Xn || {});
const Cl = class {
    constructor(e, n) {
        if (this.position = 0,
            this.spacing = 0,
            this.rotateMix = 0,
            this.translateMix = 0,
            this.spaces = new Array,
            this.positions = new Array,
            this.world = new Array,
            this.curves = new Array,
            this.lengths = new Array,
            this.segments = new Array,
            this.active = !1,
            e == null)
            throw new Error("data cannot be null.");
        if (n == null)
            throw new Error("skeleton cannot be null.");
        this.data = e,
            this.bones = new Array;
        for (let s = 0, r = e.bones.length; s < r; s++)
            this.bones.push(n.findBone(e.bones[s].name));
        this.target = n.findSlot(e.target.name),
            this.position = e.position,
            this.spacing = e.spacing,
            this.rotateMix = e.rotateMix,
            this.translateMix = e.translateMix
    }
    isActive() {
        return this.active
    }
    apply() {
        this.update()
    }
    update() {
        const e = this.target.getAttachment();
        if (!(e instanceof $d))
            return;
        const n = this.rotateMix
            , s = this.translateMix
            , r = s > 0
            , i = n > 0;
        if (!r && !i)
            return;
        const o = this.data
            , l = o.spacingMode
            , a = l == Xn.Length
            , c = o.rotateMode
            , u = c == bn.Tangent
            , h = c == bn.ChainScale
            , d = this.bones.length
            , f = u ? d : d + 1
            , p = this.bones
            , m = Q.setArraySize(this.spaces, f);
        let g = null;
        const b = this.spacing;
        if (h || a) {
            h && (g = Q.setArraySize(this.lengths, d));
            for (let S = 0, E = f - 1; S < E;) {
                const C = p[S]
                    , I = C.data.length;
                if (I < Cl.epsilon)
                    h && (g[S] = 0),
                        m[++S] = 0;
                else {
                    const L = I * C.matrix.a
                        , k = I * C.matrix.b
                        , R = Math.sqrt(L * L + k * k);
                    h && (g[S] = R),
                        m[++S] = (a ? I + b : b) * R / I
                }
            }
        } else
            for (let S = 1; S < f; S++)
                m[S] = b;
        const v = this.computeWorldPositions(e, f, u, o.positionMode == on.Percent, l == Xn.Percent);
        let _ = v[0]
            , y = v[1]
            , x = o.offsetRotation
            , w = !1;
        if (x == 0)
            w = c == bn.Chain;
        else {
            w = !1;
            const S = this.target.bone.matrix;
            x *= S.a * S.d - S.b * S.c > 0 ? F.degRad : -F.degRad
        }
        for (let S = 0, E = 3; S < d; S++,
            E += 3) {
            const C = p[S]
                , I = C.matrix;
            I.tx += (_ - I.tx) * s,
                I.ty += (y - I.ty) * s;
            const L = v[E]
                , k = v[E + 1]
                , R = L - _
                , U = k - y;
            if (h) {
                const W = g[S];
                if (W != 0) {
                    const H = (Math.sqrt(R * R + U * U) / W - 1) * n + 1;
                    I.a *= H,
                        I.b *= H
                }
            }
            if (_ = L,
                y = k,
                i) {
                const W = I.a
                    , H = I.c
                    , j = I.b
                    , z = I.d;
                let ee = 0
                    , J = 0
                    , Y = 0;
                if (u && (u ? ee = v[E - 1] : m[S + 1] == 0 ? ee = v[E + 2] : ee = Math.atan2(U, R)),
                    ee -= Math.atan2(j, W),
                    w) {
                    J = Math.cos(ee),
                        Y = Math.sin(ee);
                    const ne = C.data.length;
                    _ += (ne * (J * W - Y * j) - R) * n,
                        y += (ne * (Y * W + J * j) - U) * n
                } else
                    ee += x;
                ee > F.PI ? ee -= F.PI2 : ee < -F.PI && (ee += F.PI2),
                    ee *= n,
                    J = Math.cos(ee),
                    Y = Math.sin(ee),
                    I.a = J * W - Y * j,
                    I.c = J * H - Y * z,
                    I.b = Y * W + J * j,
                    I.d = Y * H + J * z
            }
            C.appliedValid = !1
        }
    }
    computeWorldPositions(e, n, s, r, i) {
        const o = this.target;
        let l = this.position;
        const a = this.spaces
            , c = Q.setArraySize(this.positions, n * 3 + 2);
        let u = null;
        const h = e.closed;
        let d = e.worldVerticesLength
            , f = d / 6
            , p = Cl.NONE;
        if (!e.constantSpeed) {
            const ee = e.lengths;
            f -= h ? 1 : 2;
            const J = ee[f];
            if (r && (l *= J),
                i)
                for (let Y = 0; Y < n; Y++)
                    a[Y] *= J;
            u = Q.setArraySize(this.world, 8);
            for (let Y = 0, ne = 0, oe = 0; Y < n; Y++,
                ne += 3) {
                const ce = a[Y];
                l += ce;
                let ue = l;
                if (h)
                    ue %= J,
                        ue < 0 && (ue += J),
                        oe = 0;
                else if (ue < 0) {
                    p != Cl.BEFORE && (p = Cl.BEFORE,
                        e.computeWorldVertices(o, 2, 4, u, 0, 2)),
                        this.addBeforePosition(ue, u, 0, c, ne);
                    continue
                } else if (ue > J) {
                    p != Cl.AFTER && (p = Cl.AFTER,
                        e.computeWorldVertices(o, d - 6, 4, u, 0, 2)),
                        this.addAfterPosition(ue - J, u, 0, c, ne);
                    continue
                }
                for (; ; oe++) {
                    const we = ee[oe];
                    if (!(ue > we)) {
                        if (oe == 0)
                            ue /= we;
                        else {
                            const K = ee[oe - 1];
                            ue = (ue - K) / (we - K)
                        }
                        break
                    }
                }
                oe != p && (p = oe,
                    h && oe == f ? (e.computeWorldVertices(o, d - 4, 4, u, 0, 2),
                        e.computeWorldVertices(o, 0, 4, u, 4, 2)) : e.computeWorldVertices(o, oe * 6 + 2, 8, u, 0, 2)),
                    this.addCurvePosition(ue, u[0], u[1], u[2], u[3], u[4], u[5], u[6], u[7], c, ne, s || Y > 0 && ce == 0)
            }
            return c
        }
        h ? (d += 2,
            u = Q.setArraySize(this.world, d),
            e.computeWorldVertices(o, 2, d - 4, u, 0, 2),
            e.computeWorldVertices(o, 0, 2, u, d - 4, 2),
            u[d - 2] = u[0],
            u[d - 1] = u[1]) : (f--,
                d -= 4,
                u = Q.setArraySize(this.world, d),
                e.computeWorldVertices(o, 2, d, u, 0, 2));
        const m = Q.setArraySize(this.curves, f);
        let g = 0
            , b = u[0]
            , v = u[1]
            , _ = 0
            , y = 0
            , x = 0
            , w = 0
            , S = 0
            , E = 0
            , C = 0
            , I = 0
            , L = 0
            , k = 0
            , R = 0
            , U = 0
            , W = 0
            , H = 0;
        for (let ee = 0, J = 2; ee < f; ee++,
            J += 6)
            _ = u[J],
                y = u[J + 1],
                x = u[J + 2],
                w = u[J + 3],
                S = u[J + 4],
                E = u[J + 5],
                C = (b - _ * 2 + x) * .1875,
                I = (v - y * 2 + w) * .1875,
                L = ((_ - x) * 3 - b + S) * .09375,
                k = ((y - w) * 3 - v + E) * .09375,
                R = C * 2 + L,
                U = I * 2 + k,
                W = (_ - b) * .75 + C + L * .16666667,
                H = (y - v) * .75 + I + k * .16666667,
                g += Math.sqrt(W * W + H * H),
                W += R,
                H += U,
                R += L,
                U += k,
                g += Math.sqrt(W * W + H * H),
                W += R,
                H += U,
                g += Math.sqrt(W * W + H * H),
                W += R + L,
                H += U + k,
                g += Math.sqrt(W * W + H * H),
                m[ee] = g,
                b = S,
                v = E;
        if (r && (l *= g),
            i)
            for (let ee = 0; ee < n; ee++)
                a[ee] *= g;
        const j = this.segments;
        let z = 0;
        for (let ee = 0, J = 0, Y = 0, ne = 0; ee < n; ee++,
            J += 3) {
            const oe = a[ee];
            l += oe;
            let ce = l;
            if (h)
                ce %= g,
                    ce < 0 && (ce += g),
                    Y = 0;
            else if (ce < 0) {
                this.addBeforePosition(ce, u, 0, c, J);
                continue
            } else if (ce > g) {
                this.addAfterPosition(ce - g, u, d - 4, c, J);
                continue
            }
            for (; ; Y++) {
                const ue = m[Y];
                if (!(ce > ue)) {
                    if (Y == 0)
                        ce /= ue;
                    else {
                        const we = m[Y - 1];
                        ce = (ce - we) / (ue - we)
                    }
                    break
                }
            }
            if (Y != p) {
                p = Y;
                let ue = Y * 6;
                for (b = u[ue],
                    v = u[ue + 1],
                    _ = u[ue + 2],
                    y = u[ue + 3],
                    x = u[ue + 4],
                    w = u[ue + 5],
                    S = u[ue + 6],
                    E = u[ue + 7],
                    C = (b - _ * 2 + x) * .03,
                    I = (v - y * 2 + w) * .03,
                    L = ((_ - x) * 3 - b + S) * .006,
                    k = ((y - w) * 3 - v + E) * .006,
                    R = C * 2 + L,
                    U = I * 2 + k,
                    W = (_ - b) * .3 + C + L * .16666667,
                    H = (y - v) * .3 + I + k * .16666667,
                    z = Math.sqrt(W * W + H * H),
                    j[0] = z,
                    ue = 1; ue < 8; ue++)
                    W += R,
                        H += U,
                        R += L,
                        U += k,
                        z += Math.sqrt(W * W + H * H),
                        j[ue] = z;
                W += R,
                    H += U,
                    z += Math.sqrt(W * W + H * H),
                    j[8] = z,
                    W += R + L,
                    H += U + k,
                    z += Math.sqrt(W * W + H * H),
                    j[9] = z,
                    ne = 0
            }
            for (ce *= z; ; ne++) {
                const ue = j[ne];
                if (!(ce > ue)) {
                    if (ne == 0)
                        ce /= ue;
                    else {
                        const we = j[ne - 1];
                        ce = ne + (ce - we) / (ue - we)
                    }
                    break
                }
            }
            this.addCurvePosition(ce * .1, b, v, _, y, x, w, S, E, c, J, s || ee > 0 && oe == 0)
        }
        return c
    }
    addBeforePosition(e, n, s, r, i) {
        const o = n[s]
            , l = n[s + 1]
            , a = n[s + 2] - o
            , c = n[s + 3] - l
            , u = Math.atan2(c, a);
        r[i] = o + e * Math.cos(u),
            r[i + 1] = l + e * Math.sin(u),
            r[i + 2] = u
    }
    addAfterPosition(e, n, s, r, i) {
        const o = n[s + 2]
            , l = n[s + 3]
            , a = o - n[s]
            , c = l - n[s + 1]
            , u = Math.atan2(c, a);
        r[i] = o + e * Math.cos(u),
            r[i + 1] = l + e * Math.sin(u),
            r[i + 2] = u
    }
    addCurvePosition(e, n, s, r, i, o, l, a, c, u, h, d) {
        (e == 0 || isNaN(e)) && (e = 1e-4);
        const f = e * e
            , p = f * e
            , m = 1 - e
            , g = m * m
            , b = g * m
            , v = m * e
            , _ = v * 3
            , y = m * _
            , x = _ * e
            , w = n * b + r * y + o * x + a * p
            , S = s * b + i * y + l * x + c * p;
        u[h] = w,
            u[h + 1] = S,
            d && (u[h + 2] = Math.atan2(S - (s * g + i * v * 2 + l * f), w - (n * g + r * v * 2 + o * f)))
    }
}
    ;
let gh = Cl;
gh.NONE = -1;
gh.BEFORE = -2;
gh.AFTER = -3;
gh.epsilon = 1e-5;
let N5 = class {
    constructor(e, n) {
        if (this.rotateMix = 0,
            this.translateMix = 0,
            this.scaleMix = 0,
            this.shearMix = 0,
            this.temp = new Fd,
            this.active = !1,
            e == null)
            throw new Error("data cannot be null.");
        if (n == null)
            throw new Error("skeleton cannot be null.");
        this.data = e,
            this.rotateMix = e.rotateMix,
            this.translateMix = e.translateMix,
            this.scaleMix = e.scaleMix,
            this.shearMix = e.shearMix,
            this.bones = new Array;
        for (let s = 0; s < e.bones.length; s++)
            this.bones.push(n.findBone(e.bones[s].name));
        this.target = n.findBone(e.target.name)
    }
    isActive() {
        return this.active
    }
    apply() {
        this.update()
    }
    update() {
        this.data.local ? this.data.relative ? this.applyRelativeLocal() : this.applyAbsoluteLocal() : this.data.relative ? this.applyRelativeWorld() : this.applyAbsoluteWorld()
    }
    applyAbsoluteWorld() {
        const e = this.rotateMix
            , n = this.translateMix
            , s = this.scaleMix
            , r = this.shearMix
            , i = this.target
            , o = i.matrix
            , l = o.a
            , a = o.c
            , c = o.b
            , u = o.d
            , h = l * u - a * c > 0 ? F.degRad : -F.degRad
            , d = this.data.offsetRotation * h
            , f = this.data.offsetShearY * h
            , p = this.bones;
        for (let m = 0, g = p.length; m < g; m++) {
            const b = p[m];
            let v = !1;
            const _ = b.matrix;
            if (e != 0) {
                const y = _.a
                    , x = _.c
                    , w = _.b
                    , S = _.d;
                let E = Math.atan2(c, l) - Math.atan2(w, y) + d;
                E > F.PI ? E -= F.PI2 : E < -F.PI && (E += F.PI2),
                    E *= e;
                const C = Math.cos(E)
                    , I = Math.sin(E);
                _.a = C * y - I * w,
                    _.c = C * x - I * S,
                    _.b = I * y + C * w,
                    _.d = I * x + C * S,
                    v = !0
            }
            if (n != 0) {
                const y = this.temp;
                i.localToWorld(y.set(this.data.offsetX, this.data.offsetY)),
                    _.tx += (y.x - _.tx) * n,
                    _.ty += (y.y - _.ty) * n,
                    v = !0
            }
            if (s > 0) {
                let y = Math.sqrt(_.a * _.a + _.b * _.b)
                    , x = Math.sqrt(l * l + c * c);
                y > 1e-5 && (y = (y + (x - y + this.data.offsetScaleX) * s) / y),
                    _.a *= y,
                    _.b *= y,
                    y = Math.sqrt(_.c * _.c + _.d * _.d),
                    x = Math.sqrt(a * a + u * u),
                    y > 1e-5 && (y = (y + (x - y + this.data.offsetScaleY) * s) / y),
                    _.c *= y,
                    _.d *= y,
                    v = !0
            }
            if (r > 0) {
                const y = _.c
                    , x = _.d
                    , w = Math.atan2(x, y);
                let S = Math.atan2(u, a) - Math.atan2(c, l) - (w - Math.atan2(_.b, _.a));
                S > F.PI ? S -= F.PI2 : S < -F.PI && (S += F.PI2),
                    S = w + (S + f) * r;
                const E = Math.sqrt(y * y + x * x);
                _.c = Math.cos(S) * E,
                    _.d = Math.sin(S) * E,
                    v = !0
            }
            v && (b.appliedValid = !1)
        }
    }
    applyRelativeWorld() {
        const e = this.rotateMix
            , n = this.translateMix
            , s = this.scaleMix
            , r = this.shearMix
            , i = this.target
            , o = i.matrix
            , l = o.a
            , a = o.c
            , c = o.b
            , u = o.d
            , h = l * u - a * c > 0 ? F.degRad : -F.degRad
            , d = this.data.offsetRotation * h
            , f = this.data.offsetShearY * h
            , p = this.bones;
        for (let m = 0, g = p.length; m < g; m++) {
            const b = p[m];
            let v = !1;
            const _ = b.matrix;
            if (e != 0) {
                const y = _.a
                    , x = _.c
                    , w = _.b
                    , S = _.d;
                let E = Math.atan2(c, l) + d;
                E > F.PI ? E -= F.PI2 : E < -F.PI && (E += F.PI2),
                    E *= e;
                const C = Math.cos(E)
                    , I = Math.sin(E);
                _.a = C * y - I * w,
                    _.c = C * x - I * S,
                    _.b = I * y + C * w,
                    _.d = I * x + C * S,
                    v = !0
            }
            if (n != 0) {
                const y = this.temp;
                i.localToWorld(y.set(this.data.offsetX, this.data.offsetY)),
                    _.tx += y.x * n,
                    _.ty += y.y * n,
                    v = !0
            }
            if (s > 0) {
                let y = (Math.sqrt(l * l + c * c) - 1 + this.data.offsetScaleX) * s + 1;
                _.a *= y,
                    _.b *= y,
                    y = (Math.sqrt(a * a + u * u) - 1 + this.data.offsetScaleY) * s + 1,
                    _.c *= y,
                    _.d *= y,
                    v = !0
            }
            if (r > 0) {
                let y = Math.atan2(u, a) - Math.atan2(c, l);
                y > F.PI ? y -= F.PI2 : y < -F.PI && (y += F.PI2);
                const x = _.c
                    , w = _.d;
                y = Math.atan2(w, x) + (y - F.PI / 2 + f) * r;
                const S = Math.sqrt(x * x + w * w);
                _.c = Math.cos(y) * S,
                    _.d = Math.sin(y) * S,
                    v = !0
            }
            v && (b.appliedValid = !1)
        }
    }
    applyAbsoluteLocal() {
        const e = this.rotateMix
            , n = this.translateMix
            , s = this.scaleMix
            , r = this.shearMix
            , i = this.target;
        i.appliedValid || i.updateAppliedTransform();
        const o = this.bones;
        for (let l = 0, a = o.length; l < a; l++) {
            const c = o[l];
            c.appliedValid || c.updateAppliedTransform();
            let u = c.arotation;
            if (e != 0) {
                let g = i.arotation - u + this.data.offsetRotation;
                g -= (16384 - (16384.499999999996 - g / 360 | 0)) * 360,
                    u += g * e
            }
            let h = c.ax
                , d = c.ay;
            n != 0 && (h += (i.ax - h + this.data.offsetX) * n,
                d += (i.ay - d + this.data.offsetY) * n);
            let f = c.ascaleX
                , p = c.ascaleY;
            s > 0 && (f > 1e-5 && (f = (f + (i.ascaleX - f + this.data.offsetScaleX) * s) / f),
                p > 1e-5 && (p = (p + (i.ascaleY - p + this.data.offsetScaleY) * s) / p));
            const m = c.ashearY;
            if (r > 0) {
                let g = i.ashearY - m + this.data.offsetShearY;
                g -= (16384 - (16384.499999999996 - g / 360 | 0)) * 360,
                    c.shearY += g * r
            }
            c.updateWorldTransformWith(h, d, u, f, p, c.ashearX, m)
        }
    }
    applyRelativeLocal() {
        const e = this.rotateMix
            , n = this.translateMix
            , s = this.scaleMix
            , r = this.shearMix
            , i = this.target;
        i.appliedValid || i.updateAppliedTransform();
        const o = this.bones;
        for (let l = 0, a = o.length; l < a; l++) {
            const c = o[l];
            c.appliedValid || c.updateAppliedTransform();
            let u = c.arotation;
            e != 0 && (u += (i.arotation + this.data.offsetRotation) * e);
            let h = c.ax
                , d = c.ay;
            n != 0 && (h += (i.ax + this.data.offsetX) * n,
                d += (i.ay + this.data.offsetY) * n);
            let f = c.ascaleX
                , p = c.ascaleY;
            s > 0 && (f > 1e-5 && (f *= (i.ascaleX - 1 + this.data.offsetScaleX) * s + 1),
                p > 1e-5 && (p *= (i.ascaleY - 1 + this.data.offsetScaleY) * s + 1));
            let m = c.ashearY;
            r > 0 && (m += (i.ashearY + this.data.offsetShearY) * r),
                c.updateWorldTransformWith(h, d, u, f, p, c.ashearX, m)
        }
    }
}
    ;
const Fh = class {
    constructor(e) {
        if (this._updateCache = new Array,
            this.updateCacheReset = new Array,
            this.time = 0,
            this.scaleX = 1,
            this.scaleY = 1,
            this.x = 0,
            this.y = 0,
            e == null)
            throw new Error("data cannot be null.");
        this.data = e,
            this.bones = new Array;
        for (let n = 0; n < e.bones.length; n++) {
            const s = e.bones[n];
            let r;
            if (s.parent == null)
                r = new Yb(s, this, null);
            else {
                const i = this.bones[s.parent.index];
                r = new Yb(s, this, i),
                    i.children.push(r)
            }
            this.bones.push(r)
        }
        this.slots = new Array,
            this.drawOrder = new Array;
        for (let n = 0; n < e.slots.length; n++) {
            const s = e.slots[n]
                , r = this.bones[s.boneData.index]
                , i = new pw(s, r);
            this.slots.push(i),
                this.drawOrder.push(i)
        }
        this.ikConstraints = new Array;
        for (let n = 0; n < e.ikConstraints.length; n++) {
            const s = e.ikConstraints[n];
            this.ikConstraints.push(new O5(s, this))
        }
        this.transformConstraints = new Array;
        for (let n = 0; n < e.transformConstraints.length; n++) {
            const s = e.transformConstraints[n];
            this.transformConstraints.push(new N5(s, this))
        }
        this.pathConstraints = new Array;
        for (let n = 0; n < e.pathConstraints.length; n++) {
            const s = e.pathConstraints[n];
            this.pathConstraints.push(new gh(s, this))
        }
        this.color = new Se(1, 1, 1, 1),
            this.updateCache()
    }
    updateCache() {
        const e = this._updateCache;
        e.length = 0,
            this.updateCacheReset.length = 0;
        const n = this.bones;
        for (let u = 0, h = n.length; u < h; u++) {
            const d = n[u];
            d.sorted = d.data.skinRequired,
                d.active = !d.sorted
        }
        if (this.skin != null) {
            const u = this.skin.bones;
            for (let h = 0, d = this.skin.bones.length; h < d; h++) {
                let f = this.bones[u[h].index];
                do
                    f.sorted = !1,
                        f.active = !0,
                        f = f.parent;
                while (f != null)
            }
        }
        const s = this.ikConstraints
            , r = this.transformConstraints
            , i = this.pathConstraints
            , o = s.length
            , l = r.length
            , a = i.length
            , c = o + l + a;
        e: for (let u = 0; u < c; u++) {
            for (let h = 0; h < o; h++) {
                const d = s[h];
                if (d.data.order == u) {
                    this.sortIkConstraint(d);
                    continue e
                }
            }
            for (let h = 0; h < l; h++) {
                const d = r[h];
                if (d.data.order == u) {
                    this.sortTransformConstraint(d);
                    continue e
                }
            }
            for (let h = 0; h < a; h++) {
                const d = i[h];
                if (d.data.order == u) {
                    this.sortPathConstraint(d);
                    continue e
                }
            }
        }
        for (let u = 0, h = n.length; u < h; u++)
            this.sortBone(n[u])
    }
    sortIkConstraint(e) {
        if (e.active = e.target.isActive() && (!e.data.skinRequired || this.skin != null && Q.contains(this.skin.constraints, e.data, !0)),
            !e.active)
            return;
        const n = e.target;
        this.sortBone(n);
        const s = e.bones
            , r = s[0];
        if (this.sortBone(r),
            s.length > 1) {
            const i = s[s.length - 1];
            this._updateCache.indexOf(i) > -1 || this.updateCacheReset.push(i)
        }
        this._updateCache.push(e),
            this.sortReset(r.children),
            s[s.length - 1].sorted = !0
    }
    sortPathConstraint(e) {
        if (e.active = e.target.bone.isActive() && (!e.data.skinRequired || this.skin != null && Q.contains(this.skin.constraints, e.data, !0)),
            !e.active)
            return;
        const n = e.target
            , s = n.data.index
            , r = n.bone;
        this.skin != null && this.sortPathConstraintAttachment(this.skin, s, r),
            this.data.defaultSkin != null && this.data.defaultSkin != this.skin && this.sortPathConstraintAttachment(this.data.defaultSkin, s, r);
        for (let a = 0, c = this.data.skins.length; a < c; a++)
            this.sortPathConstraintAttachment(this.data.skins[a], s, r);
        const i = n.getAttachment();
        i instanceof $d && this.sortPathConstraintAttachmentWith(i, r);
        const o = e.bones
            , l = o.length;
        for (let a = 0; a < l; a++)
            this.sortBone(o[a]);
        this._updateCache.push(e);
        for (let a = 0; a < l; a++)
            this.sortReset(o[a].children);
        for (let a = 0; a < l; a++)
            o[a].sorted = !0
    }
    sortTransformConstraint(e) {
        if (e.active = e.target.isActive() && (!e.data.skinRequired || this.skin != null && Q.contains(this.skin.constraints, e.data, !0)),
            !e.active)
            return;
        this.sortBone(e.target);
        const n = e.bones
            , s = n.length;
        if (e.data.local)
            for (let r = 0; r < s; r++) {
                const i = n[r];
                this.sortBone(i.parent),
                    this._updateCache.indexOf(i) > -1 || this.updateCacheReset.push(i)
            }
        else
            for (let r = 0; r < s; r++)
                this.sortBone(n[r]);
        this._updateCache.push(e);
        for (let r = 0; r < s; r++)
            this.sortReset(n[r].children);
        for (let r = 0; r < s; r++)
            n[r].sorted = !0
    }
    sortPathConstraintAttachment(e, n, s) {
        const r = e.attachments[n];
        if (r)
            for (const i in r)
                this.sortPathConstraintAttachmentWith(r[i], s)
    }
    sortPathConstraintAttachmentWith(e, n) {
        if (!(e instanceof $d))
            return;
        const s = e.bones;
        if (s == null)
            this.sortBone(n);
        else {
            const r = this.bones;
            let i = 0;
            for (; i < s.length;) {
                const o = s[i++];
                for (let l = i + o; i < l; i++) {
                    const a = s[i];
                    this.sortBone(r[a])
                }
            }
        }
    }
    sortBone(e) {
        if (e.sorted)
            return;
        const n = e.parent;
        n != null && this.sortBone(n),
            e.sorted = !0,
            this._updateCache.push(e)
    }
    sortReset(e) {
        for (let n = 0, s = e.length; n < s; n++) {
            const r = e[n];
            r.active && (r.sorted && this.sortReset(r.children),
                r.sorted = !1)
        }
    }
    updateWorldTransform() {
        const e = this.updateCacheReset;
        for (let s = 0, r = e.length; s < r; s++) {
            const i = e[s];
            i.ax = i.x,
                i.ay = i.y,
                i.arotation = i.rotation,
                i.ascaleX = i.scaleX,
                i.ascaleY = i.scaleY,
                i.ashearX = i.shearX,
                i.ashearY = i.shearY,
                i.appliedValid = !0
        }
        const n = this._updateCache;
        for (let s = 0, r = n.length; s < r; s++)
            n[s].update()
    }
    setToSetupPose() {
        this.setBonesToSetupPose(),
            this.setSlotsToSetupPose()
    }
    setBonesToSetupPose() {
        const e = this.bones;
        for (let i = 0, o = e.length; i < o; i++)
            e[i].setToSetupPose();
        const n = this.ikConstraints;
        for (let i = 0, o = n.length; i < o; i++) {
            const l = n[i];
            l.mix = l.data.mix,
                l.softness = l.data.softness,
                l.bendDirection = l.data.bendDirection,
                l.compress = l.data.compress,
                l.stretch = l.data.stretch
        }
        const s = this.transformConstraints;
        for (let i = 0, o = s.length; i < o; i++) {
            const l = s[i]
                , a = l.data;
            l.rotateMix = a.rotateMix,
                l.translateMix = a.translateMix,
                l.scaleMix = a.scaleMix,
                l.shearMix = a.shearMix
        }
        const r = this.pathConstraints;
        for (let i = 0, o = r.length; i < o; i++) {
            const l = r[i]
                , a = l.data;
            l.position = a.position,
                l.spacing = a.spacing,
                l.rotateMix = a.rotateMix,
                l.translateMix = a.translateMix
        }
    }
    setSlotsToSetupPose() {
        const e = this.slots;
        Q.arrayCopy(e, 0, this.drawOrder, 0, e.length);
        for (let n = 0, s = e.length; n < s; n++)
            e[n].setToSetupPose()
    }
    getRootBone() {
        return this.bones.length == 0 ? null : this.bones[0]
    }
    findBone(e) {
        if (e == null)
            throw new Error("boneName cannot be null.");
        const n = this.bones;
        for (let s = 0, r = n.length; s < r; s++) {
            const i = n[s];
            if (i.data.name == e)
                return i
        }
        return null
    }
    findBoneIndex(e) {
        if (e == null)
            throw new Error("boneName cannot be null.");
        const n = this.bones;
        for (let s = 0, r = n.length; s < r; s++)
            if (n[s].data.name == e)
                return s;
        return -1
    }
    findSlot(e) {
        if (e == null)
            throw new Error("slotName cannot be null.");
        const n = this.slots;
        for (let s = 0, r = n.length; s < r; s++) {
            const i = n[s];
            if (i.data.name == e)
                return i
        }
        return null
    }
    findSlotIndex(e) {
        if (e == null)
            throw new Error("slotName cannot be null.");
        const n = this.slots;
        for (let s = 0, r = n.length; s < r; s++)
            if (n[s].data.name == e)
                return s;
        return -1
    }
    setSkinByName(e) {
        const n = this.data.findSkin(e);
        if (n == null)
            throw new Error(`Skin not found: ${e}`);
        this.setSkin(n)
    }
    setSkin(e) {
        if (e != this.skin) {
            if (e != null)
                if (this.skin != null)
                    e.attachAll(this, this.skin);
                else {
                    const n = this.slots;
                    for (let s = 0, r = n.length; s < r; s++) {
                        const i = n[s]
                            , o = i.data.attachmentName;
                        if (o != null) {
                            const l = e.getAttachment(s, o);
                            l != null && i.setAttachment(l)
                        }
                    }
                }
            this.skin = e,
                this.updateCache()
        }
    }
    getAttachmentByName(e, n) {
        return this.getAttachment(this.data.findSlotIndex(e), n)
    }
    getAttachment(e, n) {
        if (n == null)
            throw new Error("attachmentName cannot be null.");
        if (this.skin != null) {
            const s = this.skin.getAttachment(e, n);
            if (s != null)
                return s
        }
        return this.data.defaultSkin != null ? this.data.defaultSkin.getAttachment(e, n) : null
    }
    setAttachment(e, n) {
        if (e == null)
            throw new Error("slotName cannot be null.");
        const s = this.slots;
        for (let r = 0, i = s.length; r < i; r++) {
            const o = s[r];
            if (o.data.name == e) {
                let l = null;
                if (n != null && (l = this.getAttachment(r, n),
                    l == null))
                    throw new Error(`Attachment not found: ${n}, for slot: ${e}`);
                o.setAttachment(l);
                return
            }
        }
        throw new Error(`Slot not found: ${e}`)
    }
    findIkConstraint(e) {
        if (e == null)
            throw new Error("constraintName cannot be null.");
        const n = this.ikConstraints;
        for (let s = 0, r = n.length; s < r; s++) {
            const i = n[s];
            if (i.data.name == e)
                return i
        }
        return null
    }
    findTransformConstraint(e) {
        if (e == null)
            throw new Error("constraintName cannot be null.");
        const n = this.transformConstraints;
        for (let s = 0, r = n.length; s < r; s++) {
            const i = n[s];
            if (i.data.name == e)
                return i
        }
        return null
    }
    findPathConstraint(e) {
        if (e == null)
            throw new Error("constraintName cannot be null.");
        const n = this.pathConstraints;
        for (let s = 0, r = n.length; s < r; s++) {
            const i = n[s];
            if (i.data.name == e)
                return i
        }
        return null
    }
    getBounds(e, n, s = new Array(2)) {
        if (e == null)
            throw new Error("offset cannot be null.");
        if (n == null)
            throw new Error("size cannot be null.");
        const r = this.drawOrder;
        let i = Number.POSITIVE_INFINITY
            , o = Number.POSITIVE_INFINITY
            , l = Number.NEGATIVE_INFINITY
            , a = Number.NEGATIVE_INFINITY;
        for (let c = 0, u = r.length; c < u; c++) {
            const h = r[c];
            if (!h.bone.active)
                continue;
            let d = 0
                , f = null;
            const p = h.getAttachment();
            if (p instanceof ot)
                d = 8,
                    f = Q.setArraySize(s, d, 0),
                    p.computeWorldVertices(h.bone, f, 0, 2);
            else if (p instanceof F_) {
                const m = p;
                d = m.worldVerticesLength,
                    f = Q.setArraySize(s, d, 0),
                    m.computeWorldVertices(h, 0, d, f, 0, 2)
            }
            if (f != null)
                for (let m = 0, g = f.length; m < g; m += 2) {
                    const b = f[m]
                        , v = f[m + 1];
                    i = Math.min(i, b),
                        o = Math.min(o, v),
                        l = Math.max(l, b),
                        a = Math.max(a, v)
                }
        }
        e.set(i, o),
            n.set(l - i, a - o)
    }
    update(e) {
        this.time += e
    }
    get flipX() {
        return this.scaleX == -1
    }
    set flipX(e) {
        Fh.deprecatedWarning1 || (Fh.deprecatedWarning1 = !0,
            console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),
            this.scaleX = e ? 1 : -1
    }
    get flipY() {
        return this.scaleY == -1
    }
    set flipY(e) {
        Fh.deprecatedWarning1 || (Fh.deprecatedWarning1 = !0,
            console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),
            this.scaleY = e ? 1 : -1
    }
}
    ;
let Iw = Fh;
Iw.deprecatedWarning1 = !1;
let Aw = class {
    constructor() {
        this.bones = new Array,
            this.slots = new Array,
            this.skins = new Array,
            this.events = new Array,
            this.animations = new Array,
            this.ikConstraints = new Array,
            this.transformConstraints = new Array,
            this.pathConstraints = new Array,
            this.fps = 0
    }
    findBone(e) {
        if (e == null)
            throw new Error("boneName cannot be null.");
        const n = this.bones;
        for (let s = 0, r = n.length; s < r; s++) {
            const i = n[s];
            if (i.name == e)
                return i
        }
        return null
    }
    findBoneIndex(e) {
        if (e == null)
            throw new Error("boneName cannot be null.");
        const n = this.bones;
        for (let s = 0, r = n.length; s < r; s++)
            if (n[s].name == e)
                return s;
        return -1
    }
    findSlot(e) {
        if (e == null)
            throw new Error("slotName cannot be null.");
        const n = this.slots;
        for (let s = 0, r = n.length; s < r; s++) {
            const i = n[s];
            if (i.name == e)
                return i
        }
        return null
    }
    findSlotIndex(e) {
        if (e == null)
            throw new Error("slotName cannot be null.");
        const n = this.slots;
        for (let s = 0, r = n.length; s < r; s++)
            if (n[s].name == e)
                return s;
        return -1
    }
    findSkin(e) {
        if (e == null)
            throw new Error("skinName cannot be null.");
        const n = this.skins;
        for (let s = 0, r = n.length; s < r; s++) {
            const i = n[s];
            if (i.name == e)
                return i
        }
        return null
    }
    findEvent(e) {
        if (e == null)
            throw new Error("eventDataName cannot be null.");
        const n = this.events;
        for (let s = 0, r = n.length; s < r; s++) {
            const i = n[s];
            if (i.name == e)
                return i
        }
        return null
    }
    findAnimation(e) {
        if (e == null)
            throw new Error("animationName cannot be null.");
        const n = this.animations;
        for (let s = 0, r = n.length; s < r; s++) {
            const i = n[s];
            if (i.name == e)
                return i
        }
        return null
    }
    findIkConstraint(e) {
        if (e == null)
            throw new Error("constraintName cannot be null.");
        const n = this.ikConstraints;
        for (let s = 0, r = n.length; s < r; s++) {
            const i = n[s];
            if (i.name == e)
                return i
        }
        return null
    }
    findTransformConstraint(e) {
        if (e == null)
            throw new Error("constraintName cannot be null.");
        const n = this.transformConstraints;
        for (let s = 0, r = n.length; s < r; s++) {
            const i = n[s];
            if (i.name == e)
                return i
        }
        return null
    }
    findPathConstraint(e) {
        if (e == null)
            throw new Error("constraintName cannot be null.");
        const n = this.pathConstraints;
        for (let s = 0, r = n.length; s < r; s++) {
            const i = n[s];
            if (i.name == e)
                return i
        }
        return null
    }
    findPathConstraintIndex(e) {
        if (e == null)
            throw new Error("pathConstraintName cannot be null.");
        const n = this.pathConstraints;
        for (let s = 0, r = n.length; s < r; s++)
            if (n[s].name == e)
                return s;
        return -1
    }
}
    , kw = class {
        constructor(e, n, s) {
            if (this.color = new Se(1, 1, 1, 1),
                e < 0)
                throw new Error("index must be >= 0.");
            if (n == null)
                throw new Error("name cannot be null.");
            if (s == null)
                throw new Error("boneData cannot be null.");
            this.index = e,
                this.name = n,
                this.boneData = s
        }
    }
    , Rw = class extends V_ {
        constructor(e) {
            super(e, 0, !1),
                this.bones = new Array,
                this.rotateMix = 0,
                this.translateMix = 0,
                this.scaleMix = 0,
                this.shearMix = 0,
                this.offsetRotation = 0,
                this.offsetX = 0,
                this.offsetY = 0,
                this.offsetScaleX = 0,
                this.offsetScaleY = 0,
                this.offsetShearY = 0,
                this.relative = !1,
                this.local = !1
        }
    }
    , Xb = class {
        constructor(e, n, s) {
            this.slotIndex = e,
                this.name = n,
                this.attachment = s
        }
    }
    , ig = class {
        constructor(e) {
            if (this.attachments = new Array,
                this.bones = Array(),
                this.constraints = new Array,
                e == null)
                throw new Error("name cannot be null.");
            this.name = e
        }
        setAttachment(e, n, s) {
            if (s == null)
                throw new Error("attachment cannot be null.");
            const r = this.attachments;
            e >= r.length && (r.length = e + 1),
                r[e] || (r[e] = {}),
                r[e][n] = s
        }
        addSkin(e) {
            for (let s = 0; s < e.bones.length; s++) {
                const r = e.bones[s];
                let i = !1;
                for (let o = 0; o < this.bones.length; o++)
                    if (this.bones[o] == r) {
                        i = !0;
                        break
                    }
                i || this.bones.push(r)
            }
            for (let s = 0; s < e.constraints.length; s++) {
                const r = e.constraints[s];
                let i = !1;
                for (let o = 0; o < this.constraints.length; o++)
                    if (this.constraints[o] == r) {
                        i = !0;
                        break
                    }
                i || this.constraints.push(r)
            }
            const n = e.getAttachments();
            for (let s = 0; s < n.length; s++) {
                const r = n[s];
                this.setAttachment(r.slotIndex, r.name, r.attachment)
            }
        }
        copySkin(e) {
            for (let s = 0; s < e.bones.length; s++) {
                const r = e.bones[s];
                let i = !1;
                for (let o = 0; o < this.bones.length; o++)
                    if (this.bones[o] == r) {
                        i = !0;
                        break
                    }
                i || this.bones.push(r)
            }
            for (let s = 0; s < e.constraints.length; s++) {
                const r = e.constraints[s];
                let i = !1;
                for (let o = 0; o < this.constraints.length; o++)
                    if (this.constraints[o] == r) {
                        i = !0;
                        break
                    }
                i || this.constraints.push(r)
            }
            const n = e.getAttachments();
            for (let s = 0; s < n.length; s++) {
                const r = n[s];
                r.attachment != null && (r.attachment instanceof F_ ? (r.attachment = r.attachment.newLinkedMesh(),
                    this.setAttachment(r.slotIndex, r.name, r.attachment)) : (r.attachment = r.attachment.copy(),
                        this.setAttachment(r.slotIndex, r.name, r.attachment)))
            }
        }
        getAttachment(e, n) {
            const s = this.attachments[e];
            return s ? s[n] : null
        }
        removeAttachment(e, n) {
            const s = this.attachments[e];
            s && (s[n] = null)
        }
        getAttachments() {
            const e = new Array;
            for (let n = 0; n < this.attachments.length; n++) {
                const s = this.attachments[n];
                if (s)
                    for (const r in s) {
                        const i = s[r];
                        i && e.push(new Xb(n, r, i))
                    }
            }
            return e
        }
        getAttachmentsForSlot(e, n) {
            const s = this.attachments[e];
            if (s)
                for (const r in s) {
                    const i = s[r];
                    i && n.push(new Xb(e, r, i))
                }
        }
        clear() {
            this.attachments.length = 0,
                this.bones.length = 0,
                this.constraints.length = 0
        }
        attachAll(e, n) {
            let s = 0;
            for (let r = 0; r < e.slots.length; r++) {
                const i = e.slots[r]
                    , o = i.getAttachment();
                if (o && s < n.attachments.length) {
                    const l = n.attachments[s];
                    for (const a in l) {
                        const c = l[a];
                        if (o == c) {
                            const u = this.getAttachment(s, a);
                            u != null && i.setAttachment(u);
                            break
                        }
                    }
                }
                s++
            }
        }
    }
    ;
const un = class {
    constructor(t) {
        this.scale = 1,
            this.linkedMeshes = new Array,
            this.attachmentLoader = t
    }
    readSkeletonData(t) {
        const e = this.scale
            , n = new Aw;
        n.name = "";
        const s = new Gm(t);
        n.hash = s.readString(),
            n.version = s.readString(),
            n.version === "3.8.75" && console.error("Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine."),
            n.x = s.readFloat(),
            n.y = s.readFloat(),
            n.width = s.readFloat(),
            n.height = s.readFloat();
        const r = s.readBoolean();
        r && (n.fps = s.readFloat(),
            n.imagesPath = s.readString(),
            n.audioPath = s.readString());
        let i = 0;
        i = s.readInt(!0);
        for (let l = 0; l < i; l++)
            s.strings.push(s.readString());
        i = s.readInt(!0);
        for (let l = 0; l < i; l++) {
            const a = s.readString()
                , c = l == 0 ? null : n.bones[s.readInt(!0)]
                , u = new ww(l, a, c);
            u.rotation = s.readFloat(),
                u.x = s.readFloat() * e,
                u.y = s.readFloat() * e,
                u.scaleX = s.readFloat(),
                u.scaleY = s.readFloat(),
                u.shearX = s.readFloat(),
                u.shearY = s.readFloat(),
                u.length = s.readFloat() * e,
                u.transformMode = un.TransformModeValues[s.readInt(!0)],
                u.skinRequired = s.readBoolean(),
                r && Se.rgba8888ToColor(u.color, s.readInt32()),
                n.bones.push(u)
        }
        i = s.readInt(!0);
        for (let l = 0; l < i; l++) {
            const a = s.readString()
                , c = n.bones[s.readInt(!0)]
                , u = new kw(l, a, c);
            Se.rgba8888ToColor(u.color, s.readInt32());
            const h = s.readInt32();
            h != -1 && Se.rgb888ToColor(u.darkColor = new Se, h),
                u.attachmentName = s.readStringRef(),
                u.blendMode = un.BlendModeValues[s.readInt(!0)],
                n.slots.push(u)
        }
        i = s.readInt(!0);
        for (let l = 0, a; l < i; l++) {
            const c = new Tw(s.readString());
            c.order = s.readInt(!0),
                c.skinRequired = s.readBoolean(),
                a = s.readInt(!0);
            for (let u = 0; u < a; u++)
                c.bones.push(n.bones[s.readInt(!0)]);
            c.target = n.bones[s.readInt(!0)],
                c.mix = s.readFloat(),
                c.softness = s.readFloat() * e,
                c.bendDirection = s.readByte(),
                c.compress = s.readBoolean(),
                c.stretch = s.readBoolean(),
                c.uniform = s.readBoolean(),
                n.ikConstraints.push(c)
        }
        i = s.readInt(!0);
        for (let l = 0, a; l < i; l++) {
            const c = new Rw(s.readString());
            c.order = s.readInt(!0),
                c.skinRequired = s.readBoolean(),
                a = s.readInt(!0);
            for (let u = 0; u < a; u++)
                c.bones.push(n.bones[s.readInt(!0)]);
            c.target = n.bones[s.readInt(!0)],
                c.local = s.readBoolean(),
                c.relative = s.readBoolean(),
                c.offsetRotation = s.readFloat(),
                c.offsetX = s.readFloat() * e,
                c.offsetY = s.readFloat() * e,
                c.offsetScaleX = s.readFloat(),
                c.offsetScaleY = s.readFloat(),
                c.offsetShearY = s.readFloat(),
                c.rotateMix = s.readFloat(),
                c.translateMix = s.readFloat(),
                c.scaleMix = s.readFloat(),
                c.shearMix = s.readFloat(),
                n.transformConstraints.push(c)
        }
        i = s.readInt(!0);
        for (let l = 0, a; l < i; l++) {
            const c = new Cw(s.readString());
            c.order = s.readInt(!0),
                c.skinRequired = s.readBoolean(),
                a = s.readInt(!0);
            for (let u = 0; u < a; u++)
                c.bones.push(n.bones[s.readInt(!0)]);
            c.target = n.slots[s.readInt(!0)],
                c.positionMode = un.PositionModeValues[s.readInt(!0)],
                c.spacingMode = un.SpacingModeValues[s.readInt(!0)],
                c.rotateMode = un.RotateModeValues[s.readInt(!0)],
                c.offsetRotation = s.readFloat(),
                c.position = s.readFloat(),
                c.positionMode == on.Fixed && (c.position *= e),
                c.spacing = s.readFloat(),
                (c.spacingMode == Xn.Length || c.spacingMode == Xn.Fixed) && (c.spacing *= e),
                c.rotateMix = s.readFloat(),
                c.translateMix = s.readFloat(),
                n.pathConstraints.push(c)
        }
        const o = this.readSkin(s, n, !0, r);
        o != null && (n.defaultSkin = o,
            n.skins.push(o));
        {
            let l = n.skins.length;
            for (Q.setArraySize(n.skins, i = l + s.readInt(!0)); l < i; l++)
                n.skins[l] = this.readSkin(s, n, !1, r)
        }
        i = this.linkedMeshes.length;
        for (let l = 0; l < i; l++) {
            const a = this.linkedMeshes[l]
                , c = a.skin == null ? n.defaultSkin : n.findSkin(a.skin);
            if (c == null)
                throw new Error(`Skin not found: ${a.skin}`);
            const u = c.getAttachment(a.slotIndex, a.parent);
            if (u == null)
                throw new Error(`Parent mesh not found: ${a.parent}`);
            a.mesh.deformAttachment = a.inheritDeform ? u : a.mesh,
                a.mesh.setParentMesh(u)
        }
        this.linkedMeshes.length = 0,
            i = s.readInt(!0);
        for (let l = 0; l < i; l++) {
            const a = new Ew(s.readStringRef());
            a.intValue = s.readInt(!1),
                a.floatValue = s.readFloat(),
                a.stringValue = s.readString(),
                a.audioPath = s.readString(),
                a.audioPath != null && (a.volume = s.readFloat(),
                    a.balance = s.readFloat()),
                n.events.push(a)
        }
        i = s.readInt(!0);
        for (let l = 0; l < i; l++)
            n.animations.push(this.readAnimation(s, s.readString(), n));
        return n
    }
    readSkin(t, e, n, s) {
        let r = null
            , i = 0;
        if (n) {
            if (i = t.readInt(!0),
                i == 0)
                return null;
            r = new ig("default")
        } else {
            r = new ig(t.readStringRef()),
                r.bones.length = t.readInt(!0);
            for (let o = 0, l = r.bones.length; o < l; o++)
                r.bones[o] = e.bones[t.readInt(!0)];
            for (let o = 0, l = t.readInt(!0); o < l; o++)
                r.constraints.push(e.ikConstraints[t.readInt(!0)]);
            for (let o = 0, l = t.readInt(!0); o < l; o++)
                r.constraints.push(e.transformConstraints[t.readInt(!0)]);
            for (let o = 0, l = t.readInt(!0); o < l; o++)
                r.constraints.push(e.pathConstraints[t.readInt(!0)]);
            i = t.readInt(!0)
        }
        for (let o = 0; o < i; o++) {
            const l = t.readInt(!0);
            for (let a = 0, c = t.readInt(!0); a < c; a++) {
                const u = t.readStringRef()
                    , h = this.readAttachment(t, e, r, l, u, s);
                h != null && r.setAttachment(l, u, h)
            }
        }
        return r
    }
    readAttachment(t, e, n, s, r, i) {
        const o = this.scale;
        let l = t.readStringRef();
        l == null && (l = r);
        const a = t.readByte();
        switch (un.AttachmentTypeValues[a]) {
            case ut.Region:
                {
                    let u = t.readStringRef();
                    const h = t.readFloat()
                        , d = t.readFloat()
                        , f = t.readFloat()
                        , p = t.readFloat()
                        , m = t.readFloat()
                        , g = t.readFloat()
                        , b = t.readFloat()
                        , v = t.readInt32();
                    u == null && (u = l);
                    const _ = this.attachmentLoader.newRegionAttachment(n, l, u);
                    return _ == null ? null : (_.path = u,
                        _.x = d * o,
                        _.y = f * o,
                        _.scaleX = p,
                        _.scaleY = m,
                        _.rotation = h,
                        _.width = g * o,
                        _.height = b * o,
                        Se.rgba8888ToColor(_.color, v),
                        _)
                }
            case ut.BoundingBox:
                {
                    const u = t.readInt(!0)
                        , h = this.readVertices(t, u)
                        , d = i ? t.readInt32() : 0
                        , f = this.attachmentLoader.newBoundingBoxAttachment(n, l);
                    return f == null ? null : (f.worldVerticesLength = u << 1,
                        f.vertices = h.vertices,
                        f.bones = h.bones,
                        i && Se.rgba8888ToColor(f.color, d),
                        f)
                }
            case ut.Mesh:
                {
                    let u = t.readStringRef();
                    const h = t.readInt32()
                        , d = t.readInt(!0)
                        , f = this.readFloatArray(t, d << 1, 1)
                        , p = this.readShortArray(t)
                        , m = this.readVertices(t, d)
                        , g = t.readInt(!0);
                    let b = null
                        , v = 0
                        , _ = 0;
                    i && (b = this.readShortArray(t),
                        v = t.readFloat(),
                        _ = t.readFloat()),
                        u == null && (u = l);
                    const y = this.attachmentLoader.newMeshAttachment(n, l, u);
                    return y == null ? null : (y.path = u,
                        Se.rgba8888ToColor(y.color, h),
                        y.bones = m.bones,
                        y.vertices = m.vertices,
                        y.worldVerticesLength = d << 1,
                        y.triangles = p,
                        y.regionUVs = new Float32Array(f),
                        y.hullLength = g << 1,
                        i && (y.edges = b,
                            y.width = v * o,
                            y.height = _ * o),
                        y)
                }
            case ut.LinkedMesh:
                {
                    let u = t.readStringRef();
                    const h = t.readInt32()
                        , d = t.readStringRef()
                        , f = t.readStringRef()
                        , p = t.readBoolean();
                    let m = 0
                        , g = 0;
                    i && (m = t.readFloat(),
                        g = t.readFloat()),
                        u == null && (u = l);
                    const b = this.attachmentLoader.newMeshAttachment(n, l, u);
                    return b == null ? null : (b.path = u,
                        Se.rgba8888ToColor(b.color, h),
                        i && (b.width = m * o,
                            b.height = g * o),
                        this.linkedMeshes.push(new phe(b, d, s, f, p)),
                        b)
                }
            case ut.Path:
                {
                    const u = t.readBoolean()
                        , h = t.readBoolean()
                        , d = t.readInt(!0)
                        , f = this.readVertices(t, d)
                        , p = Q.newArray(d / 3, 0);
                    for (let b = 0, v = p.length; b < v; b++)
                        p[b] = t.readFloat() * o;
                    const m = i ? t.readInt32() : 0
                        , g = this.attachmentLoader.newPathAttachment(n, l);
                    return g == null ? null : (g.closed = u,
                        g.constantSpeed = h,
                        g.worldVerticesLength = d << 1,
                        g.vertices = f.vertices,
                        g.bones = f.bones,
                        g.lengths = p,
                        i && Se.rgba8888ToColor(g.color, m),
                        g)
                }
            case ut.Point:
                {
                    const u = t.readFloat()
                        , h = t.readFloat()
                        , d = t.readFloat()
                        , f = i ? t.readInt32() : 0
                        , p = this.attachmentLoader.newPointAttachment(n, l);
                    return p == null ? null : (p.x = h * o,
                        p.y = d * o,
                        p.rotation = u,
                        i && Se.rgba8888ToColor(p.color, f),
                        p)
                }
            case ut.Clipping:
                {
                    const u = t.readInt(!0)
                        , h = t.readInt(!0)
                        , d = this.readVertices(t, h)
                        , f = i ? t.readInt32() : 0
                        , p = this.attachmentLoader.newClippingAttachment(n, l);
                    return p == null ? null : (p.endSlot = e.slots[u],
                        p.worldVerticesLength = h << 1,
                        p.vertices = d.vertices,
                        p.bones = d.bones,
                        i && Se.rgba8888ToColor(p.color, f),
                        p)
                }
        }
        return null
    }
    readVertices(t, e) {
        const n = e << 1
            , s = new mhe
            , r = this.scale;
        if (!t.readBoolean())
            return s.vertices = this.readFloatArray(t, n, r),
                s;
        const i = new Array
            , o = new Array;
        for (let l = 0; l < e; l++) {
            const a = t.readInt(!0);
            o.push(a);
            for (let c = 0; c < a; c++)
                o.push(t.readInt(!0)),
                    i.push(t.readFloat() * r),
                    i.push(t.readFloat() * r),
                    i.push(t.readFloat())
        }
        return s.vertices = Q.toFloatArray(i),
            s.bones = o,
            s
    }
    readFloatArray(t, e, n) {
        const s = new Array(e);
        if (n == 1)
            for (let r = 0; r < e; r++)
                s[r] = t.readFloat();
        else
            for (let r = 0; r < e; r++)
                s[r] = t.readFloat() * n;
        return s
    }
    readShortArray(t) {
        const e = t.readInt(!0)
            , n = new Array(e);
        for (let s = 0; s < e; s++)
            n[s] = t.readShort();
        return n
    }
    readAnimation(t, e, n) {
        const s = new Array
            , r = this.scale;
        let i = 0;
        const o = new Se
            , l = new Se;
        for (let u = 0, h = t.readInt(!0); u < h; u++) {
            const d = t.readInt(!0);
            for (let f = 0, p = t.readInt(!0); f < p; f++) {
                const m = t.readByte()
                    , g = t.readInt(!0);
                switch (m) {
                    case un.SLOT_ATTACHMENT:
                        {
                            const b = new Dl(g);
                            b.slotIndex = d;
                            for (let v = 0; v < g; v++)
                                b.setFrame(v, t.readFloat(), t.readStringRef());
                            s.push(b),
                                i = Math.max(i, b.frames[g - 1]);
                            break
                        }
                    case un.SLOT_COLOR:
                        {
                            const b = new Os(g);
                            b.slotIndex = d;
                            for (let v = 0; v < g; v++) {
                                const _ = t.readFloat();
                                Se.rgba8888ToColor(o, t.readInt32()),
                                    b.setFrame(v, _, o.r, o.g, o.b, o.a),
                                    v < g - 1 && this.readCurve(t, v, b)
                            }
                            s.push(b),
                                i = Math.max(i, b.frames[(g - 1) * Os.ENTRIES]);
                            break
                        }
                    case un.SLOT_TWO_COLOR:
                        {
                            const b = new wn(g);
                            b.slotIndex = d;
                            for (let v = 0; v < g; v++) {
                                const _ = t.readFloat();
                                Se.rgba8888ToColor(o, t.readInt32()),
                                    Se.rgb888ToColor(l, t.readInt32()),
                                    b.setFrame(v, _, o.r, o.g, o.b, o.a, l.r, l.g, l.b),
                                    v < g - 1 && this.readCurve(t, v, b)
                            }
                            s.push(b),
                                i = Math.max(i, b.frames[(g - 1) * wn.ENTRIES]);
                            break
                        }
                }
            }
        }
        for (let u = 0, h = t.readInt(!0); u < h; u++) {
            const d = t.readInt(!0);
            for (let f = 0, p = t.readInt(!0); f < p; f++) {
                const m = t.readByte()
                    , g = t.readInt(!0);
                switch (m) {
                    case un.BONE_ROTATE:
                        {
                            const b = new ts(g);
                            b.boneIndex = d;
                            for (let v = 0; v < g; v++)
                                b.setFrame(v, t.readFloat(), t.readFloat()),
                                    v < g - 1 && this.readCurve(t, v, b);
                            s.push(b),
                                i = Math.max(i, b.frames[(g - 1) * ts.ENTRIES]);
                            break
                        }
                    case un.BONE_TRANSLATE:
                    case un.BONE_SCALE:
                    case un.BONE_SHEAR:
                        {
                            let b, v = 1;
                            m == un.BONE_SCALE ? b = new mw(g) : m == un.BONE_SHEAR ? b = new gw(g) : (b = new hr(g),
                                v = r),
                                b.boneIndex = d;
                            for (let _ = 0; _ < g; _++)
                                b.setFrame(_, t.readFloat(), t.readFloat() * v, t.readFloat() * v),
                                    _ < g - 1 && this.readCurve(t, _, b);
                            s.push(b),
                                i = Math.max(i, b.frames[(g - 1) * hr.ENTRIES]);
                            break
                        }
                }
            }
        }
        for (let u = 0, h = t.readInt(!0); u < h; u++) {
            const d = t.readInt(!0)
                , f = t.readInt(!0)
                , p = new as(f);
            p.ikConstraintIndex = d;
            for (let m = 0; m < f; m++)
                p.setFrame(m, t.readFloat(), t.readFloat(), t.readFloat() * r, t.readByte(), t.readBoolean(), t.readBoolean()),
                    m < f - 1 && this.readCurve(t, m, p);
            s.push(p),
                i = Math.max(i, p.frames[(f - 1) * as.ENTRIES])
        }
        for (let u = 0, h = t.readInt(!0); u < h; u++) {
            const d = t.readInt(!0)
                , f = t.readInt(!0)
                , p = new Ns(f);
            p.transformConstraintIndex = d;
            for (let m = 0; m < f; m++)
                p.setFrame(m, t.readFloat(), t.readFloat(), t.readFloat(), t.readFloat(), t.readFloat()),
                    m < f - 1 && this.readCurve(t, m, p);
            s.push(p),
                i = Math.max(i, p.frames[(f - 1) * Ns.ENTRIES])
        }
        for (let u = 0, h = t.readInt(!0); u < h; u++) {
            const d = t.readInt(!0)
                , f = n.pathConstraints[d];
            for (let p = 0, m = t.readInt(!0); p < m; p++) {
                const g = t.readByte()
                    , b = t.readInt(!0);
                switch (g) {
                    case un.PATH_POSITION:
                    case un.PATH_SPACING:
                        {
                            let v, _ = 1;
                            g == un.PATH_SPACING ? (v = new yw(b),
                                (f.spacingMode == Xn.Length || f.spacingMode == Xn.Fixed) && (_ = r)) : (v = new zi(b),
                                    f.positionMode == on.Fixed && (_ = r)),
                                v.pathConstraintIndex = d;
                            for (let y = 0; y < b; y++)
                                v.setFrame(y, t.readFloat(), t.readFloat() * _),
                                    y < b - 1 && this.readCurve(t, y, v);
                            s.push(v),
                                i = Math.max(i, v.frames[(b - 1) * zi.ENTRIES]);
                            break
                        }
                    case un.PATH_MIX:
                        {
                            const v = new ui(b);
                            v.pathConstraintIndex = d;
                            for (let _ = 0; _ < b; _++)
                                v.setFrame(_, t.readFloat(), t.readFloat(), t.readFloat()),
                                    _ < b - 1 && this.readCurve(t, _, v);
                            s.push(v),
                                i = Math.max(i, v.frames[(b - 1) * ui.ENTRIES]);
                            break
                        }
                }
            }
        }
        for (let u = 0, h = t.readInt(!0); u < h; u++) {
            const d = n.skins[t.readInt(!0)];
            for (let f = 0, p = t.readInt(!0); f < p; f++) {
                const m = t.readInt(!0);
                for (let g = 0, b = t.readInt(!0); g < b; g++) {
                    const v = d.getAttachment(m, t.readStringRef())
                        , _ = v.bones != null
                        , y = v.vertices
                        , x = _ ? y.length / 3 * 2 : y.length
                        , w = t.readInt(!0)
                        , S = new _w(w);
                    S.slotIndex = m,
                        S.attachment = v;
                    for (let E = 0; E < w; E++) {
                        const C = t.readFloat();
                        let I, L = t.readInt(!0);
                        if (L == 0)
                            I = _ ? Q.newFloatArray(x) : y;
                        else {
                            I = Q.newFloatArray(x);
                            const k = t.readInt(!0);
                            if (L += k,
                                r == 1)
                                for (let R = k; R < L; R++)
                                    I[R] = t.readFloat();
                            else
                                for (let R = k; R < L; R++)
                                    I[R] = t.readFloat() * r;
                            if (!_)
                                for (let R = 0, U = I.length; R < U; R++)
                                    I[R] += y[R]
                        }
                        S.setFrame(E, C, I),
                            E < w - 1 && this.readCurve(t, E, S)
                    }
                    s.push(S),
                        i = Math.max(i, S.frames[w - 1])
                }
            }
        }
        const a = t.readInt(!0);
        if (a > 0) {
            const u = new Cu(a)
                , h = n.slots.length;
            for (let d = 0; d < a; d++) {
                const f = t.readFloat()
                    , p = t.readInt(!0)
                    , m = Q.newArray(h, 0);
                for (let _ = h - 1; _ >= 0; _--)
                    m[_] = -1;
                const g = Q.newArray(h - p, 0);
                let b = 0
                    , v = 0;
                for (let _ = 0; _ < p; _++) {
                    const y = t.readInt(!0);
                    for (; b != y;)
                        g[v++] = b++;
                    m[b + t.readInt(!0)] = b++
                }
                for (; b < h;)
                    g[v++] = b++;
                for (let _ = h - 1; _ >= 0; _--)
                    m[_] == -1 && (m[_] = g[--v]);
                u.setFrame(d, f, m)
            }
            s.push(u),
                i = Math.max(i, u.frames[a - 1])
        }
        const c = t.readInt(!0);
        if (c > 0) {
            const u = new $_(c);
            for (let h = 0; h < c; h++) {
                const d = t.readFloat()
                    , f = n.events[t.readInt(!0)]
                    , p = new Sw(d, f);
                p.intValue = t.readInt(!1),
                    p.floatValue = t.readFloat(),
                    p.stringValue = t.readBoolean() ? t.readString() : f.stringValue,
                    p.data.audioPath != null && (p.volume = t.readFloat(),
                        p.balance = t.readFloat()),
                    u.setFrame(h, p)
            }
            s.push(u),
                i = Math.max(i, u.frames[c - 1])
        }
        return new xn(e, s, i)
    }
    readCurve(t, e, n) {
        switch (t.readByte()) {
            case un.CURVE_STEPPED:
                n.setStepped(e);
                break;
            case un.CURVE_BEZIER:
                this.setCurve(n, e, t.readFloat(), t.readFloat(), t.readFloat(), t.readFloat());
                break
        }
    }
    setCurve(t, e, n, s, r, i) {
        t.setCurve(e, n, s, r, i)
    }
}
    ;
let Sn = un;
Sn.AttachmentTypeValues = [0, 1, 2, 3, 4, 5, 6];
Sn.TransformModeValues = [Qe.Normal, Qe.OnlyTranslation, Qe.NoRotationOrReflection, Qe.NoScale, Qe.NoScaleOrReflection];
Sn.PositionModeValues = [on.Fixed, on.Percent];
Sn.SpacingModeValues = [Xn.Length, Xn.Fixed, Xn.Percent];
Sn.RotateModeValues = [bn.Tangent, bn.Chain, bn.ChainScale];
Sn.BlendModeValues = [Oe.NORMAL, Oe.ADD, Oe.MULTIPLY, Oe.SCREEN];
Sn.BONE_ROTATE = 0;
Sn.BONE_TRANSLATE = 1;
Sn.BONE_SCALE = 2;
Sn.BONE_SHEAR = 3;
Sn.SLOT_ATTACHMENT = 0;
Sn.SLOT_COLOR = 1;
Sn.SLOT_TWO_COLOR = 2;
Sn.PATH_POSITION = 0;
Sn.PATH_SPACING = 1;
Sn.PATH_MIX = 2;
Sn.CURVE_LINEAR = 0;
Sn.CURVE_STEPPED = 1;
Sn.CURVE_BEZIER = 2;
let phe = class {
    constructor(e, n, s, r, i) {
        this.mesh = e,
            this.skin = n,
            this.slotIndex = s,
            this.parent = r,
            this.inheritDeform = i
    }
}
    , mhe = class {
        constructor(e = null, n = null) {
            this.bones = e,
                this.vertices = n
        }
    }
    , ghe = class extends aw {
    }
    , D5 = class Yc {
        constructor(e) {
            this.scale = 1,
                this.linkedMeshes = new Array,
                this.attachmentLoader = e
        }
        readSkeletonData(e) {
            const n = this.scale
                , s = new Aw
                , r = typeof e == "string" ? JSON.parse(e) : e
                , i = r.skeleton;
            if (i != null) {
                if (s.hash = i.hash,
                    s.version = i.spine,
                    s.version.substr(0, 3) !== "3.8") {
                    const o = `Spine 3.8 loader cant load version ${i.spine}. Please configure your pixi-spine bundle`;
                    console.error(o)
                }
                s.version === "3.8.75" && console.error("Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine."),
                    s.x = i.x,
                    s.y = i.y,
                    s.width = i.width,
                    s.height = i.height,
                    s.fps = i.fps,
                    s.imagesPath = i.images
            }
            if (r.bones)
                for (let o = 0; o < r.bones.length; o++) {
                    const l = r.bones[o];
                    let a = null;
                    const c = this.getValue(l, "parent", null);
                    if (c != null && (a = s.findBone(c),
                        a == null))
                        throw new Error(`Parent bone not found: ${c}`);
                    const u = new ww(s.bones.length, l.name, a);
                    u.length = this.getValue(l, "length", 0) * n,
                        u.x = this.getValue(l, "x", 0) * n,
                        u.y = this.getValue(l, "y", 0) * n,
                        u.rotation = this.getValue(l, "rotation", 0),
                        u.scaleX = this.getValue(l, "scaleX", 1),
                        u.scaleY = this.getValue(l, "scaleY", 1),
                        u.shearX = this.getValue(l, "shearX", 0),
                        u.shearY = this.getValue(l, "shearY", 0),
                        u.transformMode = Yc.transformModeFromString(this.getValue(l, "transform", "normal")),
                        u.skinRequired = this.getValue(l, "skin", !1),
                        s.bones.push(u)
                }
            if (r.slots)
                for (let o = 0; o < r.slots.length; o++) {
                    const l = r.slots[o]
                        , a = l.name
                        , c = l.bone
                        , u = s.findBone(c);
                    if (u == null)
                        throw new Error(`Slot bone not found: ${c}`);
                    const h = new kw(s.slots.length, a, u)
                        , d = this.getValue(l, "color", null);
                    d != null && h.color.setFromString(d);
                    const f = this.getValue(l, "dark", null);
                    f != null && (h.darkColor = new Se(1, 1, 1, 1),
                        h.darkColor.setFromString(f)),
                        h.attachmentName = this.getValue(l, "attachment", null),
                        h.blendMode = Yc.blendModeFromString(this.getValue(l, "blend", "normal")),
                        s.slots.push(h)
                }
            if (r.ik)
                for (let o = 0; o < r.ik.length; o++) {
                    const l = r.ik[o]
                        , a = new Tw(l.name);
                    a.order = this.getValue(l, "order", 0),
                        a.skinRequired = this.getValue(l, "skin", !1);
                    for (let u = 0; u < l.bones.length; u++) {
                        const h = l.bones[u]
                            , d = s.findBone(h);
                        if (d == null)
                            throw new Error(`IK bone not found: ${h}`);
                        a.bones.push(d)
                    }
                    const c = l.target;
                    if (a.target = s.findBone(c),
                        a.target == null)
                        throw new Error(`IK target bone not found: ${c}`);
                    a.mix = this.getValue(l, "mix", 1),
                        a.softness = this.getValue(l, "softness", 0) * n,
                        a.bendDirection = this.getValue(l, "bendPositive", !0) ? 1 : -1,
                        a.compress = this.getValue(l, "compress", !1),
                        a.stretch = this.getValue(l, "stretch", !1),
                        a.uniform = this.getValue(l, "uniform", !1),
                        s.ikConstraints.push(a)
                }
            if (r.transform)
                for (let o = 0; o < r.transform.length; o++) {
                    const l = r.transform[o]
                        , a = new Rw(l.name);
                    a.order = this.getValue(l, "order", 0),
                        a.skinRequired = this.getValue(l, "skin", !1);
                    for (let u = 0; u < l.bones.length; u++) {
                        const h = l.bones[u]
                            , d = s.findBone(h);
                        if (d == null)
                            throw new Error(`Transform constraint bone not found: ${h}`);
                        a.bones.push(d)
                    }
                    const c = l.target;
                    if (a.target = s.findBone(c),
                        a.target == null)
                        throw new Error(`Transform constraint target bone not found: ${c}`);
                    a.local = this.getValue(l, "local", !1),
                        a.relative = this.getValue(l, "relative", !1),
                        a.offsetRotation = this.getValue(l, "rotation", 0),
                        a.offsetX = this.getValue(l, "x", 0) * n,
                        a.offsetY = this.getValue(l, "y", 0) * n,
                        a.offsetScaleX = this.getValue(l, "scaleX", 0),
                        a.offsetScaleY = this.getValue(l, "scaleY", 0),
                        a.offsetShearY = this.getValue(l, "shearY", 0),
                        a.rotateMix = this.getValue(l, "rotateMix", 1),
                        a.translateMix = this.getValue(l, "translateMix", 1),
                        a.scaleMix = this.getValue(l, "scaleMix", 1),
                        a.shearMix = this.getValue(l, "shearMix", 1),
                        s.transformConstraints.push(a)
                }
            if (r.path)
                for (let o = 0; o < r.path.length; o++) {
                    const l = r.path[o]
                        , a = new Cw(l.name);
                    a.order = this.getValue(l, "order", 0),
                        a.skinRequired = this.getValue(l, "skin", !1);
                    for (let u = 0; u < l.bones.length; u++) {
                        const h = l.bones[u]
                            , d = s.findBone(h);
                        if (d == null)
                            throw new Error(`Transform constraint bone not found: ${h}`);
                        a.bones.push(d)
                    }
                    const c = l.target;
                    if (a.target = s.findSlot(c),
                        a.target == null)
                        throw new Error(`Path target slot not found: ${c}`);
                    a.positionMode = Yc.positionModeFromString(this.getValue(l, "positionMode", "percent")),
                        a.spacingMode = Yc.spacingModeFromString(this.getValue(l, "spacingMode", "length")),
                        a.rotateMode = Yc.rotateModeFromString(this.getValue(l, "rotateMode", "tangent")),
                        a.offsetRotation = this.getValue(l, "rotation", 0),
                        a.position = this.getValue(l, "position", 0),
                        a.positionMode == on.Fixed && (a.position *= n),
                        a.spacing = this.getValue(l, "spacing", 0),
                        (a.spacingMode == Xn.Length || a.spacingMode == Xn.Fixed) && (a.spacing *= n),
                        a.rotateMix = this.getValue(l, "rotateMix", 1),
                        a.translateMix = this.getValue(l, "translateMix", 1),
                        s.pathConstraints.push(a)
                }
            if (r.skins)
                for (let o = 0; o < r.skins.length; o++) {
                    const l = r.skins[o]
                        , a = new ig(l.name);
                    if (l.bones)
                        for (let c = 0; c < l.bones.length; c++) {
                            const u = s.findBone(l.bones[c]);
                            if (u == null)
                                throw new Error(`Skin bone not found: ${l.bones[o]}`);
                            a.bones.push(u)
                        }
                    if (l.ik)
                        for (let c = 0; c < l.ik.length; c++) {
                            const u = s.findIkConstraint(l.ik[c]);
                            if (u == null)
                                throw new Error(`Skin IK constraint not found: ${l.ik[o]}`);
                            a.constraints.push(u)
                        }
                    if (l.transform)
                        for (let c = 0; c < l.transform.length; c++) {
                            const u = s.findTransformConstraint(l.transform[c]);
                            if (u == null)
                                throw new Error(`Skin transform constraint not found: ${l.transform[o]}`);
                            a.constraints.push(u)
                        }
                    if (l.path)
                        for (let c = 0; c < l.path.length; c++) {
                            const u = s.findPathConstraint(l.path[c]);
                            if (u == null)
                                throw new Error(`Skin path constraint not found: ${l.path[o]}`);
                            a.constraints.push(u)
                        }
                    for (const c in l.attachments) {
                        const u = s.findSlot(c);
                        if (u == null)
                            throw new Error(`Slot not found: ${c}`);
                        const h = l.attachments[c];
                        for (const d in h) {
                            const f = this.readAttachment(h[d], a, u.index, d, s);
                            f != null && a.setAttachment(u.index, d, f)
                        }
                    }
                    s.skins.push(a),
                        a.name == "default" && (s.defaultSkin = a)
                }
            for (let o = 0, l = this.linkedMeshes.length; o < l; o++) {
                const a = this.linkedMeshes[o]
                    , c = a.skin == null ? s.defaultSkin : s.findSkin(a.skin);
                if (c == null)
                    throw new Error(`Skin not found: ${a.skin}`);
                const u = c.getAttachment(a.slotIndex, a.parent);
                if (u == null)
                    throw new Error(`Parent mesh not found: ${a.parent}`);
                a.mesh.deformAttachment = a.inheritDeform ? u : a.mesh,
                    a.mesh.setParentMesh(u)
            }
            if (this.linkedMeshes.length = 0,
                r.events)
                for (const o in r.events) {
                    const l = r.events[o]
                        , a = new Ew(o);
                    a.intValue = this.getValue(l, "int", 0),
                        a.floatValue = this.getValue(l, "float", 0),
                        a.stringValue = this.getValue(l, "string", ""),
                        a.audioPath = this.getValue(l, "audio", null),
                        a.audioPath != null && (a.volume = this.getValue(l, "volume", 1),
                            a.balance = this.getValue(l, "balance", 0)),
                        s.events.push(a)
                }
            if (r.animations)
                for (const o in r.animations) {
                    const l = r.animations[o];
                    this.readAnimation(l, o, s)
                }
            return s
        }
        readAttachment(e, n, s, r, i) {
            const o = this.scale;
            switch (r = this.getValue(e, "name", r),
            this.getValue(e, "type", "region")) {
                case "region":
                    {
                        const a = this.getValue(e, "path", r)
                            , c = this.attachmentLoader.newRegionAttachment(n, r, a);
                        if (c == null)
                            return null;
                        c.path = a,
                            c.x = this.getValue(e, "x", 0) * o,
                            c.y = this.getValue(e, "y", 0) * o,
                            c.scaleX = this.getValue(e, "scaleX", 1),
                            c.scaleY = this.getValue(e, "scaleY", 1),
                            c.rotation = this.getValue(e, "rotation", 0),
                            c.width = e.width * o,
                            c.height = e.height * o;
                        const u = this.getValue(e, "color", null);
                        return u != null && c.color.setFromString(u),
                            c
                    }
                case "boundingbox":
                    {
                        const a = this.attachmentLoader.newBoundingBoxAttachment(n, r);
                        if (a == null)
                            return null;
                        this.readVertices(e, a, e.vertexCount << 1);
                        const c = this.getValue(e, "color", null);
                        return c != null && a.color.setFromString(c),
                            a
                    }
                case "mesh":
                case "linkedmesh":
                    {
                        const a = this.getValue(e, "path", r)
                            , c = this.attachmentLoader.newMeshAttachment(n, r, a);
                        if (c == null)
                            return null;
                        c.path = a;
                        const u = this.getValue(e, "color", null);
                        u != null && c.color.setFromString(u),
                            c.width = this.getValue(e, "width", 0) * o,
                            c.height = this.getValue(e, "height", 0) * o;
                        const h = this.getValue(e, "parent", null);
                        if (h != null)
                            return this.linkedMeshes.push(new _he(c, this.getValue(e, "skin", null), s, h, this.getValue(e, "deform", !0))),
                                c;
                        const d = e.uvs;
                        return this.readVertices(e, c, d.length),
                            c.triangles = e.triangles,
                            c.regionUVs = new Float32Array(d),
                            c.edges = this.getValue(e, "edges", null),
                            c.hullLength = this.getValue(e, "hull", 0) * 2,
                            c
                    }
                case "path":
                    {
                        const a = this.attachmentLoader.newPathAttachment(n, r);
                        if (a == null)
                            return null;
                        a.closed = this.getValue(e, "closed", !1),
                            a.constantSpeed = this.getValue(e, "constantSpeed", !0);
                        const c = e.vertexCount;
                        this.readVertices(e, a, c << 1);
                        const u = Q.newArray(c / 3, 0);
                        for (let d = 0; d < e.lengths.length; d++)
                            u[d] = e.lengths[d] * o;
                        a.lengths = u;
                        const h = this.getValue(e, "color", null);
                        return h != null && a.color.setFromString(h),
                            a
                    }
                case "point":
                    {
                        const a = this.attachmentLoader.newPointAttachment(n, r);
                        if (a == null)
                            return null;
                        a.x = this.getValue(e, "x", 0) * o,
                            a.y = this.getValue(e, "y", 0) * o,
                            a.rotation = this.getValue(e, "rotation", 0);
                        const c = this.getValue(e, "color", null);
                        return c != null && a.color.setFromString(c),
                            a
                    }
                case "clipping":
                    {
                        const a = this.attachmentLoader.newClippingAttachment(n, r);
                        if (a == null)
                            return null;
                        const c = this.getValue(e, "end", null);
                        if (c != null) {
                            const d = i.findSlot(c);
                            if (d == null)
                                throw new Error(`Clipping end slot not found: ${c}`);
                            a.endSlot = d
                        }
                        const u = e.vertexCount;
                        this.readVertices(e, a, u << 1);
                        const h = this.getValue(e, "color", null);
                        return h != null && a.color.setFromString(h),
                            a
                    }
            }
            return null
        }
        readVertices(e, n, s) {
            const r = this.scale;
            n.worldVerticesLength = s;
            const i = e.vertices;
            if (s == i.length) {
                const a = Q.toFloatArray(i);
                if (r != 1)
                    for (let c = 0, u = i.length; c < u; c++)
                        a[c] *= r;
                n.vertices = a;
                return
            }
            const o = new Array
                , l = new Array;
            for (let a = 0, c = i.length; a < c;) {
                const u = i[a++];
                l.push(u);
                for (let h = a + u * 4; a < h; a += 4)
                    l.push(i[a]),
                        o.push(i[a + 1] * r),
                        o.push(i[a + 2] * r),
                        o.push(i[a + 3])
            }
            n.bones = l,
                n.vertices = Q.toFloatArray(o)
        }
        readAnimation(e, n, s) {
            const r = this.scale
                , i = new Array;
            let o = 0;
            if (e.slots)
                for (const a in e.slots) {
                    const c = e.slots[a]
                        , u = s.findSlotIndex(a);
                    if (u == -1)
                        throw new Error(`Slot not found: ${a}`);
                    for (const h in c) {
                        const d = c[h];
                        if (h == "attachment") {
                            const f = new Dl(d.length);
                            f.slotIndex = u;
                            let p = 0;
                            for (let m = 0; m < d.length; m++) {
                                const g = d[m];
                                f.setFrame(p++, this.getValue(g, "time", 0), g.name)
                            }
                            i.push(f),
                                o = Math.max(o, f.frames[f.getFrameCount() - 1])
                        } else if (h == "color") {
                            const f = new Os(d.length);
                            f.slotIndex = u;
                            let p = 0;
                            for (let m = 0; m < d.length; m++) {
                                const g = d[m]
                                    , b = new Se;
                                b.setFromString(g.color || "ffffffff"),
                                    f.setFrame(p, this.getValue(g, "time", 0), b.r, b.g, b.b, b.a),
                                    this.readCurve(g, f, p),
                                    p++
                            }
                            i.push(f),
                                o = Math.max(o, f.frames[(f.getFrameCount() - 1) * Os.ENTRIES])
                        } else if (h == "twoColor") {
                            const f = new wn(d.length);
                            f.slotIndex = u;
                            let p = 0;
                            for (let m = 0; m < d.length; m++) {
                                const g = d[m]
                                    , b = new Se
                                    , v = new Se;
                                b.setFromString(g.light),
                                    v.setFromString(g.dark),
                                    f.setFrame(p, this.getValue(g, "time", 0), b.r, b.g, b.b, b.a, v.r, v.g, v.b),
                                    this.readCurve(g, f, p),
                                    p++
                            }
                            i.push(f),
                                o = Math.max(o, f.frames[(f.getFrameCount() - 1) * wn.ENTRIES])
                        } else
                            throw new Error(`Invalid timeline type for a slot: ${h} (${a})`)
                    }
                }
            if (e.bones)
                for (const a in e.bones) {
                    const c = e.bones[a]
                        , u = s.findBoneIndex(a);
                    if (u == -1)
                        throw new Error(`Bone not found: ${a}`);
                    for (const h in c) {
                        const d = c[h];
                        if (h === "rotate") {
                            const f = new ts(d.length);
                            f.boneIndex = u;
                            let p = 0;
                            for (let m = 0; m < d.length; m++) {
                                const g = d[m];
                                f.setFrame(p, this.getValue(g, "time", 0), this.getValue(g, "angle", 0)),
                                    this.readCurve(g, f, p),
                                    p++
                            }
                            i.push(f),
                                o = Math.max(o, f.frames[(f.getFrameCount() - 1) * ts.ENTRIES])
                        } else if (h === "translate" || h === "scale" || h === "shear") {
                            let f = null
                                , p = 1
                                , m = 0;
                            h === "scale" ? (f = new mw(d.length),
                                m = 1) : h === "shear" ? f = new gw(d.length) : (f = new hr(d.length),
                                    p = r),
                                f.boneIndex = u;
                            let g = 0;
                            for (let b = 0; b < d.length; b++) {
                                const v = d[b]
                                    , _ = this.getValue(v, "x", m)
                                    , y = this.getValue(v, "y", m);
                                f.setFrame(g, this.getValue(v, "time", 0), _ * p, y * p),
                                    this.readCurve(v, f, g),
                                    g++
                            }
                            i.push(f),
                                o = Math.max(o, f.frames[(f.getFrameCount() - 1) * hr.ENTRIES])
                        } else
                            throw new Error(`Invalid timeline type for a bone: ${h} (${a})`)
                    }
                }
            if (e.ik)
                for (const a in e.ik) {
                    const c = e.ik[a]
                        , u = s.findIkConstraint(a)
                        , h = new as(c.length);
                    h.ikConstraintIndex = s.ikConstraints.indexOf(u);
                    let d = 0;
                    for (let f = 0; f < c.length; f++) {
                        const p = c[f];
                        h.setFrame(d, this.getValue(p, "time", 0), this.getValue(p, "mix", 1), this.getValue(p, "softness", 0) * r, this.getValue(p, "bendPositive", !0) ? 1 : -1, this.getValue(p, "compress", !1), this.getValue(p, "stretch", !1)),
                            this.readCurve(p, h, d),
                            d++
                    }
                    i.push(h),
                        o = Math.max(o, h.frames[(h.getFrameCount() - 1) * as.ENTRIES])
                }
            if (e.transform)
                for (const a in e.transform) {
                    const c = e.transform[a]
                        , u = s.findTransformConstraint(a)
                        , h = new Ns(c.length);
                    h.transformConstraintIndex = s.transformConstraints.indexOf(u);
                    let d = 0;
                    for (let f = 0; f < c.length; f++) {
                        const p = c[f];
                        h.setFrame(d, this.getValue(p, "time", 0), this.getValue(p, "rotateMix", 1), this.getValue(p, "translateMix", 1), this.getValue(p, "scaleMix", 1), this.getValue(p, "shearMix", 1)),
                            this.readCurve(p, h, d),
                            d++
                    }
                    i.push(h),
                        o = Math.max(o, h.frames[(h.getFrameCount() - 1) * Ns.ENTRIES])
                }
            if (e.path)
                for (const a in e.path) {
                    const c = e.path[a]
                        , u = s.findPathConstraintIndex(a);
                    if (u == -1)
                        throw new Error(`Path constraint not found: ${a}`);
                    const h = s.pathConstraints[u];
                    for (const d in c) {
                        const f = c[d];
                        if (d === "position" || d === "spacing") {
                            let p = null
                                , m = 1;
                            d === "spacing" ? (p = new yw(f.length),
                                (h.spacingMode == Xn.Length || h.spacingMode == Xn.Fixed) && (m = r)) : (p = new zi(f.length),
                                    h.positionMode == on.Fixed && (m = r)),
                                p.pathConstraintIndex = u;
                            let g = 0;
                            for (let b = 0; b < f.length; b++) {
                                const v = f[b];
                                p.setFrame(g, this.getValue(v, "time", 0), this.getValue(v, d, 0) * m),
                                    this.readCurve(v, p, g),
                                    g++
                            }
                            i.push(p),
                                o = Math.max(o, p.frames[(p.getFrameCount() - 1) * zi.ENTRIES])
                        } else if (d === "mix") {
                            const p = new ui(f.length);
                            p.pathConstraintIndex = u;
                            let m = 0;
                            for (let g = 0; g < f.length; g++) {
                                const b = f[g];
                                p.setFrame(m, this.getValue(b, "time", 0), this.getValue(b, "rotateMix", 1), this.getValue(b, "translateMix", 1)),
                                    this.readCurve(b, p, m),
                                    m++
                            }
                            i.push(p),
                                o = Math.max(o, p.frames[(p.getFrameCount() - 1) * ui.ENTRIES])
                        }
                    }
                }
            if (e.deform)
                for (const a in e.deform) {
                    const c = e.deform[a]
                        , u = s.findSkin(a);
                    if (u != null)
                        for (const h in c) {
                            const d = c[h]
                                , f = s.findSlotIndex(h);
                            if (f == -1)
                                throw new Error(`Slot not found: ${d.name}`);
                            for (const p in d) {
                                const m = d[p]
                                    , g = u.getAttachment(f, p);
                                if (g == null)
                                    throw new Error(`Deform attachment not found: ${m.name}`);
                                const b = g.bones != null
                                    , v = g.vertices
                                    , _ = b ? v.length / 3 * 2 : v.length
                                    , y = new _w(m.length);
                                y.slotIndex = f,
                                    y.attachment = g;
                                let x = 0;
                                for (let w = 0; w < m.length; w++) {
                                    const S = m[w];
                                    let E;
                                    const C = this.getValue(S, "vertices", null);
                                    if (C == null)
                                        E = b ? Q.newFloatArray(_) : v;
                                    else {
                                        E = Q.newFloatArray(_);
                                        const I = this.getValue(S, "offset", 0);
                                        if (Q.arrayCopy(C, 0, E, I, C.length),
                                            r != 1)
                                            for (let L = I, k = L + C.length; L < k; L++)
                                                E[L] *= r;
                                        if (!b)
                                            for (let L = 0; L < _; L++)
                                                E[L] += v[L]
                                    }
                                    y.setFrame(x, this.getValue(S, "time", 0), E),
                                        this.readCurve(S, y, x),
                                        x++
                                }
                                i.push(y),
                                    o = Math.max(o, y.frames[y.getFrameCount() - 1])
                            }
                        }
                }
            let l = e.drawOrder;
            if (l == null && (l = e.draworder),
                l != null) {
                const a = new Cu(l.length)
                    , c = s.slots.length;
                let u = 0;
                for (let h = 0; h < l.length; h++) {
                    const d = l[h];
                    let f = null;
                    const p = this.getValue(d, "offsets", null);
                    if (p != null) {
                        f = Q.newArray(c, -1);
                        const m = Q.newArray(c - p.length, 0);
                        let g = 0
                            , b = 0;
                        for (let v = 0; v < p.length; v++) {
                            const _ = p[v]
                                , y = s.findSlotIndex(_.slot);
                            if (y == -1)
                                throw new Error(`Slot not found: ${_.slot}`);
                            for (; g != y;)
                                m[b++] = g++;
                            f[g + _.offset] = g++
                        }
                        for (; g < c;)
                            m[b++] = g++;
                        for (let v = c - 1; v >= 0; v--)
                            f[v] == -1 && (f[v] = m[--b])
                    }
                    a.setFrame(u++, this.getValue(d, "time", 0), f)
                }
                i.push(a),
                    o = Math.max(o, a.frames[a.getFrameCount() - 1])
            }
            if (e.events) {
                const a = new $_(e.events.length);
                let c = 0;
                for (let u = 0; u < e.events.length; u++) {
                    const h = e.events[u]
                        , d = s.findEvent(h.name);
                    if (d == null)
                        throw new Error(`Event not found: ${h.name}`);
                    const f = new Sw(Q.toSinglePrecision(this.getValue(h, "time", 0)), d);
                    f.intValue = this.getValue(h, "int", d.intValue),
                        f.floatValue = this.getValue(h, "float", d.floatValue),
                        f.stringValue = this.getValue(h, "string", d.stringValue),
                        f.data.audioPath != null && (f.volume = this.getValue(h, "volume", 1),
                            f.balance = this.getValue(h, "balance", 0)),
                        a.setFrame(c++, f)
                }
                i.push(a),
                    o = Math.max(o, a.frames[a.getFrameCount() - 1])
            }
            if (isNaN(o))
                throw new Error("Error while parsing animation, duration is NaN");
            s.animations.push(new xn(n, i, o))
        }
        readCurve(e, n, s) {
            if (e.hasOwnProperty("curve"))
                if (e.curve === "stepped")
                    n.setStepped(s);
                else {
                    const r = e.curve;
                    n.setCurve(s, r, this.getValue(e, "c2", 0), this.getValue(e, "c3", 1), this.getValue(e, "c4", 1))
                }
        }
        getValue(e, n, s) {
            return e[n] !== void 0 ? e[n] : s
        }
        static blendModeFromString(e) {
            if (e = e.toLowerCase(),
                e == "normal")
                return Oe.NORMAL;
            if (e == "additive")
                return Oe.ADD;
            if (e == "multiply")
                return Oe.MULTIPLY;
            if (e == "screen")
                return Oe.SCREEN;
            throw new Error(`Unknown blend mode: ${e}`)
        }
        static positionModeFromString(e) {
            if (e = e.toLowerCase(),
                e == "fixed")
                return on.Fixed;
            if (e == "percent")
                return on.Percent;
            throw new Error(`Unknown position mode: ${e}`)
        }
        static spacingModeFromString(e) {
            if (e = e.toLowerCase(),
                e == "length")
                return Xn.Length;
            if (e == "fixed")
                return Xn.Fixed;
            if (e == "percent")
                return Xn.Percent;
            throw new Error(`Unknown position mode: ${e}`)
        }
        static rotateModeFromString(e) {
            if (e = e.toLowerCase(),
                e == "tangent")
                return bn.Tangent;
            if (e == "chain")
                return bn.Chain;
            if (e == "chainscale")
                return bn.ChainScale;
            throw new Error(`Unknown rotate mode: ${e}`)
        }
        static transformModeFromString(e) {
            if (e = e.toLowerCase(),
                e == "normal")
                return Qe.Normal;
            if (e == "onlytranslation")
                return Qe.OnlyTranslation;
            if (e == "norotationorreflection")
                return Qe.NoRotationOrReflection;
            if (e == "noscale")
                return Qe.NoScale;
            if (e == "noscaleorreflection")
                return Qe.NoScaleOrReflection;
            throw new Error(`Unknown transform mode: ${e}`)
        }
    }
    , _he = class {
        constructor(e, n, s, r, i) {
            this.mesh = e,
                this.skin = n,
                this.slotIndex = s,
                this.parent = r,
                this.inheritDeform = i
        }
    }
    , yhe = class extends ph {
        createSkeleton(e) {
            this.skeleton = new Iw(e),
                this.skeleton.updateWorldTransform(),
                this.stateData = new vw(e),
                this.state = new yr(this.stateData)
        }
    }
    ;
const bhe = Object.freeze(Object.defineProperty({
    __proto__: null,
    Animation: xn,
    AnimationState: yr,
    AnimationStateAdapter: fhe,
    AnimationStateData: vw,
    AtlasAttachmentLoader: xw,
    Attachment: fw,
    AttachmentTimeline: Dl,
    Bone: Yb,
    BoneData: ww,
    BoundingBoxAttachment: E5,
    ClippingAttachment: C5,
    ColorTimeline: Os,
    ConstraintData: V_,
    CurveTimeline: Ks,
    DeformTimeline: _w,
    DrawOrderTimeline: Cu,
    Event: Sw,
    EventData: Ew,
    EventQueue: bw,
    EventTimeline: $_,
    EventType: $s,
    IkConstraint: O5,
    IkConstraintData: Tw,
    IkConstraintTimeline: as,
    JitterEffect: dhe,
    MeshAttachment: F_,
    PathAttachment: $d,
    PathConstraint: gh,
    PathConstraintData: Cw,
    PathConstraintMixTimeline: ui,
    PathConstraintPositionTimeline: zi,
    PathConstraintSpacingTimeline: yw,
    PointAttachment: k5,
    RegionAttachment: ot,
    RotateTimeline: ts,
    ScaleTimeline: mw,
    ShearTimeline: gw,
    Skeleton: Iw,
    SkeletonBinary: Sn,
    SkeletonBounds: ghe,
    SkeletonData: Aw,
    SkeletonJson: D5,
    Skin: ig,
    SkinEntry: Xb,
    Slot: pw,
    SlotData: kw,
    SpacingMode: Xn,
    Spine: yhe,
    SwirlEffect: P5,
    TimelineType: L5,
    TrackEntry: U_,
    TransformConstraint: N5,
    TransformConstraintData: Rw,
    TransformConstraintTimeline: Ns,
    TranslateTimeline: hr,
    TwoColorTimeline: wn,
    VertexAttachment: cl
}, Symbol.toStringTag, {
    value: "Module"
}));
let Mw = class {
    constructor(e) {
        if (e == null)
            throw new Error("name cannot be null.");
        this.name = e
    }
}
    ;
const B5 = class extends Mw {
    constructor(e) {
        super(e),
            this.id = (B5.nextID++ & 65535) << 11,
            this.worldVerticesLength = 0
    }
    computeWorldVerticesOld(e, n) {
        this.computeWorldVertices(e, 0, this.worldVerticesLength, n, 0, 2)
    }
    computeWorldVertices(e, n, s, r, i, o) {
        s = i + (s >> 1) * o;
        const l = e.bone.skeleton
            , a = e.attachmentVertices;
        let c = this.vertices;
        const u = this.bones;
        if (u == null) {
            a.length > 0 && (c = a);
            const p = e.bone.matrix
                , m = p.tx
                , g = p.ty
                , b = p.a
                , v = p.c
                , _ = p.b
                , y = p.d;
            for (let x = n, w = i; w < s; x += 2,
                w += o) {
                const S = c[x]
                    , E = c[x + 1];
                r[w] = S * b + E * v + m,
                    r[w + 1] = S * _ + E * y + g
            }
            return
        }
        let h = 0
            , d = 0;
        for (let p = 0; p < n; p += 2) {
            const m = u[h];
            h += m + 1,
                d += m
        }
        const f = l.bones;
        if (a.length == 0)
            for (let p = i, m = d * 3; p < s; p += o) {
                let g = 0
                    , b = 0
                    , v = u[h++];
                for (v += h; h < v; h++,
                    m += 3) {
                    const _ = f[u[h]].matrix
                        , y = c[m]
                        , x = c[m + 1]
                        , w = c[m + 2];
                    g += (y * _.a + x * _.c + _.tx) * w,
                        b += (y * _.b + x * _.d + _.ty) * w
                }
                r[p] = g,
                    r[p + 1] = b
            }
        else {
            const p = a;
            for (let m = i, g = d * 3, b = d << 1; m < s; m += o) {
                let v = 0
                    , _ = 0
                    , y = u[h++];
                for (y += h; h < y; h++,
                    g += 3,
                    b += 2) {
                    const x = f[u[h]].matrix
                        , w = c[g] + p[b]
                        , S = c[g + 1] + p[b + 1]
                        , E = c[g + 2];
                    v += (w * x.a + S * x.c + x.tx) * E,
                        _ += (w * x.b + S * x.d + x.ty) * E
                }
                r[m] = v,
                    r[m + 1] = _
            }
        }
    }
    applyDeform(e) {
        return this == e
    }
}
    ;
let ul = B5;
ul.nextID = 0;
let F5 = class extends ul {
    constructor(e) {
        super(e),
            this.type = ut.BoundingBox,
            this.color = new Se(1, 1, 1, 1)
    }
}
    , $5 = class extends ul {
        constructor(e) {
            super(e),
                this.type = ut.Clipping,
                this.color = new Se(.2275, .2275, .8078, 1)
        }
    }
    , Pw = class extends ul {
        constructor(e) {
            super(e),
                this.type = ut.Mesh,
                this.color = new Se(1, 1, 1, 1),
                this.inheritDeform = !1,
                this.tempColor = new Se(0, 0, 0, 0)
        }
        applyDeform(e) {
            return this == e || this.inheritDeform && this.parentMesh == e
        }
        getParentMesh() {
            return this.parentMesh
        }
        setParentMesh(e) {
            this.parentMesh = e,
                e != null && (this.bones = e.bones,
                    this.vertices = e.vertices,
                    this.worldVerticesLength = e.worldVerticesLength,
                    this.regionUVs = e.regionUVs,
                    this.triangles = e.triangles,
                    this.hullLength = e.hullLength,
                    this.worldVerticesLength = e.worldVerticesLength)
        }
    }
    , Ud = class extends ul {
        constructor(e) {
            super(e),
                this.type = ut.Path,
                this.closed = !1,
                this.constantSpeed = !1,
                this.color = new Se(1, 1, 1, 1)
        }
    }
    , U5 = class extends ul {
        constructor(e) {
            super(e),
                this.type = ut.Point,
                this.color = new Se(.38, .94, 0, 1)
        }
        computeWorldPosition(e, n) {
            const s = e.matrix;
            return n.x = this.x * s.a + this.y * s.c + e.worldX,
                n.y = this.x * s.b + this.y * s.d + e.worldY,
                n
        }
        computeWorldRotation(e) {
            const n = e.matrix
                , s = F.cosDeg(this.rotation)
                , r = F.sinDeg(this.rotation)
                , i = s * n.a + r * n.c
                , o = s * n.b + r * n.d;
            return Math.atan2(o, i) * F.radDeg
        }
    }
    , Lw = class {
        constructor(e, n) {
            if (this.attachmentVertices = new Array,
                e == null)
                throw new Error("data cannot be null.");
            if (n == null)
                throw new Error("bone cannot be null.");
            this.data = e,
                this.bone = n,
                this.color = new Se,
                this.darkColor = e.darkColor == null ? null : new Se,
                this.setToSetupPose(),
                this.blendMode = this.data.blendMode
        }
        getAttachment() {
            return this.attachment
        }
        setAttachment(e) {
            this.attachment != e && (this.attachment = e,
                this.attachmentTime = this.bone.skeleton.time,
                this.attachmentVertices.length = 0)
        }
        setAttachmentTime(e) {
            this.attachmentTime = this.bone.skeleton.time - e
        }
        getAttachmentTime() {
            return this.bone.skeleton.time - this.attachmentTime
        }
        setToSetupPose() {
            this.color.setFromColor(this.data.color),
                this.darkColor != null && this.darkColor.setFromColor(this.data.darkColor),
                this.data.attachmentName == null ? this.attachment = null : (this.attachment = null,
                    this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName)))
        }
    }
    ;
const Zn = class extends Mw {
    constructor(e) {
        super(e),
            this.type = ut.Region,
            this.x = 0,
            this.y = 0,
            this.scaleX = 1,
            this.scaleY = 1,
            this.rotation = 0,
            this.width = 0,
            this.height = 0,
            this.color = new Se(1, 1, 1, 1),
            this.offset = Q.newFloatArray(8),
            this.uvs = Q.newFloatArray(8),
            this.tempColor = new Se(1, 1, 1, 1)
    }
    updateOffset() {
        const e = this.width / this.region.originalWidth * this.scaleX
            , n = this.height / this.region.originalHeight * this.scaleY
            , s = -this.width / 2 * this.scaleX + this.region.offsetX * e
            , r = -this.height / 2 * this.scaleY + this.region.offsetY * n
            , i = s + this.region.width * e
            , o = r + this.region.height * n
            , l = this.rotation * Math.PI / 180
            , a = Math.cos(l)
            , c = Math.sin(l)
            , u = s * a + this.x
            , h = s * c
            , d = r * a + this.y
            , f = r * c
            , p = i * a + this.x
            , m = i * c
            , g = o * a + this.y
            , b = o * c
            , v = this.offset;
        v[Zn.OX1] = u - f,
            v[Zn.OY1] = d + h,
            v[Zn.OX2] = u - b,
            v[Zn.OY2] = g + h,
            v[Zn.OX3] = p - b,
            v[Zn.OY3] = g + m,
            v[Zn.OX4] = p - f,
            v[Zn.OY4] = d + m
    }
    setRegion(e) {
        this.region = e;
        const n = this.uvs;
        e.rotate ? (n[2] = e.u,
            n[3] = e.v2,
            n[4] = e.u,
            n[5] = e.v,
            n[6] = e.u2,
            n[7] = e.v,
            n[0] = e.u2,
            n[1] = e.v2) : (n[0] = e.u,
                n[1] = e.v2,
                n[2] = e.u,
                n[3] = e.v,
                n[4] = e.u2,
                n[5] = e.v,
                n[6] = e.u2,
                n[7] = e.v2)
    }
    computeWorldVertices(e, n, s, r) {
        const i = this.offset
            , o = e instanceof Lw ? e.bone.matrix : e.matrix
            , l = o.tx
            , a = o.ty
            , c = o.a
            , u = o.c
            , h = o.b
            , d = o.d;
        let f = 0
            , p = 0;
        f = i[Zn.OX1],
            p = i[Zn.OY1],
            n[s] = f * c + p * u + l,
            n[s + 1] = f * h + p * d + a,
            s += r,
            f = i[Zn.OX2],
            p = i[Zn.OY2],
            n[s] = f * c + p * u + l,
            n[s + 1] = f * h + p * d + a,
            s += r,
            f = i[Zn.OX3],
            p = i[Zn.OY3],
            n[s] = f * c + p * u + l,
            n[s + 1] = f * h + p * d + a,
            s += r,
            f = i[Zn.OX4],
            p = i[Zn.OY4],
            n[s] = f * c + p * u + l,
            n[s + 1] = f * h + p * d + a
    }
}
    ;
let at = Zn;
at.OX1 = 0;
at.OY1 = 1;
at.OX2 = 2;
at.OY2 = 3;
at.OX3 = 4;
at.OY3 = 5;
at.OX4 = 6;
at.OY4 = 7;
at.X1 = 0;
at.Y1 = 1;
at.C1R = 2;
at.C1G = 3;
at.C1B = 4;
at.C1A = 5;
at.U1 = 6;
at.V1 = 7;
at.X2 = 8;
at.Y2 = 9;
at.C2R = 10;
at.C2G = 11;
at.C2B = 12;
at.C2A = 13;
at.U2 = 14;
at.V2 = 15;
at.X3 = 16;
at.Y3 = 17;
at.C3R = 18;
at.C3G = 19;
at.C3B = 20;
at.C3A = 21;
at.U3 = 22;
at.V3 = 23;
at.X4 = 24;
at.Y4 = 25;
at.C4R = 26;
at.C4G = 27;
at.C4B = 28;
at.C4A = 29;
at.U4 = 30;
at.V4 = 31;
class vhe {
    constructor(e, n) {
        this.jitterX = 0,
            this.jitterY = 0,
            this.jitterX = e,
            this.jitterY = n
    }
    begin(e) { }
    transform(e, n, s, r) {
        e.x += F.randomTriangular(-this.jitterX, this.jitterY),
            e.y += F.randomTriangular(-this.jitterX, this.jitterY)
    }
    end() { }
}
const V5 = class {
    constructor(t) {
        this.centerX = 0,
            this.centerY = 0,
            this.radius = 0,
            this.angle = 0,
            this.worldX = 0,
            this.worldY = 0,
            this.radius = t
    }
    begin(t) {
        this.worldX = t.x + this.centerX,
            this.worldY = t.y + this.centerY
    }
    transform(t, e, n, s) {
        const r = this.angle * F.degreesToRadians
            , i = t.x - this.worldX
            , o = t.y - this.worldY
            , l = Math.sqrt(i * i + o * o);
        if (l < this.radius) {
            const a = V5.interpolation.apply(0, r, (this.radius - l) / this.radius)
                , c = Math.cos(a)
                , u = Math.sin(a);
            t.x = c * i - u * o + this.worldX,
                t.y = u * i + c * o + this.worldY
        }
    }
    end() { }
}
    ;
let G5 = V5;
G5.interpolation = new u5(2);
let Un = class {
    constructor(e, n, s) {
        if (e == null)
            throw new Error("name cannot be null.");
        if (n == null)
            throw new Error("timelines cannot be null.");
        this.name = e,
            this.timelines = n,
            this.duration = s
    }
    apply(e, n, s, r, i, o, l, a) {
        if (e == null)
            throw new Error("skeleton cannot be null.");
        r && this.duration != 0 && (s %= this.duration,
            n > 0 && (n %= this.duration));
        const c = this.timelines;
        for (let u = 0, h = c.length; u < h; u++)
            c[u].apply(e, n, s, i, o, l, a)
    }
    static binarySearch(e, n, s = 1) {
        let r = 0
            , i = e.length / s - 2;
        if (i == 0)
            return s;
        let o = i >>> 1;
        for (; ;) {
            if (e[(o + 1) * s] <= n ? r = o + 1 : i = o,
                r == i)
                return (r + 1) * s;
            o = r + i >>> 1
        }
    }
    static linearSearch(e, n, s) {
        for (let r = 0, i = e.length - s; r <= i; r += s)
            if (e[r] > n)
                return r;
        return -1
    }
}
    ;
var H5 = (t => (t[t.rotate = 0] = "rotate",
    t[t.translate = 1] = "translate",
    t[t.scale = 2] = "scale",
    t[t.shear = 3] = "shear",
    t[t.attachment = 4] = "attachment",
    t[t.color = 5] = "color",
    t[t.deform = 6] = "deform",
    t[t.event = 7] = "event",
    t[t.drawOrder = 8] = "drawOrder",
    t[t.ikConstraint = 9] = "ikConstraint",
    t[t.transformConstraint = 10] = "transformConstraint",
    t[t.pathConstraintPosition = 11] = "pathConstraintPosition",
    t[t.pathConstraintSpacing = 12] = "pathConstraintSpacing",
    t[t.pathConstraintMix = 13] = "pathConstraintMix",
    t[t.twoColor = 14] = "twoColor",
    t))(H5 || {});
const mn = class {
    constructor(t) {
        if (t <= 0)
            throw new Error(`frameCount must be > 0: ${t}`);
        this.curves = Q.newFloatArray((t - 1) * mn.BEZIER_SIZE)
    }
    getFrameCount() {
        return this.curves.length / mn.BEZIER_SIZE + 1
    }
    setLinear(t) {
        this.curves[t * mn.BEZIER_SIZE] = mn.LINEAR
    }
    setStepped(t) {
        this.curves[t * mn.BEZIER_SIZE] = mn.STEPPED
    }
    getCurveType(t) {
        const e = t * mn.BEZIER_SIZE;
        if (e == this.curves.length)
            return mn.LINEAR;
        const n = this.curves[e];
        return n == mn.LINEAR ? mn.LINEAR : n == mn.STEPPED ? mn.STEPPED : mn.BEZIER
    }
    setCurve(t, e, n, s, r) {
        const i = (-e * 2 + s) * .03
            , o = (-n * 2 + r) * .03
            , l = ((e - s) * 3 + 1) * .006
            , a = ((n - r) * 3 + 1) * .006;
        let c = i * 2 + l
            , u = o * 2 + a
            , h = e * .3 + i + l * .16666667
            , d = n * .3 + o + a * .16666667
            , f = t * mn.BEZIER_SIZE;
        const p = this.curves;
        p[f++] = mn.BEZIER;
        let m = h
            , g = d;
        for (let b = f + mn.BEZIER_SIZE - 1; f < b; f += 2)
            p[f] = m,
                p[f + 1] = g,
                h += c,
                d += u,
                c += l,
                u += a,
                m += h,
                g += d
    }
    getCurvePercent(t, e) {
        e = F.clamp(e, 0, 1);
        const n = this.curves;
        let s = t * mn.BEZIER_SIZE;
        const r = n[s];
        if (r == mn.LINEAR)
            return e;
        if (r == mn.STEPPED)
            return 0;
        s++;
        let i = 0;
        for (let l = s, a = s + mn.BEZIER_SIZE - 1; s < a; s += 2)
            if (i = n[s],
                i >= e) {
                let c, u;
                return s == l ? (c = 0,
                    u = 0) : (c = n[s - 2],
                        u = n[s - 1]),
                    u + (n[s + 1] - u) * (e - c) / (i - c)
            }
        const o = n[s - 1];
        return o + (1 - o) * (e - i) / (1 - i)
    }
}
    ;
let Js = mn;
Js.LINEAR = 0;
Js.STEPPED = 1;
Js.BEZIER = 2;
Js.BEZIER_SIZE = 10 * 2 - 1;
const aa = class extends Js {
    constructor(t) {
        super(t),
            this.frames = Q.newFloatArray(t << 1)
    }
    getPropertyId() {
        return 0 + this.boneIndex
    }
    setFrame(t, e, n) {
        t <<= 1,
            this.frames[t] = e,
            this.frames[t + aa.ROTATION] = n
    }
    apply(t, e, n, s, r, i, o) {
        const l = this.frames
            , a = t.bones[this.boneIndex];
        if (n < l[0]) {
            switch (i) {
                case O.setup:
                    a.rotation = a.data.rotation;
                    return;
                case O.first:
                    const p = a.data.rotation - a.rotation;
                    a.rotation += (p - (16384 - (16384.499999999996 - p / 360 | 0)) * 360) * r
            }
            return
        }
        if (n >= l[l.length - aa.ENTRIES]) {
            let p = l[l.length + aa.PREV_ROTATION];
            switch (i) {
                case O.setup:
                    a.rotation = a.data.rotation + p * r;
                    break;
                case O.first:
                case O.replace:
                    p += a.data.rotation - a.rotation,
                        p -= (16384 - (16384.499999999996 - p / 360 | 0)) * 360;
                case O.add:
                    a.rotation += p * r
            }
            return
        }
        const c = Un.binarySearch(l, n, aa.ENTRIES)
            , u = l[c + aa.PREV_ROTATION]
            , h = l[c]
            , d = this.getCurvePercent((c >> 1) - 1, 1 - (n - h) / (l[c + aa.PREV_TIME] - h));
        let f = l[c + aa.ROTATION] - u;
        switch (f = u + (f - (16384 - (16384.499999999996 - f / 360 | 0)) * 360) * d,
        i) {
            case O.setup:
                a.rotation = a.data.rotation + (f - (16384 - (16384.499999999996 - f / 360 | 0)) * 360) * r;
                break;
            case O.first:
            case O.replace:
                f += a.data.rotation - a.rotation;
            case O.add:
                a.rotation += (f - (16384 - (16384.499999999996 - f / 360 | 0)) * 360) * r
        }
    }
}
    ;
let Ts = aa;
Ts.ENTRIES = 2;
Ts.PREV_TIME = -2;
Ts.PREV_ROTATION = -1;
Ts.ROTATION = 1;
const xs = class extends Js {
    constructor(t) {
        super(t),
            this.frames = Q.newFloatArray(t * xs.ENTRIES)
    }
    getPropertyId() {
        return (1 << 24) + this.boneIndex
    }
    setFrame(t, e, n, s) {
        t *= xs.ENTRIES,
            this.frames[t] = e,
            this.frames[t + xs.X] = n,
            this.frames[t + xs.Y] = s
    }
    apply(t, e, n, s, r, i, o) {
        const l = this.frames
            , a = t.bones[this.boneIndex];
        if (n < l[0]) {
            switch (i) {
                case O.setup:
                    a.x = a.data.x,
                        a.y = a.data.y;
                    return;
                case O.first:
                    a.x += (a.data.x - a.x) * r,
                        a.y += (a.data.y - a.y) * r
            }
            return
        }
        let c = 0
            , u = 0;
        if (n >= l[l.length - xs.ENTRIES])
            c = l[l.length + xs.PREV_X],
                u = l[l.length + xs.PREV_Y];
        else {
            const h = Un.binarySearch(l, n, xs.ENTRIES);
            c = l[h + xs.PREV_X],
                u = l[h + xs.PREV_Y];
            const d = l[h]
                , f = this.getCurvePercent(h / xs.ENTRIES - 1, 1 - (n - d) / (l[h + xs.PREV_TIME] - d));
            c += (l[h + xs.X] - c) * f,
                u += (l[h + xs.Y] - u) * f
        }
        switch (i) {
            case O.setup:
                a.x = a.data.x + c * r,
                    a.y = a.data.y + u * r;
                break;
            case O.first:
            case O.replace:
                a.x += (a.data.x + c - a.x) * r,
                    a.y += (a.data.y + u - a.y) * r;
                break;
            case O.add:
                a.x += c * r,
                    a.y += u * r
        }
    }
}
    ;
let hi = xs;
hi.ENTRIES = 3;
hi.PREV_TIME = -3;
hi.PREV_X = -2;
hi.PREV_Y = -1;
hi.X = 1;
hi.Y = 2;
let W5 = class Yr extends hi {
    constructor(e) {
        super(e)
    }
    getPropertyId() {
        return (2 << 24) + this.boneIndex
    }
    apply(e, n, s, r, i, o, l) {
        const a = this.frames
            , c = e.bones[this.boneIndex];
        if (s < a[0]) {
            switch (o) {
                case O.setup:
                    c.scaleX = c.data.scaleX,
                        c.scaleY = c.data.scaleY;
                    return;
                case O.first:
                    c.scaleX += (c.data.scaleX - c.scaleX) * i,
                        c.scaleY += (c.data.scaleY - c.scaleY) * i
            }
            return
        }
        let u = 0
            , h = 0;
        if (s >= a[a.length - Yr.ENTRIES])
            u = a[a.length + Yr.PREV_X] * c.data.scaleX,
                h = a[a.length + Yr.PREV_Y] * c.data.scaleY;
        else {
            const d = Un.binarySearch(a, s, Yr.ENTRIES);
            u = a[d + Yr.PREV_X],
                h = a[d + Yr.PREV_Y];
            const f = a[d]
                , p = this.getCurvePercent(d / Yr.ENTRIES - 1, 1 - (s - f) / (a[d + Yr.PREV_TIME] - f));
            u = (u + (a[d + Yr.X] - u) * p) * c.data.scaleX,
                h = (h + (a[d + Yr.Y] - h) * p) * c.data.scaleY
        }
        if (i == 1)
            o == O.add ? (c.scaleX += u - c.data.scaleX,
                c.scaleY += h - c.data.scaleY) : (c.scaleX = u,
                    c.scaleY = h);
        else {
            let d = 0
                , f = 0;
            if (l == ct.mixOut)
                switch (o) {
                    case O.setup:
                        d = c.data.scaleX,
                            f = c.data.scaleY,
                            c.scaleX = d + (Math.abs(u) * F.signum(d) - d) * i,
                            c.scaleY = f + (Math.abs(h) * F.signum(f) - f) * i;
                        break;
                    case O.first:
                    case O.replace:
                        d = c.scaleX,
                            f = c.scaleY,
                            c.scaleX = d + (Math.abs(u) * F.signum(d) - d) * i,
                            c.scaleY = f + (Math.abs(h) * F.signum(f) - f) * i;
                        break;
                    case O.add:
                        d = c.scaleX,
                            f = c.scaleY,
                            c.scaleX = d + (Math.abs(u) * F.signum(d) - c.data.scaleX) * i,
                            c.scaleY = f + (Math.abs(h) * F.signum(f) - c.data.scaleY) * i
                }
            else
                switch (o) {
                    case O.setup:
                        d = Math.abs(c.data.scaleX) * F.signum(u),
                            f = Math.abs(c.data.scaleY) * F.signum(h),
                            c.scaleX = d + (u - d) * i,
                            c.scaleY = f + (h - f) * i;
                        break;
                    case O.first:
                    case O.replace:
                        d = Math.abs(c.scaleX) * F.signum(u),
                            f = Math.abs(c.scaleY) * F.signum(h),
                            c.scaleX = d + (u - d) * i,
                            c.scaleY = f + (h - f) * i;
                        break;
                    case O.add:
                        d = F.signum(u),
                            f = F.signum(h),
                            c.scaleX = Math.abs(c.scaleX) * d + (u - Math.abs(c.data.scaleX) * d) * i,
                            c.scaleY = Math.abs(c.scaleY) * f + (h - Math.abs(c.data.scaleY) * f) * i
                }
        }
    }
}
    , Y5 = class Xr extends hi {
        constructor(e) {
            super(e)
        }
        getPropertyId() {
            return (3 << 24) + this.boneIndex
        }
        apply(e, n, s, r, i, o, l) {
            const a = this.frames
                , c = e.bones[this.boneIndex];
            if (s < a[0]) {
                switch (o) {
                    case O.setup:
                        c.shearX = c.data.shearX,
                            c.shearY = c.data.shearY;
                        return;
                    case O.first:
                        c.shearX += (c.data.shearX - c.shearX) * i,
                            c.shearY += (c.data.shearY - c.shearY) * i
                }
                return
            }
            let u = 0
                , h = 0;
            if (s >= a[a.length - Xr.ENTRIES])
                u = a[a.length + Xr.PREV_X],
                    h = a[a.length + Xr.PREV_Y];
            else {
                const d = Un.binarySearch(a, s, Xr.ENTRIES);
                u = a[d + Xr.PREV_X],
                    h = a[d + Xr.PREV_Y];
                const f = a[d]
                    , p = this.getCurvePercent(d / Xr.ENTRIES - 1, 1 - (s - f) / (a[d + Xr.PREV_TIME] - f));
                u = u + (a[d + Xr.X] - u) * p,
                    h = h + (a[d + Xr.Y] - h) * p
            }
            switch (o) {
                case O.setup:
                    c.shearX = c.data.shearX + u * i,
                        c.shearY = c.data.shearY + h * i;
                    break;
                case O.first:
                case O.replace:
                    c.shearX += (c.data.shearX + u - c.shearX) * i,
                        c.shearY += (c.data.shearY + h - c.shearY) * i;
                    break;
                case O.add:
                    c.shearX += u * i,
                        c.shearY += h * i
            }
        }
    }
    ;
const tn = class extends Js {
    constructor(t) {
        super(t),
            this.frames = Q.newFloatArray(t * tn.ENTRIES)
    }
    getPropertyId() {
        return (5 << 24) + this.slotIndex
    }
    setFrame(t, e, n, s, r, i) {
        t *= tn.ENTRIES,
            this.frames[t] = e,
            this.frames[t + tn.R] = n,
            this.frames[t + tn.G] = s,
            this.frames[t + tn.B] = r,
            this.frames[t + tn.A] = i
    }
    apply(t, e, n, s, r, i, o) {
        const l = t.slots[this.slotIndex]
            , a = this.frames;
        if (n < a[0]) {
            switch (i) {
                case O.setup:
                    l.color.setFromColor(l.data.color);
                    return;
                case O.first:
                    const f = l.color
                        , p = l.data.color;
                    f.add((p.r - f.r) * r, (p.g - f.g) * r, (p.b - f.b) * r, (p.a - f.a) * r)
            }
            return
        }
        let c = 0
            , u = 0
            , h = 0
            , d = 0;
        if (n >= a[a.length - tn.ENTRIES]) {
            const f = a.length;
            c = a[f + tn.PREV_R],
                u = a[f + tn.PREV_G],
                h = a[f + tn.PREV_B],
                d = a[f + tn.PREV_A]
        } else {
            const f = Un.binarySearch(a, n, tn.ENTRIES);
            c = a[f + tn.PREV_R],
                u = a[f + tn.PREV_G],
                h = a[f + tn.PREV_B],
                d = a[f + tn.PREV_A];
            const p = a[f]
                , m = this.getCurvePercent(f / tn.ENTRIES - 1, 1 - (n - p) / (a[f + tn.PREV_TIME] - p));
            c += (a[f + tn.R] - c) * m,
                u += (a[f + tn.G] - u) * m,
                h += (a[f + tn.B] - h) * m,
                d += (a[f + tn.A] - d) * m
        }
        if (r == 1)
            l.color.set(c, u, h, d);
        else {
            const f = l.color;
            i == O.setup && f.setFromColor(l.data.color),
                f.add((c - f.r) * r, (u - f.g) * r, (h - f.b) * r, (d - f.a) * r)
        }
    }
}
    ;
let dr = tn;
dr.ENTRIES = 5;
dr.PREV_TIME = -5;
dr.PREV_R = -4;
dr.PREV_G = -3;
dr.PREV_B = -2;
dr.PREV_A = -1;
dr.R = 1;
dr.G = 2;
dr.B = 3;
dr.A = 4;
const xt = class extends Js {
    constructor(t) {
        super(t),
            this.frames = Q.newFloatArray(t * xt.ENTRIES)
    }
    getPropertyId() {
        return (14 << 24) + this.slotIndex
    }
    setFrame(t, e, n, s, r, i, o, l, a) {
        t *= xt.ENTRIES,
            this.frames[t] = e,
            this.frames[t + xt.R] = n,
            this.frames[t + xt.G] = s,
            this.frames[t + xt.B] = r,
            this.frames[t + xt.A] = i,
            this.frames[t + xt.R2] = o,
            this.frames[t + xt.G2] = l,
            this.frames[t + xt.B2] = a
    }
    apply(t, e, n, s, r, i, o) {
        const l = t.slots[this.slotIndex]
            , a = this.frames;
        if (n < a[0]) {
            switch (i) {
                case O.setup:
                    l.color.setFromColor(l.data.color),
                        l.darkColor.setFromColor(l.data.darkColor);
                    return;
                case O.first:
                    const g = l.color
                        , b = l.darkColor
                        , v = l.data.color
                        , _ = l.data.darkColor;
                    g.add((v.r - g.r) * r, (v.g - g.g) * r, (v.b - g.b) * r, (v.a - g.a) * r),
                        b.add((_.r - b.r) * r, (_.g - b.g) * r, (_.b - b.b) * r, 0)
            }
            return
        }
        let c = 0
            , u = 0
            , h = 0
            , d = 0
            , f = 0
            , p = 0
            , m = 0;
        if (n >= a[a.length - xt.ENTRIES]) {
            const g = a.length;
            c = a[g + xt.PREV_R],
                u = a[g + xt.PREV_G],
                h = a[g + xt.PREV_B],
                d = a[g + xt.PREV_A],
                f = a[g + xt.PREV_R2],
                p = a[g + xt.PREV_G2],
                m = a[g + xt.PREV_B2]
        } else {
            const g = Un.binarySearch(a, n, xt.ENTRIES);
            c = a[g + xt.PREV_R],
                u = a[g + xt.PREV_G],
                h = a[g + xt.PREV_B],
                d = a[g + xt.PREV_A],
                f = a[g + xt.PREV_R2],
                p = a[g + xt.PREV_G2],
                m = a[g + xt.PREV_B2];
            const b = a[g]
                , v = this.getCurvePercent(g / xt.ENTRIES - 1, 1 - (n - b) / (a[g + xt.PREV_TIME] - b));
            c += (a[g + xt.R] - c) * v,
                u += (a[g + xt.G] - u) * v,
                h += (a[g + xt.B] - h) * v,
                d += (a[g + xt.A] - d) * v,
                f += (a[g + xt.R2] - f) * v,
                p += (a[g + xt.G2] - p) * v,
                m += (a[g + xt.B2] - m) * v
        }
        if (r == 1)
            l.color.set(c, u, h, d),
                l.darkColor.set(f, p, m, 1);
        else {
            const g = l.color
                , b = l.darkColor;
            i == O.setup && (g.setFromColor(l.data.color),
                b.setFromColor(l.data.darkColor)),
                g.add((c - g.r) * r, (u - g.g) * r, (h - g.b) * r, (d - g.a) * r),
                b.add((f - b.r) * r, (p - b.g) * r, (m - b.b) * r, 0)
        }
    }
}
    ;
let $n = xt;
$n.ENTRIES = 8;
$n.PREV_TIME = -8;
$n.PREV_R = -7;
$n.PREV_G = -6;
$n.PREV_B = -5;
$n.PREV_A = -4;
$n.PREV_R2 = -3;
$n.PREV_G2 = -2;
$n.PREV_B2 = -1;
$n.R = 1;
$n.G = 2;
$n.B = 3;
$n.A = 4;
$n.R2 = 5;
$n.G2 = 6;
$n.B2 = 7;
let og = class {
    constructor(e) {
        this.frames = Q.newFloatArray(e),
            this.attachmentNames = new Array(e)
    }
    getPropertyId() {
        return (4 << 24) + this.slotIndex
    }
    getFrameCount() {
        return this.frames.length
    }
    setFrame(e, n, s) {
        this.frames[e] = n,
            this.attachmentNames[e] = s
    }
    apply(e, n, s, r, i, o, l) {
        const a = e.slots[this.slotIndex];
        if (l == ct.mixOut && o == O.setup) {
            const d = a.data.attachmentName;
            a.setAttachment(d == null ? null : e.getAttachment(this.slotIndex, d));
            return
        }
        const c = this.frames;
        if (s < c[0]) {
            if (o == O.setup || o == O.first) {
                const d = a.data.attachmentName;
                a.setAttachment(d == null ? null : e.getAttachment(this.slotIndex, d))
            }
            return
        }
        let u = 0;
        s >= c[c.length - 1] ? u = c.length - 1 : u = Un.binarySearch(c, s, 1) - 1;
        const h = this.attachmentNames[u];
        e.slots[this.slotIndex].setAttachment(h == null ? null : e.getAttachment(this.slotIndex, h))
    }
}
    , _A = null
    , X5 = class extends Js {
        constructor(e) {
            super(e),
                this.frames = Q.newFloatArray(e),
                this.frameVertices = new Array(e),
                _A == null && (_A = Q.newFloatArray(64))
        }
        getPropertyId() {
            return (6 << 27) + Number(this.attachment.id) + this.slotIndex
        }
        setFrame(e, n, s) {
            this.frames[e] = n,
                this.frameVertices[e] = s
        }
        apply(e, n, s, r, i, o, l) {
            const a = e.slots[this.slotIndex]
                , c = a.getAttachment();
            if (!(c instanceof ul) || !c.applyDeform(this.attachment))
                return;
            const u = a.attachmentVertices;
            u.length == 0 && (o = O.setup);
            const h = this.frameVertices
                , d = h[0].length
                , f = this.frames;
            if (s < f[0]) {
                const y = c;
                switch (o) {
                    case O.setup:
                        u.length = 0;
                        return;
                    case O.first:
                        if (i == 1) {
                            u.length = 0;
                            break
                        }
                        const x = Q.setArraySize(u, d);
                        if (y.bones == null) {
                            const w = y.vertices;
                            for (let S = 0; S < d; S++)
                                x[S] += (w[S] - x[S]) * i
                        } else {
                            i = 1 - i;
                            for (let w = 0; w < d; w++)
                                x[w] *= i
                        }
                }
                return
            }
            const p = Q.setArraySize(u, d);
            if (s >= f[f.length - 1]) {
                const y = h[f.length - 1];
                if (i == 1)
                    if (o == O.add) {
                        const x = c;
                        if (x.bones == null) {
                            const w = x.vertices;
                            for (let S = 0; S < d; S++)
                                p[S] += y[S] - w[S]
                        } else
                            for (let w = 0; w < d; w++)
                                p[w] += y[w]
                    } else
                        Q.arrayCopy(y, 0, p, 0, d);
                else
                    switch (o) {
                        case O.setup:
                            {
                                const w = c;
                                if (w.bones == null) {
                                    const S = w.vertices;
                                    for (let E = 0; E < d; E++) {
                                        const C = S[E];
                                        p[E] = C + (y[E] - C) * i
                                    }
                                } else
                                    for (let S = 0; S < d; S++)
                                        p[S] = y[S] * i;
                                break
                            }
                        case O.first:
                        case O.replace:
                            for (let w = 0; w < d; w++)
                                p[w] += (y[w] - p[w]) * i;
                        case O.add:
                            const x = c;
                            if (x.bones == null) {
                                const w = x.vertices;
                                for (let S = 0; S < d; S++)
                                    p[S] += (y[S] - w[S]) * i
                            } else
                                for (let w = 0; w < d; w++)
                                    p[w] += y[w] * i
                    }
                return
            }
            const m = Un.binarySearch(f, s)
                , g = h[m - 1]
                , b = h[m]
                , v = f[m]
                , _ = this.getCurvePercent(m - 1, 1 - (s - v) / (f[m - 1] - v));
            if (i == 1)
                if (o == O.add) {
                    const y = c;
                    if (y.bones == null) {
                        const x = y.vertices;
                        for (let w = 0; w < d; w++) {
                            const S = g[w];
                            p[w] += S + (b[w] - S) * _ - x[w]
                        }
                    } else
                        for (let x = 0; x < d; x++) {
                            const w = g[x];
                            p[x] += w + (b[x] - w) * _
                        }
                } else
                    for (let y = 0; y < d; y++) {
                        const x = g[y];
                        p[y] = x + (b[y] - x) * _
                    }
            else
                switch (o) {
                    case O.setup:
                        {
                            const x = c;
                            if (x.bones == null) {
                                const w = x.vertices;
                                for (let S = 0; S < d; S++) {
                                    const E = g[S]
                                        , C = w[S];
                                    p[S] = C + (E + (b[S] - E) * _ - C) * i
                                }
                            } else
                                for (let w = 0; w < d; w++) {
                                    const S = g[w];
                                    p[w] = (S + (b[w] - S) * _) * i
                                }
                            break
                        }
                    case O.first:
                    case O.replace:
                        for (let x = 0; x < d; x++) {
                            const w = g[x];
                            p[x] += (w + (b[x] - w) * _ - p[x]) * i
                        }
                        break;
                    case O.add:
                        const y = c;
                        if (y.bones == null) {
                            const x = y.vertices;
                            for (let w = 0; w < d; w++) {
                                const S = g[w];
                                p[w] += (S + (b[w] - S) * _ - x[w]) * i
                            }
                        } else
                            for (let x = 0; x < d; x++) {
                                const w = g[x];
                                p[x] += (w + (b[x] - w) * _) * i
                            }
                }
        }
    }
    , j5 = class {
        constructor(e) {
            this.frames = Q.newFloatArray(e),
                this.events = new Array(e)
        }
        getPropertyId() {
            return 7 << 24
        }
        getFrameCount() {
            return this.frames.length
        }
        setFrame(e, n) {
            this.frames[e] = n.time,
                this.events[e] = n
        }
        apply(e, n, s, r, i, o, l) {
            if (r == null)
                return;
            const a = this.frames
                , c = this.frames.length;
            if (n > s)
                this.apply(e, n, Number.MAX_VALUE, r, i, o, l),
                    n = -1;
            else if (n >= a[c - 1])
                return;
            if (s < a[0])
                return;
            let u = 0;
            if (n < a[0])
                u = 0;
            else {
                u = Un.binarySearch(a, n);
                const h = a[u];
                for (; u > 0 && a[u - 1] == h;)
                    u--
            }
            for (; u < c && s >= a[u]; u++)
                r.push(this.events[u])
        }
    }
    , ag = class {
        constructor(e) {
            this.frames = Q.newFloatArray(e),
                this.drawOrders = new Array(e)
        }
        getPropertyId() {
            return 8 << 24
        }
        getFrameCount() {
            return this.frames.length
        }
        setFrame(e, n, s) {
            this.frames[e] = n,
                this.drawOrders[e] = s
        }
        apply(e, n, s, r, i, o, l) {
            const a = e.drawOrder
                , c = e.slots;
            if (l == ct.mixOut && o == O.setup) {
                Q.arrayCopy(e.slots, 0, e.drawOrder, 0, e.slots.length);
                return
            }
            const u = this.frames;
            if (s < u[0]) {
                (o == O.setup || o == O.first) && Q.arrayCopy(e.slots, 0, e.drawOrder, 0, e.slots.length);
                return
            }
            let h = 0;
            s >= u[u.length - 1] ? h = u.length - 1 : h = Un.binarySearch(u, s) - 1;
            const d = this.drawOrders[h];
            if (d == null)
                Q.arrayCopy(c, 0, a, 0, c.length);
            else
                for (let f = 0, p = d.length; f < p; f++)
                    a[f] = c[d[f]]
        }
    }
    ;
const Nt = class extends Js {
    constructor(t) {
        super(t),
            this.frames = Q.newFloatArray(t * Nt.ENTRIES)
    }
    getPropertyId() {
        return (9 << 24) + this.ikConstraintIndex
    }
    setFrame(t, e, n, s, r, i) {
        t *= Nt.ENTRIES,
            this.frames[t] = e,
            this.frames[t + Nt.MIX] = n,
            this.frames[t + Nt.BEND_DIRECTION] = s,
            this.frames[t + Nt.COMPRESS] = r ? 1 : 0,
            this.frames[t + Nt.STRETCH] = i ? 1 : 0
    }
    apply(t, e, n, s, r, i, o) {
        const l = this.frames
            , a = t.ikConstraints[this.ikConstraintIndex];
        if (n < l[0]) {
            switch (i) {
                case O.setup:
                    a.mix = a.data.mix,
                        a.bendDirection = a.data.bendDirection,
                        a.compress = a.data.compress,
                        a.stretch = a.data.stretch;
                    return;
                case O.first:
                    a.mix += (a.data.mix - a.mix) * r,
                        a.bendDirection = a.data.bendDirection,
                        a.compress = a.data.compress,
                        a.stretch = a.data.stretch
            }
            return
        }
        if (n >= l[l.length - Nt.ENTRIES]) {
            i == O.setup ? (a.mix = a.data.mix + (l[l.length + Nt.PREV_MIX] - a.data.mix) * r,
                o == ct.mixOut ? (a.bendDirection = a.data.bendDirection,
                    a.compress = a.data.compress,
                    a.stretch = a.data.stretch) : (a.bendDirection = l[l.length + Nt.PREV_BEND_DIRECTION],
                        a.compress = l[l.length + Nt.PREV_COMPRESS] != 0,
                        a.stretch = l[l.length + Nt.PREV_STRETCH] != 0)) : (a.mix += (l[l.length + Nt.PREV_MIX] - a.mix) * r,
                            o == ct.mixIn && (a.bendDirection = l[l.length + Nt.PREV_BEND_DIRECTION],
                                a.compress = l[l.length + Nt.PREV_COMPRESS] != 0,
                                a.stretch = l[l.length + Nt.PREV_STRETCH] != 0));
            return
        }
        const c = Un.binarySearch(l, n, Nt.ENTRIES)
            , u = l[c + Nt.PREV_MIX]
            , h = l[c]
            , d = this.getCurvePercent(c / Nt.ENTRIES - 1, 1 - (n - h) / (l[c + Nt.PREV_TIME] - h));
        i == O.setup ? (a.mix = a.data.mix + (u + (l[c + Nt.MIX] - u) * d - a.data.mix) * r,
            o == ct.mixOut ? (a.bendDirection = a.data.bendDirection,
                a.compress = a.data.compress,
                a.stretch = a.data.stretch) : (a.bendDirection = l[c + Nt.PREV_BEND_DIRECTION],
                    a.compress = l[c + Nt.PREV_COMPRESS] != 0,
                    a.stretch = l[c + Nt.PREV_STRETCH] != 0)) : (a.mix += (u + (l[c + Nt.MIX] - u) * d - a.mix) * r,
                        o == ct.mixIn && (a.bendDirection = l[c + Nt.PREV_BEND_DIRECTION],
                            a.compress = l[c + Nt.PREV_COMPRESS] != 0,
                            a.stretch = l[c + Nt.PREV_STRETCH] != 0))
    }
}
    ;
let fr = Nt;
fr.ENTRIES = 5;
fr.PREV_TIME = -5;
fr.PREV_MIX = -4;
fr.PREV_BEND_DIRECTION = -3;
fr.PREV_COMPRESS = -2;
fr.PREV_STRETCH = -1;
fr.MIX = 1;
fr.BEND_DIRECTION = 2;
fr.COMPRESS = 3;
fr.STRETCH = 4;
const nn = class extends Js {
    constructor(t) {
        super(t),
            this.frames = Q.newFloatArray(t * nn.ENTRIES)
    }
    getPropertyId() {
        return (10 << 24) + this.transformConstraintIndex
    }
    setFrame(t, e, n, s, r, i) {
        t *= nn.ENTRIES,
            this.frames[t] = e,
            this.frames[t + nn.ROTATE] = n,
            this.frames[t + nn.TRANSLATE] = s,
            this.frames[t + nn.SCALE] = r,
            this.frames[t + nn.SHEAR] = i
    }
    apply(t, e, n, s, r, i, o) {
        const l = this.frames
            , a = t.transformConstraints[this.transformConstraintIndex];
        if (n < l[0]) {
            const f = a.data;
            switch (i) {
                case O.setup:
                    a.rotateMix = f.rotateMix,
                        a.translateMix = f.translateMix,
                        a.scaleMix = f.scaleMix,
                        a.shearMix = f.shearMix;
                    return;
                case O.first:
                    a.rotateMix += (f.rotateMix - a.rotateMix) * r,
                        a.translateMix += (f.translateMix - a.translateMix) * r,
                        a.scaleMix += (f.scaleMix - a.scaleMix) * r,
                        a.shearMix += (f.shearMix - a.shearMix) * r
            }
            return
        }
        let c = 0
            , u = 0
            , h = 0
            , d = 0;
        if (n >= l[l.length - nn.ENTRIES]) {
            const f = l.length;
            c = l[f + nn.PREV_ROTATE],
                u = l[f + nn.PREV_TRANSLATE],
                h = l[f + nn.PREV_SCALE],
                d = l[f + nn.PREV_SHEAR]
        } else {
            const f = Un.binarySearch(l, n, nn.ENTRIES);
            c = l[f + nn.PREV_ROTATE],
                u = l[f + nn.PREV_TRANSLATE],
                h = l[f + nn.PREV_SCALE],
                d = l[f + nn.PREV_SHEAR];
            const p = l[f]
                , m = this.getCurvePercent(f / nn.ENTRIES - 1, 1 - (n - p) / (l[f + nn.PREV_TIME] - p));
            c += (l[f + nn.ROTATE] - c) * m,
                u += (l[f + nn.TRANSLATE] - u) * m,
                h += (l[f + nn.SCALE] - h) * m,
                d += (l[f + nn.SHEAR] - d) * m
        }
        if (i == O.setup) {
            const f = a.data;
            a.rotateMix = f.rotateMix + (c - f.rotateMix) * r,
                a.translateMix = f.translateMix + (u - f.translateMix) * r,
                a.scaleMix = f.scaleMix + (h - f.scaleMix) * r,
                a.shearMix = f.shearMix + (d - f.shearMix) * r
        } else
            a.rotateMix += (c - a.rotateMix) * r,
                a.translateMix += (u - a.translateMix) * r,
                a.scaleMix += (h - a.scaleMix) * r,
                a.shearMix += (d - a.shearMix) * r
    }
}
    ;
let pr = nn;
pr.ENTRIES = 5;
pr.PREV_TIME = -5;
pr.PREV_ROTATE = -4;
pr.PREV_TRANSLATE = -3;
pr.PREV_SCALE = -2;
pr.PREV_SHEAR = -1;
pr.ROTATE = 1;
pr.TRANSLATE = 2;
pr.SCALE = 3;
pr.SHEAR = 4;
const jr = class extends Js {
    constructor(t) {
        super(t),
            this.frames = Q.newFloatArray(t * jr.ENTRIES)
    }
    getPropertyId() {
        return (11 << 24) + this.pathConstraintIndex
    }
    setFrame(t, e, n) {
        t *= jr.ENTRIES,
            this.frames[t] = e,
            this.frames[t + jr.VALUE] = n
    }
    apply(t, e, n, s, r, i, o) {
        const l = this.frames
            , a = t.pathConstraints[this.pathConstraintIndex];
        if (n < l[0]) {
            switch (i) {
                case O.setup:
                    a.position = a.data.position;
                    return;
                case O.first:
                    a.position += (a.data.position - a.position) * r
            }
            return
        }
        let c = 0;
        if (n >= l[l.length - jr.ENTRIES])
            c = l[l.length + jr.PREV_VALUE];
        else {
            const u = Un.binarySearch(l, n, jr.ENTRIES);
            c = l[u + jr.PREV_VALUE];
            const h = l[u]
                , d = this.getCurvePercent(u / jr.ENTRIES - 1, 1 - (n - h) / (l[u + jr.PREV_TIME] - h));
            c += (l[u + jr.VALUE] - c) * d
        }
        i == O.setup ? a.position = a.data.position + (c - a.data.position) * r : a.position += (c - a.position) * r
    }
}
    ;
let za = jr;
za.ENTRIES = 2;
za.PREV_TIME = -2;
za.PREV_VALUE = -1;
za.VALUE = 1;
let z5 = class la extends za {
    constructor(e) {
        super(e)
    }
    getPropertyId() {
        return (12 << 24) + this.pathConstraintIndex
    }
    apply(e, n, s, r, i, o, l) {
        const a = this.frames
            , c = e.pathConstraints[this.pathConstraintIndex];
        if (s < a[0]) {
            switch (o) {
                case O.setup:
                    c.spacing = c.data.spacing;
                    return;
                case O.first:
                    c.spacing += (c.data.spacing - c.spacing) * i
            }
            return
        }
        let u = 0;
        if (s >= a[a.length - la.ENTRIES])
            u = a[a.length + la.PREV_VALUE];
        else {
            const h = Un.binarySearch(a, s, la.ENTRIES);
            u = a[h + la.PREV_VALUE];
            const d = a[h]
                , f = this.getCurvePercent(h / la.ENTRIES - 1, 1 - (s - d) / (a[h + la.PREV_TIME] - d));
            u += (a[h + la.VALUE] - u) * f
        }
        o == O.setup ? c.spacing = c.data.spacing + (u - c.data.spacing) * i : c.spacing += (u - c.spacing) * i
    }
}
    ;
const ws = class extends Js {
    constructor(t) {
        super(t),
            this.frames = Q.newFloatArray(t * ws.ENTRIES)
    }
    getPropertyId() {
        return (13 << 24) + this.pathConstraintIndex
    }
    setFrame(t, e, n, s) {
        t *= ws.ENTRIES,
            this.frames[t] = e,
            this.frames[t + ws.ROTATE] = n,
            this.frames[t + ws.TRANSLATE] = s
    }
    apply(t, e, n, s, r, i, o) {
        const l = this.frames
            , a = t.pathConstraints[this.pathConstraintIndex];
        if (n < l[0]) {
            switch (i) {
                case O.setup:
                    a.rotateMix = a.data.rotateMix,
                        a.translateMix = a.data.translateMix;
                    return;
                case O.first:
                    a.rotateMix += (a.data.rotateMix - a.rotateMix) * r,
                        a.translateMix += (a.data.translateMix - a.translateMix) * r
            }
            return
        }
        let c = 0
            , u = 0;
        if (n >= l[l.length - ws.ENTRIES])
            c = l[l.length + ws.PREV_ROTATE],
                u = l[l.length + ws.PREV_TRANSLATE];
        else {
            const h = Un.binarySearch(l, n, ws.ENTRIES);
            c = l[h + ws.PREV_ROTATE],
                u = l[h + ws.PREV_TRANSLATE];
            const d = l[h]
                , f = this.getCurvePercent(h / ws.ENTRIES - 1, 1 - (n - d) / (l[h + ws.PREV_TIME] - d));
            c += (l[h + ws.ROTATE] - c) * f,
                u += (l[h + ws.TRANSLATE] - u) * f
        }
        i == O.setup ? (a.rotateMix = a.data.rotateMix + (c - a.data.rotateMix) * r,
            a.translateMix = a.data.translateMix + (u - a.data.translateMix) * r) : (a.rotateMix += (c - a.rotateMix) * r,
                a.translateMix += (u - a.translateMix) * r)
    }
}
    ;
let Ho = ws;
Ho.ENTRIES = 3;
Ho.PREV_TIME = -3;
Ho.PREV_ROTATE = -2;
Ho.PREV_TRANSLATE = -1;
Ho.ROTATE = 1;
Ho.TRANSLATE = 2;
const Gn = class {
    constructor(e) {
        this.tracks = new Array,
            this.events = new Array,
            this.listeners = new Array,
            this.queue = new Ow(this),
            this.propertyIDs = new l5,
            this.animationsChanged = !1,
            this.timeScale = 1,
            this.trackEntryPool = new N_(() => new G_),
            this.data = e
    }
    update(e) {
        e *= this.timeScale;
        const n = this.tracks;
        for (let s = 0, r = n.length; s < r; s++) {
            const i = n[s];
            if (i == null)
                continue;
            i.animationLast = i.nextAnimationLast,
                i.trackLast = i.nextTrackLast;
            let o = e * i.timeScale;
            if (i.delay > 0) {
                if (i.delay -= o,
                    i.delay > 0)
                    continue;
                o = -i.delay,
                    i.delay = 0
            }
            let l = i.next;
            if (l != null) {
                const a = i.trackLast - l.delay;
                if (a >= 0) {
                    for (l.delay = 0,
                        l.trackTime = i.timeScale == 0 ? 0 : (a / i.timeScale + e) * l.timeScale,
                        i.trackTime += o,
                        this.setCurrent(s, l, !0); l.mixingFrom != null;)
                        l.mixTime += e,
                            l = l.mixingFrom;
                    continue
                }
            } else if (i.trackLast >= i.trackEnd && i.mixingFrom == null) {
                n[s] = null,
                    this.queue.end(i),
                    this.disposeNext(i);
                continue
            }
            if (i.mixingFrom != null && this.updateMixingFrom(i, e)) {
                let a = i.mixingFrom;
                for (i.mixingFrom = null,
                    a != null && (a.mixingTo = null); a != null;)
                    this.queue.end(a),
                        a = a.mixingFrom
            }
            i.trackTime += o
        }
        this.queue.drain()
    }
    updateMixingFrom(e, n) {
        const s = e.mixingFrom;
        if (s == null)
            return !0;
        const r = this.updateMixingFrom(s, n);
        return s.animationLast = s.nextAnimationLast,
            s.trackLast = s.nextTrackLast,
            e.mixTime > 0 && e.mixTime >= e.mixDuration ? ((s.totalAlpha == 0 || e.mixDuration == 0) && (e.mixingFrom = s.mixingFrom,
                s.mixingFrom != null && (s.mixingFrom.mixingTo = e),
                e.interruptAlpha = s.interruptAlpha,
                this.queue.end(s)),
                r) : (s.trackTime += n * s.timeScale,
                    e.mixTime += n,
                    !1)
    }
    apply(e) {
        if (e == null)
            throw new Error("skeleton cannot be null.");
        this.animationsChanged && this._animationsChanged();
        const n = this.events
            , s = this.tracks;
        let r = !1;
        for (let i = 0, o = s.length; i < o; i++) {
            const l = s[i];
            if (l == null || l.delay > 0)
                continue;
            r = !0;
            const a = i == 0 ? O.first : l.mixBlend;
            let c = l.alpha;
            l.mixingFrom != null ? c *= this.applyMixingFrom(l, e, a) : l.trackTime >= l.trackEnd && l.next == null && (c = 0);
            const u = l.animationLast
                , h = l.getAnimationTime()
                , d = l.animation.timelines.length
                , f = l.animation.timelines;
            if (i == 0 && c == 1 || a == O.add)
                for (let p = 0; p < d; p++)
                    f[p].apply(e, u, h, n, c, a, ct.mixIn);
            else {
                const p = l.timelineMode
                    , m = l.timelinesRotation.length == 0;
                m && Q.setArraySize(l.timelinesRotation, d << 1, null);
                const g = l.timelinesRotation;
                for (let b = 0; b < d; b++) {
                    const v = f[b]
                        , _ = p[b] == Gn.SUBSEQUENT ? a : O.setup;
                    v instanceof Ts ? this.applyRotateTimeline(v, e, h, c, _, g, b << 1, m) : v.apply(e, u, h, n, c, _, ct.mixIn)
                }
            }
            this.queueEvents(l, h),
                n.length = 0,
                l.nextAnimationLast = h,
                l.nextTrackLast = l.trackTime
        }
        return this.queue.drain(),
            r
    }
    applyMixingFrom(e, n, s) {
        const r = e.mixingFrom;
        r.mixingFrom != null && this.applyMixingFrom(r, n, s);
        let i = 0;
        e.mixDuration == 0 ? (i = 1,
            s == O.first && (s = O.setup)) : (i = e.mixTime / e.mixDuration,
                i > 1 && (i = 1),
                s != O.first && (s = r.mixBlend));
        const o = i < r.eventThreshold ? this.events : null
            , l = i < r.attachmentThreshold
            , a = i < r.drawOrderThreshold
            , c = r.animationLast
            , u = r.getAnimationTime()
            , h = r.animation.timelines.length
            , d = r.animation.timelines
            , f = r.alpha * e.interruptAlpha
            , p = f * (1 - i);
        if (s == O.add)
            for (let m = 0; m < h; m++)
                d[m].apply(n, c, u, o, p, s, ct.mixOut);
        else {
            const m = r.timelineMode
                , g = r.timelineHoldMix
                , b = r.timelinesRotation.length == 0;
            b && Q.setArraySize(r.timelinesRotation, h << 1, null);
            const v = r.timelinesRotation;
            r.totalAlpha = 0;
            for (let _ = 0; _ < h; _++) {
                const y = d[_];
                let x = ct.mixOut, w, S = 0;
                switch (m[_]) {
                    case Gn.SUBSEQUENT:
                        if (!l && y instanceof og || !a && y instanceof ag)
                            continue;
                        w = s,
                            S = p;
                        break;
                    case Gn.FIRST:
                        w = O.setup,
                            S = p;
                        break;
                    case Gn.HOLD:
                        w = O.setup,
                            S = f;
                        break;
                    default:
                        w = O.setup;
                        const E = g[_];
                        S = f * Math.max(0, 1 - E.mixTime / E.mixDuration);
                        break
                }
                r.totalAlpha += S,
                    y instanceof Ts ? this.applyRotateTimeline(y, n, u, S, w, v, _ << 1, b) : (w == O.setup && (y instanceof og ? l && (x = ct.mixOut) : y instanceof ag && a && (x = ct.mixOut)),
                        y.apply(n, c, u, o, S, w, x))
            }
        }
        return e.mixDuration > 0 && this.queueEvents(r, u),
            this.events.length = 0,
            r.nextAnimationLast = u,
            r.nextTrackLast = r.trackTime,
            i
    }
    applyRotateTimeline(e, n, s, r, i, o, l, a) {
        if (a && (o[l] = 0),
            r == 1) {
            e.apply(n, 0, s, null, 1, i, ct.mixIn);
            return
        }
        const c = e
            , u = c.frames
            , h = n.bones[c.boneIndex];
        let d = 0
            , f = 0;
        if (s < u[0])
            switch (i) {
                case O.setup:
                    h.rotation = h.data.rotation;
                default:
                    return;
                case O.first:
                    d = h.rotation,
                        f = h.data.rotation
            }
        else if (d = i == O.setup ? h.data.rotation : h.rotation,
            s >= u[u.length - Ts.ENTRIES])
            f = h.data.rotation + u[u.length + Ts.PREV_ROTATION];
        else {
            const g = Un.binarySearch(u, s, Ts.ENTRIES)
                , b = u[g + Ts.PREV_ROTATION]
                , v = u[g]
                , _ = c.getCurvePercent((g >> 1) - 1, 1 - (s - v) / (u[g + Ts.PREV_TIME] - v));
            f = u[g + Ts.ROTATION] - b,
                f -= (16384 - (16384.499999999996 - f / 360 | 0)) * 360,
                f = b + f * _ + h.data.rotation,
                f -= (16384 - (16384.499999999996 - f / 360 | 0)) * 360
        }
        let p = 0
            , m = f - d;
        if (m -= (16384 - (16384.499999999996 - m / 360 | 0)) * 360,
            m == 0)
            p = o[l];
        else {
            let g = 0
                , b = 0;
            a ? (g = 0,
                b = m) : (g = o[l],
                    b = o[l + 1]);
            const v = m > 0;
            let _ = g >= 0;
            F.signum(b) != F.signum(m) && Math.abs(b) <= 90 && (Math.abs(g) > 180 && (g += 360 * F.signum(g)),
                _ = v),
                p = m + g - g % 360,
                _ != v && (p += 360 * F.signum(g)),
                o[l] = p
        }
        o[l + 1] = m,
            d += p * r,
            h.rotation = d - (16384 - (16384.499999999996 - d / 360 | 0)) * 360
    }
    queueEvents(e, n) {
        const s = e.animationStart
            , r = e.animationEnd
            , i = r - s
            , o = e.trackLast % i
            , l = this.events;
        let a = 0;
        const c = l.length;
        for (; a < c; a++) {
            const h = l[a];
            if (h.time < o)
                break;
            h.time > r || this.queue.event(e, h)
        }
        let u = !1;
        for (e.loop ? u = i == 0 || o > e.trackTime % i : u = n >= r && e.animationLast < r,
            u && this.queue.complete(e); a < c; a++)
            l[a].time < s || this.queue.event(e, l[a])
    }
    clearTracks() {
        const e = this.queue.drainDisabled;
        this.queue.drainDisabled = !0;
        for (let n = 0, s = this.tracks.length; n < s; n++)
            this.clearTrack(n);
        this.tracks.length = 0,
            this.queue.drainDisabled = e,
            this.queue.drain()
    }
    clearTrack(e) {
        if (e >= this.tracks.length)
            return;
        const n = this.tracks[e];
        if (n == null)
            return;
        this.queue.end(n),
            this.disposeNext(n);
        let s = n;
        for (; ;) {
            const r = s.mixingFrom;
            if (r == null)
                break;
            this.queue.end(r),
                s.mixingFrom = null,
                s.mixingTo = null,
                s = r
        }
        this.tracks[n.trackIndex] = null,
            this.queue.drain()
    }
    setCurrent(e, n, s) {
        const r = this.expandToIndex(e);
        this.tracks[e] = n,
            r != null && (s && this.queue.interrupt(r),
                n.mixingFrom = r,
                r.mixingTo = n,
                n.mixTime = 0,
                r.mixingFrom != null && r.mixDuration > 0 && (n.interruptAlpha *= Math.min(1, r.mixTime / r.mixDuration)),
                r.timelinesRotation.length = 0),
            this.queue.start(n)
    }
    setAnimation(e, n, s) {
        const r = this.data.skeletonData.findAnimation(n);
        if (r == null)
            throw new Error(`Animation not found: ${n}`);
        return this.setAnimationWith(e, r, s)
    }
    setAnimationWith(e, n, s) {
        if (n == null)
            throw new Error("animation cannot be null.");
        let r = !0
            , i = this.expandToIndex(e);
        i != null && (i.nextTrackLast == -1 ? (this.tracks[e] = i.mixingFrom,
            this.queue.interrupt(i),
            this.queue.end(i),
            this.disposeNext(i),
            i = i.mixingFrom,
            r = !1) : this.disposeNext(i));
        const o = this.trackEntry(e, n, s, i);
        return this.setCurrent(e, o, r),
            this.queue.drain(),
            o
    }
    addAnimation(e, n, s, r) {
        const i = this.data.skeletonData.findAnimation(n);
        if (i == null)
            throw new Error(`Animation not found: ${n}`);
        return this.addAnimationWith(e, i, s, r)
    }
    addAnimationWith(e, n, s, r) {
        if (n == null)
            throw new Error("animation cannot be null.");
        let i = this.expandToIndex(e);
        if (i != null)
            for (; i.next != null;)
                i = i.next;
        const o = this.trackEntry(e, n, s, i);
        if (i == null)
            this.setCurrent(e, o, !0),
                this.queue.drain();
        else if (i.next = o,
            r <= 0) {
            const l = i.animationEnd - i.animationStart;
            l != 0 ? (i.loop ? r += l * (1 + (i.trackTime / l | 0)) : r += Math.max(l, i.trackTime),
                r -= this.data.getMix(i.animation, n)) : r = i.trackTime
        }
        return o.delay = r,
            o
    }
    setEmptyAnimation(e, n) {
        const s = this.setAnimationWith(e, Gn.emptyAnimation, !1);
        return s.mixDuration = n,
            s.trackEnd = n,
            s
    }
    addEmptyAnimation(e, n, s) {
        s <= 0 && (s -= n);
        const r = this.addAnimationWith(e, Gn.emptyAnimation, !1, s);
        return r.mixDuration = n,
            r.trackEnd = n,
            r
    }
    setEmptyAnimations(e) {
        const n = this.queue.drainDisabled;
        this.queue.drainDisabled = !0;
        for (let s = 0, r = this.tracks.length; s < r; s++) {
            const i = this.tracks[s];
            i != null && this.setEmptyAnimation(i.trackIndex, e)
        }
        this.queue.drainDisabled = n,
            this.queue.drain()
    }
    expandToIndex(e) {
        return e < this.tracks.length ? this.tracks[e] : (Q.ensureArrayCapacity(this.tracks, e - this.tracks.length + 1, null),
            this.tracks.length = e + 1,
            null)
    }
    trackEntry(e, n, s, r) {
        const i = this.trackEntryPool.obtain();
        return i.trackIndex = e,
            i.animation = n,
            i.loop = s,
            i.holdPrevious = !1,
            i.eventThreshold = 0,
            i.attachmentThreshold = 0,
            i.drawOrderThreshold = 0,
            i.animationStart = 0,
            i.animationEnd = n.duration,
            i.animationLast = -1,
            i.nextAnimationLast = -1,
            i.delay = 0,
            i.trackTime = 0,
            i.trackLast = -1,
            i.nextTrackLast = -1,
            i.trackEnd = Number.MAX_VALUE,
            i.timeScale = 1,
            i.alpha = 1,
            i.interruptAlpha = 1,
            i.mixTime = 0,
            i.mixDuration = r == null ? 0 : this.data.getMix(r.animation, n),
            i
    }
    disposeNext(e) {
        let n = e.next;
        for (; n != null;)
            this.queue.dispose(n),
                n = n.next;
        e.next = null
    }
    _animationsChanged() {
        this.animationsChanged = !1,
            this.propertyIDs.clear();
        for (let e = 0, n = this.tracks.length; e < n; e++) {
            let s = this.tracks[e];
            if (s != null) {
                for (; s.mixingFrom != null;)
                    s = s.mixingFrom;
                do
                    (s.mixingFrom == null || s.mixBlend != O.add) && this.setTimelineModes(s),
                        s = s.mixingTo;
                while (s != null)
            }
        }
    }
    setTimelineModes(e) {
        const n = e.mixingTo
            , s = e.animation.timelines
            , r = e.animation.timelines.length
            , i = Q.setArraySize(e.timelineMode, r);
        e.timelineHoldMix.length = 0;
        const o = Q.setArraySize(e.timelineHoldMix, r)
            , l = this.propertyIDs;
        if (n != null && n.holdPrevious) {
            for (let a = 0; a < r; a++)
                l.add(s[a].getPropertyId()),
                    i[a] = Gn.HOLD;
            return
        }
        e: for (let a = 0; a < r; a++) {
            const c = s[a].getPropertyId();
            if (!l.add(c))
                i[a] = Gn.SUBSEQUENT;
            else if (n == null || !this.hasTimeline(n, c))
                i[a] = Gn.FIRST;
            else {
                for (let u = n.mixingTo; u != null; u = u.mixingTo)
                    if (!this.hasTimeline(u, c)) {
                        if (e.mixDuration > 0) {
                            i[a] = Gn.HOLD_MIX,
                                o[a] = u;
                            continue e
                        }
                        break
                    }
                i[a] = Gn.HOLD
            }
        }
    }
    hasTimeline(e, n) {
        const s = e.animation.timelines;
        for (let r = 0, i = s.length; r < i; r++)
            if (s[r].getPropertyId() == n)
                return !0;
        return !1
    }
    getCurrent(e) {
        return e >= this.tracks.length ? null : this.tracks[e]
    }
    addListener(e) {
        if (e == null)
            throw new Error("listener cannot be null.");
        this.listeners.push(e)
    }
    removeListener(e) {
        const n = this.listeners.indexOf(e);
        n >= 0 && this.listeners.splice(n, 1)
    }
    clearListeners() {
        this.listeners.length = 0
    }
    clearListenerNotifications() {
        this.queue.clear()
    }
    setAnimationByName(e, n, s) {
        Gn.deprecatedWarning1 || (Gn.deprecatedWarning1 = !0,
            console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.")),
            this.setAnimation(e, n, s)
    }
    addAnimationByName(e, n, s, r) {
        Gn.deprecatedWarning2 || (Gn.deprecatedWarning2 = !0,
            console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.")),
            this.addAnimation(e, n, s, r)
    }
    hasAnimation(e) {
        return this.data.skeletonData.findAnimation(e) !== null
    }
    hasAnimationByName(e) {
        return Gn.deprecatedWarning3 || (Gn.deprecatedWarning3 = !0,
            console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.")),
            this.hasAnimation(e)
    }
}
    ;
let Zi = Gn;
Zi.emptyAnimation = new Un("<empty>", [], 0);
Zi.SUBSEQUENT = 0;
Zi.FIRST = 1;
Zi.HOLD = 2;
Zi.HOLD_MIX = 3;
Zi.deprecatedWarning1 = !1;
Zi.deprecatedWarning2 = !1;
Zi.deprecatedWarning3 = !1;
const ao = class {
    constructor() {
        this.mixBlend = O.replace,
            this.timelineMode = new Array,
            this.timelineHoldMix = new Array,
            this.timelinesRotation = new Array
    }
    reset() {
        this.next = null,
            this.mixingFrom = null,
            this.mixingTo = null,
            this.animation = null,
            this.listener = null,
            this.timelineMode.length = 0,
            this.timelineHoldMix.length = 0,
            this.timelinesRotation.length = 0
    }
    getAnimationTime() {
        if (this.loop) {
            const e = this.animationEnd - this.animationStart;
            return e == 0 ? this.animationStart : this.trackTime % e + this.animationStart
        }
        return Math.min(this.trackTime + this.animationStart, this.animationEnd)
    }
    setAnimationLast(e) {
        this.animationLast = e,
            this.nextAnimationLast = e
    }
    isComplete() {
        return this.trackTime >= this.animationEnd - this.animationStart
    }
    resetRotationDirections() {
        this.timelinesRotation.length = 0
    }
    get time() {
        return ao.deprecatedWarning1 || (ao.deprecatedWarning1 = !0,
            console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),
            this.trackTime
    }
    set time(e) {
        ao.deprecatedWarning1 || (ao.deprecatedWarning1 = !0,
            console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),
            this.trackTime = e
    }
    get endTime() {
        return ao.deprecatedWarning2 || (ao.deprecatedWarning2 = !0,
            console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),
            this.trackTime
    }
    set endTime(e) {
        ao.deprecatedWarning2 || (ao.deprecatedWarning2 = !0,
            console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),
            this.trackTime = e
    }
    loopsCount() {
        return Math.floor(this.trackTime / this.trackEnd)
    }
}
    ;
let G_ = ao;
G_.deprecatedWarning1 = !1;
G_.deprecatedWarning2 = !1;
const jb = class {
    constructor(t) {
        this.objects = [],
            this.drainDisabled = !1,
            this.animState = t
    }
    start(t) {
        this.objects.push(Us.start),
            this.objects.push(t),
            this.animState.animationsChanged = !0
    }
    interrupt(t) {
        this.objects.push(Us.interrupt),
            this.objects.push(t)
    }
    end(t) {
        this.objects.push(Us.end),
            this.objects.push(t),
            this.animState.animationsChanged = !0
    }
    dispose(t) {
        this.objects.push(Us.dispose),
            this.objects.push(t)
    }
    complete(t) {
        this.objects.push(Us.complete),
            this.objects.push(t)
    }
    event(t, e) {
        this.objects.push(Us.event),
            this.objects.push(t),
            this.objects.push(e)
    }
    deprecateStuff() {
        return jb.deprecatedWarning1 || (jb.deprecatedWarning1 = !0,
            console.warn("Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'")),
            !0
    }
    drain() {
        if (this.drainDisabled)
            return;
        this.drainDisabled = !0;
        const t = this.objects
            , e = this.animState.listeners;
        for (let n = 0; n < t.length; n += 2) {
            const s = t[n]
                , r = t[n + 1];
            switch (s) {
                case Us.start:
                    r.listener != null && r.listener.start && r.listener.start(r);
                    for (let l = 0; l < e.length; l++)
                        e[l].start && e[l].start(r);
                    r.onStart && this.deprecateStuff() && r.onStart(r.trackIndex),
                        this.animState.onStart && this.deprecateStuff() && this.deprecateStuff && this.animState.onStart(r.trackIndex);
                    break;
                case Us.interrupt:
                    r.listener != null && r.listener.interrupt && r.listener.interrupt(r);
                    for (let l = 0; l < e.length; l++)
                        e[l].interrupt && e[l].interrupt(r);
                    break;
                case Us.end:
                    r.listener != null && r.listener.end && r.listener.end(r);
                    for (let l = 0; l < e.length; l++)
                        e[l].end && e[l].end(r);
                    r.onEnd && this.deprecateStuff() && r.onEnd(r.trackIndex),
                        this.animState.onEnd && this.deprecateStuff() && this.animState.onEnd(r.trackIndex);
                case Us.dispose:
                    r.listener != null && r.listener.dispose && r.listener.dispose(r);
                    for (let l = 0; l < e.length; l++)
                        e[l].dispose && e[l].dispose(r);
                    this.animState.trackEntryPool.free(r);
                    break;
                case Us.complete:
                    r.listener != null && r.listener.complete && r.listener.complete(r);
                    for (let l = 0; l < e.length; l++)
                        e[l].complete && e[l].complete(r);
                    const i = F.toInt(r.loopsCount());
                    r.onComplete && this.deprecateStuff() && r.onComplete(r.trackIndex, i),
                        this.animState.onComplete && this.deprecateStuff() && this.animState.onComplete(r.trackIndex, i);
                    break;
                case Us.event:
                    const o = t[n++ + 2];
                    r.listener != null && r.listener.event && r.listener.event(r, o);
                    for (let l = 0; l < e.length; l++)
                        e[l].event && e[l].event(r, o);
                    r.onEvent && this.deprecateStuff() && r.onEvent(r.trackIndex, o),
                        this.animState.onEvent && this.deprecateStuff() && this.animState.onEvent(r.trackIndex, o);
                    break
            }
        }
        this.clear(),
            this.drainDisabled = !1
    }
    clear() {
        this.objects.length = 0
    }
}
    ;
let Ow = jb;
Ow.deprecatedWarning1 = !1;
var Us = (t => (t[t.start = 0] = "start",
    t[t.interrupt = 1] = "interrupt",
    t[t.end = 2] = "end",
    t[t.dispose = 3] = "dispose",
    t[t.complete = 4] = "complete",
    t[t.event = 5] = "event",
    t))(Us || {});
class xhe {
    start(e) { }
    interrupt(e) { }
    end(e) { }
    dispose(e) { }
    complete(e) { }
    event(e, n) { }
}
const zb = class {
    constructor(t) {
        if (this.animationToMixTime = {},
            this.defaultMix = 0,
            t == null)
            throw new Error("skeletonData cannot be null.");
        this.skeletonData = t
    }
    setMix(t, e, n) {
        const s = this.skeletonData.findAnimation(t);
        if (s == null)
            throw new Error(`Animation not found: ${t}`);
        const r = this.skeletonData.findAnimation(e);
        if (r == null)
            throw new Error(`Animation not found: ${e}`);
        this.setMixWith(s, r, n)
    }
    setMixByName(t, e, n) {
        zb.deprecatedWarning1 || (zb.deprecatedWarning1 = !0,
            console.warn("Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.")),
            this.setMix(t, e, n)
    }
    setMixWith(t, e, n) {
        if (t == null)
            throw new Error("from cannot be null.");
        if (e == null)
            throw new Error("to cannot be null.");
        const s = `${t.name}.${e.name}`;
        this.animationToMixTime[s] = n
    }
    getMix(t, e) {
        const n = `${t.name}.${e.name}`
            , s = this.animationToMixTime[n];
        return s === void 0 ? this.defaultMix : s
    }
}
    ;
let Nw = zb;
Nw.deprecatedWarning1 = !1;
let q5 = class {
    constructor(e) {
        this.atlas = e
    }
    newRegionAttachment(e, n, s) {
        const r = this.atlas.findRegion(s);
        if (r == null)
            throw new Error(`Region not found in atlas: ${s} (region attachment: ${n})`);
        const i = new at(n);
        return i.region = r,
            i
    }
    newMeshAttachment(e, n, s) {
        const r = this.atlas.findRegion(s);
        if (r == null)
            throw new Error(`Region not found in atlas: ${s} (mesh attachment: ${n})`);
        const i = new Pw(n);
        return i.region = r,
            i
    }
    newBoundingBoxAttachment(e, n) {
        return new F5(n)
    }
    newPathAttachment(e, n) {
        return new Ud(n)
    }
    newPointAttachment(e, n) {
        return new U5(n)
    }
    newClippingAttachment(e, n) {
        return new $5(n)
    }
}
    , qb = class {
        constructor(e, n, s) {
            if (this.matrix = new Bt,
                this.children = new Array,
                this.x = 0,
                this.y = 0,
                this.rotation = 0,
                this.scaleX = 0,
                this.scaleY = 0,
                this.shearX = 0,
                this.shearY = 0,
                this.ax = 0,
                this.ay = 0,
                this.arotation = 0,
                this.ascaleX = 0,
                this.ascaleY = 0,
                this.ashearX = 0,
                this.ashearY = 0,
                this.appliedValid = !1,
                this.sorted = !1,
                this.active = !0,
                e == null)
                throw new Error("data cannot be null.");
            if (n == null)
                throw new Error("skeleton cannot be null.");
            this.data = e,
                this.skeleton = n,
                this.parent = s,
                this.setToSetupPose()
        }
        get worldX() {
            return this.matrix.tx
        }
        get worldY() {
            return this.matrix.ty
        }
        update() {
            this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY)
        }
        updateWorldTransform() {
            this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY)
        }
        updateWorldTransformWith(e, n, s, r, i, o, l) {
            this.ax = e,
                this.ay = n,
                this.arotation = s,
                this.ascaleX = r,
                this.ascaleY = i,
                this.ashearX = o,
                this.ashearY = l,
                this.appliedValid = !0;
            const a = this.parent
                , c = this.matrix
                , u = this.skeleton.scaleX
                , h = -this.skeleton.scaleY;
            if (a == null) {
                const g = this.skeleton
                    , b = s + 90 + l;
                c.a = F.cosDeg(s + o) * r * u,
                    c.c = F.cosDeg(b) * i * u,
                    c.b = F.sinDeg(s + o) * r * h,
                    c.d = F.sinDeg(b) * i * h,
                    c.tx = e * u + g.x,
                    c.ty = n * h + g.y;
                return
            }
            let d = a.matrix.a
                , f = a.matrix.c
                , p = a.matrix.b
                , m = a.matrix.d;
            switch (c.tx = d * e + f * n + a.matrix.tx,
            c.ty = p * e + m * n + a.matrix.ty,
            this.data.transformMode) {
                case Qe.Normal:
                    {
                        const g = s + 90 + l
                            , b = F.cosDeg(s + o) * r
                            , v = F.cosDeg(g) * i
                            , _ = F.sinDeg(s + o) * r
                            , y = F.sinDeg(g) * i;
                        c.a = d * b + f * _,
                            c.c = d * v + f * y,
                            c.b = p * b + m * _,
                            c.d = p * v + m * y;
                        return
                    }
                case Qe.OnlyTranslation:
                    {
                        const g = s + 90 + l;
                        c.a = F.cosDeg(s + o) * r,
                            c.c = F.cosDeg(g) * i,
                            c.b = F.sinDeg(s + o) * r,
                            c.d = F.sinDeg(g) * i;
                        break
                    }
                case Qe.NoRotationOrReflection:
                    {
                        let g = d * d + p * p
                            , b = 0;
                        g > 1e-4 ? (g = Math.abs(d * m - f * p) / g,
                            f = p * g,
                            m = d * g,
                            b = Math.atan2(p, d) * F.radDeg) : (d = 0,
                                p = 0,
                                b = 90 - Math.atan2(m, f) * F.radDeg);
                        const v = s + o - b
                            , _ = s + l - b + 90
                            , y = F.cosDeg(v) * r
                            , x = F.cosDeg(_) * i
                            , w = F.sinDeg(v) * r
                            , S = F.sinDeg(_) * i;
                        c.a = d * y - f * w,
                            c.c = d * x - f * S,
                            c.b = p * y + m * w,
                            c.d = p * x + m * S;
                        break
                    }
                case Qe.NoScale:
                case Qe.NoScaleOrReflection:
                    {
                        const g = F.cosDeg(s)
                            , b = F.sinDeg(s);
                        let v = (d * g + f * b) / u
                            , _ = (p * g + m * b) / h
                            , y = Math.sqrt(v * v + _ * _);
                        y > 1e-5 && (y = 1 / y),
                            v *= y,
                            _ *= y,
                            y = Math.sqrt(v * v + _ * _),
                            this.data.transformMode == Qe.NoScale && d * m - f * p < 0 != (this.skeleton.scaleX < 0 != this.skeleton.scaleY > 0) && (y = -y);
                        const x = Math.PI / 2 + Math.atan2(_, v)
                            , w = Math.cos(x) * y
                            , S = Math.sin(x) * y
                            , E = F.cosDeg(o) * r
                            , C = F.cosDeg(90 + l) * i
                            , I = F.sinDeg(o) * r
                            , L = F.sinDeg(90 + l) * i;
                        c.a = v * E + w * I,
                            c.c = v * C + w * L,
                            c.b = _ * E + S * I,
                            c.d = _ * C + S * L;
                        break
                    }
            }
            c.a *= u,
                c.c *= u,
                c.b *= h,
                c.d *= h
        }
        setToSetupPose() {
            const e = this.data;
            this.x = e.x,
                this.y = e.y,
                this.rotation = e.rotation,
                this.scaleX = e.scaleX,
                this.scaleY = e.scaleY,
                this.shearX = e.shearX,
                this.shearY = e.shearY
        }
        getWorldRotationX() {
            return Math.atan2(this.matrix.b, this.matrix.a) * F.radDeg
        }
        getWorldRotationY() {
            return Math.atan2(this.matrix.d, this.matrix.c) * F.radDeg
        }
        getWorldScaleX() {
            const e = this.matrix;
            return Math.sqrt(e.a * e.a + e.c * e.c)
        }
        getWorldScaleY() {
            const e = this.matrix;
            return Math.sqrt(e.b * e.b + e.d * e.d)
        }
        updateAppliedTransform() {
            this.appliedValid = !0;
            const e = this.parent
                , n = this.matrix;
            if (e == null) {
                this.ax = n.tx,
                    this.ay = n.ty,
                    this.arotation = Math.atan2(n.b, n.a) * F.radDeg,
                    this.ascaleX = Math.sqrt(n.a * n.a + n.b * n.b),
                    this.ascaleY = Math.sqrt(n.c * n.c + n.d * n.d),
                    this.ashearX = 0,
                    this.ashearY = Math.atan2(n.a * n.c + n.b * n.d, n.a * n.d - n.b * n.c) * F.radDeg;
                return
            }
            const s = e.matrix
                , r = 1 / (s.a * s.d - s.b * s.c)
                , i = n.tx - s.tx
                , o = n.ty - s.ty;
            this.ax = i * s.d * r - o * s.c * r,
                this.ay = o * s.a * r - i * s.b * r;
            const l = r * s.d
                , a = r * s.a
                , c = r * s.c
                , u = r * s.b
                , h = l * n.a - c * n.b
                , d = l * n.c - c * n.d
                , f = a * n.b - u * n.a
                , p = a * n.d - u * n.c;
            if (this.ashearX = 0,
                this.ascaleX = Math.sqrt(h * h + f * f),
                this.ascaleX > 1e-4) {
                const m = h * p - d * f;
                this.ascaleY = m / this.ascaleX,
                    this.ashearY = Math.atan2(h * d + f * p, m) * F.radDeg,
                    this.arotation = Math.atan2(f, h) * F.radDeg
            } else
                this.ascaleX = 0,
                    this.ascaleY = Math.sqrt(d * d + p * p),
                    this.ashearY = 0,
                    this.arotation = 90 - Math.atan2(p, d) * F.radDeg
        }
        worldToLocal(e) {
            const n = this.matrix
                , s = n.a
                , r = n.c
                , i = n.b
                , o = n.d
                , l = 1 / (s * o - r * i)
                , a = e.x - n.tx
                , c = e.y - n.ty;
            return e.x = a * o * l - c * r * l,
                e.y = c * s * l - a * i * l,
                e
        }
        localToWorld(e) {
            const n = this.matrix
                , s = e.x
                , r = e.y;
            return e.x = s * n.a + r * n.c + n.tx,
                e.y = s * n.b + r * n.d + n.ty,
                e
        }
        worldToLocalRotation(e) {
            const n = F.sinDeg(e)
                , s = F.cosDeg(e)
                , r = this.matrix;
            return Math.atan2(r.a * n - r.b * s, r.d * s - r.c * n) * F.radDeg
        }
        localToWorldRotation(e) {
            const n = F.sinDeg(e)
                , s = F.cosDeg(e)
                , r = this.matrix;
            return Math.atan2(s * r.b + n * r.d, s * r.a + n * r.c) * F.radDeg
        }
        rotateWorld(e) {
            const n = this.matrix
                , s = n.a
                , r = n.c
                , i = n.b
                , o = n.d
                , l = F.cosDeg(e)
                , a = F.sinDeg(e);
            n.a = l * s - a * i,
                n.c = l * r - a * o,
                n.b = a * s + l * i,
                n.d = a * r + l * o,
                this.appliedValid = !1
        }
    }
    , K5 = class {
        constructor(e, n, s) {
            if (this.x = 0,
                this.y = 0,
                this.rotation = 0,
                this.scaleX = 1,
                this.scaleY = 1,
                this.shearX = 0,
                this.shearY = 0,
                this.transformMode = Qe.Normal,
                e < 0)
                throw new Error("index must be >= 0.");
            if (n == null)
                throw new Error("name cannot be null.");
            this.index = e,
                this.name = n,
                this.parent = s
        }
    }
    , J5 = class {
        constructor(e, n) {
            if (n == null)
                throw new Error("data cannot be null.");
            this.time = e,
                this.data = n
        }
    }
    , Z5 = class {
        constructor(e) {
            this.name = e
        }
    }
    , Q5 = class {
        constructor(e, n) {
            if (this.bendDirection = 0,
                this.compress = !1,
                this.stretch = !1,
                this.mix = 1,
                e == null)
                throw new Error("data cannot be null.");
            if (n == null)
                throw new Error("skeleton cannot be null.");
            this.data = e,
                this.mix = e.mix,
                this.bendDirection = e.bendDirection,
                this.compress = e.compress,
                this.stretch = e.stretch,
                this.bones = new Array;
            for (let s = 0; s < e.bones.length; s++)
                this.bones.push(n.findBone(e.bones[s].name));
            this.target = n.findBone(e.target.name)
        }
        getOrder() {
            return this.data.order
        }
        apply() {
            this.update()
        }
        update() {
            const e = this.target
                , n = this.bones;
            switch (n.length) {
                case 1:
                    this.apply1(n[0], e.worldX, e.worldY, this.compress, this.stretch, this.data.uniform, this.mix);
                    break;
                case 2:
                    this.apply2(n[0], n[1], e.worldX, e.worldY, this.bendDirection, this.stretch, this.mix);
                    break
            }
        }
        apply1(e, n, s, r, i, o, l) {
            e.appliedValid || e.updateAppliedTransform();
            const a = e.parent.matrix
                , c = 1 / (a.a * a.d - a.b * a.c)
                , u = n - a.tx
                , h = s - a.ty
                , d = (u * a.d - h * a.c) * c - e.ax
                , f = (h * a.a - u * a.b) * c - e.ay;
            let p = Math.atan2(f, d) * F.radDeg - e.ashearX - e.arotation;
            e.ascaleX < 0 && (p += 180),
                p > 180 ? p -= 360 : p < -180 && (p += 360);
            let m = e.ascaleX
                , g = e.ascaleY;
            if (r || i) {
                const b = e.data.length * m
                    , v = Math.sqrt(d * d + f * f);
                if (r && v < b || i && v > b && b > 1e-4) {
                    const _ = (v / b - 1) * l + 1;
                    m *= _,
                        o && (g *= _)
                }
            }
            e.updateWorldTransformWith(e.ax, e.ay, e.arotation + p * l, m, g, e.ashearX, e.ashearY)
        }
        apply2(e, n, s, r, i, o, l) {
            if (l == 0) {
                n.updateWorldTransform();
                return
            }
            e.appliedValid || e.updateAppliedTransform(),
                n.appliedValid || n.updateAppliedTransform();
            const a = e.ax
                , c = e.ay;
            let u = e.ascaleX
                , h = u
                , d = e.ascaleY
                , f = n.ascaleX;
            const p = e.matrix;
            let m = 0
                , g = 0
                , b = 0;
            u < 0 ? (u = -u,
                m = 180,
                b = -1) : (m = 0,
                    b = 1),
                d < 0 && (d = -d,
                    b = -b),
                f < 0 ? (f = -f,
                    g = 180) : g = 0;
            const v = n.ax;
            let _ = 0
                , y = 0
                , x = 0
                , w = p.a
                , S = p.c
                , E = p.b
                , C = p.d;
            const I = Math.abs(u - d) <= 1e-4;
            I ? (_ = n.ay,
                y = w * v + S * _ + p.tx,
                x = E * v + C * _ + p.ty) : (_ = 0,
                    y = w * v + p.tx,
                    x = E * v + p.ty);
            const L = e.parent.matrix;
            w = L.a,
                S = L.c,
                E = L.b,
                C = L.d;
            const k = 1 / (w * C - S * E);
            let R = s - L.tx
                , U = r - L.ty;
            const W = (R * C - U * S) * k - a
                , H = (U * w - R * E) * k - c
                , j = W * W + H * H;
            R = y - L.tx,
                U = x - L.ty;
            const z = (R * C - U * S) * k - a
                , ee = (U * w - R * E) * k - c
                , J = Math.sqrt(z * z + ee * ee);
            let Y = n.data.length * f
                , ne = 0
                , oe = 0;
            e: if (I) {
                Y *= u;
                let we = (j - J * J - Y * Y) / (2 * J * Y);
                we < -1 ? we = -1 : we > 1 && (we = 1,
                    o && J + Y > 1e-4 && (h *= (Math.sqrt(j) / (J + Y) - 1) * l + 1)),
                    oe = Math.acos(we) * i,
                    w = J + Y * we,
                    S = Y * Math.sin(oe),
                    ne = Math.atan2(H * w - W * S, W * w + H * S)
            } else {
                w = u * Y,
                    S = d * Y;
                const we = w * w
                    , K = S * S
                    , ge = Math.atan2(H, W);
                E = K * J * J + we * j - we * K;
                const he = -2 * K * J
                    , be = K - we;
                if (C = he * he - 4 * be * E,
                    C >= 0) {
                    let xe = Math.sqrt(C);
                    he < 0 && (xe = -xe),
                        xe = -(he + xe) / 2;
                    const P = xe / be
                        , B = E / xe
                        , V = Math.abs(P) < Math.abs(B) ? P : B;
                    if (V * V <= j) {
                        U = Math.sqrt(j - V * V) * i,
                            ne = ge - Math.atan2(U, V),
                            oe = Math.atan2(U / d, (V - J) / u);
                        break e
                    }
                }
                let Pe = F.PI
                    , De = J - w
                    , D = De * De
                    , M = 0
                    , X = 0
                    , ae = J + w
                    , ie = ae * ae
                    , pe = 0;
                E = -w * J / (we - K),
                    E >= -1 && E <= 1 && (E = Math.acos(E),
                        R = w * Math.cos(E) + J,
                        U = S * Math.sin(E),
                        C = R * R + U * U,
                        C < D && (Pe = E,
                            D = C,
                            De = R,
                            M = U),
                        C > ie && (X = E,
                            ie = C,
                            ae = R,
                            pe = U)),
                    j <= (D + ie) / 2 ? (ne = ge - Math.atan2(M * i, De),
                        oe = Pe * i) : (ne = ge - Math.atan2(pe * i, ae),
                            oe = X * i)
            }
            const ce = Math.atan2(_, v) * b;
            let ue = e.arotation;
            ne = (ne - ce) * F.radDeg + m - ue,
                ne > 180 ? ne -= 360 : ne < -180 && (ne += 360),
                e.updateWorldTransformWith(a, c, ue + ne * l, h, e.ascaleY, 0, 0),
                ue = n.arotation,
                oe = ((oe + ce) * F.radDeg - n.ashearX) * b + g - ue,
                oe > 180 ? oe -= 360 : oe < -180 && (oe += 360),
                n.updateWorldTransformWith(v, _, ue + oe * l, n.ascaleX, n.ascaleY, n.ashearX, n.ashearY)
        }
    }
    , eL = class {
        constructor(e) {
            this.order = 0,
                this.bones = new Array,
                this.bendDirection = 1,
                this.compress = !1,
                this.stretch = !1,
                this.uniform = !1,
                this.mix = 1,
                this.name = e
        }
    }
    , tL = class {
        constructor(e) {
            this.order = 0,
                this.bones = new Array,
                this.name = e
        }
    }
    ;
var Jr = (t => (t[t.Length = 0] = "Length",
    t[t.Fixed = 1] = "Fixed",
    t[t.Percent = 2] = "Percent",
    t))(Jr || {});
const Il = class {
    constructor(e, n) {
        if (this.position = 0,
            this.spacing = 0,
            this.rotateMix = 0,
            this.translateMix = 0,
            this.spaces = new Array,
            this.positions = new Array,
            this.world = new Array,
            this.curves = new Array,
            this.lengths = new Array,
            this.segments = new Array,
            e == null)
            throw new Error("data cannot be null.");
        if (n == null)
            throw new Error("skeleton cannot be null.");
        this.data = e,
            this.bones = new Array;
        for (let s = 0, r = e.bones.length; s < r; s++)
            this.bones.push(n.findBone(e.bones[s].name));
        this.target = n.findSlot(e.target.name),
            this.position = e.position,
            this.spacing = e.spacing,
            this.rotateMix = e.rotateMix,
            this.translateMix = e.translateMix
    }
    apply() {
        this.update()
    }
    update() {
        const e = this.target.getAttachment();
        if (!(e instanceof Ud))
            return;
        const n = this.rotateMix
            , s = this.translateMix
            , r = s > 0
            , i = n > 0;
        if (!r && !i)
            return;
        const o = this.data
            , l = o.spacingMode
            , a = l == Jr.Length
            , c = o.rotateMode
            , u = c == bn.Tangent
            , h = c == bn.ChainScale
            , d = this.bones.length
            , f = u ? d : d + 1
            , p = this.bones
            , m = Q.setArraySize(this.spaces, f);
        let g = null;
        const b = this.spacing;
        if (h || a) {
            h && (g = Q.setArraySize(this.lengths, d));
            for (let S = 0, E = f - 1; S < E;) {
                const C = p[S]
                    , I = C.data.length;
                if (I < Il.epsilon)
                    h && (g[S] = 0),
                        m[++S] = 0;
                else {
                    const L = I * C.matrix.a
                        , k = I * C.matrix.b
                        , R = Math.sqrt(L * L + k * k);
                    h && (g[S] = R),
                        m[++S] = (a ? I + b : b) * R / I
                }
            }
        } else
            for (let S = 1; S < f; S++)
                m[S] = b;
        const v = this.computeWorldPositions(e, f, u, o.positionMode == on.Percent, l == Jr.Percent);
        let _ = v[0]
            , y = v[1]
            , x = o.offsetRotation
            , w = !1;
        if (x == 0)
            w = c == bn.Chain;
        else {
            w = !1;
            const S = this.target.bone.matrix;
            x *= S.a * S.d - S.b * S.c > 0 ? F.degRad : -F.degRad
        }
        for (let S = 0, E = 3; S < d; S++,
            E += 3) {
            const C = p[S]
                , I = C.matrix;
            I.tx += (_ - I.tx) * s,
                I.ty += (y - I.ty) * s;
            const L = v[E]
                , k = v[E + 1]
                , R = L - _
                , U = k - y;
            if (h) {
                const W = g[S];
                if (W != 0) {
                    const H = (Math.sqrt(R * R + U * U) / W - 1) * n + 1;
                    I.a *= H,
                        I.b *= H
                }
            }
            if (_ = L,
                y = k,
                i) {
                const W = I.a
                    , H = I.c
                    , j = I.b
                    , z = I.d;
                let ee = 0
                    , J = 0
                    , Y = 0;
                if (u && (u ? ee = v[E - 1] : m[S + 1] == 0 ? ee = v[E + 2] : ee = Math.atan2(U, R)),
                    ee -= Math.atan2(j, W),
                    w) {
                    J = Math.cos(ee),
                        Y = Math.sin(ee);
                    const ne = C.data.length;
                    _ += (ne * (J * W - Y * j) - R) * n,
                        y += (ne * (Y * W + J * j) - U) * n
                } else
                    ee += x;
                ee > F.PI ? ee -= F.PI2 : ee < -F.PI && (ee += F.PI2),
                    ee *= n,
                    J = Math.cos(ee),
                    Y = Math.sin(ee),
                    I.a = J * W - Y * j,
                    I.c = J * H - Y * z,
                    I.b = Y * W + J * j,
                    I.d = Y * H + J * z
            }
            C.appliedValid = !1
        }
    }
    computeWorldPositions(e, n, s, r, i) {
        const o = this.target;
        let l = this.position;
        const a = this.spaces
            , c = Q.setArraySize(this.positions, n * 3 + 2);
        let u = null;
        const h = e.closed;
        let d = e.worldVerticesLength
            , f = d / 6
            , p = Il.NONE;
        if (!e.constantSpeed) {
            const ee = e.lengths;
            f -= h ? 1 : 2;
            const J = ee[f];
            if (r && (l *= J),
                i)
                for (let Y = 0; Y < n; Y++)
                    a[Y] *= J;
            u = Q.setArraySize(this.world, 8);
            for (let Y = 0, ne = 0, oe = 0; Y < n; Y++,
                ne += 3) {
                const ce = a[Y];
                l += ce;
                let ue = l;
                if (h)
                    ue %= J,
                        ue < 0 && (ue += J),
                        oe = 0;
                else if (ue < 0) {
                    p != Il.BEFORE && (p = Il.BEFORE,
                        e.computeWorldVertices(o, 2, 4, u, 0, 2)),
                        this.addBeforePosition(ue, u, 0, c, ne);
                    continue
                } else if (ue > J) {
                    p != Il.AFTER && (p = Il.AFTER,
                        e.computeWorldVertices(o, d - 6, 4, u, 0, 2)),
                        this.addAfterPosition(ue - J, u, 0, c, ne);
                    continue
                }
                for (; ; oe++) {
                    const we = ee[oe];
                    if (!(ue > we)) {
                        if (oe == 0)
                            ue /= we;
                        else {
                            const K = ee[oe - 1];
                            ue = (ue - K) / (we - K)
                        }
                        break
                    }
                }
                oe != p && (p = oe,
                    h && oe == f ? (e.computeWorldVertices(o, d - 4, 4, u, 0, 2),
                        e.computeWorldVertices(o, 0, 4, u, 4, 2)) : e.computeWorldVertices(o, oe * 6 + 2, 8, u, 0, 2)),
                    this.addCurvePosition(ue, u[0], u[1], u[2], u[3], u[4], u[5], u[6], u[7], c, ne, s || Y > 0 && ce == 0)
            }
            return c
        }
        h ? (d += 2,
            u = Q.setArraySize(this.world, d),
            e.computeWorldVertices(o, 2, d - 4, u, 0, 2),
            e.computeWorldVertices(o, 0, 2, u, d - 4, 2),
            u[d - 2] = u[0],
            u[d - 1] = u[1]) : (f--,
                d -= 4,
                u = Q.setArraySize(this.world, d),
                e.computeWorldVertices(o, 2, d, u, 0, 2));
        const m = Q.setArraySize(this.curves, f);
        let g = 0
            , b = u[0]
            , v = u[1]
            , _ = 0
            , y = 0
            , x = 0
            , w = 0
            , S = 0
            , E = 0
            , C = 0
            , I = 0
            , L = 0
            , k = 0
            , R = 0
            , U = 0
            , W = 0
            , H = 0;
        for (let ee = 0, J = 2; ee < f; ee++,
            J += 6)
            _ = u[J],
                y = u[J + 1],
                x = u[J + 2],
                w = u[J + 3],
                S = u[J + 4],
                E = u[J + 5],
                C = (b - _ * 2 + x) * .1875,
                I = (v - y * 2 + w) * .1875,
                L = ((_ - x) * 3 - b + S) * .09375,
                k = ((y - w) * 3 - v + E) * .09375,
                R = C * 2 + L,
                U = I * 2 + k,
                W = (_ - b) * .75 + C + L * .16666667,
                H = (y - v) * .75 + I + k * .16666667,
                g += Math.sqrt(W * W + H * H),
                W += R,
                H += U,
                R += L,
                U += k,
                g += Math.sqrt(W * W + H * H),
                W += R,
                H += U,
                g += Math.sqrt(W * W + H * H),
                W += R + L,
                H += U + k,
                g += Math.sqrt(W * W + H * H),
                m[ee] = g,
                b = S,
                v = E;
        if (r && (l *= g),
            i)
            for (let ee = 0; ee < n; ee++)
                a[ee] *= g;
        const j = this.segments;
        let z = 0;
        for (let ee = 0, J = 0, Y = 0, ne = 0; ee < n; ee++,
            J += 3) {
            const oe = a[ee];
            l += oe;
            let ce = l;
            if (h)
                ce %= g,
                    ce < 0 && (ce += g),
                    Y = 0;
            else if (ce < 0) {
                this.addBeforePosition(ce, u, 0, c, J);
                continue
            } else if (ce > g) {
                this.addAfterPosition(ce - g, u, d - 4, c, J);
                continue
            }
            for (; ; Y++) {
                const ue = m[Y];
                if (!(ce > ue)) {
                    if (Y == 0)
                        ce /= ue;
                    else {
                        const we = m[Y - 1];
                        ce = (ce - we) / (ue - we)
                    }
                    break
                }
            }
            if (Y != p) {
                p = Y;
                let ue = Y * 6;
                for (b = u[ue],
                    v = u[ue + 1],
                    _ = u[ue + 2],
                    y = u[ue + 3],
                    x = u[ue + 4],
                    w = u[ue + 5],
                    S = u[ue + 6],
                    E = u[ue + 7],
                    C = (b - _ * 2 + x) * .03,
                    I = (v - y * 2 + w) * .03,
                    L = ((_ - x) * 3 - b + S) * .006,
                    k = ((y - w) * 3 - v + E) * .006,
                    R = C * 2 + L,
                    U = I * 2 + k,
                    W = (_ - b) * .3 + C + L * .16666667,
                    H = (y - v) * .3 + I + k * .16666667,
                    z = Math.sqrt(W * W + H * H),
                    j[0] = z,
                    ue = 1; ue < 8; ue++)
                    W += R,
                        H += U,
                        R += L,
                        U += k,
                        z += Math.sqrt(W * W + H * H),
                        j[ue] = z;
                W += R,
                    H += U,
                    z += Math.sqrt(W * W + H * H),
                    j[8] = z,
                    W += R + L,
                    H += U + k,
                    z += Math.sqrt(W * W + H * H),
                    j[9] = z,
                    ne = 0
            }
            for (ce *= z; ; ne++) {
                const ue = j[ne];
                if (!(ce > ue)) {
                    if (ne == 0)
                        ce /= ue;
                    else {
                        const we = j[ne - 1];
                        ce = ne + (ce - we) / (ue - we)
                    }
                    break
                }
            }
            this.addCurvePosition(ce * .1, b, v, _, y, x, w, S, E, c, J, s || ee > 0 && oe == 0)
        }
        return c
    }
    addBeforePosition(e, n, s, r, i) {
        const o = n[s]
            , l = n[s + 1]
            , a = n[s + 2] - o
            , c = n[s + 3] - l
            , u = Math.atan2(c, a);
        r[i] = o + e * Math.cos(u),
            r[i + 1] = l + e * Math.sin(u),
            r[i + 2] = u
    }
    addAfterPosition(e, n, s, r, i) {
        const o = n[s + 2]
            , l = n[s + 3]
            , a = o - n[s]
            , c = l - n[s + 1]
            , u = Math.atan2(c, a);
        r[i] = o + e * Math.cos(u),
            r[i + 1] = l + e * Math.sin(u),
            r[i + 2] = u
    }
    addCurvePosition(e, n, s, r, i, o, l, a, c, u, h, d) {
        (e == 0 || isNaN(e)) && (e = 1e-4);
        const f = e * e
            , p = f * e
            , m = 1 - e
            , g = m * m
            , b = g * m
            , v = m * e
            , _ = v * 3
            , y = m * _
            , x = _ * e
            , w = n * b + r * y + o * x + a * p
            , S = s * b + i * y + l * x + c * p;
        u[h] = w,
            u[h + 1] = S,
            d && (u[h + 2] = Math.atan2(S - (s * g + i * v * 2 + l * f), w - (n * g + r * v * 2 + o * f)))
    }
    getOrder() {
        return this.data.order
    }
}
    ;
let _h = Il;
_h.NONE = -1;
_h.BEFORE = -2;
_h.AFTER = -3;
_h.epsilon = 1e-5;
let nL = class {
    constructor(e, n) {
        if (this.rotateMix = 0,
            this.translateMix = 0,
            this.scaleMix = 0,
            this.shearMix = 0,
            this.temp = new Fd,
            e == null)
            throw new Error("data cannot be null.");
        if (n == null)
            throw new Error("skeleton cannot be null.");
        this.data = e,
            this.rotateMix = e.rotateMix,
            this.translateMix = e.translateMix,
            this.scaleMix = e.scaleMix,
            this.shearMix = e.shearMix,
            this.bones = new Array;
        for (let s = 0; s < e.bones.length; s++)
            this.bones.push(n.findBone(e.bones[s].name));
        this.target = n.findBone(e.target.name)
    }
    apply() {
        this.update()
    }
    update() {
        this.data.local ? this.data.relative ? this.applyRelativeLocal() : this.applyAbsoluteLocal() : this.data.relative ? this.applyRelativeWorld() : this.applyAbsoluteWorld()
    }
    applyAbsoluteWorld() {
        const e = this.rotateMix
            , n = this.translateMix
            , s = this.scaleMix
            , r = this.shearMix
            , i = this.target
            , o = i.matrix
            , l = o.a
            , a = o.c
            , c = o.b
            , u = o.d
            , h = l * u - a * c > 0 ? F.degRad : -F.degRad
            , d = this.data.offsetRotation * h
            , f = this.data.offsetShearY * h
            , p = this.bones;
        for (let m = 0, g = p.length; m < g; m++) {
            const b = p[m];
            let v = !1;
            const _ = b.matrix;
            if (e != 0) {
                const y = _.a
                    , x = _.c
                    , w = _.b
                    , S = _.d;
                let E = Math.atan2(c, l) - Math.atan2(w, y) + d;
                E > F.PI ? E -= F.PI2 : E < -F.PI && (E += F.PI2),
                    E *= e;
                const C = Math.cos(E)
                    , I = Math.sin(E);
                _.a = C * y - I * w,
                    _.c = C * x - I * S,
                    _.b = I * y + C * w,
                    _.d = I * x + C * S,
                    v = !0
            }
            if (n != 0) {
                const y = this.temp;
                i.localToWorld(y.set(this.data.offsetX, this.data.offsetY)),
                    _.tx += (y.x - _.tx) * n,
                    _.ty += (y.y - _.ty) * n,
                    v = !0
            }
            if (s > 0) {
                let y = Math.sqrt(_.a * _.a + _.b * _.b)
                    , x = Math.sqrt(l * l + c * c);
                y > 1e-5 && (y = (y + (x - y + this.data.offsetScaleX) * s) / y),
                    _.a *= y,
                    _.b *= y,
                    y = Math.sqrt(_.c * _.c + _.d * _.d),
                    x = Math.sqrt(a * a + u * u),
                    y > 1e-5 && (y = (y + (x - y + this.data.offsetScaleY) * s) / y),
                    _.c *= y,
                    _.d *= y,
                    v = !0
            }
            if (r > 0) {
                const y = _.c
                    , x = _.d
                    , w = Math.atan2(x, y);
                let S = Math.atan2(u, a) - Math.atan2(c, l) - (w - Math.atan2(_.b, _.a));
                S > F.PI ? S -= F.PI2 : S < -F.PI && (S += F.PI2),
                    S = w + (S + f) * r;
                const E = Math.sqrt(y * y + x * x);
                _.c = Math.cos(S) * E,
                    _.d = Math.sin(S) * E,
                    v = !0
            }
            v && (b.appliedValid = !1)
        }
    }
    applyRelativeWorld() {
        const e = this.rotateMix
            , n = this.translateMix
            , s = this.scaleMix
            , r = this.shearMix
            , i = this.target
            , o = i.matrix
            , l = o.a
            , a = o.c
            , c = o.b
            , u = o.d
            , h = l * u - a * c > 0 ? F.degRad : -F.degRad
            , d = this.data.offsetRotation * h
            , f = this.data.offsetShearY * h
            , p = this.bones;
        for (let m = 0, g = p.length; m < g; m++) {
            const b = p[m];
            let v = !1;
            const _ = b.matrix;
            if (e != 0) {
                const y = _.a
                    , x = _.c
                    , w = _.b
                    , S = _.d;
                let E = Math.atan2(c, l) + d;
                E > F.PI ? E -= F.PI2 : E < -F.PI && (E += F.PI2),
                    E *= e;
                const C = Math.cos(E)
                    , I = Math.sin(E);
                _.a = C * y - I * w,
                    _.c = C * x - I * S,
                    _.b = I * y + C * w,
                    _.d = I * x + C * S,
                    v = !0
            }
            if (n != 0) {
                const y = this.temp;
                i.localToWorld(y.set(this.data.offsetX, this.data.offsetY)),
                    _.tx += y.x * n,
                    _.ty += y.y * n,
                    v = !0
            }
            if (s > 0) {
                let y = (Math.sqrt(l * l + c * c) - 1 + this.data.offsetScaleX) * s + 1;
                _.a *= y,
                    _.b *= y,
                    y = (Math.sqrt(a * a + u * u) - 1 + this.data.offsetScaleY) * s + 1,
                    _.c *= y,
                    _.d *= y,
                    v = !0
            }
            if (r > 0) {
                let y = Math.atan2(u, a) - Math.atan2(c, l);
                y > F.PI ? y -= F.PI2 : y < -F.PI && (y += F.PI2);
                const x = _.c
                    , w = _.d;
                y = Math.atan2(w, x) + (y - F.PI / 2 + f) * r;
                const S = Math.sqrt(x * x + w * w);
                _.c = Math.cos(y) * S,
                    _.d = Math.sin(y) * S,
                    v = !0
            }
            v && (b.appliedValid = !1)
        }
    }
    applyAbsoluteLocal() {
        const e = this.rotateMix
            , n = this.translateMix
            , s = this.scaleMix
            , r = this.shearMix
            , i = this.target;
        i.appliedValid || i.updateAppliedTransform();
        const o = this.bones;
        for (let l = 0, a = o.length; l < a; l++) {
            const c = o[l];
            c.appliedValid || c.updateAppliedTransform();
            let u = c.arotation;
            if (e != 0) {
                let g = i.arotation - u + this.data.offsetRotation;
                g -= (16384 - (16384.499999999996 - g / 360 | 0)) * 360,
                    u += g * e
            }
            let h = c.ax
                , d = c.ay;
            n != 0 && (h += (i.ax - h + this.data.offsetX) * n,
                d += (i.ay - d + this.data.offsetY) * n);
            let f = c.ascaleX
                , p = c.ascaleY;
            s > 0 && (f > 1e-5 && (f = (f + (i.ascaleX - f + this.data.offsetScaleX) * s) / f),
                p > 1e-5 && (p = (p + (i.ascaleY - p + this.data.offsetScaleY) * s) / p));
            const m = c.ashearY;
            if (r > 0) {
                let g = i.ashearY - m + this.data.offsetShearY;
                g -= (16384 - (16384.499999999996 - g / 360 | 0)) * 360,
                    c.shearY += g * r
            }
            c.updateWorldTransformWith(h, d, u, f, p, c.ashearX, m)
        }
    }
    applyRelativeLocal() {
        const e = this.rotateMix
            , n = this.translateMix
            , s = this.scaleMix
            , r = this.shearMix
            , i = this.target;
        i.appliedValid || i.updateAppliedTransform();
        const o = this.bones;
        for (let l = 0, a = o.length; l < a; l++) {
            const c = o[l];
            c.appliedValid || c.updateAppliedTransform();
            let u = c.arotation;
            e != 0 && (u += (i.arotation + this.data.offsetRotation) * e);
            let h = c.ax
                , d = c.ay;
            n != 0 && (h += (i.ax + this.data.offsetX) * n,
                d += (i.ay + this.data.offsetY) * n);
            let f = c.ascaleX
                , p = c.ascaleY;
            s > 0 && (f > 1e-5 && (f *= (i.ascaleX - 1 + this.data.offsetScaleX) * s + 1),
                p > 1e-5 && (p *= (i.ascaleY - 1 + this.data.offsetScaleY) * s + 1));
            let m = c.ashearY;
            r > 0 && (m += (i.ashearY + this.data.offsetShearY) * r),
                c.updateWorldTransformWith(h, d, u, f, p, c.ashearX, m)
        }
    }
    getOrder() {
        return this.data.order
    }
}
    ;
const $h = class {
    constructor(e) {
        if (this._updateCache = new Array,
            this.updateCacheReset = new Array,
            this.time = 0,
            this.scaleX = 1,
            this.scaleY = 1,
            this.x = 0,
            this.y = 0,
            e == null)
            throw new Error("data cannot be null.");
        this.data = e,
            this.bones = new Array;
        for (let n = 0; n < e.bones.length; n++) {
            const s = e.bones[n];
            let r;
            if (s.parent == null)
                r = new qb(s, this, null);
            else {
                const i = this.bones[s.parent.index];
                r = new qb(s, this, i),
                    i.children.push(r)
            }
            this.bones.push(r)
        }
        this.slots = new Array,
            this.drawOrder = new Array;
        for (let n = 0; n < e.slots.length; n++) {
            const s = e.slots[n]
                , r = this.bones[s.boneData.index]
                , i = new Lw(s, r);
            this.slots.push(i),
                this.drawOrder.push(i)
        }
        this.ikConstraints = new Array;
        for (let n = 0; n < e.ikConstraints.length; n++) {
            const s = e.ikConstraints[n];
            this.ikConstraints.push(new Q5(s, this))
        }
        this.transformConstraints = new Array;
        for (let n = 0; n < e.transformConstraints.length; n++) {
            const s = e.transformConstraints[n];
            this.transformConstraints.push(new nL(s, this))
        }
        this.pathConstraints = new Array;
        for (let n = 0; n < e.pathConstraints.length; n++) {
            const s = e.pathConstraints[n];
            this.pathConstraints.push(new _h(s, this))
        }
        this.color = new Se(1, 1, 1, 1),
            this.updateCache()
    }
    updateCache() {
        const e = this._updateCache;
        e.length = 0,
            this.updateCacheReset.length = 0;
        const n = this.bones;
        for (let u = 0, h = n.length; u < h; u++)
            n[u].sorted = !1;
        const s = this.ikConstraints
            , r = this.transformConstraints
            , i = this.pathConstraints
            , o = s.length
            , l = r.length
            , a = i.length
            , c = o + l + a;
        e: for (let u = 0; u < c; u++) {
            for (let h = 0; h < o; h++) {
                const d = s[h];
                if (d.data.order == u) {
                    this.sortIkConstraint(d);
                    continue e
                }
            }
            for (let h = 0; h < l; h++) {
                const d = r[h];
                if (d.data.order == u) {
                    this.sortTransformConstraint(d);
                    continue e
                }
            }
            for (let h = 0; h < a; h++) {
                const d = i[h];
                if (d.data.order == u) {
                    this.sortPathConstraint(d);
                    continue e
                }
            }
        }
        for (let u = 0, h = n.length; u < h; u++)
            this.sortBone(n[u])
    }
    sortIkConstraint(e) {
        const n = e.target;
        this.sortBone(n);
        const s = e.bones
            , r = s[0];
        if (this.sortBone(r),
            s.length > 1) {
            const i = s[s.length - 1];
            this._updateCache.indexOf(i) > -1 || this.updateCacheReset.push(i)
        }
        this._updateCache.push(e),
            this.sortReset(r.children),
            s[s.length - 1].sorted = !0
    }
    sortPathConstraint(e) {
        const n = e.target
            , s = n.data.index
            , r = n.bone;
        this.skin != null && this.sortPathConstraintAttachment(this.skin, s, r),
            this.data.defaultSkin != null && this.data.defaultSkin != this.skin && this.sortPathConstraintAttachment(this.data.defaultSkin, s, r);
        for (let a = 0, c = this.data.skins.length; a < c; a++)
            this.sortPathConstraintAttachment(this.data.skins[a], s, r);
        const i = n.getAttachment();
        i instanceof Ud && this.sortPathConstraintAttachmentWith(i, r);
        const o = e.bones
            , l = o.length;
        for (let a = 0; a < l; a++)
            this.sortBone(o[a]);
        this._updateCache.push(e);
        for (let a = 0; a < l; a++)
            this.sortReset(o[a].children);
        for (let a = 0; a < l; a++)
            o[a].sorted = !0
    }
    sortTransformConstraint(e) {
        this.sortBone(e.target);
        const n = e.bones
            , s = n.length;
        if (e.data.local)
            for (let r = 0; r < s; r++) {
                const i = n[r];
                this.sortBone(i.parent),
                    this._updateCache.indexOf(i) > -1 || this.updateCacheReset.push(i)
            }
        else
            for (let r = 0; r < s; r++)
                this.sortBone(n[r]);
        this._updateCache.push(e);
        for (let r = 0; r < s; r++)
            this.sortReset(n[r].children);
        for (let r = 0; r < s; r++)
            n[r].sorted = !0
    }
    sortPathConstraintAttachment(e, n, s) {
        const r = e.attachments[n];
        if (r)
            for (const i in r)
                this.sortPathConstraintAttachmentWith(r[i], s)
    }
    sortPathConstraintAttachmentWith(e, n) {
        if (!(e instanceof Ud))
            return;
        const s = e.bones;
        if (s == null)
            this.sortBone(n);
        else {
            const r = this.bones;
            let i = 0;
            for (; i < s.length;) {
                const o = s[i++];
                for (let l = i + o; i < l; i++) {
                    const a = s[i];
                    this.sortBone(r[a])
                }
            }
        }
    }
    sortBone(e) {
        if (e.sorted)
            return;
        const n = e.parent;
        n != null && this.sortBone(n),
            e.sorted = !0,
            this._updateCache.push(e)
    }
    sortReset(e) {
        for (let n = 0, s = e.length; n < s; n++) {
            const r = e[n];
            r.sorted && this.sortReset(r.children),
                r.sorted = !1
        }
    }
    updateWorldTransform() {
        const e = this.updateCacheReset;
        for (let s = 0, r = e.length; s < r; s++) {
            const i = e[s];
            i.ax = i.x,
                i.ay = i.y,
                i.arotation = i.rotation,
                i.ascaleX = i.scaleX,
                i.ascaleY = i.scaleY,
                i.ashearX = i.shearX,
                i.ashearY = i.shearY,
                i.appliedValid = !0
        }
        const n = this._updateCache;
        for (let s = 0, r = n.length; s < r; s++)
            n[s].update()
    }
    setToSetupPose() {
        this.setBonesToSetupPose(),
            this.setSlotsToSetupPose()
    }
    setBonesToSetupPose() {
        const e = this.bones;
        for (let i = 0, o = e.length; i < o; i++)
            e[i].setToSetupPose();
        const n = this.ikConstraints;
        for (let i = 0, o = n.length; i < o; i++) {
            const l = n[i];
            l.bendDirection = l.data.bendDirection,
                l.mix = l.data.mix
        }
        const s = this.transformConstraints;
        for (let i = 0, o = s.length; i < o; i++) {
            const l = s[i]
                , a = l.data;
            l.rotateMix = a.rotateMix,
                l.translateMix = a.translateMix,
                l.scaleMix = a.scaleMix,
                l.shearMix = a.shearMix
        }
        const r = this.pathConstraints;
        for (let i = 0, o = r.length; i < o; i++) {
            const l = r[i]
                , a = l.data;
            l.position = a.position,
                l.spacing = a.spacing,
                l.rotateMix = a.rotateMix,
                l.translateMix = a.translateMix
        }
    }
    setSlotsToSetupPose() {
        const e = this.slots;
        Q.arrayCopy(e, 0, this.drawOrder, 0, e.length);
        for (let n = 0, s = e.length; n < s; n++)
            e[n].setToSetupPose()
    }
    getRootBone() {
        return this.bones.length == 0 ? null : this.bones[0]
    }
    findBone(e) {
        if (e == null)
            throw new Error("boneName cannot be null.");
        const n = this.bones;
        for (let s = 0, r = n.length; s < r; s++) {
            const i = n[s];
            if (i.data.name == e)
                return i
        }
        return null
    }
    findBoneIndex(e) {
        if (e == null)
            throw new Error("boneName cannot be null.");
        const n = this.bones;
        for (let s = 0, r = n.length; s < r; s++)
            if (n[s].data.name == e)
                return s;
        return -1
    }
    findSlot(e) {
        if (e == null)
            throw new Error("slotName cannot be null.");
        const n = this.slots;
        for (let s = 0, r = n.length; s < r; s++) {
            const i = n[s];
            if (i.data.name == e)
                return i
        }
        return null
    }
    findSlotIndex(e) {
        if (e == null)
            throw new Error("slotName cannot be null.");
        const n = this.slots;
        for (let s = 0, r = n.length; s < r; s++)
            if (n[s].data.name == e)
                return s;
        return -1
    }
    setSkinByName(e) {
        const n = this.data.findSkin(e);
        if (n == null)
            throw new Error(`Skin not found: ${e}`);
        this.setSkin(n)
    }
    setSkin(e) {
        if (e != null)
            if (this.skin != null)
                e.attachAll(this, this.skin);
            else {
                const n = this.slots;
                for (let s = 0, r = n.length; s < r; s++) {
                    const i = n[s]
                        , o = i.data.attachmentName;
                    if (o != null) {
                        const l = e.getAttachment(s, o);
                        l != null && i.setAttachment(l)
                    }
                }
            }
        this.skin = e
    }
    getAttachmentByName(e, n) {
        return this.getAttachment(this.data.findSlotIndex(e), n)
    }
    getAttachment(e, n) {
        if (n == null)
            throw new Error("attachmentName cannot be null.");
        if (this.skin != null) {
            const s = this.skin.getAttachment(e, n);
            if (s != null)
                return s
        }
        return this.data.defaultSkin != null ? this.data.defaultSkin.getAttachment(e, n) : null
    }
    setAttachment(e, n) {
        if (e == null)
            throw new Error("slotName cannot be null.");
        const s = this.slots;
        for (let r = 0, i = s.length; r < i; r++) {
            const o = s[r];
            if (o.data.name == e) {
                let l = null;
                if (n != null && (l = this.getAttachment(r, n),
                    l == null))
                    throw new Error(`Attachment not found: ${n}, for slot: ${e}`);
                o.setAttachment(l);
                return
            }
        }
        throw new Error(`Slot not found: ${e}`)
    }
    findIkConstraint(e) {
        if (e == null)
            throw new Error("constraintName cannot be null.");
        const n = this.ikConstraints;
        for (let s = 0, r = n.length; s < r; s++) {
            const i = n[s];
            if (i.data.name == e)
                return i
        }
        return null
    }
    findTransformConstraint(e) {
        if (e == null)
            throw new Error("constraintName cannot be null.");
        const n = this.transformConstraints;
        for (let s = 0, r = n.length; s < r; s++) {
            const i = n[s];
            if (i.data.name == e)
                return i
        }
        return null
    }
    findPathConstraint(e) {
        if (e == null)
            throw new Error("constraintName cannot be null.");
        const n = this.pathConstraints;
        for (let s = 0, r = n.length; s < r; s++) {
            const i = n[s];
            if (i.data.name == e)
                return i
        }
        return null
    }
    getBounds(e, n, s) {
        if (e == null)
            throw new Error("offset cannot be null.");
        if (n == null)
            throw new Error("size cannot be null.");
        const r = this.drawOrder;
        let i = Number.POSITIVE_INFINITY
            , o = Number.POSITIVE_INFINITY
            , l = Number.NEGATIVE_INFINITY
            , a = Number.NEGATIVE_INFINITY;
        for (let c = 0, u = r.length; c < u; c++) {
            const h = r[c];
            let d = 0
                , f = null;
            const p = h.getAttachment();
            if (p instanceof at)
                d = 8,
                    f = Q.setArraySize(s, d, 0),
                    p.computeWorldVertices(h.bone, f, 0, 2);
            else if (p instanceof Pw) {
                const m = p;
                d = m.worldVerticesLength,
                    f = Q.setArraySize(s, d, 0),
                    m.computeWorldVertices(h, 0, d, f, 0, 2)
            }
            if (f != null)
                for (let m = 0, g = f.length; m < g; m += 2) {
                    const b = f[m]
                        , v = f[m + 1];
                    i = Math.min(i, b),
                        o = Math.min(o, v),
                        l = Math.max(l, b),
                        a = Math.max(a, v)
                }
        }
        e.set(i, o),
            n.set(l - i, a - o)
    }
    update(e) {
        this.time += e
    }
    get flipX() {
        return this.scaleX == -1
    }
    set flipX(e) {
        $h.deprecatedWarning1 || ($h.deprecatedWarning1 = !0,
            console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),
            this.scaleX = e ? 1 : -1
    }
    get flipY() {
        return this.scaleY == -1
    }
    set flipY(e) {
        $h.deprecatedWarning1 || ($h.deprecatedWarning1 = !0,
            console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),
            this.scaleY = e ? 1 : -1
    }
}
    ;
let Dw = $h;
Dw.deprecatedWarning1 = !1;
let whe = class extends aw {
}
    , sL = class {
        constructor() {
            this.bones = new Array,
                this.slots = new Array,
                this.skins = new Array,
                this.events = new Array,
                this.animations = new Array,
                this.ikConstraints = new Array,
                this.transformConstraints = new Array,
                this.pathConstraints = new Array,
                this.fps = 0
        }
        findBone(e) {
            if (e == null)
                throw new Error("boneName cannot be null.");
            const n = this.bones;
            for (let s = 0, r = n.length; s < r; s++) {
                const i = n[s];
                if (i.name == e)
                    return i
            }
            return null
        }
        findBoneIndex(e) {
            if (e == null)
                throw new Error("boneName cannot be null.");
            const n = this.bones;
            for (let s = 0, r = n.length; s < r; s++)
                if (n[s].name == e)
                    return s;
            return -1
        }
        findSlot(e) {
            if (e == null)
                throw new Error("slotName cannot be null.");
            const n = this.slots;
            for (let s = 0, r = n.length; s < r; s++) {
                const i = n[s];
                if (i.name == e)
                    return i
            }
            return null
        }
        findSlotIndex(e) {
            if (e == null)
                throw new Error("slotName cannot be null.");
            const n = this.slots;
            for (let s = 0, r = n.length; s < r; s++)
                if (n[s].name == e)
                    return s;
            return -1
        }
        findSkin(e) {
            if (e == null)
                throw new Error("skinName cannot be null.");
            const n = this.skins;
            for (let s = 0, r = n.length; s < r; s++) {
                const i = n[s];
                if (i.name == e)
                    return i
            }
            return null
        }
        findEvent(e) {
            if (e == null)
                throw new Error("eventDataName cannot be null.");
            const n = this.events;
            for (let s = 0, r = n.length; s < r; s++) {
                const i = n[s];
                if (i.name == e)
                    return i
            }
            return null
        }
        findAnimation(e) {
            if (e == null)
                throw new Error("animationName cannot be null.");
            const n = this.animations;
            for (let s = 0, r = n.length; s < r; s++) {
                const i = n[s];
                if (i.name == e)
                    return i
            }
            return null
        }
        findIkConstraint(e) {
            if (e == null)
                throw new Error("constraintName cannot be null.");
            const n = this.ikConstraints;
            for (let s = 0, r = n.length; s < r; s++) {
                const i = n[s];
                if (i.name == e)
                    return i
            }
            return null
        }
        findTransformConstraint(e) {
            if (e == null)
                throw new Error("constraintName cannot be null.");
            const n = this.transformConstraints;
            for (let s = 0, r = n.length; s < r; s++) {
                const i = n[s];
                if (i.name == e)
                    return i
            }
            return null
        }
        findPathConstraint(e) {
            if (e == null)
                throw new Error("constraintName cannot be null.");
            const n = this.pathConstraints;
            for (let s = 0, r = n.length; s < r; s++) {
                const i = n[s];
                if (i.name == e)
                    return i
            }
            return null
        }
        findPathConstraintIndex(e) {
            if (e == null)
                throw new Error("pathConstraintName cannot be null.");
            const n = this.pathConstraints;
            for (let s = 0, r = n.length; s < r; s++)
                if (n[s].name == e)
                    return s;
            return -1
        }
    }
    , rL = class {
        constructor(e, n, s) {
            if (this.color = new Se(1, 1, 1, 1),
                e < 0)
                throw new Error("index must be >= 0.");
            if (n == null)
                throw new Error("name cannot be null.");
            if (s == null)
                throw new Error("boneData cannot be null.");
            this.index = e,
                this.name = n,
                this.boneData = s
        }
    }
    , iL = class {
        constructor(e) {
            if (this.order = 0,
                this.bones = new Array,
                this.rotateMix = 0,
                this.translateMix = 0,
                this.scaleMix = 0,
                this.shearMix = 0,
                this.offsetRotation = 0,
                this.offsetX = 0,
                this.offsetY = 0,
                this.offsetScaleX = 0,
                this.offsetScaleY = 0,
                this.offsetShearY = 0,
                this.relative = !1,
                this.local = !1,
                e == null)
                throw new Error("name cannot be null.");
            this.name = e
        }
    }
    , oL = class {
        constructor(e) {
            if (this.attachments = new Array,
                e == null)
                throw new Error("name cannot be null.");
            this.name = e
        }
        addAttachment(e, n, s) {
            if (s == null)
                throw new Error("attachment cannot be null.");
            const r = this.attachments;
            e >= r.length && (r.length = e + 1),
                r[e] || (r[e] = {}),
                r[e][n] = s
        }
        getAttachment(e, n) {
            const s = this.attachments[e];
            return s ? s[n] : null
        }
        attachAll(e, n) {
            let s = 0;
            for (let r = 0; r < e.slots.length; r++) {
                const i = e.slots[r]
                    , o = i.getAttachment();
                if (o && s < n.attachments.length) {
                    const l = n.attachments[s];
                    for (const a in l) {
                        const c = l[a];
                        if (o == c) {
                            const u = this.getAttachment(s, a);
                            u != null && i.setAttachment(u);
                            break
                        }
                    }
                }
                s++
            }
        }
    }
    , aL = class Xc {
        constructor(e) {
            this.scale = 1,
                this.linkedMeshes = new Array,
                this.attachmentLoader = e
        }
        readSkeletonData(e) {
            const n = this.scale
                , s = new sL
                , r = typeof e == "string" ? JSON.parse(e) : e
                , i = r.skeleton;
            if (i != null && (s.hash = i.hash,
                s.version = i.spine,
                s.width = i.width,
                s.height = i.height,
                s.fps = i.fps,
                s.imagesPath = i.images),
                r.bones)
                for (let o = 0; o < r.bones.length; o++) {
                    const l = r.bones[o];
                    let a = null;
                    const c = this.getValue(l, "parent", null);
                    if (c != null && (a = s.findBone(c),
                        a == null))
                        throw new Error(`Parent bone not found: ${c}`);
                    const u = new K5(s.bones.length, l.name, a);
                    u.length = this.getValue(l, "length", 0) * n,
                        u.x = this.getValue(l, "x", 0) * n,
                        u.y = this.getValue(l, "y", 0) * n,
                        u.rotation = this.getValue(l, "rotation", 0),
                        u.scaleX = this.getValue(l, "scaleX", 1),
                        u.scaleY = this.getValue(l, "scaleY", 1),
                        u.shearX = this.getValue(l, "shearX", 0),
                        u.shearY = this.getValue(l, "shearY", 0),
                        u.transformMode = Xc.transformModeFromString(this.getValue(l, "transform", "normal")),
                        s.bones.push(u)
                }
            if (r.slots)
                for (let o = 0; o < r.slots.length; o++) {
                    const l = r.slots[o]
                        , a = l.name
                        , c = l.bone
                        , u = s.findBone(c);
                    if (u == null)
                        throw new Error(`Slot bone not found: ${c}`);
                    const h = new rL(s.slots.length, a, u)
                        , d = this.getValue(l, "color", null);
                    d != null && h.color.setFromString(d);
                    const f = this.getValue(l, "dark", null);
                    f != null && (h.darkColor = new Se(1, 1, 1, 1),
                        h.darkColor.setFromString(f)),
                        h.attachmentName = this.getValue(l, "attachment", null),
                        h.blendMode = Xc.blendModeFromString(this.getValue(l, "blend", "normal")),
                        s.slots.push(h)
                }
            if (r.ik)
                for (let o = 0; o < r.ik.length; o++) {
                    const l = r.ik[o]
                        , a = new eL(l.name);
                    a.order = this.getValue(l, "order", 0);
                    for (let u = 0; u < l.bones.length; u++) {
                        const h = l.bones[u]
                            , d = s.findBone(h);
                        if (d == null)
                            throw new Error(`IK bone not found: ${h}`);
                        a.bones.push(d)
                    }
                    const c = l.target;
                    if (a.target = s.findBone(c),
                        a.target == null)
                        throw new Error(`IK target bone not found: ${c}`);
                    a.bendDirection = this.getValue(l, "bendPositive", !0) ? 1 : -1,
                        a.mix = this.getValue(l, "mix", 1),
                        s.ikConstraints.push(a)
                }
            if (r.transform)
                for (let o = 0; o < r.transform.length; o++) {
                    const l = r.transform[o]
                        , a = new iL(l.name);
                    a.order = this.getValue(l, "order", 0);
                    for (let u = 0; u < l.bones.length; u++) {
                        const h = l.bones[u]
                            , d = s.findBone(h);
                        if (d == null)
                            throw new Error(`Transform constraint bone not found: ${h}`);
                        a.bones.push(d)
                    }
                    const c = l.target;
                    if (a.target = s.findBone(c),
                        a.target == null)
                        throw new Error(`Transform constraint target bone not found: ${c}`);
                    a.local = this.getValue(l, "local", !1),
                        a.relative = this.getValue(l, "relative", !1),
                        a.offsetRotation = this.getValue(l, "rotation", 0),
                        a.offsetX = this.getValue(l, "x", 0) * n,
                        a.offsetY = this.getValue(l, "y", 0) * n,
                        a.offsetScaleX = this.getValue(l, "scaleX", 0),
                        a.offsetScaleY = this.getValue(l, "scaleY", 0),
                        a.offsetShearY = this.getValue(l, "shearY", 0),
                        a.rotateMix = this.getValue(l, "rotateMix", 1),
                        a.translateMix = this.getValue(l, "translateMix", 1),
                        a.scaleMix = this.getValue(l, "scaleMix", 1),
                        a.shearMix = this.getValue(l, "shearMix", 1),
                        s.transformConstraints.push(a)
                }
            if (r.path)
                for (let o = 0; o < r.path.length; o++) {
                    const l = r.path[o]
                        , a = new tL(l.name);
                    a.order = this.getValue(l, "order", 0);
                    for (let u = 0; u < l.bones.length; u++) {
                        const h = l.bones[u]
                            , d = s.findBone(h);
                        if (d == null)
                            throw new Error(`Transform constraint bone not found: ${h}`);
                        a.bones.push(d)
                    }
                    const c = l.target;
                    if (a.target = s.findSlot(c),
                        a.target == null)
                        throw new Error(`Path target slot not found: ${c}`);
                    a.positionMode = Xc.positionModeFromString(this.getValue(l, "positionMode", "percent")),
                        a.spacingMode = Xc.spacingModeFromString(this.getValue(l, "spacingMode", "length")),
                        a.rotateMode = Xc.rotateModeFromString(this.getValue(l, "rotateMode", "tangent")),
                        a.offsetRotation = this.getValue(l, "rotation", 0),
                        a.position = this.getValue(l, "position", 0),
                        a.positionMode == on.Fixed && (a.position *= n),
                        a.spacing = this.getValue(l, "spacing", 0),
                        (a.spacingMode == Jr.Length || a.spacingMode == Jr.Fixed) && (a.spacing *= n),
                        a.rotateMix = this.getValue(l, "rotateMix", 1),
                        a.translateMix = this.getValue(l, "translateMix", 1),
                        s.pathConstraints.push(a)
                }
            if (r.skins)
                for (const o in r.skins) {
                    const l = r.skins[o]
                        , a = new oL(o);
                    for (const c in l) {
                        const u = s.findSlotIndex(c);
                        if (u == -1)
                            throw new Error(`Slot not found: ${c}`);
                        const h = l[c];
                        for (const d in h) {
                            const f = this.readAttachment(h[d], a, u, d, s);
                            f != null && a.addAttachment(u, d, f)
                        }
                    }
                    s.skins.push(a),
                        a.name == "default" && (s.defaultSkin = a)
                }
            for (let o = 0, l = this.linkedMeshes.length; o < l; o++) {
                const a = this.linkedMeshes[o]
                    , c = a.skin == null ? s.defaultSkin : s.findSkin(a.skin);
                if (c == null)
                    throw new Error(`Skin not found: ${a.skin}`);
                const u = c.getAttachment(a.slotIndex, a.parent);
                if (u == null)
                    throw new Error(`Parent mesh not found: ${a.parent}`);
                a.mesh.setParentMesh(u)
            }
            if (this.linkedMeshes.length = 0,
                r.events)
                for (const o in r.events) {
                    const l = r.events[o]
                        , a = new Z5(o);
                    a.intValue = this.getValue(l, "int", 0),
                        a.floatValue = this.getValue(l, "float", 0),
                        a.stringValue = this.getValue(l, "string", ""),
                        a.audioPath = this.getValue(l, "audio", null),
                        a.audioPath != null && (a.volume = this.getValue(l, "volume", 1),
                            a.balance = this.getValue(l, "balance", 0)),
                        s.events.push(a)
                }
            if (r.animations)
                for (const o in r.animations) {
                    const l = r.animations[o];
                    this.readAnimation(l, o, s)
                }
            return s
        }
        readAttachment(e, n, s, r, i) {
            const o = this.scale;
            switch (r = this.getValue(e, "name", r),
            this.getValue(e, "type", "region")) {
                case "region":
                    {
                        const a = this.getValue(e, "path", r)
                            , c = this.attachmentLoader.newRegionAttachment(n, r, a);
                        if (c == null)
                            return null;
                        c.path = a,
                            c.x = this.getValue(e, "x", 0) * o,
                            c.y = this.getValue(e, "y", 0) * o,
                            c.scaleX = this.getValue(e, "scaleX", 1),
                            c.scaleY = this.getValue(e, "scaleY", 1),
                            c.rotation = this.getValue(e, "rotation", 0),
                            c.width = e.width * o,
                            c.height = e.height * o;
                        const u = this.getValue(e, "color", null);
                        return u != null && c.color.setFromString(u),
                            c
                    }
                case "boundingbox":
                    {
                        const a = this.attachmentLoader.newBoundingBoxAttachment(n, r);
                        if (a == null)
                            return null;
                        this.readVertices(e, a, e.vertexCount << 1);
                        const c = this.getValue(e, "color", null);
                        return c != null && a.color.setFromString(c),
                            a
                    }
                case "mesh":
                case "linkedmesh":
                    {
                        const a = this.getValue(e, "path", r)
                            , c = this.attachmentLoader.newMeshAttachment(n, r, a);
                        if (c == null)
                            return null;
                        c.path = a;
                        const u = this.getValue(e, "color", null);
                        u != null && c.color.setFromString(u);
                        const h = this.getValue(e, "parent", null);
                        if (h != null)
                            return c.inheritDeform = this.getValue(e, "deform", !0),
                                this.linkedMeshes.push(new She(c, this.getValue(e, "skin", null), s, h)),
                                c;
                        const d = e.uvs;
                        return this.readVertices(e, c, d.length),
                            c.triangles = e.triangles,
                            c.regionUVs = new Float32Array(d),
                            c.hullLength = this.getValue(e, "hull", 0) * 2,
                            c
                    }
                case "path":
                    {
                        const a = this.attachmentLoader.newPathAttachment(n, r);
                        if (a == null)
                            return null;
                        a.closed = this.getValue(e, "closed", !1),
                            a.constantSpeed = this.getValue(e, "constantSpeed", !0);
                        const c = e.vertexCount;
                        this.readVertices(e, a, c << 1);
                        const u = Q.newArray(c / 3, 0);
                        for (let d = 0; d < e.lengths.length; d++)
                            u[d] = e.lengths[d] * o;
                        a.lengths = u;
                        const h = this.getValue(e, "color", null);
                        return h != null && a.color.setFromString(h),
                            a
                    }
                case "point":
                    {
                        const a = this.attachmentLoader.newPointAttachment(n, r);
                        if (a == null)
                            return null;
                        a.x = this.getValue(e, "x", 0) * o,
                            a.y = this.getValue(e, "y", 0) * o,
                            a.rotation = this.getValue(e, "rotation", 0);
                        const c = this.getValue(e, "color", null);
                        return c != null && a.color.setFromString(c),
                            a
                    }
                case "clipping":
                    {
                        const a = this.attachmentLoader.newClippingAttachment(n, r);
                        if (a == null)
                            return null;
                        const c = this.getValue(e, "end", null);
                        if (c != null) {
                            const d = i.findSlot(c);
                            if (d == null)
                                throw new Error(`Clipping end slot not found: ${c}`);
                            a.endSlot = d
                        }
                        const u = e.vertexCount;
                        this.readVertices(e, a, u << 1);
                        const h = this.getValue(e, "color", null);
                        return h != null && a.color.setFromString(h),
                            a
                    }
            }
            return null
        }
        readVertices(e, n, s) {
            const r = this.scale;
            n.worldVerticesLength = s;
            const i = e.vertices;
            if (s == i.length) {
                const a = Q.toFloatArray(i);
                if (r != 1)
                    for (let c = 0, u = i.length; c < u; c++)
                        a[c] *= r;
                n.vertices = a;
                return
            }
            const o = new Array
                , l = new Array;
            for (let a = 0, c = i.length; a < c;) {
                const u = i[a++];
                l.push(u);
                for (let h = a + u * 4; a < h; a += 4)
                    l.push(i[a]),
                        o.push(i[a + 1] * r),
                        o.push(i[a + 2] * r),
                        o.push(i[a + 3])
            }
            n.bones = l,
                n.vertices = Q.toFloatArray(o)
        }
        readAnimation(e, n, s) {
            const r = this.scale
                , i = new Array;
            let o = 0;
            if (e.slots)
                for (const a in e.slots) {
                    const c = e.slots[a]
                        , u = s.findSlotIndex(a);
                    if (u == -1)
                        throw new Error(`Slot not found: ${a}`);
                    for (const h in c) {
                        const d = c[h];
                        if (h == "attachment") {
                            const f = new og(d.length);
                            f.slotIndex = u;
                            let p = 0;
                            for (let m = 0; m < d.length; m++) {
                                const g = d[m];
                                f.setFrame(p++, g.time, g.name)
                            }
                            i.push(f),
                                o = Math.max(o, f.frames[f.getFrameCount() - 1])
                        } else if (h == "color") {
                            const f = new dr(d.length);
                            f.slotIndex = u;
                            let p = 0;
                            for (let m = 0; m < d.length; m++) {
                                const g = d[m]
                                    , b = new Se;
                                b.setFromString(g.color || "ffffffff"),
                                    f.setFrame(p, g.time, b.r, b.g, b.b, b.a),
                                    this.readCurve(g, f, p),
                                    p++
                            }
                            i.push(f),
                                o = Math.max(o, f.frames[(f.getFrameCount() - 1) * dr.ENTRIES])
                        } else if (h == "twoColor") {
                            const f = new $n(d.length);
                            f.slotIndex = u;
                            let p = 0;
                            for (let m = 0; m < d.length; m++) {
                                const g = d[m]
                                    , b = new Se
                                    , v = new Se;
                                b.setFromString(g.light),
                                    v.setFromString(g.dark),
                                    f.setFrame(p, g.time, b.r, b.g, b.b, b.a, v.r, v.g, v.b),
                                    this.readCurve(g, f, p),
                                    p++
                            }
                            i.push(f),
                                o = Math.max(o, f.frames[(f.getFrameCount() - 1) * $n.ENTRIES])
                        } else
                            throw new Error(`Invalid timeline type for a slot: ${h} (${a})`)
                    }
                }
            if (e.bones)
                for (const a in e.bones) {
                    const c = e.bones[a]
                        , u = s.findBoneIndex(a);
                    if (u == -1)
                        throw new Error(`Bone not found: ${a}`);
                    for (const h in c) {
                        const d = c[h];
                        if (h === "rotate") {
                            const f = new Ts(d.length);
                            f.boneIndex = u;
                            let p = 0;
                            for (let m = 0; m < d.length; m++) {
                                const g = d[m];
                                f.setFrame(p, g.time, g.angle),
                                    this.readCurve(g, f, p),
                                    p++
                            }
                            i.push(f),
                                o = Math.max(o, f.frames[(f.getFrameCount() - 1) * Ts.ENTRIES])
                        } else if (h === "translate" || h === "scale" || h === "shear") {
                            let f = null
                                , p = 1;
                            h === "scale" ? f = new W5(d.length) : h === "shear" ? f = new Y5(d.length) : (f = new hi(d.length),
                                p = r),
                                f.boneIndex = u;
                            let m = 0;
                            for (let g = 0; g < d.length; g++) {
                                const b = d[g]
                                    , v = this.getValue(b, "x", 0)
                                    , _ = this.getValue(b, "y", 0);
                                f.setFrame(m, b.time, v * p, _ * p),
                                    this.readCurve(b, f, m),
                                    m++
                            }
                            i.push(f),
                                o = Math.max(o, f.frames[(f.getFrameCount() - 1) * hi.ENTRIES])
                        } else
                            throw new Error(`Invalid timeline type for a bone: ${h} (${a})`)
                    }
                }
            if (e.ik)
                for (const a in e.ik) {
                    const c = e.ik[a]
                        , u = s.findIkConstraint(a)
                        , h = new fr(c.length);
                    h.ikConstraintIndex = s.ikConstraints.indexOf(u);
                    let d = 0;
                    for (let f = 0; f < c.length; f++) {
                        const p = c[f];
                        h.setFrame(d, p.time, this.getValue(p, "mix", 1), this.getValue(p, "bendPositive", !0) ? 1 : -1, this.getValue(p, "compress", !1), this.getValue(p, "stretch", !1)),
                            this.readCurve(p, h, d),
                            d++
                    }
                    i.push(h),
                        o = Math.max(o, h.frames[(h.getFrameCount() - 1) * fr.ENTRIES])
                }
            if (e.transform)
                for (const a in e.transform) {
                    const c = e.transform[a]
                        , u = s.findTransformConstraint(a)
                        , h = new pr(c.length);
                    h.transformConstraintIndex = s.transformConstraints.indexOf(u);
                    let d = 0;
                    for (let f = 0; f < c.length; f++) {
                        const p = c[f];
                        h.setFrame(d, p.time, this.getValue(p, "rotateMix", 1), this.getValue(p, "translateMix", 1), this.getValue(p, "scaleMix", 1), this.getValue(p, "shearMix", 1)),
                            this.readCurve(p, h, d),
                            d++
                    }
                    i.push(h),
                        o = Math.max(o, h.frames[(h.getFrameCount() - 1) * pr.ENTRIES])
                }
            if (e.paths)
                for (const a in e.paths) {
                    const c = e.paths[a]
                        , u = s.findPathConstraintIndex(a);
                    if (u == -1)
                        throw new Error(`Path constraint not found: ${a}`);
                    const h = s.pathConstraints[u];
                    for (const d in c) {
                        const f = c[d];
                        if (d === "position" || d === "spacing") {
                            let p = null
                                , m = 1;
                            d === "spacing" ? (p = new z5(f.length),
                                (h.spacingMode == Jr.Length || h.spacingMode == Jr.Fixed) && (m = r)) : (p = new za(f.length),
                                    h.positionMode == on.Fixed && (m = r)),
                                p.pathConstraintIndex = u;
                            let g = 0;
                            for (let b = 0; b < f.length; b++) {
                                const v = f[b];
                                p.setFrame(g, v.time, this.getValue(v, d, 0) * m),
                                    this.readCurve(v, p, g),
                                    g++
                            }
                            i.push(p),
                                o = Math.max(o, p.frames[(p.getFrameCount() - 1) * za.ENTRIES])
                        } else if (d === "mix") {
                            const p = new Ho(f.length);
                            p.pathConstraintIndex = u;
                            let m = 0;
                            for (let g = 0; g < f.length; g++) {
                                const b = f[g];
                                p.setFrame(m, b.time, this.getValue(b, "rotateMix", 1), this.getValue(b, "translateMix", 1)),
                                    this.readCurve(b, p, m),
                                    m++
                            }
                            i.push(p),
                                o = Math.max(o, p.frames[(p.getFrameCount() - 1) * Ho.ENTRIES])
                        }
                    }
                }
            if (e.deform)
                for (const a in e.deform) {
                    const c = e.deform[a]
                        , u = s.findSkin(a);
                    if (u != null)
                        for (const h in c) {
                            const d = c[h]
                                , f = s.findSlotIndex(h);
                            if (f == -1)
                                throw new Error(`Slot not found: ${d.name}`);
                            for (const p in d) {
                                const m = d[p]
                                    , g = u.getAttachment(f, p);
                                if (g == null)
                                    throw new Error(`Deform attachment not found: ${m.name}`);
                                const b = g.bones != null
                                    , v = g.vertices
                                    , _ = b ? v.length / 3 * 2 : v.length
                                    , y = new X5(m.length);
                                y.slotIndex = f,
                                    y.attachment = g;
                                let x = 0;
                                for (let w = 0; w < m.length; w++) {
                                    const S = m[w];
                                    let E;
                                    const C = this.getValue(S, "vertices", null);
                                    if (C == null)
                                        E = b ? Q.newFloatArray(_) : v;
                                    else {
                                        E = Q.newFloatArray(_);
                                        const I = this.getValue(S, "offset", 0);
                                        if (Q.arrayCopy(C, 0, E, I, C.length),
                                            r != 1)
                                            for (let L = I, k = L + C.length; L < k; L++)
                                                E[L] *= r;
                                        if (!b)
                                            for (let L = 0; L < _; L++)
                                                E[L] += v[L]
                                    }
                                    y.setFrame(x, S.time, E),
                                        this.readCurve(S, y, x),
                                        x++
                                }
                                i.push(y),
                                    o = Math.max(o, y.frames[y.getFrameCount() - 1])
                            }
                        }
                }
            let l = e.drawOrder;
            if (l == null && (l = e.draworder),
                l != null) {
                const a = new ag(l.length)
                    , c = s.slots.length;
                let u = 0;
                for (let h = 0; h < l.length; h++) {
                    const d = l[h];
                    let f = null;
                    const p = this.getValue(d, "offsets", null);
                    if (p != null) {
                        f = Q.newArray(c, -1);
                        const m = Q.newArray(c - p.length, 0);
                        let g = 0
                            , b = 0;
                        for (let v = 0; v < p.length; v++) {
                            const _ = p[v]
                                , y = s.findSlotIndex(_.slot);
                            if (y == -1)
                                throw new Error(`Slot not found: ${_.slot}`);
                            for (; g != y;)
                                m[b++] = g++;
                            f[g + _.offset] = g++
                        }
                        for (; g < c;)
                            m[b++] = g++;
                        for (let v = c - 1; v >= 0; v--)
                            f[v] == -1 && (f[v] = m[--b])
                    }
                    a.setFrame(u++, d.time, f)
                }
                i.push(a),
                    o = Math.max(o, a.frames[a.getFrameCount() - 1])
            }
            if (e.events) {
                const a = new j5(e.events.length);
                let c = 0;
                for (let u = 0; u < e.events.length; u++) {
                    const h = e.events[u]
                        , d = s.findEvent(h.name);
                    if (d == null)
                        throw new Error(`Event not found: ${h.name}`);
                    const f = new J5(Q.toSinglePrecision(h.time), d);
                    f.intValue = this.getValue(h, "int", d.intValue),
                        f.floatValue = this.getValue(h, "float", d.floatValue),
                        f.stringValue = this.getValue(h, "string", d.stringValue),
                        f.data.audioPath != null && (f.volume = this.getValue(h, "volume", 1),
                            f.balance = this.getValue(h, "balance", 0)),
                        a.setFrame(c++, f)
                }
                i.push(a),
                    o = Math.max(o, a.frames[a.getFrameCount() - 1])
            }
            if (isNaN(o))
                throw new Error("Error while parsing animation, duration is NaN");
            s.animations.push(new Un(n, i, o))
        }
        readCurve(e, n, s) {
            if (e.curve) {
                if (e.curve === "stepped")
                    n.setStepped(s);
                else if (Object.prototype.toString.call(e.curve) === "[object Array]") {
                    const r = e.curve;
                    n.setCurve(s, r[0], r[1], r[2], r[3])
                }
            }
        }
        getValue(e, n, s) {
            return e[n] !== void 0 ? e[n] : s
        }
        static blendModeFromString(e) {
            if (e = e.toLowerCase(),
                e == "normal")
                return Oe.NORMAL;
            if (e == "additive")
                return Oe.ADD;
            if (e == "multiply")
                return Oe.MULTIPLY;
            if (e == "screen")
                return Oe.SCREEN;
            throw new Error(`Unknown blend mode: ${e}`)
        }
        static positionModeFromString(e) {
            if (e = e.toLowerCase(),
                e == "fixed")
                return on.Fixed;
            if (e == "percent")
                return on.Percent;
            throw new Error(`Unknown position mode: ${e}`)
        }
        static spacingModeFromString(e) {
            if (e = e.toLowerCase(),
                e == "length")
                return Jr.Length;
            if (e == "fixed")
                return Jr.Fixed;
            if (e == "percent")
                return Jr.Percent;
            throw new Error(`Unknown position mode: ${e}`)
        }
        static rotateModeFromString(e) {
            if (e = e.toLowerCase(),
                e == "tangent")
                return bn.Tangent;
            if (e == "chain")
                return bn.Chain;
            if (e == "chainscale")
                return bn.ChainScale;
            throw new Error(`Unknown rotate mode: ${e}`)
        }
        static transformModeFromString(e) {
            if (e = e.toLowerCase(),
                e == "normal")
                return Qe.Normal;
            if (e == "onlytranslation")
                return Qe.OnlyTranslation;
            if (e == "norotationorreflection")
                return Qe.NoRotationOrReflection;
            if (e == "noscale")
                return Qe.NoScale;
            if (e == "noscaleorreflection")
                return Qe.NoScaleOrReflection;
            throw new Error(`Unknown transform mode: ${e}`)
        }
    }
    , She = class {
        constructor(e, n, s, r) {
            this.mesh = e,
                this.skin = n,
                this.slotIndex = s,
                this.parent = r
        }
    }
    , Ehe = class extends ph {
        createSkeleton(e) {
            this.skeleton = new Dw(e),
                this.skeleton.updateWorldTransform(),
                this.stateData = new Nw(e),
                this.state = new Zi(this.stateData)
        }
    }
    ;
const The = Object.freeze(Object.defineProperty({
    __proto__: null,
    Animation: Un,
    AnimationState: Zi,
    AnimationStateAdapter2: xhe,
    AnimationStateData: Nw,
    AtlasAttachmentLoader: q5,
    Attachment: Mw,
    AttachmentTimeline: og,
    Bone: qb,
    BoneData: K5,
    BoundingBoxAttachment: F5,
    ClippingAttachment: $5,
    ColorTimeline: dr,
    CurveTimeline: Js,
    DeformTimeline: X5,
    DrawOrderTimeline: ag,
    Event: J5,
    EventData: Z5,
    EventQueue: Ow,
    EventTimeline: j5,
    EventType: Us,
    IkConstraint: Q5,
    IkConstraintData: eL,
    IkConstraintTimeline: fr,
    JitterEffect: vhe,
    MeshAttachment: Pw,
    PathAttachment: Ud,
    PathConstraint: _h,
    PathConstraintData: tL,
    PathConstraintMixTimeline: Ho,
    PathConstraintPositionTimeline: za,
    PathConstraintSpacingTimeline: z5,
    PointAttachment: U5,
    RegionAttachment: at,
    RotateTimeline: Ts,
    ScaleTimeline: W5,
    ShearTimeline: Y5,
    Skeleton: Dw,
    SkeletonBounds: whe,
    SkeletonData: sL,
    SkeletonJson: aL,
    Skin: oL,
    Slot: Lw,
    SlotData: rL,
    SpacingMode: Jr,
    Spine: Ehe,
    SwirlEffect: G5,
    TimelineType: H5,
    TrackEntry: G_,
    TransformConstraint: nL,
    TransformConstraintData: iL,
    TransformConstraintTimeline: pr,
    TranslateTimeline: hi,
    TwoColorTimeline: $n,
    VertexAttachment: ul
}, Symbol.toStringTag, {
    value: "Module"
}));
class Bw {
    constructor(e) {
        if (!e)
            throw new Error("name cannot be null.");
        this.name = e
    }
}
const lL = class extends Bw {
    constructor(t) {
        super(t),
            this.id = lL.nextID++,
            this.bones = null,
            this.vertices = [],
            this.worldVerticesLength = 0,
            this.timelineAttachment = this
    }
    computeWorldVerticesOld(t, e) {
        this.computeWorldVertices(t, 0, this.worldVerticesLength, e, 0, 2)
    }
    computeWorldVertices(t, e, n, s, r, i) {
        n = r + (n >> 1) * i;
        const o = t.bone.skeleton
            , l = t.deform;
        let a = this.vertices;
        const c = this.bones;
        if (!c) {
            l.length > 0 && (a = l);
            const f = t.bone.matrix
                , p = f.tx
                , m = f.ty
                , g = f.a
                , b = f.c
                , v = f.b
                , _ = f.d;
            for (let y = e, x = r; x < n; y += 2,
                x += i) {
                const w = a[y]
                    , S = a[y + 1];
                s[x] = w * g + S * b + p,
                    s[x + 1] = w * v + S * _ + m
            }
            return
        }
        let u = 0
            , h = 0;
        for (let f = 0; f < e; f += 2) {
            const p = c[u];
            u += p + 1,
                h += p
        }
        const d = o.bones;
        if (l.length == 0)
            for (let f = r, p = h * 3; f < n; f += i) {
                let m = 0
                    , g = 0
                    , b = c[u++];
                for (b += u; u < b; u++,
                    p += 3) {
                    const v = d[c[u]].matrix
                        , _ = a[p]
                        , y = a[p + 1]
                        , x = a[p + 2];
                    m += (_ * v.a + y * v.c + v.tx) * x,
                        g += (_ * v.b + y * v.d + v.ty) * x
                }
                s[f] = m,
                    s[f + 1] = g
            }
        else {
            const f = l;
            for (let p = r, m = h * 3, g = h << 1; p < n; p += i) {
                let b = 0
                    , v = 0
                    , _ = c[u++];
                for (_ += u; u < _; u++,
                    m += 3,
                    g += 2) {
                    const y = d[c[u]].matrix
                        , x = a[m] + f[g]
                        , w = a[m + 1] + f[g + 1]
                        , S = a[m + 2];
                    b += (x * y.a + w * y.c + y.tx) * S,
                        v += (x * y.b + w * y.d + y.ty) * S
                }
                s[p] = b,
                    s[p + 1] = v
            }
        }
    }
    copyTo(t) {
        this.bones ? (t.bones = new Array(this.bones.length),
            Q.arrayCopy(this.bones, 0, t.bones, 0, this.bones.length)) : t.bones = null,
            this.vertices && (t.vertices = Q.newFloatArray(this.vertices.length),
                Q.arrayCopy(this.vertices, 0, t.vertices, 0, this.vertices.length)),
            t.worldVerticesLength = this.worldVerticesLength,
            t.timelineAttachment = this.timelineAttachment
    }
}
    ;
let di = lL;
di.nextID = 0;
class H_ extends di {
    constructor(e) {
        super(e),
            this.type = ut.BoundingBox,
            this.color = new Se(1, 1, 1, 1)
    }
    copy() {
        const e = new H_(this.name);
        return this.copyTo(e),
            e.color.setFromColor(this.color),
            e
    }
}
class W_ extends di {
    constructor(e) {
        super(e),
            this.type = ut.Clipping,
            this.endSlot = null,
            this.color = new Se(.2275, .2275, .8078, 1)
    }
    copy() {
        const e = new W_(this.name);
        return this.copyTo(e),
            e.endSlot = this.endSlot,
            e.color.setFromColor(this.color),
            e
    }
}
class uc extends di {
    constructor(e, n) {
        super(e),
            this.type = ut.Mesh,
            this.region = null,
            this.triangles = [],
            this.color = new Se(1, 1, 1, 1),
            this.width = 0,
            this.height = 0,
            this.hullLength = 0,
            this.edges = [],
            this.parentMesh = null,
            this.sequence = null,
            this.tempColor = new Se(0, 0, 0, 0),
            this.path = n
    }
    getParentMesh() {
        return this.parentMesh
    }
    setParentMesh(e) {
        this.parentMesh = e,
            e && (this.bones = e.bones,
                this.vertices = e.vertices,
                this.worldVerticesLength = e.worldVerticesLength,
                this.regionUVs = e.regionUVs,
                this.triangles = e.triangles,
                this.hullLength = e.hullLength,
                this.worldVerticesLength = e.worldVerticesLength)
    }
    copy() {
        if (this.parentMesh)
            return this.newLinkedMesh();
        const e = new uc(this.name, this.path);
        return e.region = this.region,
            e.color.setFromColor(this.color),
            this.copyTo(e),
            e.regionUVs = new Float32Array(this.regionUVs.length),
            Q.arrayCopy(this.regionUVs, 0, e.regionUVs, 0, this.regionUVs.length),
            e.triangles = new Array(this.triangles.length),
            Q.arrayCopy(this.triangles, 0, e.triangles, 0, this.triangles.length),
            e.hullLength = this.hullLength,
            e.sequence = this.sequence != null ? this.sequence.copy() : null,
            this.edges && (e.edges = new Array(this.edges.length),
                Q.arrayCopy(this.edges, 0, e.edges, 0, this.edges.length)),
            e.width = this.width,
            e.height = this.height,
            e
    }
    computeWorldVertices(e, n, s, r, i, o) {
        this.sequence != null && this.sequence.apply(e, this),
            super.computeWorldVertices(e, n, s, r, i, o)
    }
    newLinkedMesh() {
        const e = new uc(this.name, this.path);
        return e.region = this.region,
            e.color.setFromColor(this.color),
            e.timelineAttachment = this.timelineAttachment,
            e.setParentMesh(this.parentMesh ? this.parentMesh : this),
            e
    }
}
class hc extends di {
    constructor(e) {
        super(e),
            this.type = ut.Path,
            this.lengths = [],
            this.closed = !1,
            this.constantSpeed = !1,
            this.color = new Se(1, 1, 1, 1)
    }
    copy() {
        const e = new hc(this.name);
        return this.copyTo(e),
            e.lengths = new Array(this.lengths.length),
            Q.arrayCopy(this.lengths, 0, e.lengths, 0, this.lengths.length),
            e.closed = closed,
            e.constantSpeed = this.constantSpeed,
            e.color.setFromColor(this.color),
            e
    }
}
class Y_ extends di {
    constructor(e) {
        super(e),
            this.type = ut.Point,
            this.x = 0,
            this.y = 0,
            this.rotation = 0,
            this.color = new Se(.38, .94, 0, 1)
    }
    computeWorldPosition(e, n) {
        const s = e.matrix;
        return n.x = this.x * s.a + this.y * s.c + e.worldX,
            n.y = this.x * s.b + this.y * s.d + e.worldY,
            n
    }
    computeWorldRotation(e) {
        const n = e.matrix
            , s = F.cosDeg(this.rotation)
            , r = F.sinDeg(this.rotation)
            , i = s * n.a + r * n.c
            , o = s * n.b + r * n.d;
        return Math.atan2(o, i) * F.radDeg
    }
    copy() {
        const e = new Y_(this.name);
        return e.x = this.x,
            e.y = this.y,
            e.rotation = this.rotation,
            e.color.setFromColor(this.color),
            e
    }
}
const cL = class extends Bw {
    constructor(t, e) {
        super(t),
            this.type = ut.Region,
            this.x = 0,
            this.y = 0,
            this.scaleX = 1,
            this.scaleY = 1,
            this.rotation = 0,
            this.width = 0,
            this.height = 0,
            this.color = new Se(1, 1, 1, 1),
            this.rendererObject = null,
            this.region = null,
            this.sequence = null,
            this.offset = Q.newFloatArray(8),
            this.uvs = Q.newFloatArray(8),
            this.tempColor = new Se(1, 1, 1, 1),
            this.path = e
    }
    updateRegion() {
        if (!this.region)
            throw new Error("Region not set.");
        const t = this.region
            , e = this.width / this.region.originalWidth * this.scaleX
            , n = this.height / this.region.originalHeight * this.scaleY
            , s = -this.width / 2 * this.scaleX + this.region.offsetX * e
            , r = -this.height / 2 * this.scaleY + this.region.offsetY * n
            , i = s + this.region.width * e
            , o = r + this.region.height * n
            , l = this.rotation * Math.PI / 180
            , a = Math.cos(l)
            , c = Math.sin(l)
            , u = this.x
            , h = this.y
            , d = s * a + u
            , f = s * c
            , p = r * a + h
            , m = r * c
            , g = i * a + u
            , b = i * c
            , v = o * a + h
            , _ = o * c
            , y = this.offset;
        y[0] = d - m,
            y[1] = p + f,
            y[2] = d - _,
            y[3] = v + f,
            y[4] = g - _,
            y[5] = v + b,
            y[6] = g - m,
            y[7] = p + b;
        const x = this.uvs;
        t.degrees == 90 ? (x[2] = t.u,
            x[3] = t.v2,
            x[4] = t.u,
            x[5] = t.v,
            x[6] = t.u2,
            x[7] = t.v,
            x[0] = t.u2,
            x[1] = t.v2) : (x[0] = t.u,
                x[1] = t.v2,
                x[2] = t.u,
                x[3] = t.v,
                x[4] = t.u2,
                x[5] = t.v,
                x[6] = t.u2,
                x[7] = t.v2)
    }
    computeWorldVertices(t, e, n, s) {
        this.sequence != null && this.sequence.apply(t, this);
        const r = t.bone
            , i = this.offset
            , o = r.matrix
            , l = o.tx
            , a = o.ty
            , c = o.a
            , u = o.c
            , h = o.b
            , d = o.d;
        let f = 0
            , p = 0;
        f = i[0],
            p = i[1],
            e[n] = f * c + p * u + l,
            e[n + 1] = f * h + p * d + a,
            n += s,
            f = i[2],
            p = i[3],
            e[n] = f * c + p * u + l,
            e[n + 1] = f * h + p * d + a,
            n += s,
            f = i[4],
            p = i[5],
            e[n] = f * c + p * u + l,
            e[n + 1] = f * h + p * d + a,
            n += s,
            f = i[6],
            p = i[7],
            e[n] = f * c + p * u + l,
            e[n + 1] = f * h + p * d + a
    }
    copy() {
        const t = new cL(this.name, this.path);
        return t.region = this.region,
            t.rendererObject = this.rendererObject,
            t.x = this.x,
            t.y = this.y,
            t.scaleX = this.scaleX,
            t.scaleY = this.scaleY,
            t.rotation = this.rotation,
            t.width = this.width,
            t.height = this.height,
            Q.arrayCopy(this.uvs, 0, t.uvs, 0, 8),
            Q.arrayCopy(this.offset, 0, t.offset, 0, 8),
            t.color.setFromColor(this.color),
            t.sequence = this.sequence != null ? this.sequence.copy() : null,
            t
    }
}
    ;
let Et = cL;
Et.X1 = 0;
Et.Y1 = 1;
Et.C1R = 2;
Et.C1G = 3;
Et.C1B = 4;
Et.C1A = 5;
Et.U1 = 6;
Et.V1 = 7;
Et.X2 = 8;
Et.Y2 = 9;
Et.C2R = 10;
Et.C2G = 11;
Et.C2B = 12;
Et.C2A = 13;
Et.U2 = 14;
Et.V2 = 15;
Et.X3 = 16;
Et.Y3 = 17;
Et.C3R = 18;
Et.C3G = 19;
Et.C3B = 20;
Et.C3A = 21;
Et.U3 = 22;
Et.V3 = 23;
Et.X4 = 24;
Et.Y4 = 25;
Et.C4R = 26;
Et.C4G = 27;
Et.C4B = 28;
Et.C4A = 29;
Et.U4 = 30;
Et.V4 = 31;
const nm = class {
    constructor(t) {
        this.id = nm.nextID(),
            this.start = 0,
            this.digits = 0,
            this.setupIndex = 0,
            this.regions = new Array(t)
    }
    copy() {
        const t = new nm(this.regions.length);
        return Q.arrayCopy(this.regions, 0, t.regions, 0, this.regions.length),
            t.start = this.start,
            t.digits = this.digits,
            t.setupIndex = this.setupIndex,
            t
    }
    apply(t, e) {
        let n = t.sequenceIndex;
        n == -1 && (n = this.setupIndex),
            n >= this.regions.length && (n = this.regions.length - 1);
        const s = this.regions[n];
        e.region != s && (e.region = s)
    }
    getPath(t, e) {
        let n = t;
        const s = (this.start + e).toString();
        for (let r = this.digits - s.length; r > 0; r--)
            n += "0";
        return n += s,
            n
    }
    static nextID() {
        return nm._nextID++
    }
}
    ;
let X_ = nm;
X_._nextID = 0;
var Mi = (t => (t[t.hold = 0] = "hold",
    t[t.once = 1] = "once",
    t[t.loop = 2] = "loop",
    t[t.pingpong = 3] = "pingpong",
    t[t.onceReverse = 4] = "onceReverse",
    t[t.loopReverse = 5] = "loopReverse",
    t[t.pingpongReverse = 6] = "pingpongReverse",
    t))(Mi || {});
const Fw = [0, 1, 2, 3, 4, 5, 6];
class j_ {
    constructor(e, n, s) {
        if (this.timelines = [],
            this.timelineIds = new c5,
            !e)
            throw new Error("name cannot be null.");
        this.name = e,
            this.setTimelines(n),
            this.duration = s
    }
    setTimelines(e) {
        if (!e)
            throw new Error("timelines cannot be null.");
        this.timelines = e,
            this.timelineIds.clear();
        for (let n = 0; n < e.length; n++)
            this.timelineIds.addAll(e[n].getPropertyIds())
    }
    hasTimeline(e) {
        for (let n = 0; n < e.length; n++)
            if (this.timelineIds.contains(e[n]))
                return !0;
        return !1
    }
    apply(e, n, s, r, i, o, l, a) {
        if (!e)
            throw new Error("skeleton cannot be null.");
        r && this.duration != 0 && (s %= this.duration,
            n > 0 && (n %= this.duration));
        const c = this.timelines;
        for (let u = 0, h = c.length; u < h; u++)
            c[u].apply(e, n, s, i, o, l, a)
    }
}
const Mt = {
    rotate: 0,
    x: 1,
    y: 2,
    scaleX: 3,
    scaleY: 4,
    shearX: 5,
    shearY: 6,
    rgb: 7,
    alpha: 8,
    rgb2: 9,
    attachment: 10,
    deform: 11,
    event: 12,
    drawOrder: 13,
    ikConstraint: 14,
    transformConstraint: 15,
    pathConstraintPosition: 16,
    pathConstraintSpacing: 17,
    pathConstraintMix: 18,
    sequence: 19
};
class fn {
    constructor(e, n) {
        this.propertyIds = n,
            this.frames = Q.newFloatArray(e * this.getFrameEntries())
    }
    getPropertyIds() {
        return this.propertyIds
    }
    getFrameEntries() {
        return 1
    }
    getFrameCount() {
        return this.frames.length / this.getFrameEntries()
    }
    getDuration() {
        return this.frames[this.frames.length - this.getFrameEntries()]
    }
    static search1(e, n) {
        const s = e.length;
        for (let r = 1; r < s; r++)
            if (e[r] > n)
                return r - 1;
        return s - 1
    }
    static search(e, n, s) {
        const r = e.length;
        for (let i = s; i < r; i += s)
            if (e[i] > n)
                return i - s;
        return r - s
    }
}
class gi extends fn {
    constructor(e, n, s) {
        super(e, s),
            this.curves = Q.newFloatArray(e + n * 18),
            this.curves[e - 1] = 1
    }
    setLinear(e) {
        this.curves[e] = 0
    }
    setStepped(e) {
        this.curves[e] = 1
    }
    shrink(e) {
        const n = this.getFrameCount() + e * 18;
        if (this.curves.length > n) {
            const s = Q.newFloatArray(n);
            Q.arrayCopy(this.curves, 0, s, 0, n),
                this.curves = s
        }
    }
    setBezier(e, n, s, r, i, o, l, a, c, u, h) {
        const d = this.curves;
        let f = this.getFrameCount() + e * 18;
        s == 0 && (d[n] = 2 + f);
        const p = (r - o * 2 + a) * .03
            , m = (i - l * 2 + c) * .03
            , g = ((o - a) * 3 - r + u) * .006
            , b = ((l - c) * 3 - i + h) * .006;
        let v = p * 2 + g
            , _ = m * 2 + b
            , y = (o - r) * .3 + p + g * .16666667
            , x = (l - i) * .3 + m + b * .16666667
            , w = r + y
            , S = i + x;
        for (let E = f + 18; f < E; f += 2)
            d[f] = w,
                d[f + 1] = S,
                y += v,
                x += _,
                v += g,
                _ += b,
                w += y,
                S += x
    }
    getBezierValue(e, n, s, r) {
        const i = this.curves;
        if (i[r] > e) {
            const c = this.frames[n]
                , u = this.frames[n + s];
            return u + (e - c) / (i[r] - c) * (i[r + 1] - u)
        }
        const o = r + 18;
        for (r += 2; r < o; r += 2)
            if (i[r] >= e) {
                const c = i[r - 2]
                    , u = i[r - 1];
                return u + (e - c) / (i[r] - c) * (i[r + 1] - u)
            }
        n += this.getFrameEntries();
        const l = i[o - 2]
            , a = i[o - 1];
        return a + (e - l) / (this.frames[n] - l) * (this.frames[n + s] - a)
    }
}
class _i extends gi {
    constructor(e, n, s) {
        super(e, n, [s])
    }
    getFrameEntries() {
        return 2
    }
    setFrame(e, n, s) {
        e <<= 1,
            this.frames[e] = n,
            this.frames[e + 1] = s
    }
    getCurveValue(e) {
        const n = this.frames;
        let s = n.length - 2;
        for (let i = 2; i <= s; i += 2)
            if (n[i] > e) {
                s = i - 2;
                break
            }
        const r = this.curves[s >> 1];
        switch (r) {
            case 0:
                const i = n[s]
                    , o = n[s + 1];
                return o + (e - i) / (n[s + 2] - i) * (n[s + 2 + 1] - o);
            case 1:
                return n[s + 1]
        }
        return this.getBezierValue(e, s, 1, r - 2)
    }
}
class z_ extends gi {
    constructor(e, n, s, r) {
        super(e, n, [s, r])
    }
    getFrameEntries() {
        return 3
    }
    setFrame(e, n, s, r) {
        e *= 3,
            this.frames[e] = n,
            this.frames[e + 1] = s,
            this.frames[e + 2] = r
    }
}
class Vd extends _i {
    constructor(e, n, s) {
        super(e, n, `${Mt.rotate}|${s}`),
            this.boneIndex = 0,
            this.boneIndex = s
    }
    apply(e, n, s, r, i, o, l) {
        const a = e.bones[this.boneIndex];
        if (!a.active)
            return;
        const c = this.frames;
        if (s < c[0]) {
            switch (o) {
                case O.setup:
                    a.rotation = a.data.rotation;
                    return;
                case O.first:
                    a.rotation += (a.data.rotation - a.rotation) * i
            }
            return
        }
        let u = this.getCurveValue(s);
        switch (o) {
            case O.setup:
                a.rotation = a.data.rotation + u * i;
                break;
            case O.first:
            case O.replace:
                u += a.data.rotation - a.rotation;
            case O.add:
                a.rotation += u * i
        }
    }
}
class $w extends z_ {
    constructor(e, n, s) {
        super(e, n, `${Mt.x}|${s}`, `${Mt.y}|${s}`),
            this.boneIndex = 0,
            this.boneIndex = s
    }
    apply(e, n, s, r, i, o, l) {
        const a = e.bones[this.boneIndex];
        if (!a.active)
            return;
        const c = this.frames;
        if (s < c[0]) {
            switch (o) {
                case O.setup:
                    a.x = a.data.x,
                        a.y = a.data.y;
                    return;
                case O.first:
                    a.x += (a.data.x - a.x) * i,
                        a.y += (a.data.y - a.y) * i
            }
            return
        }
        let u = 0
            , h = 0;
        const d = fn.search(c, s, 3)
            , f = this.curves[d / 3];
        switch (f) {
            case 0:
                const p = c[d];
                u = c[d + 1],
                    h = c[d + 2];
                const m = (s - p) / (c[d + 3] - p);
                u += (c[d + 3 + 1] - u) * m,
                    h += (c[d + 3 + 2] - h) * m;
                break;
            case 1:
                u = c[d + 1],
                    h = c[d + 2];
                break;
            default:
                u = this.getBezierValue(s, d, 1, f - 2),
                    h = this.getBezierValue(s, d, 2, f + 18 - 2)
        }
        switch (o) {
            case O.setup:
                a.x = a.data.x + u * i,
                    a.y = a.data.y + h * i;
                break;
            case O.first:
            case O.replace:
                a.x += (a.data.x + u - a.x) * i,
                    a.y += (a.data.y + h - a.y) * i;
                break;
            case O.add:
                a.x += u * i,
                    a.y += h * i
        }
    }
}
class Uw extends _i {
    constructor(e, n, s) {
        super(e, n, `${Mt.x}|${s}`),
            this.boneIndex = 0,
            this.boneIndex = s
    }
    apply(e, n, s, r, i, o, l) {
        const a = e.bones[this.boneIndex];
        if (!a.active)
            return;
        const c = this.frames;
        if (s < c[0]) {
            switch (o) {
                case O.setup:
                    a.x = a.data.x;
                    return;
                case O.first:
                    a.x += (a.data.x - a.x) * i
            }
            return
        }
        const u = this.getCurveValue(s);
        switch (o) {
            case O.setup:
                a.x = a.data.x + u * i;
                break;
            case O.first:
            case O.replace:
                a.x += (a.data.x + u - a.x) * i;
                break;
            case O.add:
                a.x += u * i
        }
    }
}
class Vw extends _i {
    constructor(e, n, s) {
        super(e, n, `${Mt.y}|${s}`),
            this.boneIndex = 0,
            this.boneIndex = s
    }
    apply(e, n, s, r, i, o, l) {
        const a = e.bones[this.boneIndex];
        if (!a.active)
            return;
        const c = this.frames;
        if (s < c[0]) {
            switch (o) {
                case O.setup:
                    a.y = a.data.y;
                    return;
                case O.first:
                    a.y += (a.data.y - a.y) * i
            }
            return
        }
        const u = this.getCurveValue(s);
        switch (o) {
            case O.setup:
                a.y = a.data.y + u * i;
                break;
            case O.first:
            case O.replace:
                a.y += (a.data.y + u - a.y) * i;
                break;
            case O.add:
                a.y += u * i
        }
    }
}
class Gw extends z_ {
    constructor(e, n, s) {
        super(e, n, `${Mt.scaleX}|${s}`, `${Mt.scaleY}|${s}`),
            this.boneIndex = 0,
            this.boneIndex = s
    }
    apply(e, n, s, r, i, o, l) {
        const a = e.bones[this.boneIndex];
        if (!a.active)
            return;
        const c = this.frames;
        if (s < c[0]) {
            switch (o) {
                case O.setup:
                    a.scaleX = a.data.scaleX,
                        a.scaleY = a.data.scaleY;
                    return;
                case O.first:
                    a.scaleX += (a.data.scaleX - a.scaleX) * i,
                        a.scaleY += (a.data.scaleY - a.scaleY) * i
            }
            return
        }
        let u, h;
        const d = fn.search(c, s, 3)
            , f = this.curves[d / 3];
        switch (f) {
            case 0:
                const p = c[d];
                u = c[d + 1],
                    h = c[d + 2];
                const m = (s - p) / (c[d + 3] - p);
                u += (c[d + 3 + 1] - u) * m,
                    h += (c[d + 3 + 2] - h) * m;
                break;
            case 1:
                u = c[d + 1],
                    h = c[d + 2];
                break;
            default:
                u = this.getBezierValue(s, d, 1, f - 2),
                    h = this.getBezierValue(s, d, 2, f + 18 - 2)
        }
        if (u *= a.data.scaleX,
            h *= a.data.scaleY,
            i == 1)
            o == O.add ? (a.scaleX += u - a.data.scaleX,
                a.scaleY += h - a.data.scaleY) : (a.scaleX = u,
                    a.scaleY = h);
        else {
            let p = 0
                , m = 0;
            if (l == ct.mixOut)
                switch (o) {
                    case O.setup:
                        p = a.data.scaleX,
                            m = a.data.scaleY,
                            a.scaleX = p + (Math.abs(u) * F.signum(p) - p) * i,
                            a.scaleY = m + (Math.abs(h) * F.signum(m) - m) * i;
                        break;
                    case O.first:
                    case O.replace:
                        p = a.scaleX,
                            m = a.scaleY,
                            a.scaleX = p + (Math.abs(u) * F.signum(p) - p) * i,
                            a.scaleY = m + (Math.abs(h) * F.signum(m) - m) * i;
                        break;
                    case O.add:
                        a.scaleX += (u - a.data.scaleX) * i,
                            a.scaleY += (h - a.data.scaleY) * i
                }
            else
                switch (o) {
                    case O.setup:
                        p = Math.abs(a.data.scaleX) * F.signum(u),
                            m = Math.abs(a.data.scaleY) * F.signum(h),
                            a.scaleX = p + (u - p) * i,
                            a.scaleY = m + (h - m) * i;
                        break;
                    case O.first:
                    case O.replace:
                        p = Math.abs(a.scaleX) * F.signum(u),
                            m = Math.abs(a.scaleY) * F.signum(h),
                            a.scaleX = p + (u - p) * i,
                            a.scaleY = m + (h - m) * i;
                        break;
                    case O.add:
                        a.scaleX += (u - a.data.scaleX) * i,
                            a.scaleY += (h - a.data.scaleY) * i
                }
        }
    }
}
class Hw extends _i {
    constructor(e, n, s) {
        super(e, n, `${Mt.scaleX}|${s}`),
            this.boneIndex = 0,
            this.boneIndex = s
    }
    apply(e, n, s, r, i, o, l) {
        const a = e.bones[this.boneIndex];
        if (!a.active)
            return;
        const c = this.frames;
        if (s < c[0]) {
            switch (o) {
                case O.setup:
                    a.scaleX = a.data.scaleX;
                    return;
                case O.first:
                    a.scaleX += (a.data.scaleX - a.scaleX) * i
            }
            return
        }
        const u = this.getCurveValue(s) * a.data.scaleX;
        if (i == 1)
            o == O.add ? a.scaleX += u - a.data.scaleX : a.scaleX = u;
        else {
            let h = 0;
            if (l == ct.mixOut)
                switch (o) {
                    case O.setup:
                        h = a.data.scaleX,
                            a.scaleX = h + (Math.abs(u) * F.signum(h) - h) * i;
                        break;
                    case O.first:
                    case O.replace:
                        h = a.scaleX,
                            a.scaleX = h + (Math.abs(u) * F.signum(h) - h) * i;
                        break;
                    case O.add:
                        a.scaleX += (u - a.data.scaleX) * i
                }
            else
                switch (o) {
                    case O.setup:
                        h = Math.abs(a.data.scaleX) * F.signum(u),
                            a.scaleX = h + (u - h) * i;
                        break;
                    case O.first:
                    case O.replace:
                        h = Math.abs(a.scaleX) * F.signum(u),
                            a.scaleX = h + (u - h) * i;
                        break;
                    case O.add:
                        a.scaleX += (u - a.data.scaleX) * i
                }
        }
    }
}
class Ww extends _i {
    constructor(e, n, s) {
        super(e, n, `${Mt.scaleY}|${s}`),
            this.boneIndex = 0,
            this.boneIndex = s
    }
    apply(e, n, s, r, i, o, l) {
        const a = e.bones[this.boneIndex];
        if (!a.active)
            return;
        const c = this.frames;
        if (s < c[0]) {
            switch (o) {
                case O.setup:
                    a.scaleY = a.data.scaleY;
                    return;
                case O.first:
                    a.scaleY += (a.data.scaleY - a.scaleY) * i
            }
            return
        }
        const u = this.getCurveValue(s) * a.data.scaleY;
        if (i == 1)
            o == O.add ? a.scaleY += u - a.data.scaleY : a.scaleY = u;
        else {
            let h = 0;
            if (l == ct.mixOut)
                switch (o) {
                    case O.setup:
                        h = a.data.scaleY,
                            a.scaleY = h + (Math.abs(u) * F.signum(h) - h) * i;
                        break;
                    case O.first:
                    case O.replace:
                        h = a.scaleY,
                            a.scaleY = h + (Math.abs(u) * F.signum(h) - h) * i;
                        break;
                    case O.add:
                        a.scaleY += (u - a.data.scaleY) * i
                }
            else
                switch (o) {
                    case O.setup:
                        h = Math.abs(a.data.scaleY) * F.signum(u),
                            a.scaleY = h + (u - h) * i;
                        break;
                    case O.first:
                    case O.replace:
                        h = Math.abs(a.scaleY) * F.signum(u),
                            a.scaleY = h + (u - h) * i;
                        break;
                    case O.add:
                        a.scaleY += (u - a.data.scaleY) * i
                }
        }
    }
}
class Yw extends z_ {
    constructor(e, n, s) {
        super(e, n, `${Mt.shearX}|${s}`, `${Mt.shearY}|${s}`),
            this.boneIndex = 0,
            this.boneIndex = s
    }
    apply(e, n, s, r, i, o, l) {
        const a = e.bones[this.boneIndex];
        if (!a.active)
            return;
        const c = this.frames;
        if (s < c[0]) {
            switch (o) {
                case O.setup:
                    a.shearX = a.data.shearX,
                        a.shearY = a.data.shearY;
                    return;
                case O.first:
                    a.shearX += (a.data.shearX - a.shearX) * i,
                        a.shearY += (a.data.shearY - a.shearY) * i
            }
            return
        }
        let u = 0
            , h = 0;
        const d = fn.search(c, s, 3)
            , f = this.curves[d / 3];
        switch (f) {
            case 0:
                const p = c[d];
                u = c[d + 1],
                    h = c[d + 2];
                const m = (s - p) / (c[d + 3] - p);
                u += (c[d + 3 + 1] - u) * m,
                    h += (c[d + 3 + 2] - h) * m;
                break;
            case 1:
                u = c[d + 1],
                    h = c[d + 2];
                break;
            default:
                u = this.getBezierValue(s, d, 1, f - 2),
                    h = this.getBezierValue(s, d, 2, f + 18 - 2)
        }
        switch (o) {
            case O.setup:
                a.shearX = a.data.shearX + u * i,
                    a.shearY = a.data.shearY + h * i;
                break;
            case O.first:
            case O.replace:
                a.shearX += (a.data.shearX + u - a.shearX) * i,
                    a.shearY += (a.data.shearY + h - a.shearY) * i;
                break;
            case O.add:
                a.shearX += u * i,
                    a.shearY += h * i
        }
    }
}
class Xw extends _i {
    constructor(e, n, s) {
        super(e, n, `${Mt.shearX}|${s}`),
            this.boneIndex = 0,
            this.boneIndex = s
    }
    apply(e, n, s, r, i, o, l) {
        const a = e.bones[this.boneIndex];
        if (!a.active)
            return;
        const c = this.frames;
        if (s < c[0]) {
            switch (o) {
                case O.setup:
                    a.shearX = a.data.shearX;
                    return;
                case O.first:
                    a.shearX += (a.data.shearX - a.shearX) * i
            }
            return
        }
        const u = this.getCurveValue(s);
        switch (o) {
            case O.setup:
                a.shearX = a.data.shearX + u * i;
                break;
            case O.first:
            case O.replace:
                a.shearX += (a.data.shearX + u - a.shearX) * i;
                break;
            case O.add:
                a.shearX += u * i
        }
    }
}
class jw extends _i {
    constructor(e, n, s) {
        super(e, n, `${Mt.shearY}|${s}`),
            this.boneIndex = 0,
            this.boneIndex = s
    }
    apply(e, n, s, r, i, o, l) {
        const a = e.bones[this.boneIndex];
        if (!a.active)
            return;
        const c = this.frames;
        if (s < c[0]) {
            switch (o) {
                case O.setup:
                    a.shearY = a.data.shearY;
                    return;
                case O.first:
                    a.shearY += (a.data.shearY - a.shearY) * i
            }
            return
        }
        const u = this.getCurveValue(s);
        switch (o) {
            case O.setup:
                a.shearY = a.data.shearY + u * i;
                break;
            case O.first:
            case O.replace:
                a.shearY += (a.data.shearY + u - a.shearY) * i;
                break;
            case O.add:
                a.shearY += u * i
        }
    }
}
class zw extends gi {
    constructor(e, n, s) {
        super(e, n, [`${Mt.rgb}|${s}`, `${Mt.alpha}|${s}`]),
            this.slotIndex = 0,
            this.slotIndex = s
    }
    getFrameEntries() {
        return 5
    }
    setFrame(e, n, s, r, i, o) {
        e *= 5,
            this.frames[e] = n,
            this.frames[e + 1] = s,
            this.frames[e + 2] = r,
            this.frames[e + 3] = i,
            this.frames[e + 4] = o
    }
    apply(e, n, s, r, i, o, l) {
        const a = e.slots[this.slotIndex];
        if (!a.bone.active)
            return;
        const c = this.frames
            , u = a.color;
        if (s < c[0]) {
            const b = a.data.color;
            switch (o) {
                case O.setup:
                    u.setFromColor(b);
                    return;
                case O.first:
                    u.add((b.r - u.r) * i, (b.g - u.g) * i, (b.b - u.b) * i, (b.a - u.a) * i)
            }
            return
        }
        let h = 0
            , d = 0
            , f = 0
            , p = 0;
        const m = fn.search(c, s, 5)
            , g = this.curves[m / 5];
        switch (g) {
            case 0:
                const b = c[m];
                h = c[m + 1],
                    d = c[m + 2],
                    f = c[m + 3],
                    p = c[m + 4];
                const v = (s - b) / (c[m + 5] - b);
                h += (c[m + 5 + 1] - h) * v,
                    d += (c[m + 5 + 2] - d) * v,
                    f += (c[m + 5 + 3] - f) * v,
                    p += (c[m + 5 + 4] - p) * v;
                break;
            case 1:
                h = c[m + 1],
                    d = c[m + 2],
                    f = c[m + 3],
                    p = c[m + 4];
                break;
            default:
                h = this.getBezierValue(s, m, 1, g - 2),
                    d = this.getBezierValue(s, m, 2, g + 18 - 2),
                    f = this.getBezierValue(s, m, 3, g + 18 * 2 - 2),
                    p = this.getBezierValue(s, m, 4, g + 18 * 3 - 2)
        }
        i == 1 ? u.set(h, d, f, p) : (o == O.setup && u.setFromColor(a.data.color),
            u.add((h - u.r) * i, (d - u.g) * i, (f - u.b) * i, (p - u.a) * i))
    }
}
class qw extends gi {
    constructor(e, n, s) {
        super(e, n, [`${Mt.rgb}|${s}`]),
            this.slotIndex = 0,
            this.slotIndex = s
    }
    getFrameEntries() {
        return 4
    }
    setFrame(e, n, s, r, i) {
        e <<= 2,
            this.frames[e] = n,
            this.frames[e + 1] = s,
            this.frames[e + 2] = r,
            this.frames[e + 3] = i
    }
    apply(e, n, s, r, i, o, l) {
        const a = e.slots[this.slotIndex];
        if (!a.bone.active)
            return;
        const c = this.frames
            , u = a.color;
        if (s < c[0]) {
            const g = a.data.color;
            switch (o) {
                case O.setup:
                    u.r = g.r,
                        u.g = g.g,
                        u.b = g.b;
                    return;
                case O.first:
                    u.r += (g.r - u.r) * i,
                        u.g += (g.g - u.g) * i,
                        u.b += (g.b - u.b) * i
            }
            return
        }
        let h = 0
            , d = 0
            , f = 0;
        const p = fn.search(c, s, 4)
            , m = this.curves[p >> 2];
        switch (m) {
            case 0:
                const g = c[p];
                h = c[p + 1],
                    d = c[p + 2],
                    f = c[p + 3];
                const b = (s - g) / (c[p + 4] - g);
                h += (c[p + 4 + 1] - h) * b,
                    d += (c[p + 4 + 2] - d) * b,
                    f += (c[p + 4 + 3] - f) * b;
                break;
            case 1:
                h = c[p + 1],
                    d = c[p + 2],
                    f = c[p + 3];
                break;
            default:
                h = this.getBezierValue(s, p, 1, m - 2),
                    d = this.getBezierValue(s, p, 2, m + 18 - 2),
                    f = this.getBezierValue(s, p, 3, m + 18 * 2 - 2)
        }
        if (i == 1)
            u.r = h,
                u.g = d,
                u.b = f;
        else {
            if (o == O.setup) {
                const g = a.data.color;
                u.r = g.r,
                    u.g = g.g,
                    u.b = g.b
            }
            u.r += (h - u.r) * i,
                u.g += (d - u.g) * i,
                u.b += (f - u.b) * i
        }
    }
}
class Kw extends _i {
    constructor(e, n, s) {
        super(e, n, `${Mt.alpha}|${s}`),
            this.slotIndex = 0,
            this.slotIndex = s
    }
    apply(e, n, s, r, i, o, l) {
        const a = e.slots[this.slotIndex];
        if (!a.bone.active)
            return;
        const c = a.color;
        if (s < this.frames[0]) {
            const h = a.data.color;
            switch (o) {
                case O.setup:
                    c.a = h.a;
                    return;
                case O.first:
                    c.a += (h.a - c.a) * i
            }
            return
        }
        const u = this.getCurveValue(s);
        i == 1 ? c.a = u : (o == O.setup && (c.a = a.data.color.a),
            c.a += (u - c.a) * i)
    }
}
class Jw extends gi {
    constructor(e, n, s) {
        super(e, n, [`${Mt.rgb}|${s}`, `${Mt.alpha}|${s}`, `${Mt.rgb2}|${s}`]),
            this.slotIndex = 0,
            this.slotIndex = s
    }
    getFrameEntries() {
        return 8
    }
    setFrame(e, n, s, r, i, o, l, a, c) {
        e <<= 3,
            this.frames[e] = n,
            this.frames[e + 1] = s,
            this.frames[e + 2] = r,
            this.frames[e + 3] = i,
            this.frames[e + 4] = o,
            this.frames[e + 5] = l,
            this.frames[e + 6] = a,
            this.frames[e + 7] = c
    }
    apply(e, n, s, r, i, o, l) {
        const a = e.slots[this.slotIndex];
        if (!a.bone.active)
            return;
        const c = this.frames
            , u = a.color
            , h = a.darkColor;
        if (s < c[0]) {
            const x = a.data.color
                , w = a.data.darkColor;
            switch (o) {
                case O.setup:
                    u.setFromColor(x),
                        h.r = w.r,
                        h.g = w.g,
                        h.b = w.b;
                    return;
                case O.first:
                    u.add((x.r - u.r) * i, (x.g - u.g) * i, (x.b - u.b) * i, (x.a - u.a) * i),
                        h.r += (w.r - h.r) * i,
                        h.g += (w.g - h.g) * i,
                        h.b += (w.b - h.b) * i
            }
            return
        }
        let d = 0
            , f = 0
            , p = 0
            , m = 0
            , g = 0
            , b = 0
            , v = 0;
        const _ = fn.search(c, s, 8)
            , y = this.curves[_ >> 3];
        switch (y) {
            case 0:
                const x = c[_];
                d = c[_ + 1],
                    f = c[_ + 2],
                    p = c[_ + 3],
                    m = c[_ + 4],
                    g = c[_ + 5],
                    b = c[_ + 6],
                    v = c[_ + 7];
                const w = (s - x) / (c[_ + 8] - x);
                d += (c[_ + 8 + 1] - d) * w,
                    f += (c[_ + 8 + 2] - f) * w,
                    p += (c[_ + 8 + 3] - p) * w,
                    m += (c[_ + 8 + 4] - m) * w,
                    g += (c[_ + 8 + 5] - g) * w,
                    b += (c[_ + 8 + 6] - b) * w,
                    v += (c[_ + 8 + 7] - v) * w;
                break;
            case 1:
                d = c[_ + 1],
                    f = c[_ + 2],
                    p = c[_ + 3],
                    m = c[_ + 4],
                    g = c[_ + 5],
                    b = c[_ + 6],
                    v = c[_ + 7];
                break;
            default:
                d = this.getBezierValue(s, _, 1, y - 2),
                    f = this.getBezierValue(s, _, 2, y + 18 - 2),
                    p = this.getBezierValue(s, _, 3, y + 18 * 2 - 2),
                    m = this.getBezierValue(s, _, 4, y + 18 * 3 - 2),
                    g = this.getBezierValue(s, _, 5, y + 18 * 4 - 2),
                    b = this.getBezierValue(s, _, 6, y + 18 * 5 - 2),
                    v = this.getBezierValue(s, _, 7, y + 18 * 6 - 2)
        }
        if (i == 1)
            u.set(d, f, p, m),
                h.r = g,
                h.g = b,
                h.b = v;
        else {
            if (o == O.setup) {
                u.setFromColor(a.data.color);
                const x = a.data.darkColor;
                h.r = x.r,
                    h.g = x.g,
                    h.b = x.b
            }
            u.add((d - u.r) * i, (f - u.g) * i, (p - u.b) * i, (m - u.a) * i),
                h.r += (g - h.r) * i,
                h.g += (b - h.g) * i,
                h.b += (v - h.b) * i
        }
    }
}
class Zw extends gi {
    constructor(e, n, s) {
        super(e, n, [`${Mt.rgb}|${s}`, `${Mt.rgb2}|${s}`]),
            this.slotIndex = 0,
            this.slotIndex = s
    }
    getFrameEntries() {
        return 7
    }
    setFrame(e, n, s, r, i, o, l, a) {
        e *= 7,
            this.frames[e] = n,
            this.frames[e + 1] = s,
            this.frames[e + 2] = r,
            this.frames[e + 3] = i,
            this.frames[e + 4] = o,
            this.frames[e + 5] = l,
            this.frames[e + 6] = a
    }
    apply(e, n, s, r, i, o, l) {
        const a = e.slots[this.slotIndex];
        if (!a.bone.active)
            return;
        const c = this.frames
            , u = a.color
            , h = a.darkColor;
        if (s < c[0]) {
            const y = a.data.color
                , x = a.data.darkColor;
            switch (o) {
                case O.setup:
                    u.r = y.r,
                        u.g = y.g,
                        u.b = y.b,
                        h.r = x.r,
                        h.g = x.g,
                        h.b = x.b;
                    return;
                case O.first:
                    u.r += (y.r - u.r) * i,
                        u.g += (y.g - u.g) * i,
                        u.b += (y.b - u.b) * i,
                        h.r += (x.r - h.r) * i,
                        h.g += (x.g - h.g) * i,
                        h.b += (x.b - h.b) * i
            }
            return
        }
        let d = 0
            , f = 0
            , p = 0
            , m = 0
            , g = 0
            , b = 0;
        const v = fn.search(c, s, 7)
            , _ = this.curves[v / 7];
        switch (_) {
            case 0:
                const y = c[v];
                d = c[v + 1],
                    f = c[v + 2],
                    p = c[v + 3],
                    m = c[v + 4],
                    g = c[v + 5],
                    b = c[v + 6];
                const x = (s - y) / (c[v + 7] - y);
                d += (c[v + 7 + 1] - d) * x,
                    f += (c[v + 7 + 2] - f) * x,
                    p += (c[v + 7 + 3] - p) * x,
                    m += (c[v + 7 + 4] - m) * x,
                    g += (c[v + 7 + 5] - g) * x,
                    b += (c[v + 7 + 6] - b) * x;
                break;
            case 1:
                d = c[v + 1],
                    f = c[v + 2],
                    p = c[v + 3],
                    m = c[v + 4],
                    g = c[v + 5],
                    b = c[v + 6];
                break;
            default:
                d = this.getBezierValue(s, v, 1, _ - 2),
                    f = this.getBezierValue(s, v, 2, _ + 18 - 2),
                    p = this.getBezierValue(s, v, 3, _ + 18 * 2 - 2),
                    m = this.getBezierValue(s, v, 4, _ + 18 * 3 - 2),
                    g = this.getBezierValue(s, v, 5, _ + 18 * 4 - 2),
                    b = this.getBezierValue(s, v, 6, _ + 18 * 5 - 2)
        }
        if (i == 1)
            u.r = d,
                u.g = f,
                u.b = p,
                h.r = m,
                h.g = g,
                h.b = b;
        else {
            if (o == O.setup) {
                const y = a.data.color
                    , x = a.data.darkColor;
                u.r = y.r,
                    u.g = y.g,
                    u.b = y.b,
                    h.r = x.r,
                    h.g = x.g,
                    h.b = x.b
            }
            u.r += (d - u.r) * i,
                u.g += (f - u.g) * i,
                u.b += (p - u.b) * i,
                h.r += (m - h.r) * i,
                h.g += (g - h.g) * i,
                h.b += (b - h.b) * i
        }
    }
}
class Bl extends fn {
    constructor(e, n) {
        super(e, [`${Mt.attachment}|${n}`]),
            this.slotIndex = 0,
            this.slotIndex = n,
            this.attachmentNames = new Array(e)
    }
    getFrameCount() {
        return this.frames.length
    }
    setFrame(e, n, s) {
        this.frames[e] = n,
            this.attachmentNames[e] = s
    }
    apply(e, n, s, r, i, o, l) {
        const a = e.slots[this.slotIndex];
        if (a.bone.active) {
            if (l == ct.mixOut) {
                o == O.setup && this.setAttachment(e, a, a.data.attachmentName);
                return
            }
            if (s < this.frames[0]) {
                (o == O.setup || o == O.first) && this.setAttachment(e, a, a.data.attachmentName);
                return
            }
            this.setAttachment(e, a, this.attachmentNames[fn.search1(this.frames, s)])
        }
    }
    setAttachment(e, n, s) {
        n.setAttachment(s ? e.getAttachment(this.slotIndex, s) : null)
    }
}
class Qw extends gi {
    constructor(e, n, s, r) {
        super(e, n, [`${Mt.deform}|${s}|${r.id}`]),
            this.slotIndex = 0,
            this.slotIndex = s,
            this.attachment = r,
            this.vertices = new Array(e)
    }
    getFrameCount() {
        return this.frames.length
    }
    setFrame(e, n, s) {
        this.frames[e] = n,
            this.vertices[e] = s
    }
    setBezier(e, n, s, r, i, o, l, a, c, u, h) {
        const d = this.curves;
        let f = this.getFrameCount() + e * 18;
        s == 0 && (d[n] = 2 + f);
        const p = (r - o * 2 + a) * .03
            , m = c * .03 - l * .06
            , g = ((o - a) * 3 - r + u) * .006
            , b = (l - c + .33333333) * .018;
        let v = p * 2 + g
            , _ = m * 2 + b
            , y = (o - r) * .3 + p + g * .16666667
            , x = l * .3 + m + b * .16666667
            , w = r + y
            , S = x;
        for (let E = f + 18; f < E; f += 2)
            d[f] = w,
                d[f + 1] = S,
                y += v,
                x += _,
                v += g,
                _ += b,
                w += y,
                S += x
    }
    getCurvePercent(e, n) {
        const s = this.curves;
        let r = s[n];
        switch (r) {
            case 0:
                const a = this.frames[n];
                return (e - a) / (this.frames[n + this.getFrameEntries()] - a);
            case 1:
                return 0
        }
        if (r -= 2,
            s[r] > e) {
            const a = this.frames[n];
            return s[r + 1] * (e - a) / (s[r] - a)
        }
        const i = r + 18;
        for (r += 2; r < i; r += 2)
            if (s[r] >= e) {
                const a = s[r - 2]
                    , c = s[r - 1];
                return c + (e - a) / (s[r] - a) * (s[r + 1] - c)
            }
        const o = s[i - 2]
            , l = s[i - 1];
        return l + (1 - l) * (e - o) / (this.frames[n + this.getFrameEntries()] - o)
    }
    apply(e, n, s, r, i, o, l) {
        const a = e.slots[this.slotIndex];
        if (!a.bone.active)
            return;
        const c = a.getAttachment();
        if (!c || !(c instanceof di) || c.timelineAttachment != this.attachment)
            return;
        const u = a.deform;
        u.length == 0 && (o = O.setup);
        const h = this.vertices
            , d = h[0].length
            , f = this.frames;
        if (s < f[0]) {
            switch (o) {
                case O.setup:
                    u.length = 0;
                    return;
                case O.first:
                    if (i == 1) {
                        u.length = 0;
                        return
                    }
                    u.length = d;
                    const v = c;
                    if (v.bones) {
                        i = 1 - i;
                        for (let _ = 0; _ < d; _++)
                            u[_] *= i
                    } else {
                        const _ = v.vertices;
                        for (let y = 0; y < d; y++)
                            u[y] += (_[y] - u[y]) * i
                    }
            }
            return
        }
        if (u.length = d,
            s >= f[f.length - 1]) {
            const v = h[f.length - 1];
            if (i == 1)
                if (o == O.add) {
                    const _ = c;
                    if (_.bones)
                        for (let y = 0; y < d; y++)
                            u[y] += v[y];
                    else {
                        const y = _.vertices;
                        for (let x = 0; x < d; x++)
                            u[x] += v[x] - y[x]
                    }
                } else
                    Q.arrayCopy(v, 0, u, 0, d);
            else
                switch (o) {
                    case O.setup:
                        {
                            const y = c;
                            if (y.bones)
                                for (let x = 0; x < d; x++)
                                    u[x] = v[x] * i;
                            else {
                                const x = y.vertices;
                                for (let w = 0; w < d; w++) {
                                    const S = x[w];
                                    u[w] = S + (v[w] - S) * i
                                }
                            }
                            break
                        }
                    case O.first:
                    case O.replace:
                        for (let y = 0; y < d; y++)
                            u[y] += (v[y] - u[y]) * i;
                        break;
                    case O.add:
                        const _ = c;
                        if (_.bones)
                            for (let y = 0; y < d; y++)
                                u[y] += v[y] * i;
                        else {
                            const y = _.vertices;
                            for (let x = 0; x < d; x++)
                                u[x] += (v[x] - y[x]) * i
                        }
                }
            return
        }
        const p = fn.search1(f, s)
            , m = this.getCurvePercent(s, p)
            , g = h[p]
            , b = h[p + 1];
        if (i == 1)
            if (o == O.add) {
                const v = c;
                if (v.bones)
                    for (let _ = 0; _ < d; _++) {
                        const y = g[_];
                        u[_] += y + (b[_] - y) * m
                    }
                else {
                    const _ = v.vertices;
                    for (let y = 0; y < d; y++) {
                        const x = g[y];
                        u[y] += x + (b[y] - x) * m - _[y]
                    }
                }
            } else
                for (let v = 0; v < d; v++) {
                    const _ = g[v];
                    u[v] = _ + (b[v] - _) * m
                }
        else
            switch (o) {
                case O.setup:
                    {
                        const _ = c;
                        if (_.bones)
                            for (let y = 0; y < d; y++) {
                                const x = g[y];
                                u[y] = (x + (b[y] - x) * m) * i
                            }
                        else {
                            const y = _.vertices;
                            for (let x = 0; x < d; x++) {
                                const w = g[x]
                                    , S = y[x];
                                u[x] = S + (w + (b[x] - w) * m - S) * i
                            }
                        }
                        break
                    }
                case O.first:
                case O.replace:
                    for (let _ = 0; _ < d; _++) {
                        const y = g[_];
                        u[_] += (y + (b[_] - y) * m - u[_]) * i
                    }
                    break;
                case O.add:
                    const v = c;
                    if (v.bones)
                        for (let _ = 0; _ < d; _++) {
                            const y = g[_];
                            u[_] += (y + (b[_] - y) * m) * i
                        }
                    else {
                        const _ = v.vertices;
                        for (let y = 0; y < d; y++) {
                            const x = g[y];
                            u[y] += (x + (b[y] - x) * m - _[y]) * i
                        }
                    }
            }
    }
}
const uL = class extends fn {
    constructor(t) {
        super(t, uL.propertyIds),
            this.events = new Array(t)
    }
    getFrameCount() {
        return this.frames.length
    }
    setFrame(t, e) {
        this.frames[t] = e.time,
            this.events[t] = e
    }
    apply(t, e, n, s, r, i, o) {
        if (!s)
            return;
        const l = this.frames
            , a = this.frames.length;
        if (e > n)
            this.apply(t, e, Number.MAX_VALUE, s, r, i, o),
                e = -1;
        else if (e >= l[a - 1])
            return;
        if (n < l[0])
            return;
        let c = 0;
        if (e < l[0])
            c = 0;
        else {
            c = fn.search1(l, e) + 1;
            const u = l[c];
            for (; c > 0 && l[c - 1] == u;)
                c--
        }
        for (; c < a && n >= l[c]; c++)
            s.push(this.events[c])
    }
}
    ;
let wf = uL;
wf.propertyIds = [`${Mt.event}`];
const hL = class extends fn {
    constructor(t) {
        super(t, hL.propertyIds),
            this.drawOrders = new Array(t)
    }
    getFrameCount() {
        return this.frames.length
    }
    setFrame(t, e, n) {
        this.frames[t] = e,
            this.drawOrders[t] = n
    }
    apply(t, e, n, s, r, i, o) {
        if (o == ct.mixOut) {
            i == O.setup && Q.arrayCopy(t.slots, 0, t.drawOrder, 0, t.slots.length);
            return
        }
        if (n < this.frames[0]) {
            (i == O.setup || i == O.first) && Q.arrayCopy(t.slots, 0, t.drawOrder, 0, t.slots.length);
            return
        }
        const l = fn.search1(this.frames, n)
            , a = this.drawOrders[l];
        if (!a)
            Q.arrayCopy(t.slots, 0, t.drawOrder, 0, t.slots.length);
        else {
            const c = t.drawOrder
                , u = t.slots;
            for (let h = 0, d = a.length; h < d; h++)
                c[h] = u[a[h]]
        }
    }
}
    ;
let jl = hL;
jl.propertyIds = [`${Mt.drawOrder}`];
class eS extends gi {
    constructor(e, n, s) {
        super(e, n, [`${Mt.ikConstraint}|${s}`]),
            this.ikConstraintIndex = 0,
            this.ikConstraintIndex = s
    }
    getFrameEntries() {
        return 6
    }
    setFrame(e, n, s, r, i, o, l) {
        e *= 6,
            this.frames[e] = n,
            this.frames[e + 1] = s,
            this.frames[e + 2] = r,
            this.frames[e + 3] = i,
            this.frames[e + 4] = o ? 1 : 0,
            this.frames[e + 5] = l ? 1 : 0
    }
    apply(e, n, s, r, i, o, l) {
        const a = e.ikConstraints[this.ikConstraintIndex];
        if (!a.active)
            return;
        const c = this.frames;
        if (s < c[0]) {
            switch (o) {
                case O.setup:
                    a.mix = a.data.mix,
                        a.softness = a.data.softness,
                        a.bendDirection = a.data.bendDirection,
                        a.compress = a.data.compress,
                        a.stretch = a.data.stretch;
                    return;
                case O.first:
                    a.mix += (a.data.mix - a.mix) * i,
                        a.softness += (a.data.softness - a.softness) * i,
                        a.bendDirection = a.data.bendDirection,
                        a.compress = a.data.compress,
                        a.stretch = a.data.stretch
            }
            return
        }
        let u = 0
            , h = 0;
        const d = fn.search(c, s, 6)
            , f = this.curves[d / 6];
        switch (f) {
            case 0:
                const p = c[d];
                u = c[d + 1],
                    h = c[d + 2];
                const m = (s - p) / (c[d + 6] - p);
                u += (c[d + 6 + 1] - u) * m,
                    h += (c[d + 6 + 2] - h) * m;
                break;
            case 1:
                u = c[d + 1],
                    h = c[d + 2];
                break;
            default:
                u = this.getBezierValue(s, d, 1, f - 2),
                    h = this.getBezierValue(s, d, 2, f + 18 - 2)
        }
        o == O.setup ? (a.mix = a.data.mix + (u - a.data.mix) * i,
            a.softness = a.data.softness + (h - a.data.softness) * i,
            l == ct.mixOut ? (a.bendDirection = a.data.bendDirection,
                a.compress = a.data.compress,
                a.stretch = a.data.stretch) : (a.bendDirection = c[d + 3],
                    a.compress = c[d + 4] != 0,
                    a.stretch = c[d + 5] != 0)) : (a.mix += (u - a.mix) * i,
                        a.softness += (h - a.softness) * i,
                        l == ct.mixIn && (a.bendDirection = c[d + 3],
                            a.compress = c[d + 4] != 0,
                            a.stretch = c[d + 5] != 0))
    }
}
class tS extends gi {
    constructor(e, n, s) {
        super(e, n, [`${Mt.transformConstraint}|${s}`]),
            this.transformConstraintIndex = 0,
            this.transformConstraintIndex = s
    }
    getFrameEntries() {
        return 7
    }
    setFrame(e, n, s, r, i, o, l, a) {
        const c = this.frames;
        e *= 7,
            c[e] = n,
            c[e + 1] = s,
            c[e + 2] = r,
            c[e + 3] = i,
            c[e + 4] = o,
            c[e + 5] = l,
            c[e + 6] = a
    }
    apply(e, n, s, r, i, o, l) {
        const a = e.transformConstraints[this.transformConstraintIndex];
        if (!a.active)
            return;
        const c = this.frames;
        if (s < c[0]) {
            const v = a.data;
            switch (o) {
                case O.setup:
                    a.mixRotate = v.mixRotate,
                        a.mixX = v.mixX,
                        a.mixY = v.mixY,
                        a.mixScaleX = v.mixScaleX,
                        a.mixScaleY = v.mixScaleY,
                        a.mixShearY = v.mixShearY;
                    return;
                case O.first:
                    a.mixRotate += (v.mixRotate - a.mixRotate) * i,
                        a.mixX += (v.mixX - a.mixX) * i,
                        a.mixY += (v.mixY - a.mixY) * i,
                        a.mixScaleX += (v.mixScaleX - a.mixScaleX) * i,
                        a.mixScaleY += (v.mixScaleY - a.mixScaleY) * i,
                        a.mixShearY += (v.mixShearY - a.mixShearY) * i
            }
            return
        }
        let u, h, d, f, p, m;
        const g = fn.search(c, s, 7)
            , b = this.curves[g / 7];
        switch (b) {
            case 0:
                const v = c[g];
                u = c[g + 1],
                    h = c[g + 2],
                    d = c[g + 3],
                    f = c[g + 4],
                    p = c[g + 5],
                    m = c[g + 6];
                const _ = (s - v) / (c[g + 7] - v);
                u += (c[g + 7 + 1] - u) * _,
                    h += (c[g + 7 + 2] - h) * _,
                    d += (c[g + 7 + 3] - d) * _,
                    f += (c[g + 7 + 4] - f) * _,
                    p += (c[g + 7 + 5] - p) * _,
                    m += (c[g + 7 + 6] - m) * _;
                break;
            case 1:
                u = c[g + 1],
                    h = c[g + 2],
                    d = c[g + 3],
                    f = c[g + 4],
                    p = c[g + 5],
                    m = c[g + 6];
                break;
            default:
                u = this.getBezierValue(s, g, 1, b - 2),
                    h = this.getBezierValue(s, g, 2, b + 18 - 2),
                    d = this.getBezierValue(s, g, 3, b + 18 * 2 - 2),
                    f = this.getBezierValue(s, g, 4, b + 18 * 3 - 2),
                    p = this.getBezierValue(s, g, 5, b + 18 * 4 - 2),
                    m = this.getBezierValue(s, g, 6, b + 18 * 5 - 2)
        }
        if (o == O.setup) {
            const v = a.data;
            a.mixRotate = v.mixRotate + (u - v.mixRotate) * i,
                a.mixX = v.mixX + (h - v.mixX) * i,
                a.mixY = v.mixY + (d - v.mixY) * i,
                a.mixScaleX = v.mixScaleX + (f - v.mixScaleX) * i,
                a.mixScaleY = v.mixScaleY + (p - v.mixScaleY) * i,
                a.mixShearY = v.mixShearY + (m - v.mixShearY) * i
        } else
            a.mixRotate += (u - a.mixRotate) * i,
                a.mixX += (h - a.mixX) * i,
                a.mixY += (d - a.mixY) * i,
                a.mixScaleX += (f - a.mixScaleX) * i,
                a.mixScaleY += (p - a.mixScaleY) * i,
                a.mixShearY += (m - a.mixShearY) * i
    }
}
class nS extends _i {
    constructor(e, n, s) {
        super(e, n, `${Mt.pathConstraintPosition}|${s}`),
            this.pathConstraintIndex = 0,
            this.pathConstraintIndex = s
    }
    apply(e, n, s, r, i, o, l) {
        const a = e.pathConstraints[this.pathConstraintIndex];
        if (!a.active)
            return;
        const c = this.frames;
        if (s < c[0]) {
            switch (o) {
                case O.setup:
                    a.position = a.data.position;
                    return;
                case O.first:
                    a.position += (a.data.position - a.position) * i
            }
            return
        }
        const u = this.getCurveValue(s);
        o == O.setup ? a.position = a.data.position + (u - a.data.position) * i : a.position += (u - a.position) * i
    }
}
class sS extends _i {
    constructor(e, n, s) {
        super(e, n, `${Mt.pathConstraintSpacing}|${s}`),
            this.pathConstraintIndex = 0,
            this.pathConstraintIndex = s
    }
    apply(e, n, s, r, i, o, l) {
        const a = e.pathConstraints[this.pathConstraintIndex];
        if (!a.active)
            return;
        const c = this.frames;
        if (s < c[0]) {
            switch (o) {
                case O.setup:
                    a.spacing = a.data.spacing;
                    return;
                case O.first:
                    a.spacing += (a.data.spacing - a.spacing) * i
            }
            return
        }
        const u = this.getCurveValue(s);
        o == O.setup ? a.spacing = a.data.spacing + (u - a.data.spacing) * i : a.spacing += (u - a.spacing) * i
    }
}
class rS extends gi {
    constructor(e, n, s) {
        super(e, n, [`${Mt.pathConstraintMix}|${s}`]),
            this.pathConstraintIndex = 0,
            this.pathConstraintIndex = s
    }
    getFrameEntries() {
        return 4
    }
    setFrame(e, n, s, r, i) {
        const o = this.frames;
        e <<= 2,
            o[e] = n,
            o[e + 1] = s,
            o[e + 2] = r,
            o[e + 3] = i
    }
    apply(e, n, s, r, i, o, l) {
        const a = e.pathConstraints[this.pathConstraintIndex];
        if (!a.active)
            return;
        const c = this.frames;
        if (s < c[0]) {
            switch (o) {
                case O.setup:
                    a.mixRotate = a.data.mixRotate,
                        a.mixX = a.data.mixX,
                        a.mixY = a.data.mixY;
                    return;
                case O.first:
                    a.mixRotate += (a.data.mixRotate - a.mixRotate) * i,
                        a.mixX += (a.data.mixX - a.mixX) * i,
                        a.mixY += (a.data.mixY - a.mixY) * i
            }
            return
        }
        let u, h, d;
        const f = fn.search(c, s, 4)
            , p = this.curves[f >> 2];
        switch (p) {
            case 0:
                const m = c[f];
                u = c[f + 1],
                    h = c[f + 2],
                    d = c[f + 3];
                const g = (s - m) / (c[f + 4] - m);
                u += (c[f + 4 + 1] - u) * g,
                    h += (c[f + 4 + 2] - h) * g,
                    d += (c[f + 4 + 3] - d) * g;
                break;
            case 1:
                u = c[f + 1],
                    h = c[f + 2],
                    d = c[f + 3];
                break;
            default:
                u = this.getBezierValue(s, f, 1, p - 2),
                    h = this.getBezierValue(s, f, 2, p + 18 - 2),
                    d = this.getBezierValue(s, f, 3, p + 18 * 2 - 2)
        }
        if (o == O.setup) {
            const m = a.data;
            a.mixRotate = m.mixRotate + (u - m.mixRotate) * i,
                a.mixX = m.mixX + (h - m.mixX) * i,
                a.mixY = m.mixY + (d - m.mixY) * i
        } else
            a.mixRotate += (u - a.mixRotate) * i,
                a.mixX += (h - a.mixX) * i,
                a.mixY += (d - a.mixY) * i
    }
}
const ca = class extends fn {
    constructor(t, e, n) {
        super(t, [`${Mt.sequence}|${e}|${n.sequence.id}`]),
            this.slotIndex = e,
            this.attachment = n
    }
    getFrameEntries() {
        return ca.ENTRIES
    }
    getSlotIndex() {
        return this.slotIndex
    }
    getAttachment() {
        return this.attachment
    }
    setFrame(t, e, n, s, r) {
        const i = this.frames;
        t *= ca.ENTRIES,
            i[t] = e,
            i[t + ca.MODE] = n | s << 4,
            i[t + ca.DELAY] = r
    }
    apply(t, e, n, s, r, i, o) {
        const l = t.slots[this.slotIndex];
        if (!l.bone.active)
            return;
        const a = l.attachment
            , c = this.attachment;
        if (a != c && (!(a instanceof di) || a.timelineAttachment != c))
            return;
        const u = this.frames;
        if (n < u[0]) {
            (i == O.setup || i == O.first) && (l.sequenceIndex = -1);
            return
        }
        const h = fn.search(u, n, ca.ENTRIES)
            , d = u[h]
            , f = u[h + ca.MODE]
            , p = u[h + ca.DELAY];
        if (!this.attachment.sequence)
            return;
        let m = f >> 4;
        const g = this.attachment.sequence.regions.length
            , b = Fw[f & 15];
        if (b != Mi.hold)
            switch (m += (n - d) / p + 1e-5 | 0,
            b) {
                case Mi.once:
                    m = Math.min(g - 1, m);
                    break;
                case Mi.loop:
                    m %= g;
                    break;
                case Mi.pingpong:
                    {
                        const v = (g << 1) - 2;
                        m = v == 0 ? 0 : m % v,
                            m >= g && (m = v - m);
                        break
                    }
                case Mi.onceReverse:
                    m = Math.max(g - 1 - m, 0);
                    break;
                case Mi.loopReverse:
                    m = g - 1 - m % g;
                    break;
                case Mi.pingpongReverse:
                    {
                        const v = (g << 1) - 2;
                        m = v == 0 ? 0 : (m + g - 1) % v,
                            m >= g && (m = v - m)
                    }
            }
        l.sequenceIndex = m
    }
}
    ;
let yh = ca;
yh.ENTRIES = 3;
yh.MODE = 1;
yh.DELAY = 2;
const Ci = class {
    constructor(t) {
        this.tracks = new Array,
            this.timeScale = 1,
            this.unkeyedState = 0,
            this.events = new Array,
            this.listeners = new Array,
            this.queue = new dL(this),
            this.propertyIDs = new c5,
            this.animationsChanged = !1,
            this.trackEntryPool = new N_(() => new q_),
            this.data = t
    }
    static emptyAnimation() {
        return Ci._emptyAnimation
    }
    update(t) {
        t *= this.timeScale;
        const e = this.tracks;
        for (let n = 0, s = e.length; n < s; n++) {
            const r = e[n];
            if (!r)
                continue;
            r.animationLast = r.nextAnimationLast,
                r.trackLast = r.nextTrackLast;
            let i = t * r.timeScale;
            if (r.delay > 0) {
                if (r.delay -= i,
                    r.delay > 0)
                    continue;
                i = -r.delay,
                    r.delay = 0
            }
            let o = r.next;
            if (o) {
                const l = r.trackLast - o.delay;
                if (l >= 0) {
                    for (o.delay = 0,
                        o.trackTime += r.timeScale == 0 ? 0 : (l / r.timeScale + t) * o.timeScale,
                        r.trackTime += i,
                        this.setCurrent(n, o, !0); o.mixingFrom;)
                        o.mixTime += t,
                            o = o.mixingFrom;
                    continue
                }
            } else if (r.trackLast >= r.trackEnd && !r.mixingFrom) {
                e[n] = null,
                    this.queue.end(r),
                    this.clearNext(r);
                continue
            }
            if (r.mixingFrom && this.updateMixingFrom(r, t)) {
                let l = r.mixingFrom;
                for (r.mixingFrom = null,
                    l && (l.mixingTo = null); l;)
                    this.queue.end(l),
                        l = l.mixingFrom
            }
            r.trackTime += i
        }
        this.queue.drain()
    }
    updateMixingFrom(t, e) {
        const n = t.mixingFrom;
        if (!n)
            return !0;
        const s = this.updateMixingFrom(n, e);
        return n.animationLast = n.nextAnimationLast,
            n.trackLast = n.nextTrackLast,
            t.mixTime > 0 && t.mixTime >= t.mixDuration ? ((n.totalAlpha == 0 || t.mixDuration == 0) && (t.mixingFrom = n.mixingFrom,
                n.mixingFrom && (n.mixingFrom.mixingTo = t),
                t.interruptAlpha = n.interruptAlpha,
                this.queue.end(n)),
                s) : (n.trackTime += e * n.timeScale,
                    t.mixTime += e,
                    !1)
    }
    apply(t) {
        if (!t)
            throw new Error("skeleton cannot be null.");
        this.animationsChanged && this._animationsChanged();
        const e = this.events
            , n = this.tracks;
        let s = !1;
        for (let o = 0, l = n.length; o < l; o++) {
            const a = n[o];
            if (!a || a.delay > 0)
                continue;
            s = !0;
            const c = o == 0 ? O.first : a.mixBlend;
            let u = a.alpha;
            a.mixingFrom ? u *= this.applyMixingFrom(a, t, c) : a.trackTime >= a.trackEnd && !a.next && (u = 0);
            const h = a.animationLast
                , d = a.getAnimationTime();
            let f = d
                , p = e;
            a.reverse && (f = a.animation.duration - f,
                p = null);
            const m = a.animation.timelines
                , g = m.length;
            if (o == 0 && u == 1 || c == O.add)
                for (let b = 0; b < g; b++) {
                    const v = m[b];
                    v instanceof Bl ? this.applyAttachmentTimeline(v, t, f, c, !0) : v.apply(t, h, f, p, u, c, ct.mixIn)
                }
            else {
                const b = a.timelineMode
                    , v = a.shortestRotation
                    , _ = !v && a.timelinesRotation.length != g << 1;
                _ && (a.timelinesRotation.length = g << 1);
                for (let y = 0; y < g; y++) {
                    const x = m[y]
                        , w = b[y] == T1 ? c : O.setup;
                    !v && x instanceof Vd ? this.applyRotateTimeline(x, t, f, u, w, a.timelinesRotation, y << 1, _) : x instanceof Bl ? this.applyAttachmentTimeline(x, t, f, c, !0) : x.apply(t, h, f, p, u, w, ct.mixIn)
                }
            }
            this.queueEvents(a, d),
                e.length = 0,
                a.nextAnimationLast = d,
                a.nextTrackLast = a.trackTime
        }
        const r = this.unkeyedState + vA
            , i = t.slots;
        for (let o = 0, l = t.slots.length; o < l; o++) {
            const a = i[o];
            if (a.attachmentState == r) {
                const c = a.data.attachmentName;
                a.setAttachment(c ? t.getAttachment(a.data.index, c) : null)
            }
        }
        return this.unkeyedState += 2,
            this.queue.drain(),
            s
    }
    applyMixingFrom(t, e, n) {
        const s = t.mixingFrom;
        s.mixingFrom && this.applyMixingFrom(s, e, n);
        let r = 0;
        t.mixDuration == 0 ? (r = 1,
            n == O.first && (n = O.setup)) : (r = t.mixTime / t.mixDuration,
                r > 1 && (r = 1),
                n != O.first && (n = s.mixBlend));
        const i = r < s.attachmentThreshold
            , o = r < s.drawOrderThreshold
            , l = s.animation.timelines
            , a = l.length
            , c = s.alpha * t.interruptAlpha
            , u = c * (1 - r)
            , h = s.animationLast
            , d = s.getAnimationTime();
        let f = d
            , p = null;
        if (s.reverse ? f = s.animation.duration - f : r < s.eventThreshold && (p = this.events),
            n == O.add)
            for (let m = 0; m < a; m++)
                l[m].apply(e, h, f, p, u, n, ct.mixOut);
        else {
            const m = s.timelineMode
                , g = s.timelineHoldMix
                , b = s.shortestRotation
                , v = !b && s.timelinesRotation.length != a << 1;
            v && (s.timelinesRotation.length = a << 1),
                s.totalAlpha = 0;
            for (let _ = 0; _ < a; _++) {
                const y = l[_];
                let x = ct.mixOut, w, S = 0;
                switch (m[_]) {
                    case T1:
                        if (!o && y instanceof jl)
                            continue;
                        w = n,
                            S = u;
                        break;
                    case yA:
                        w = O.setup,
                            S = u;
                        break;
                    case bA:
                        w = n,
                            S = c;
                        break;
                    case C1:
                        w = O.setup,
                            S = c;
                        break;
                    default:
                        w = O.setup;
                        const E = g[_];
                        S = c * Math.max(0, 1 - E.mixTime / E.mixDuration);
                        break
                }
                s.totalAlpha += S,
                    !b && y instanceof Vd ? this.applyRotateTimeline(y, e, f, S, w, s.timelinesRotation, _ << 1, v) : y instanceof Bl ? this.applyAttachmentTimeline(y, e, f, w, i) : (o && y instanceof jl && w == O.setup && (x = ct.mixIn),
                        y.apply(e, h, f, p, S, w, x))
            }
        }
        return t.mixDuration > 0 && this.queueEvents(s, d),
            this.events.length = 0,
            s.nextAnimationLast = d,
            s.nextTrackLast = s.trackTime,
            r
    }
    applyAttachmentTimeline(t, e, n, s, r) {
        const i = e.slots[t.slotIndex];
        i.bone.active && (n < t.frames[0] ? (s == O.setup || s == O.first) && this.setAttachment(e, i, i.data.attachmentName, r) : this.setAttachment(e, i, t.attachmentNames[fn.search1(t.frames, n)], r),
            i.attachmentState <= this.unkeyedState && (i.attachmentState = this.unkeyedState + vA))
    }
    setAttachment(t, e, n, s) {
        e.setAttachment(n ? t.getAttachment(e.data.index, n) : null),
            s && (e.attachmentState = this.unkeyedState + Ahe)
    }
    applyRotateTimeline(t, e, n, s, r, i, o, l) {
        if (l && (i[o] = 0),
            s == 1) {
            t.apply(e, 0, n, null, 1, r, ct.mixIn);
            return
        }
        const a = e.bones[t.boneIndex];
        if (!a.active)
            return;
        const c = t.frames;
        let u = 0
            , h = 0;
        if (n < c[0])
            switch (r) {
                case O.setup:
                    a.rotation = a.data.rotation;
                default:
                    return;
                case O.first:
                    u = a.rotation,
                        h = a.data.rotation
            }
        else
            u = r == O.setup ? a.data.rotation : a.rotation,
                h = a.data.rotation + t.getCurveValue(n);
        let d = 0
            , f = h - u;
        if (f -= (16384 - (16384.499999999996 - f / 360 | 0)) * 360,
            f == 0)
            d = i[o];
        else {
            let p = 0
                , m = 0;
            l ? (p = 0,
                m = f) : (p = i[o],
                    m = i[o + 1]);
            const g = f > 0;
            let b = p >= 0;
            F.signum(m) != F.signum(f) && Math.abs(m) <= 90 && (Math.abs(p) > 180 && (p += 360 * F.signum(p)),
                b = g),
                d = f + p - p % 360,
                b != g && (d += 360 * F.signum(p)),
                i[o] = d
        }
        i[o + 1] = f,
            a.rotation = u + d * s
    }
    queueEvents(t, e) {
        const n = t.animationStart
            , s = t.animationEnd
            , r = s - n
            , i = t.trackLast % r
            , o = this.events;
        let l = 0;
        const a = o.length;
        for (; l < a; l++) {
            const u = o[l];
            if (u.time < i)
                break;
            u.time > s || this.queue.event(t, u)
        }
        let c = !1;
        for (t.loop ? c = r == 0 || i > t.trackTime % r : c = e >= s && t.animationLast < s,
            c && this.queue.complete(t); l < a; l++) {
            const u = o[l];
            u.time < n || this.queue.event(t, u)
        }
    }
    clearTracks() {
        const t = this.queue.drainDisabled;
        this.queue.drainDisabled = !0;
        for (let e = 0, n = this.tracks.length; e < n; e++)
            this.clearTrack(e);
        this.tracks.length = 0,
            this.queue.drainDisabled = t,
            this.queue.drain()
    }
    clearTrack(t) {
        if (t >= this.tracks.length)
            return;
        const e = this.tracks[t];
        if (!e)
            return;
        this.queue.end(e),
            this.clearNext(e);
        let n = e;
        for (; ;) {
            const s = n.mixingFrom;
            if (!s)
                break;
            this.queue.end(s),
                n.mixingFrom = null,
                n.mixingTo = null,
                n = s
        }
        this.tracks[e.trackIndex] = null,
            this.queue.drain()
    }
    setCurrent(t, e, n) {
        const s = this.expandToIndex(t);
        this.tracks[t] = e,
            e.previous = null,
            s && (n && this.queue.interrupt(s),
                e.mixingFrom = s,
                s.mixingTo = e,
                e.mixTime = 0,
                s.mixingFrom && s.mixDuration > 0 && (e.interruptAlpha *= Math.min(1, s.mixTime / s.mixDuration)),
                s.timelinesRotation.length = 0),
            this.queue.start(e)
    }
    setAnimation(t, e, n = !1) {
        const s = this.data.skeletonData.findAnimation(e);
        if (!s)
            throw new Error(`Animation not found: ${e}`);
        return this.setAnimationWith(t, s, n)
    }
    setAnimationWith(t, e, n = !1) {
        if (!e)
            throw new Error("animation cannot be null.");
        let s = !0
            , r = this.expandToIndex(t);
        r && (r.nextTrackLast == -1 ? (this.tracks[t] = r.mixingFrom,
            this.queue.interrupt(r),
            this.queue.end(r),
            this.clearNext(r),
            r = r.mixingFrom,
            s = !1) : this.clearNext(r));
        const i = this.trackEntry(t, e, n, r);
        return this.setCurrent(t, i, s),
            this.queue.drain(),
            i
    }
    addAnimation(t, e, n = !1, s = 0) {
        const r = this.data.skeletonData.findAnimation(e);
        if (!r)
            throw new Error(`Animation not found: ${e}`);
        return this.addAnimationWith(t, r, n, s)
    }
    addAnimationWith(t, e, n = !1, s = 0) {
        if (!e)
            throw new Error("animation cannot be null.");
        let r = this.expandToIndex(t);
        if (r)
            for (; r.next;)
                r = r.next;
        const i = this.trackEntry(t, e, n, r);
        return r ? (r.next = i,
            i.previous = r,
            s <= 0 && (s += r.getTrackComplete() - i.mixDuration)) : (this.setCurrent(t, i, !0),
                this.queue.drain()),
            i.delay = s,
            i
    }
    setEmptyAnimation(t, e = 0) {
        const n = this.setAnimationWith(t, Ci.emptyAnimation(), !1);
        return n.mixDuration = e,
            n.trackEnd = e,
            n
    }
    addEmptyAnimation(t, e = 0, n = 0) {
        const s = this.addAnimationWith(t, Ci.emptyAnimation(), !1, n);
        return n <= 0 && (s.delay += s.mixDuration - e),
            s.mixDuration = e,
            s.trackEnd = e,
            s
    }
    setEmptyAnimations(t = 0) {
        const e = this.queue.drainDisabled;
        this.queue.drainDisabled = !0;
        for (let n = 0, s = this.tracks.length; n < s; n++) {
            const r = this.tracks[n];
            r && this.setEmptyAnimation(r.trackIndex, t)
        }
        this.queue.drainDisabled = e,
            this.queue.drain()
    }
    expandToIndex(t) {
        return t < this.tracks.length ? this.tracks[t] : (Q.ensureArrayCapacity(this.tracks, t + 1, null),
            this.tracks.length = t + 1,
            null)
    }
    trackEntry(t, e, n, s) {
        const r = this.trackEntryPool.obtain();
        return r.reset(),
            r.trackIndex = t,
            r.animation = e,
            r.loop = n,
            r.holdPrevious = !1,
            r.reverse = !1,
            r.shortestRotation = !1,
            r.eventThreshold = 0,
            r.attachmentThreshold = 0,
            r.drawOrderThreshold = 0,
            r.animationStart = 0,
            r.animationEnd = e.duration,
            r.animationLast = -1,
            r.nextAnimationLast = -1,
            r.delay = 0,
            r.trackTime = 0,
            r.trackLast = -1,
            r.nextTrackLast = -1,
            r.trackEnd = Number.MAX_VALUE,
            r.timeScale = 1,
            r.alpha = 1,
            r.mixTime = 0,
            r.mixDuration = s ? this.data.getMix(s.animation, e) : 0,
            r.interruptAlpha = 1,
            r.totalAlpha = 0,
            r.mixBlend = O.replace,
            r
    }
    clearNext(t) {
        let e = t.next;
        for (; e;)
            this.queue.dispose(e),
                e = e.next;
        t.next = null
    }
    _animationsChanged() {
        this.animationsChanged = !1,
            this.propertyIDs.clear();
        const t = this.tracks;
        for (let e = 0, n = t.length; e < n; e++) {
            let s = t[e];
            if (s) {
                for (; s.mixingFrom;)
                    s = s.mixingFrom;
                do
                    (!s.mixingTo || s.mixBlend != O.add) && this.computeHold(s),
                        s = s.mixingTo;
                while (s)
            }
        }
    }
    computeHold(t) {
        const e = t.mixingTo
            , n = t.animation.timelines
            , s = t.animation.timelines.length
            , r = t.timelineMode;
        r.length = s;
        const i = t.timelineHoldMix;
        i.length = 0;
        const o = this.propertyIDs;
        if (e && e.holdPrevious) {
            for (let l = 0; l < s; l++)
                r[l] = o.addAll(n[l].getPropertyIds()) ? C1 : bA;
            return
        }
        e: for (let l = 0; l < s; l++) {
            const a = n[l]
                , c = a.getPropertyIds();
            if (!o.addAll(c))
                r[l] = T1;
            else if (!e || a instanceof Bl || a instanceof jl || a instanceof wf || !e.animation.hasTimeline(c))
                r[l] = yA;
            else {
                for (let u = e.mixingTo; u; u = u.mixingTo)
                    if (!u.animation.hasTimeline(c)) {
                        if (t.mixDuration > 0) {
                            r[l] = Ihe,
                                i[l] = u;
                            continue e
                        }
                        break
                    }
                r[l] = C1
            }
        }
    }
    getCurrent(t) {
        return t >= this.tracks.length ? null : this.tracks[t]
    }
    addListener(t) {
        if (!t)
            throw new Error("listener cannot be null.");
        this.listeners.push(t)
    }
    removeListener(t) {
        const e = this.listeners.indexOf(t);
        e >= 0 && this.listeners.splice(e, 1)
    }
    clearListeners() {
        this.listeners.length = 0
    }
    clearListenerNotifications() {
        this.queue.clear()
    }
    setAnimationByName(t, e, n) {
        Ci.deprecatedWarning1 || (Ci.deprecatedWarning1 = !0,
            console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.")),
            this.setAnimation(t, e, n)
    }
    addAnimationByName(t, e, n, s) {
        Ci.deprecatedWarning2 || (Ci.deprecatedWarning2 = !0,
            console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.")),
            this.addAnimation(t, e, n, s)
    }
    hasAnimation(t) {
        return this.data.skeletonData.findAnimation(t) !== null
    }
    hasAnimationByName(t) {
        return Ci.deprecatedWarning3 || (Ci.deprecatedWarning3 = !0,
            console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.")),
            this.hasAnimation(t)
    }
}
    ;
let bh = Ci;
bh._emptyAnimation = new j_("<empty>", [], 0);
bh.deprecatedWarning1 = !1;
bh.deprecatedWarning2 = !1;
bh.deprecatedWarning3 = !1;
const lo = class {
    constructor() {
        this.animation = null,
            this.previous = null,
            this.next = null,
            this.mixingFrom = null,
            this.mixingTo = null,
            this.listener = null,
            this.trackIndex = 0,
            this.loop = !1,
            this.holdPrevious = !1,
            this.reverse = !1,
            this.shortestRotation = !1,
            this.eventThreshold = 0,
            this.attachmentThreshold = 0,
            this.drawOrderThreshold = 0,
            this.animationStart = 0,
            this.animationEnd = 0,
            this.animationLast = 0,
            this.nextAnimationLast = 0,
            this.delay = 0,
            this.trackTime = 0,
            this.trackLast = 0,
            this.nextTrackLast = 0,
            this.trackEnd = 0,
            this.timeScale = 0,
            this.alpha = 0,
            this.mixTime = 0,
            this.mixDuration = 0,
            this.interruptAlpha = 0,
            this.totalAlpha = 0,
            this.mixBlend = O.replace,
            this.timelineMode = new Array,
            this.timelineHoldMix = new Array,
            this.timelinesRotation = new Array
    }
    reset() {
        this.next = null,
            this.previous = null,
            this.mixingFrom = null,
            this.mixingTo = null,
            this.animation = null,
            this.listener = null,
            this.timelineMode.length = 0,
            this.timelineHoldMix.length = 0,
            this.timelinesRotation.length = 0
    }
    getAnimationTime() {
        if (this.loop) {
            const t = this.animationEnd - this.animationStart;
            return t == 0 ? this.animationStart : this.trackTime % t + this.animationStart
        }
        return Math.min(this.trackTime + this.animationStart, this.animationEnd)
    }
    setAnimationLast(t) {
        this.animationLast = t,
            this.nextAnimationLast = t
    }
    isComplete() {
        return this.trackTime >= this.animationEnd - this.animationStart
    }
    resetRotationDirections() {
        this.timelinesRotation.length = 0
    }
    getTrackComplete() {
        const t = this.animationEnd - this.animationStart;
        if (t != 0) {
            if (this.loop)
                return t * (1 + (this.trackTime / t | 0));
            if (this.trackTime < t)
                return t
        }
        return this.trackTime
    }
    get time() {
        return lo.deprecatedWarning1 || (lo.deprecatedWarning1 = !0,
            console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),
            this.trackTime
    }
    set time(t) {
        lo.deprecatedWarning1 || (lo.deprecatedWarning1 = !0,
            console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),
            this.trackTime = t
    }
    get endTime() {
        return lo.deprecatedWarning2 || (lo.deprecatedWarning2 = !0,
            console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),
            this.trackTime
    }
    set endTime(t) {
        lo.deprecatedWarning2 || (lo.deprecatedWarning2 = !0,
            console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),
            this.trackTime = t
    }
    loopsCount() {
        return Math.floor(this.trackTime / this.trackEnd)
    }
}
    ;
let q_ = lo;
q_.deprecatedWarning1 = !1;
q_.deprecatedWarning2 = !1;
class dL {
    constructor(e) {
        this.objects = [],
            this.drainDisabled = !1,
            this.animState = e
    }
    start(e) {
        this.objects.push(Vs.start),
            this.objects.push(e),
            this.animState.animationsChanged = !0
    }
    interrupt(e) {
        this.objects.push(Vs.interrupt),
            this.objects.push(e)
    }
    end(e) {
        this.objects.push(Vs.end),
            this.objects.push(e),
            this.animState.animationsChanged = !0
    }
    dispose(e) {
        this.objects.push(Vs.dispose),
            this.objects.push(e)
    }
    complete(e) {
        this.objects.push(Vs.complete),
            this.objects.push(e)
    }
    event(e, n) {
        this.objects.push(Vs.event),
            this.objects.push(e),
            this.objects.push(n)
    }
    drain() {
        if (this.drainDisabled)
            return;
        this.drainDisabled = !0;
        const e = this.objects
            , n = this.animState.listeners;
        for (let s = 0; s < e.length; s += 2) {
            const r = e[s]
                , i = e[s + 1];
            switch (r) {
                case Vs.start:
                    i.listener && i.listener.start && i.listener.start(i);
                    for (let l = 0; l < n.length; l++) {
                        const a = n[l];
                        a.start && a.start(i)
                    }
                    break;
                case Vs.interrupt:
                    i.listener && i.listener.interrupt && i.listener.interrupt(i);
                    for (let l = 0; l < n.length; l++) {
                        const a = n[l];
                        a.interrupt && a.interrupt(i)
                    }
                    break;
                case Vs.end:
                    i.listener && i.listener.end && i.listener.end(i);
                    for (let l = 0; l < n.length; l++) {
                        const a = n[l];
                        a.end && a.end(i)
                    }
                case Vs.dispose:
                    i.listener && i.listener.dispose && i.listener.dispose(i);
                    for (let l = 0; l < n.length; l++) {
                        const a = n[l];
                        a.dispose && a.dispose(i)
                    }
                    this.animState.trackEntryPool.free(i);
                    break;
                case Vs.complete:
                    i.listener && i.listener.complete && i.listener.complete(i);
                    for (let l = 0; l < n.length; l++) {
                        const a = n[l];
                        a.complete && a.complete(i)
                    }
                    break;
                case Vs.event:
                    const o = e[s++ + 2];
                    i.listener && i.listener.event && i.listener.event(i, o);
                    for (let l = 0; l < n.length; l++) {
                        const a = n[l];
                        a.event && a.event(i, o)
                    }
                    break
            }
        }
        this.clear(),
            this.drainDisabled = !1
    }
    clear() {
        this.objects.length = 0
    }
}
var Vs = (t => (t[t.start = 0] = "start",
    t[t.interrupt = 1] = "interrupt",
    t[t.end = 2] = "end",
    t[t.dispose = 3] = "dispose",
    t[t.complete = 4] = "complete",
    t[t.event = 5] = "event",
    t))(Vs || {});
class Che {
    start(e) { }
    interrupt(e) { }
    end(e) { }
    dispose(e) { }
    complete(e) { }
    event(e, n) { }
}
const T1 = 0
    , yA = 1
    , bA = 2
    , C1 = 3
    , Ihe = 4
    , vA = 1
    , Ahe = 2;
class fL {
    constructor(e) {
        if (this.animationToMixTime = {},
            this.defaultMix = 0,
            !e)
            throw new Error("skeletonData cannot be null.");
        this.skeletonData = e
    }
    setMix(e, n, s) {
        const r = this.skeletonData.findAnimation(e);
        if (!r)
            throw new Error(`Animation not found: ${e}`);
        const i = this.skeletonData.findAnimation(n);
        if (!i)
            throw new Error(`Animation not found: ${n}`);
        this.setMixWith(r, i, s)
    }
    setMixWith(e, n, s) {
        if (!e)
            throw new Error("from cannot be null.");
        if (!n)
            throw new Error("to cannot be null.");
        const r = `${e.name}.${n.name}`;
        this.animationToMixTime[r] = s
    }
    getMix(e, n) {
        const s = `${e.name}.${n.name}`
            , r = this.animationToMixTime[s];
        return r === void 0 ? this.defaultMix : r
    }
}
class iS {
    constructor(e) {
        this.atlas = e
    }
    loadSequence(e, n, s) {
        const r = s.regions;
        for (let i = 0, o = r.length; i < o; i++) {
            const l = s.getPath(n, i)
                , a = this.atlas.findRegion(l);
            if (a == null)
                throw new Error(`Region not found in atlas: ${l} (sequence: ${e})`);
            r[i] = a,
                r[i].renderObject = r[i]
        }
    }
    newRegionAttachment(e, n, s, r) {
        const i = new Et(n, s);
        if (r != null)
            this.loadSequence(n, s, r);
        else {
            const o = this.atlas.findRegion(s);
            if (!o)
                throw new Error(`Region not found in atlas: ${s} (region attachment: ${n})`);
            o.renderObject = o,
                i.region = o
        }
        return i
    }
    newMeshAttachment(e, n, s, r) {
        const i = new uc(n, s);
        if (r != null)
            this.loadSequence(n, s, r);
        else {
            const o = this.atlas.findRegion(s);
            if (!o)
                throw new Error(`Region not found in atlas: ${s} (mesh attachment: ${n})`);
            o.renderObject = o,
                i.region = o
        }
        return i
    }
    newBoundingBoxAttachment(e, n) {
        return new H_(n)
    }
    newPathAttachment(e, n) {
        return new hc(n)
    }
    newPointAttachment(e, n) {
        return new Y_(n)
    }
    newClippingAttachment(e, n) {
        return new W_(n)
    }
}
class Kb {
    constructor(e, n, s) {
        if (this.matrix = new Bt,
            this.parent = null,
            this.children = new Array,
            this.x = 0,
            this.y = 0,
            this.rotation = 0,
            this.scaleX = 0,
            this.scaleY = 0,
            this.shearX = 0,
            this.shearY = 0,
            this.ax = 0,
            this.ay = 0,
            this.arotation = 0,
            this.ascaleX = 0,
            this.ascaleY = 0,
            this.ashearX = 0,
            this.ashearY = 0,
            this.sorted = !1,
            this.active = !1,
            !e)
            throw new Error("data cannot be null.");
        if (!n)
            throw new Error("skeleton cannot be null.");
        this.data = e,
            this.skeleton = n,
            this.parent = s,
            this.setToSetupPose()
    }
    get worldX() {
        return this.matrix.tx
    }
    get worldY() {
        return this.matrix.ty
    }
    isActive() {
        return this.active
    }
    update() {
        this.updateWorldTransformWith(this.ax, this.ay, this.arotation, this.ascaleX, this.ascaleY, this.ashearX, this.ashearY)
    }
    updateWorldTransform() {
        this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY)
    }
    updateWorldTransformWith(e, n, s, r, i, o, l) {
        this.ax = e,
            this.ay = n,
            this.arotation = s,
            this.ascaleX = r,
            this.ascaleY = i,
            this.ashearX = o,
            this.ashearY = l;
        const a = this.parent
            , c = this.matrix
            , u = this.skeleton.scaleX
            , h = -this.skeleton.scaleY;
        if (!a) {
            const g = this.skeleton
                , b = s + 90 + l;
            c.a = F.cosDeg(s + o) * r * u,
                c.c = F.cosDeg(b) * i * u,
                c.b = F.sinDeg(s + o) * r * h,
                c.d = F.sinDeg(b) * i * h,
                c.tx = e * u + g.x,
                c.ty = n * h + g.y;
            return
        }
        let d = a.matrix.a
            , f = a.matrix.c
            , p = a.matrix.b
            , m = a.matrix.d;
        switch (c.tx = d * e + f * n + a.matrix.tx,
        c.ty = p * e + m * n + a.matrix.ty,
        this.data.transformMode) {
            case Qe.Normal:
                {
                    const g = s + 90 + l
                        , b = F.cosDeg(s + o) * r
                        , v = F.cosDeg(g) * i
                        , _ = F.sinDeg(s + o) * r
                        , y = F.sinDeg(g) * i;
                    c.a = d * b + f * _,
                        c.c = d * v + f * y,
                        c.b = p * b + m * _,
                        c.d = p * v + m * y;
                    return
                }
            case Qe.OnlyTranslation:
                {
                    const g = s + 90 + l;
                    c.a = F.cosDeg(s + o) * r,
                        c.c = F.cosDeg(g) * i,
                        c.b = F.sinDeg(s + o) * r,
                        c.d = F.sinDeg(g) * i;
                    break
                }
            case Qe.NoRotationOrReflection:
                {
                    let g = d * d + p * p
                        , b = 0;
                    g > 1e-4 ? (g = Math.abs(d * m - f * p) / g,
                        d /= u,
                        p /= h,
                        f = p * g,
                        m = d * g,
                        b = Math.atan2(p, d) * F.radDeg) : (d = 0,
                            p = 0,
                            b = 90 - Math.atan2(m, f) * F.radDeg);
                    const v = s + o - b
                        , _ = s + l - b + 90
                        , y = F.cosDeg(v) * r
                        , x = F.cosDeg(_) * i
                        , w = F.sinDeg(v) * r
                        , S = F.sinDeg(_) * i;
                    c.a = d * y - f * w,
                        c.c = d * x - f * S,
                        c.b = p * y + m * w,
                        c.d = p * x + m * S;
                    break
                }
            case Qe.NoScale:
            case Qe.NoScaleOrReflection:
                {
                    const g = F.cosDeg(s)
                        , b = F.sinDeg(s);
                    let v = (d * g + f * b) / u
                        , _ = (p * g + m * b) / h
                        , y = Math.sqrt(v * v + _ * _);
                    y > 1e-5 && (y = 1 / y),
                        v *= y,
                        _ *= y,
                        y = Math.sqrt(v * v + _ * _),
                        this.data.transformMode == Qe.NoScale && d * m - f * p < 0 != (u < 0 != h < 0) && (y = -y);
                    const x = Math.PI / 2 + Math.atan2(_, v)
                        , w = Math.cos(x) * y
                        , S = Math.sin(x) * y
                        , E = F.cosDeg(o) * r
                        , C = F.cosDeg(90 + l) * i
                        , I = F.sinDeg(o) * r
                        , L = F.sinDeg(90 + l) * i;
                    c.a = v * E + w * I,
                        c.c = v * C + w * L,
                        c.b = _ * E + S * I,
                        c.d = _ * C + S * L;
                    break
                }
        }
        c.a *= u,
            c.c *= u,
            c.b *= h,
            c.d *= h
    }
    setToSetupPose() {
        const e = this.data;
        this.x = e.x,
            this.y = e.y,
            this.rotation = e.rotation,
            this.scaleX = e.scaleX,
            this.scaleY = e.scaleY,
            this.shearX = e.shearX,
            this.shearY = e.shearY
    }
    getWorldRotationX() {
        return Math.atan2(this.matrix.b, this.matrix.a) * F.radDeg
    }
    getWorldRotationY() {
        return Math.atan2(this.matrix.d, this.matrix.c) * F.radDeg
    }
    getWorldScaleX() {
        const e = this.matrix;
        return Math.sqrt(e.a * e.a + e.b * e.b)
    }
    getWorldScaleY() {
        const e = this.matrix;
        return Math.sqrt(e.c * e.c + e.d * e.d)
    }
    updateAppliedTransform() {
        const e = this.parent
            , n = this.matrix;
        if (!e) {
            this.ax = n.tx - this.skeleton.x,
                this.ay = n.ty - this.skeleton.y,
                this.arotation = Math.atan2(n.b, n.a) * F.radDeg,
                this.ascaleX = Math.sqrt(n.a * n.a + n.b * n.b),
                this.ascaleY = Math.sqrt(n.c * n.c + n.d * n.d),
                this.ashearX = 0,
                this.ashearY = Math.atan2(n.a * n.c + n.b * n.d, n.a * n.d - n.b * n.c) * F.radDeg;
            return
        }
        const s = e.matrix
            , r = 1 / (s.a * s.d - s.b * s.c)
            , i = n.tx - s.tx
            , o = n.ty - s.ty;
        this.ax = i * s.d * r - o * s.c * r,
            this.ay = o * s.a * r - i * s.b * r;
        const l = r * s.d
            , a = r * s.a
            , c = r * s.c
            , u = r * s.b
            , h = l * n.a - c * n.b
            , d = l * n.c - c * n.d
            , f = a * n.b - u * n.a
            , p = a * n.d - u * n.c;
        if (this.ashearX = 0,
            this.ascaleX = Math.sqrt(h * h + f * f),
            this.ascaleX > 1e-4) {
            const m = h * p - d * f;
            this.ascaleY = m / this.ascaleX,
                this.ashearY = Math.atan2(h * d + f * p, m) * F.radDeg,
                this.arotation = Math.atan2(f, h) * F.radDeg
        } else
            this.ascaleX = 0,
                this.ascaleY = Math.sqrt(d * d + p * p),
                this.ashearY = 0,
                this.arotation = 90 - Math.atan2(p, d) * F.radDeg
    }
    worldToLocal(e) {
        const n = this.matrix
            , s = n.a
            , r = n.c
            , i = n.b
            , o = n.d
            , l = 1 / (s * o - r * i)
            , a = e.x - n.tx
            , c = e.y - n.ty;
        return e.x = a * o * l - c * r * l,
            e.y = c * s * l - a * i * l,
            e
    }
    localToWorld(e) {
        const n = this.matrix
            , s = e.x
            , r = e.y;
        return e.x = s * n.a + r * n.c + n.tx,
            e.y = s * n.b + r * n.d + n.ty,
            e
    }
    worldToLocalRotation(e) {
        const n = F.sinDeg(e)
            , s = F.cosDeg(e)
            , r = this.matrix;
        return Math.atan2(r.a * n - r.b * s, r.d * s - r.c * n) * F.radDeg
    }
    localToWorldRotation(e) {
        e -= this.rotation - this.shearX;
        const n = F.sinDeg(e)
            , s = F.cosDeg(e)
            , r = this.matrix;
        return Math.atan2(s * r.b + n * r.d, s * r.a + n * r.c) * F.radDeg
    }
    rotateWorld(e) {
        const n = this.matrix
            , s = n.a
            , r = n.c
            , i = n.b
            , o = n.d
            , l = F.cosDeg(e)
            , a = F.sinDeg(e);
        n.a = l * s - a * i,
            n.c = l * r - a * o,
            n.b = a * s + l * i,
            n.d = a * r + l * o
    }
}
class oS {
    constructor(e, n, s) {
        if (this.index = 0,
            this.parent = null,
            this.length = 0,
            this.x = 0,
            this.y = 0,
            this.rotation = 0,
            this.scaleX = 1,
            this.scaleY = 1,
            this.shearX = 0,
            this.shearY = 0,
            this.transformMode = Qe.Normal,
            this.skinRequired = !1,
            this.color = new Se,
            e < 0)
            throw new Error("index must be >= 0.");
        if (!n)
            throw new Error("name cannot be null.");
        this.index = e,
            this.name = n,
            this.parent = s
    }
}
class K_ {
    constructor(e, n, s) {
        this.name = e,
            this.order = n,
            this.skinRequired = s
    }
}
let aS = class {
    constructor(e, n) {
        if (this.intValue = 0,
            this.floatValue = 0,
            this.stringValue = null,
            this.time = 0,
            this.volume = 0,
            this.balance = 0,
            !n)
            throw new Error("data cannot be null.");
        this.time = e,
            this.data = n
    }
}
    ;
class lS {
    constructor(e) {
        this.intValue = 0,
            this.floatValue = 0,
            this.stringValue = null,
            this.audioPath = null,
            this.volume = 0,
            this.balance = 0,
            this.name = e
    }
}
class pL {
    constructor(e, n) {
        if (this.bendDirection = 0,
            this.compress = !1,
            this.stretch = !1,
            this.mix = 1,
            this.softness = 0,
            this.active = !1,
            !e)
            throw new Error("data cannot be null.");
        if (!n)
            throw new Error("skeleton cannot be null.");
        this.data = e,
            this.mix = e.mix,
            this.softness = e.softness,
            this.bendDirection = e.bendDirection,
            this.compress = e.compress,
            this.stretch = e.stretch,
            this.bones = new Array;
        for (let r = 0; r < e.bones.length; r++) {
            const i = n.findBone(e.bones[r].name);
            if (!i)
                throw new Error(`Couldn't find bone ${e.bones[r].name}`);
            this.bones.push(i)
        }
        const s = n.findBone(e.target.name);
        if (!s)
            throw new Error(`Couldn't find bone ${e.target.name}`);
        this.target = s
    }
    isActive() {
        return this.active
    }
    update() {
        if (this.mix == 0)
            return;
        const e = this.target
            , n = this.bones;
        switch (n.length) {
            case 1:
                this.apply1(n[0], e.worldX, e.worldY, this.compress, this.stretch, this.data.uniform, this.mix);
                break;
            case 2:
                this.apply2(n[0], n[1], e.worldX, e.worldY, this.bendDirection, this.stretch, this.data.uniform, this.softness, this.mix);
                break
        }
    }
    apply1(e, n, s, r, i, o, l) {
        const a = e.parent.matrix;
        if (!a)
            throw new Error("IK bone must have parent.");
        const c = a.a;
        let u = a.c;
        const h = a.b;
        let d = a.d
            , f = -e.ashearX - e.arotation
            , p = 0
            , m = 0;
        const g = e.skeleton.scaleX
            , b = -e.skeleton.scaleY;
        switch (e.data.transformMode) {
            case Qe.OnlyTranslation:
                p = n - e.worldX,
                    m = s - e.worldY,
                    m = -m;
                break;
            case Qe.NoRotationOrReflection:
                const y = Math.abs(c * d - u * h) / (c * c + h * h)
                    , x = c / g
                    , w = h / b;
                u = -w * y * g,
                    d = x * y * b,
                    f += Math.atan2(w, x) * F.radDeg;
            default:
                const S = n - a.tx
                    , E = s - a.ty
                    , C = c * d - u * h;
                p = (S * d - E * u) / C - e.ax,
                    m = (E * c - S * h) / C - e.ay
        }
        f += Math.atan2(m, p) * F.radDeg,
            e.ascaleX < 0 && (f += 180),
            f > 180 ? f -= 360 : f < -180 && (f += 360);
        let v = e.ascaleX
            , _ = e.ascaleY;
        if (r || i) {
            switch (e.data.transformMode) {
                case Qe.NoScale:
                case Qe.NoScaleOrReflection:
                    p = n - e.worldX,
                        m = s - e.worldY
            }
            const y = e.data.length * v
                , x = Math.sqrt(p * p + m * m);
            if (r && x < y || i && x > y && y > 1e-4) {
                const w = (x / y - 1) * l + 1;
                v *= w,
                    o && (_ *= w)
            }
        }
        e.updateWorldTransformWith(e.ax, e.ay, e.arotation + f * l, v, _, e.ashearX, e.ashearY)
    }
    apply2(e, n, s, r, i, o, l, a, c) {
        const u = e.ax
            , h = e.ay;
        let d = e.ascaleX
            , f = e.ascaleY
            , p = d
            , m = f
            , g = n.ascaleX;
        const b = e.matrix;
        let v = 0
            , _ = 0
            , y = 0;
        d < 0 ? (d = -d,
            v = 180,
            y = -1) : (v = 0,
                y = 1),
            f < 0 && (f = -f,
                y = -y),
            g < 0 ? (g = -g,
                _ = 180) : _ = 0;
        const x = n.ax;
        let w = 0
            , S = 0
            , E = 0
            , C = b.a
            , I = b.c
            , L = b.b
            , k = b.d;
        const R = Math.abs(d - f) <= 1e-4;
        !R || o ? (w = 0,
            S = C * x + b.tx,
            E = L * x + b.ty) : (w = n.ay,
                S = C * x + I * w + b.tx,
                E = L * x + k * w + b.ty);
        const U = e.parent.matrix;
        if (!U)
            throw new Error("IK parent must itself have a parent.");
        C = U.a,
            I = U.c,
            L = U.b,
            k = U.d;
        const W = 1 / (C * k - I * L);
        let H = S - U.tx
            , j = E - U.ty;
        const z = (H * k - j * I) * W - u
            , ee = (j * C - H * L) * W - h
            , J = Math.sqrt(z * z + ee * ee);
        let Y = n.data.length * g, ne, oe;
        if (J < 1e-4) {
            this.apply1(e, s, r, !1, o, !1, c),
                n.updateWorldTransformWith(x, w, 0, n.ascaleX, n.ascaleY, n.ashearX, n.ashearY);
            return
        }
        H = s - U.tx,
            j = r - U.ty;
        let ce = (H * k - j * I) * W - u
            , ue = (j * C - H * L) * W - h
            , we = ce * ce + ue * ue;
        if (a != 0) {
            a *= d * (g + 1) * .5;
            const he = Math.sqrt(we)
                , be = he - J - Y * d + a;
            if (be > 0) {
                let Pe = Math.min(1, be / (a * 2)) - 1;
                Pe = (be - a * (1 - Pe * Pe)) / he,
                    ce -= Pe * ce,
                    ue -= Pe * ue,
                    we = ce * ce + ue * ue
            }
        }
        e: if (R) {
            Y *= d;
            let he = (we - J * J - Y * Y) / (2 * J * Y);
            he < -1 ? (he = -1,
                oe = Math.PI * i) : he > 1 ? (he = 1,
                    oe = 0,
                    o && (C = (Math.sqrt(we) / (J + Y) - 1) * c + 1,
                        p *= C,
                        l && (m *= C))) : oe = Math.acos(he) * i,
                C = J + Y * he,
                I = Y * Math.sin(oe),
                ne = Math.atan2(ue * C - ce * I, ce * C + ue * I)
        } else {
            C = d * Y,
                I = f * Y;
            const he = C * C
                , be = I * I
                , Pe = Math.atan2(ue, ce);
            L = be * J * J + he * we - he * be;
            const De = -2 * be * J
                , D = be - he;
            if (k = De * De - 4 * D * L,
                k >= 0) {
                let V = Math.sqrt(k);
                De < 0 && (V = -V),
                    V = -(De + V) * .5;
                const re = V / D
                    , ye = L / V
                    , me = Math.abs(re) < Math.abs(ye) ? re : ye;
                if (me * me <= we) {
                    j = Math.sqrt(we - me * me) * i,
                        ne = Pe - Math.atan2(j, me),
                        oe = Math.atan2(j / f, (me - J) / d);
                    break e
                }
            }
            let M = F.PI
                , X = J - C
                , ae = X * X
                , ie = 0
                , pe = 0
                , xe = J + C
                , P = xe * xe
                , B = 0;
            L = -C * J / (he - be),
                L >= -1 && L <= 1 && (L = Math.acos(L),
                    H = C * Math.cos(L) + J,
                    j = I * Math.sin(L),
                    k = H * H + j * j,
                    k < ae && (M = L,
                        ae = k,
                        X = H,
                        ie = j),
                    k > P && (pe = L,
                        P = k,
                        xe = H,
                        B = j)),
                we <= (ae + P) * .5 ? (ne = Pe - Math.atan2(ie * i, X),
                    oe = M * i) : (ne = Pe - Math.atan2(B * i, xe),
                        oe = pe * i)
        }
        const K = Math.atan2(w, x) * y;
        let ge = e.arotation;
        ne = (ne - K) * F.radDeg + v - ge,
            ne > 180 ? ne -= 360 : ne < -180 && (ne += 360),
            e.updateWorldTransformWith(u, h, ge + ne * c, p, m, 0, 0),
            ge = n.arotation,
            oe = ((oe + K) * F.radDeg - n.ashearX) * y + _ - ge,
            oe > 180 ? oe -= 360 : oe < -180 && (oe += 360),
            n.updateWorldTransformWith(x, w, ge + oe * c, n.ascaleX, n.ascaleY, n.ashearX, n.ashearY)
    }
}
class cS extends K_ {
    constructor(e) {
        super(e, 0, !1),
            this.bones = new Array,
            this._target = null,
            this.bendDirection = 1,
            this.compress = !1,
            this.stretch = !1,
            this.uniform = !1,
            this.mix = 1,
            this.softness = 0
    }
    set target(e) {
        this._target = e
    }
    get target() {
        if (this._target)
            return this._target;
        throw new Error("BoneData not set.")
    }
}
class uS extends K_ {
    constructor(e) {
        super(e, 0, !1),
            this.bones = new Array,
            this._target = null,
            this.positionMode = on.Fixed,
            this.spacingMode = Rn.Fixed,
            this.rotateMode = bn.Chain,
            this.offsetRotation = 0,
            this.position = 0,
            this.spacing = 0,
            this.mixRotate = 0,
            this.mixX = 0,
            this.mixY = 0
    }
    set target(e) {
        this._target = e
    }
    get target() {
        if (this._target)
            return this._target;
        throw new Error("SlotData not set.")
    }
}
var Rn = (t => (t[t.Length = 0] = "Length",
    t[t.Fixed = 1] = "Fixed",
    t[t.Percent = 2] = "Percent",
    t[t.Proportional = 3] = "Proportional",
    t))(Rn || {});
const co = class {
    constructor(t, e) {
        if (this.position = 0,
            this.spacing = 0,
            this.mixRotate = 0,
            this.mixX = 0,
            this.mixY = 0,
            this.spaces = new Array,
            this.positions = new Array,
            this.world = new Array,
            this.curves = new Array,
            this.lengths = new Array,
            this.segments = new Array,
            this.active = !1,
            !t)
            throw new Error("data cannot be null.");
        if (!e)
            throw new Error("skeleton cannot be null.");
        this.data = t,
            this.bones = new Array;
        for (let s = 0, r = t.bones.length; s < r; s++) {
            const i = e.findBone(t.bones[s].name);
            if (!i)
                throw new Error(`Couldn't find bone ${t.bones[s].name}.`);
            this.bones.push(i)
        }
        const n = e.findSlot(t.target.name);
        if (!n)
            throw new Error(`Couldn't find target bone ${t.target.name}`);
        this.target = n,
            this.position = t.position,
            this.spacing = t.spacing,
            this.mixRotate = t.mixRotate,
            this.mixX = t.mixX,
            this.mixY = t.mixY
    }
    isActive() {
        return this.active
    }
    update() {
        const t = this.target.getAttachment();
        if (!(t instanceof hc))
            return;
        const e = this.mixRotate
            , n = this.mixX
            , s = this.mixY;
        if (e == 0 && n == 0 && s == 0)
            return;
        const r = this.data
            , i = r.rotateMode == bn.Tangent
            , o = r.rotateMode == bn.ChainScale
            , l = this.bones
            , a = l.length
            , c = i ? a : a + 1
            , u = Q.setArraySize(this.spaces, c)
            , h = o ? this.lengths = Q.setArraySize(this.lengths, a) : []
            , d = this.spacing;
        switch (r.spacingMode) {
            case Rn.Percent:
                if (o)
                    for (let y = 0, x = c - 1; y < x; y++) {
                        const w = l[y]
                            , S = w.data.length;
                        if (S < co.epsilon)
                            h[y] = 0;
                        else {
                            const E = S * w.matrix.a
                                , C = S * w.matrix.b;
                            h[y] = Math.sqrt(E * E + C * C)
                        }
                    }
                Q.arrayFill(u, 1, c, d);
                break;
            case Rn.Proportional:
                let v = 0;
                for (let y = 0, x = c - 1; y < x;) {
                    const w = l[y]
                        , S = w.data.length;
                    if (S < co.epsilon)
                        o && (h[y] = 0),
                            u[++y] = d;
                    else {
                        const E = S * w.matrix.a
                            , C = S * w.matrix.b
                            , I = Math.sqrt(E * E + C * C);
                        o && (h[y] = I),
                            u[++y] = I,
                            v += I
                    }
                }
                if (v > 0) {
                    v = c / v * d;
                    for (let y = 1; y < c; y++)
                        u[y] *= v
                }
                break;
            default:
                const _ = r.spacingMode == Rn.Length;
                for (let y = 0, x = c - 1; y < x;) {
                    const w = l[y]
                        , S = w.data.length;
                    if (S < co.epsilon)
                        o && (h[y] = 0),
                            u[++y] = d;
                    else {
                        const E = S * w.matrix.a
                            , C = S * w.matrix.b
                            , I = Math.sqrt(E * E + C * C);
                        o && (h[y] = I),
                            u[++y] = (_ ? S + d : d) * I / S
                    }
                }
        }
        const f = this.computeWorldPositions(t, c, i);
        let p = f[0]
            , m = f[1]
            , g = r.offsetRotation
            , b = !1;
        if (g == 0)
            b = r.rotateMode == bn.Chain;
        else {
            b = !1;
            const v = this.target.bone.matrix;
            g *= v.a * v.d - v.b * v.c > 0 ? F.degRad : -F.degRad
        }
        for (let v = 0, _ = 3; v < a; v++,
            _ += 3) {
            const y = l[v]
                , x = y.matrix;
            x.tx += (p - x.tx) * n,
                x.ty += (m - x.ty) * s;
            const w = f[_]
                , S = f[_ + 1]
                , E = w - p
                , C = S - m;
            if (o) {
                const I = h[v];
                if (I != 0) {
                    const L = (Math.sqrt(E * E + C * C) / I - 1) * e + 1;
                    x.a *= L,
                        x.b *= L
                }
            }
            if (p = w,
                m = S,
                e > 0) {
                const I = x.a
                    , L = x.c
                    , k = x.b
                    , R = x.d;
                let U = 0
                    , W = 0
                    , H = 0;
                if (i ? U = f[_ - 1] : u[v + 1] == 0 ? U = f[_ + 2] : U = Math.atan2(C, E),
                    U -= Math.atan2(k, I),
                    b) {
                    W = Math.cos(U),
                        H = Math.sin(U);
                    const j = y.data.length;
                    p += (j * (W * I - H * k) - E) * e,
                        m += (j * (H * I + W * k) - C) * e
                } else
                    U += g;
                U > F.PI ? U -= F.PI2 : U < -F.PI && (U += F.PI2),
                    U *= e,
                    W = Math.cos(U),
                    H = Math.sin(U),
                    x.a = W * I - H * k,
                    x.c = W * L - H * R,
                    x.b = H * I + W * k,
                    x.d = H * L + W * R
            }
            y.updateAppliedTransform()
        }
    }
    computeWorldPositions(t, e, n) {
        const s = this.target;
        let r = this.position;
        const i = this.spaces
            , o = Q.setArraySize(this.positions, e * 3 + 2);
        let l = this.world;
        const a = t.closed;
        let c = t.worldVerticesLength
            , u = c / 6
            , h = co.NONE;
        if (!t.constantSpeed) {
            const j = t.lengths;
            u -= a ? 1 : 2;
            const z = j[u];
            this.data.positionMode == on.Percent && (r *= z);
            let ee;
            switch (this.data.spacingMode) {
                case Rn.Percent:
                    ee = z;
                    break;
                case Rn.Proportional:
                    ee = z / e;
                    break;
                default:
                    ee = 1
            }
            l = Q.setArraySize(this.world, 8);
            for (let J = 0, Y = 0, ne = 0; J < e; J++,
                Y += 3) {
                const oe = i[J] * ee;
                r += oe;
                let ce = r;
                if (a)
                    ce %= z,
                        ce < 0 && (ce += z),
                        ne = 0;
                else if (ce < 0) {
                    h != co.BEFORE && (h = co.BEFORE,
                        t.computeWorldVertices(s, 2, 4, l, 0, 2)),
                        this.addBeforePosition(ce, l, 0, o, Y);
                    continue
                } else if (ce > z) {
                    h != co.AFTER && (h = co.AFTER,
                        t.computeWorldVertices(s, c - 6, 4, l, 0, 2)),
                        this.addAfterPosition(ce - z, l, 0, o, Y);
                    continue
                }
                for (; ; ne++) {
                    const ue = j[ne];
                    if (!(ce > ue)) {
                        if (ne == 0)
                            ce /= ue;
                        else {
                            const we = j[ne - 1];
                            ce = (ce - we) / (ue - we)
                        }
                        break
                    }
                }
                ne != h && (h = ne,
                    a && ne == u ? (t.computeWorldVertices(s, c - 4, 4, l, 0, 2),
                        t.computeWorldVertices(s, 0, 4, l, 4, 2)) : t.computeWorldVertices(s, ne * 6 + 2, 8, l, 0, 2)),
                    this.addCurvePosition(ce, l[0], l[1], l[2], l[3], l[4], l[5], l[6], l[7], o, Y, n || J > 0 && oe == 0)
            }
            return o
        }
        a ? (c += 2,
            l = Q.setArraySize(this.world, c),
            t.computeWorldVertices(s, 2, c - 4, l, 0, 2),
            t.computeWorldVertices(s, 0, 2, l, c - 4, 2),
            l[c - 2] = l[0],
            l[c - 1] = l[1]) : (u--,
                c -= 4,
                l = Q.setArraySize(this.world, c),
                t.computeWorldVertices(s, 2, c, l, 0, 2));
        const d = Q.setArraySize(this.curves, u);
        let f = 0
            , p = l[0]
            , m = l[1]
            , g = 0
            , b = 0
            , v = 0
            , _ = 0
            , y = 0
            , x = 0
            , w = 0
            , S = 0
            , E = 0
            , C = 0
            , I = 0
            , L = 0
            , k = 0
            , R = 0;
        for (let j = 0, z = 2; j < u; j++,
            z += 6)
            g = l[z],
                b = l[z + 1],
                v = l[z + 2],
                _ = l[z + 3],
                y = l[z + 4],
                x = l[z + 5],
                w = (p - g * 2 + v) * .1875,
                S = (m - b * 2 + _) * .1875,
                E = ((g - v) * 3 - p + y) * .09375,
                C = ((b - _) * 3 - m + x) * .09375,
                I = w * 2 + E,
                L = S * 2 + C,
                k = (g - p) * .75 + w + E * .16666667,
                R = (b - m) * .75 + S + C * .16666667,
                f += Math.sqrt(k * k + R * R),
                k += I,
                R += L,
                I += E,
                L += C,
                f += Math.sqrt(k * k + R * R),
                k += I,
                R += L,
                f += Math.sqrt(k * k + R * R),
                k += I + E,
                R += L + C,
                f += Math.sqrt(k * k + R * R),
                d[j] = f,
                p = y,
                m = x;
        this.data.positionMode == on.Percent && (r *= f);
        let U;
        switch (this.data.spacingMode) {
            case Rn.Percent:
                U = f;
                break;
            case Rn.Proportional:
                U = f / e;
                break;
            default:
                U = 1
        }
        const W = this.segments;
        let H = 0;
        for (let j = 0, z = 0, ee = 0, J = 0; j < e; j++,
            z += 3) {
            const Y = i[j] * U;
            r += Y;
            let ne = r;
            if (a)
                ne %= f,
                    ne < 0 && (ne += f),
                    ee = 0;
            else if (ne < 0) {
                this.addBeforePosition(ne, l, 0, o, z);
                continue
            } else if (ne > f) {
                this.addAfterPosition(ne - f, l, c - 4, o, z);
                continue
            }
            for (; ; ee++) {
                const oe = d[ee];
                if (!(ne > oe)) {
                    if (ee == 0)
                        ne /= oe;
                    else {
                        const ce = d[ee - 1];
                        ne = (ne - ce) / (oe - ce)
                    }
                    break
                }
            }
            if (ee != h) {
                h = ee;
                let oe = ee * 6;
                for (p = l[oe],
                    m = l[oe + 1],
                    g = l[oe + 2],
                    b = l[oe + 3],
                    v = l[oe + 4],
                    _ = l[oe + 5],
                    y = l[oe + 6],
                    x = l[oe + 7],
                    w = (p - g * 2 + v) * .03,
                    S = (m - b * 2 + _) * .03,
                    E = ((g - v) * 3 - p + y) * .006,
                    C = ((b - _) * 3 - m + x) * .006,
                    I = w * 2 + E,
                    L = S * 2 + C,
                    k = (g - p) * .3 + w + E * .16666667,
                    R = (b - m) * .3 + S + C * .16666667,
                    H = Math.sqrt(k * k + R * R),
                    W[0] = H,
                    oe = 1; oe < 8; oe++)
                    k += I,
                        R += L,
                        I += E,
                        L += C,
                        H += Math.sqrt(k * k + R * R),
                        W[oe] = H;
                k += I,
                    R += L,
                    H += Math.sqrt(k * k + R * R),
                    W[8] = H,
                    k += I + E,
                    R += L + C,
                    H += Math.sqrt(k * k + R * R),
                    W[9] = H,
                    J = 0
            }
            for (ne *= H; ; J++) {
                const oe = W[J];
                if (!(ne > oe)) {
                    if (J == 0)
                        ne /= oe;
                    else {
                        const ce = W[J - 1];
                        ne = J + (ne - ce) / (oe - ce)
                    }
                    break
                }
            }
            this.addCurvePosition(ne * .1, p, m, g, b, v, _, y, x, o, z, n || j > 0 && Y == 0)
        }
        return o
    }
    addBeforePosition(t, e, n, s, r) {
        const i = e[n]
            , o = e[n + 1]
            , l = e[n + 2] - i
            , a = e[n + 3] - o
            , c = Math.atan2(a, l);
        s[r] = i + t * Math.cos(c),
            s[r + 1] = o + t * Math.sin(c),
            s[r + 2] = c
    }
    addAfterPosition(t, e, n, s, r) {
        const i = e[n + 2]
            , o = e[n + 3]
            , l = i - e[n]
            , a = o - e[n + 1]
            , c = Math.atan2(a, l);
        s[r] = i + t * Math.cos(c),
            s[r + 1] = o + t * Math.sin(c),
            s[r + 2] = c
    }
    addCurvePosition(t, e, n, s, r, i, o, l, a, c, u, h) {
        if (t == 0 || isNaN(t)) {
            c[u] = e,
                c[u + 1] = n,
                c[u + 2] = Math.atan2(r - n, s - e);
            return
        }
        const d = t * t
            , f = d * t
            , p = 1 - t
            , m = p * p
            , g = m * p
            , b = p * t
            , v = b * 3
            , _ = p * v
            , y = v * t
            , x = e * g + s * _ + i * y + l * f
            , w = n * g + r * _ + o * y + a * f;
        c[u] = x,
            c[u + 1] = w,
            h && (t < .001 ? c[u + 2] = Math.atan2(r - n, s - e) : c[u + 2] = Math.atan2(w - (n * m + r * b * 2 + o * d), x - (e * m + s * b * 2 + i * d)))
    }
}
    ;
let vh = co;
vh.NONE = -1;
vh.BEFORE = -2;
vh.AFTER = -3;
vh.epsilon = 1e-5;
class mL {
    constructor(e, n) {
        if (this.darkColor = null,
            this.attachment = null,
            this.attachmentState = 0,
            this.sequenceIndex = -1,
            this.deform = new Array,
            !e)
            throw new Error("data cannot be null.");
        if (!n)
            throw new Error("bone cannot be null.");
        this.data = e,
            this.bone = n,
            this.color = new Se,
            this.darkColor = e.darkColor ? new Se : null,
            this.setToSetupPose(),
            this.blendMode = this.data.blendMode
    }
    getSkeleton() {
        return this.bone.skeleton
    }
    getAttachment() {
        return this.attachment
    }
    setAttachment(e) {
        this.attachment != e && ((!(e instanceof di) || !(this.attachment instanceof di) || e.timelineAttachment != this.attachment.timelineAttachment) && (this.deform.length = 0),
            this.attachment = e,
            this.sequenceIndex = -1)
    }
    setToSetupPose() {
        this.color.setFromColor(this.data.color),
            this.darkColor && this.darkColor.setFromColor(this.data.darkColor),
            this.data.attachmentName ? (this.attachment = null,
                this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName))) : this.attachment = null
    }
}
class gL {
    constructor(e, n) {
        if (this.mixRotate = 0,
            this.mixX = 0,
            this.mixY = 0,
            this.mixScaleX = 0,
            this.mixScaleY = 0,
            this.mixShearY = 0,
            this.temp = new Fd,
            this.active = !1,
            !e)
            throw new Error("data cannot be null.");
        if (!n)
            throw new Error("skeleton cannot be null.");
        this.data = e,
            this.mixRotate = e.mixRotate,
            this.mixX = e.mixX,
            this.mixY = e.mixY,
            this.mixScaleX = e.mixScaleX,
            this.mixScaleY = e.mixScaleY,
            this.mixShearY = e.mixShearY,
            this.bones = new Array;
        for (let r = 0; r < e.bones.length; r++) {
            const i = n.findBone(e.bones[r].name);
            if (!i)
                throw new Error(`Couldn't find bone ${e.bones[r].name}.`);
            this.bones.push(i)
        }
        const s = n.findBone(e.target.name);
        if (!s)
            throw new Error(`Couldn't find target bone ${e.target.name}.`);
        this.target = s
    }
    isActive() {
        return this.active
    }
    update() {
        this.mixRotate == 0 && this.mixX == 0 && this.mixY == 0 && this.mixScaleX == 0 && this.mixScaleX == 0 && this.mixShearY == 0 || (this.data.local ? this.data.relative ? this.applyRelativeLocal() : this.applyAbsoluteLocal() : this.data.relative ? this.applyRelativeWorld() : this.applyAbsoluteWorld())
    }
    applyAbsoluteWorld() {
        const e = this.mixRotate
            , n = this.mixX
            , s = this.mixY
            , r = this.mixScaleX
            , i = this.mixScaleY
            , o = this.mixShearY
            , l = n != 0 || s != 0
            , a = this.target
            , c = a.matrix
            , u = c.a
            , h = c.c
            , d = c.b
            , f = c.d
            , p = u * f - h * d > 0 ? F.degRad : -F.degRad
            , m = this.data.offsetRotation * p
            , g = this.data.offsetShearY * p
            , b = this.bones;
        for (let v = 0, _ = b.length; v < _; v++) {
            const y = b[v]
                , x = y.matrix;
            if (e != 0) {
                const w = x.a
                    , S = x.c
                    , E = x.b
                    , C = x.d;
                let I = Math.atan2(d, u) - Math.atan2(E, w) + m;
                I > F.PI ? I -= F.PI2 : I < -F.PI && (I += F.PI2),
                    I *= e;
                const L = Math.cos(I)
                    , k = Math.sin(I);
                x.a = L * w - k * E,
                    x.c = L * S - k * C,
                    x.b = k * w + L * E,
                    x.d = k * S + L * C
            }
            if (l) {
                const w = this.temp;
                a.localToWorld(w.set(this.data.offsetX, this.data.offsetY)),
                    x.tx += (w.x - x.tx) * n,
                    x.ty += (w.y - x.ty) * s
            }
            if (r != 0) {
                let w = Math.sqrt(x.a * x.a + x.b * x.b);
                w != 0 && (w = (w + (Math.sqrt(u * u + d * d) - w + this.data.offsetScaleX) * r) / w),
                    x.a *= w,
                    x.b *= w
            }
            if (i != 0) {
                let w = Math.sqrt(x.c * x.c + x.d * x.d);
                w != 0 && (w = (w + (Math.sqrt(h * h + f * f) - w + this.data.offsetScaleY) * i) / w),
                    x.c *= w,
                    x.d *= w
            }
            if (o > 0) {
                const w = x.c
                    , S = x.d
                    , E = Math.atan2(S, w);
                let C = Math.atan2(f, h) - Math.atan2(d, u) - (E - Math.atan2(x.b, x.a));
                C > F.PI ? C -= F.PI2 : C < -F.PI && (C += F.PI2),
                    C = E + (C + g) * o;
                const I = Math.sqrt(w * w + S * S);
                x.c = Math.cos(C) * I,
                    x.d = Math.sin(C) * I
            }
            y.updateAppliedTransform()
        }
    }
    applyRelativeWorld() {
        const e = this.mixRotate
            , n = this.mixX
            , s = this.mixY
            , r = this.mixScaleX
            , i = this.mixScaleY
            , o = this.mixShearY
            , l = n != 0 || s != 0
            , a = this.target
            , c = a.matrix
            , u = c.a
            , h = c.c
            , d = c.b
            , f = c.d
            , p = u * f - h * d > 0 ? F.degRad : -F.degRad
            , m = this.data.offsetRotation * p
            , g = this.data.offsetShearY * p
            , b = this.bones;
        for (let v = 0, _ = b.length; v < _; v++) {
            const y = b[v]
                , x = y.matrix;
            if (e != 0) {
                const w = x.a
                    , S = x.c
                    , E = x.b
                    , C = x.d;
                let I = Math.atan2(d, u) + m;
                I > F.PI ? I -= F.PI2 : I < -F.PI && (I += F.PI2),
                    I *= e;
                const L = Math.cos(I)
                    , k = Math.sin(I);
                x.a = L * w - k * E,
                    x.c = L * S - k * C,
                    x.b = k * w + L * E,
                    x.d = k * S + L * C
            }
            if (l) {
                const w = this.temp;
                a.localToWorld(w.set(this.data.offsetX, this.data.offsetY)),
                    x.tx += w.x * n,
                    x.ty += w.y * s
            }
            if (r != 0) {
                const w = (Math.sqrt(u * u + d * d) - 1 + this.data.offsetScaleX) * r + 1;
                x.a *= w,
                    x.b *= w
            }
            if (i != 0) {
                const w = (Math.sqrt(h * h + f * f) - 1 + this.data.offsetScaleY) * i + 1;
                x.c *= w,
                    x.d *= w
            }
            if (o > 0) {
                let w = Math.atan2(f, h) - Math.atan2(d, u);
                w > F.PI ? w -= F.PI2 : w < -F.PI && (w += F.PI2);
                const S = x.c
                    , E = x.d;
                w = Math.atan2(E, S) + (w - F.PI / 2 + g) * o;
                const C = Math.sqrt(S * S + E * E);
                x.c = Math.cos(w) * C,
                    x.d = Math.sin(w) * C
            }
            y.updateAppliedTransform()
        }
    }
    applyAbsoluteLocal() {
        const e = this.mixRotate
            , n = this.mixX
            , s = this.mixY
            , r = this.mixScaleX
            , i = this.mixScaleY
            , o = this.mixShearY
            , l = this.target
            , a = this.bones;
        for (let c = 0, u = a.length; c < u; c++) {
            const h = a[c];
            let d = h.arotation;
            if (e != 0) {
                let v = l.arotation - d + this.data.offsetRotation;
                v -= (16384 - (16384.499999999996 - v / 360 | 0)) * 360,
                    d += v * e
            }
            let f = h.ax
                , p = h.ay;
            f += (l.ax - f + this.data.offsetX) * n,
                p += (l.ay - p + this.data.offsetY) * s;
            let m = h.ascaleX
                , g = h.ascaleY;
            r != 0 && m != 0 && (m = (m + (l.ascaleX - m + this.data.offsetScaleX) * r) / m),
                i != 0 && g != 0 && (g = (g + (l.ascaleY - g + this.data.offsetScaleY) * i) / g);
            let b = h.ashearY;
            if (o != 0) {
                let v = l.ashearY - b + this.data.offsetShearY;
                v -= (16384 - (16384.499999999996 - v / 360 | 0)) * 360,
                    b += v * o
            }
            h.updateWorldTransformWith(f, p, d, m, g, h.ashearX, b)
        }
    }
    applyRelativeLocal() {
        const e = this.mixRotate
            , n = this.mixX
            , s = this.mixY
            , r = this.mixScaleX
            , i = this.mixScaleY
            , o = this.mixShearY
            , l = this.target
            , a = this.bones;
        for (let c = 0, u = a.length; c < u; c++) {
            const h = a[c]
                , d = h.arotation + (l.arotation + this.data.offsetRotation) * e
                , f = h.ax + (l.ax + this.data.offsetX) * n
                , p = h.ay + (l.ay + this.data.offsetY) * s
                , m = h.ascaleX * ((l.ascaleX - 1 + this.data.offsetScaleX) * r + 1)
                , g = h.ascaleY * ((l.ascaleY - 1 + this.data.offsetScaleY) * i + 1)
                , b = h.ashearY + (l.ashearY + this.data.offsetShearY) * o;
            h.updateWorldTransformWith(f, p, d, m, g, h.ashearX, b)
        }
    }
}
const Uh = class {
    constructor(t) {
        if (this._updateCache = new Array,
            this.skin = null,
            this.scaleX = 1,
            this.scaleY = 1,
            this.x = 0,
            this.y = 0,
            !t)
            throw new Error("data cannot be null.");
        this.data = t,
            this.bones = new Array;
        for (let e = 0; e < t.bones.length; e++) {
            const n = t.bones[e];
            let s;
            if (!n.parent)
                s = new Kb(n, this, null);
            else {
                const r = this.bones[n.parent.index];
                s = new Kb(n, this, r),
                    r.children.push(s)
            }
            this.bones.push(s)
        }
        this.slots = new Array,
            this.drawOrder = new Array;
        for (let e = 0; e < t.slots.length; e++) {
            const n = t.slots[e]
                , s = this.bones[n.boneData.index]
                , r = new mL(n, s);
            this.slots.push(r),
                this.drawOrder.push(r)
        }
        this.ikConstraints = new Array;
        for (let e = 0; e < t.ikConstraints.length; e++) {
            const n = t.ikConstraints[e];
            this.ikConstraints.push(new pL(n, this))
        }
        this.transformConstraints = new Array;
        for (let e = 0; e < t.transformConstraints.length; e++) {
            const n = t.transformConstraints[e];
            this.transformConstraints.push(new gL(n, this))
        }
        this.pathConstraints = new Array;
        for (let e = 0; e < t.pathConstraints.length; e++) {
            const n = t.pathConstraints[e];
            this.pathConstraints.push(new vh(n, this))
        }
        this.color = new Se(1, 1, 1, 1),
            this.updateCache()
    }
    updateCache() {
        const t = this._updateCache;
        t.length = 0;
        const e = this.bones;
        for (let c = 0, u = e.length; c < u; c++) {
            const h = e[c];
            h.sorted = h.data.skinRequired,
                h.active = !h.sorted
        }
        if (this.skin) {
            const c = this.skin.bones;
            for (let u = 0, h = this.skin.bones.length; u < h; u++) {
                let d = this.bones[c[u].index];
                do
                    d.sorted = !1,
                        d.active = !0,
                        d = d.parent;
                while (d)
            }
        }
        const n = this.ikConstraints
            , s = this.transformConstraints
            , r = this.pathConstraints
            , i = n.length
            , o = s.length
            , l = r.length
            , a = i + o + l;
        e: for (let c = 0; c < a; c++) {
            for (let u = 0; u < i; u++) {
                const h = n[u];
                if (h.data.order == c) {
                    this.sortIkConstraint(h);
                    continue e
                }
            }
            for (let u = 0; u < o; u++) {
                const h = s[u];
                if (h.data.order == c) {
                    this.sortTransformConstraint(h);
                    continue e
                }
            }
            for (let u = 0; u < l; u++) {
                const h = r[u];
                if (h.data.order == c) {
                    this.sortPathConstraint(h);
                    continue e
                }
            }
        }
        for (let c = 0, u = e.length; c < u; c++)
            this.sortBone(e[c])
    }
    sortIkConstraint(t) {
        if (t.active = t.target.isActive() && (!t.data.skinRequired || this.skin && Q.contains(this.skin.constraints, t.data, !0)),
            !t.active)
            return;
        const e = t.target;
        this.sortBone(e);
        const n = t.bones
            , s = n[0];
        if (this.sortBone(s),
            n.length == 1)
            this._updateCache.push(t),
                this.sortReset(s.children);
        else {
            const r = n[n.length - 1];
            this.sortBone(r),
                this._updateCache.push(t),
                this.sortReset(s.children),
                r.sorted = !0
        }
    }
    sortPathConstraint(t) {
        if (t.active = t.target.bone.isActive() && (!t.data.skinRequired || this.skin && Q.contains(this.skin.constraints, t.data, !0)),
            !t.active)
            return;
        const e = t.target
            , n = e.data.index
            , s = e.bone;
        this.skin && this.sortPathConstraintAttachment(this.skin, n, s),
            this.data.defaultSkin && this.data.defaultSkin != this.skin && this.sortPathConstraintAttachment(this.data.defaultSkin, n, s);
        for (let l = 0, a = this.data.skins.length; l < a; l++)
            this.sortPathConstraintAttachment(this.data.skins[l], n, s);
        const r = e.getAttachment();
        r instanceof hc && this.sortPathConstraintAttachmentWith(r, s);
        const i = t.bones
            , o = i.length;
        for (let l = 0; l < o; l++)
            this.sortBone(i[l]);
        this._updateCache.push(t);
        for (let l = 0; l < o; l++)
            this.sortReset(i[l].children);
        for (let l = 0; l < o; l++)
            i[l].sorted = !0
    }
    sortTransformConstraint(t) {
        if (t.active = t.target.isActive() && (!t.data.skinRequired || this.skin && Q.contains(this.skin.constraints, t.data, !0)),
            !t.active)
            return;
        this.sortBone(t.target);
        const e = t.bones
            , n = e.length;
        if (t.data.local)
            for (let s = 0; s < n; s++) {
                const r = e[s];
                this.sortBone(r.parent),
                    this.sortBone(r)
            }
        else
            for (let s = 0; s < n; s++)
                this.sortBone(e[s]);
        this._updateCache.push(t);
        for (let s = 0; s < n; s++)
            this.sortReset(e[s].children);
        for (let s = 0; s < n; s++)
            e[s].sorted = !0
    }
    sortPathConstraintAttachment(t, e, n) {
        const s = t.attachments[e];
        if (s)
            for (const r in s)
                this.sortPathConstraintAttachmentWith(s[r], n)
    }
    sortPathConstraintAttachmentWith(t, e) {
        if (!(t instanceof hc))
            return;
        const n = t.bones;
        if (!n)
            this.sortBone(e);
        else {
            const s = this.bones;
            for (let r = 0, i = n.length; r < i;) {
                let o = n[r++];
                for (o += r; r < o;)
                    this.sortBone(s[n[r++]])
            }
        }
    }
    sortBone(t) {
        if (!t || t.sorted)
            return;
        const e = t.parent;
        e && this.sortBone(e),
            t.sorted = !0,
            this._updateCache.push(t)
    }
    sortReset(t) {
        for (let e = 0, n = t.length; e < n; e++) {
            const s = t[e];
            s.active && (s.sorted && this.sortReset(s.children),
                s.sorted = !1)
        }
    }
    updateWorldTransform() {
        const t = this.bones;
        for (let n = 0, s = t.length; n < s; n++) {
            const r = t[n];
            r.ax = r.x,
                r.ay = r.y,
                r.arotation = r.rotation,
                r.ascaleX = r.scaleX,
                r.ascaleY = r.scaleY,
                r.ashearX = r.shearX,
                r.ashearY = r.shearY
        }
        const e = this._updateCache;
        for (let n = 0, s = e.length; n < s; n++)
            e[n].update()
    }
    updateWorldTransformWith(t) {
        const e = this.getRootBone()
            , n = t.matrix.a
            , s = t.matrix.c
            , r = t.matrix.b
            , i = t.matrix.d;
        e.matrix.tx = n * this.x + s * this.y + t.worldX,
            e.matrix.ty = r * this.x + i * this.y + t.worldY;
        const o = e.rotation + 90 + e.shearY
            , l = F.cosDeg(e.rotation + e.shearX) * e.scaleX
            , a = F.cosDeg(o) * e.scaleY
            , c = F.sinDeg(e.rotation + e.shearX) * e.scaleX
            , u = F.sinDeg(o) * e.scaleY
            , h = this.scaleX
            , d = -this.scaleY;
        e.matrix.a = (n * l + s * c) * h,
            e.matrix.c = (n * a + s * u) * h,
            e.matrix.b = (r * l + i * c) * d,
            e.matrix.d = (r * a + i * u) * d;
        const f = this._updateCache;
        for (let p = 0, m = f.length; p < m; p++) {
            const g = f[p];
            g != e && g.update()
        }
    }
    setToSetupPose() {
        this.setBonesToSetupPose(),
            this.setSlotsToSetupPose()
    }
    setBonesToSetupPose() {
        const t = this.bones;
        for (let r = 0, i = t.length; r < i; r++)
            t[r].setToSetupPose();
        const e = this.ikConstraints;
        for (let r = 0, i = e.length; r < i; r++) {
            const o = e[r];
            o.mix = o.data.mix,
                o.softness = o.data.softness,
                o.bendDirection = o.data.bendDirection,
                o.compress = o.data.compress,
                o.stretch = o.data.stretch
        }
        const n = this.transformConstraints;
        for (let r = 0, i = n.length; r < i; r++) {
            const o = n[r]
                , l = o.data;
            o.mixRotate = l.mixRotate,
                o.mixX = l.mixX,
                o.mixY = l.mixY,
                o.mixScaleX = l.mixScaleX,
                o.mixScaleY = l.mixScaleY,
                o.mixShearY = l.mixShearY
        }
        const s = this.pathConstraints;
        for (let r = 0, i = s.length; r < i; r++) {
            const o = s[r]
                , l = o.data;
            o.position = l.position,
                o.spacing = l.spacing,
                o.mixRotate = l.mixRotate,
                o.mixX = l.mixX,
                o.mixY = l.mixY
        }
    }
    setSlotsToSetupPose() {
        const t = this.slots;
        Q.arrayCopy(t, 0, this.drawOrder, 0, t.length);
        for (let e = 0, n = t.length; e < n; e++)
            t[e].setToSetupPose()
    }
    getRootBone() {
        return this.bones.length == 0 ? null : this.bones[0]
    }
    findBone(t) {
        if (!t)
            throw new Error("boneName cannot be null.");
        const e = this.bones;
        for (let n = 0, s = e.length; n < s; n++) {
            const r = e[n];
            if (r.data.name == t)
                return r
        }
        return null
    }
    findBoneIndex(t) {
        if (!t)
            throw new Error("boneName cannot be null.");
        const e = this.bones;
        for (let n = 0, s = e.length; n < s; n++)
            if (e[n].data.name == t)
                return n;
        return -1
    }
    findSlot(t) {
        if (!t)
            throw new Error("slotName cannot be null.");
        const e = this.slots;
        for (let n = 0, s = e.length; n < s; n++) {
            const r = e[n];
            if (r.data.name == t)
                return r
        }
        return null
    }
    findSlotIndex(t) {
        if (!t)
            throw new Error("slotName cannot be null.");
        const e = this.slots;
        for (let n = 0, s = e.length; n < s; n++)
            if (e[n].data.name == t)
                return n;
        return -1
    }
    setSkinByName(t) {
        const e = this.data.findSkin(t);
        if (!e)
            throw new Error(`Skin not found: ${t}`);
        this.setSkin(e)
    }
    setSkin(t) {
        if (t != this.skin) {
            if (t)
                if (this.skin)
                    t.attachAll(this, this.skin);
                else {
                    const e = this.slots;
                    for (let n = 0, s = e.length; n < s; n++) {
                        const r = e[n]
                            , i = r.data.attachmentName;
                        if (i) {
                            const o = t.getAttachment(n, i);
                            o && r.setAttachment(o)
                        }
                    }
                }
            this.skin = t,
                this.updateCache()
        }
    }
    getAttachmentByName(t, e) {
        const n = this.data.findSlot(t);
        if (!n)
            throw new Error(`Can't find slot with name ${t}`);
        return this.getAttachment(n.index, e)
    }
    getAttachment(t, e) {
        if (!e)
            throw new Error("attachmentName cannot be null.");
        if (this.skin) {
            const n = this.skin.getAttachment(t, e);
            if (n)
                return n
        }
        return this.data.defaultSkin ? this.data.defaultSkin.getAttachment(t, e) : null
    }
    setAttachment(t, e) {
        if (!t)
            throw new Error("slotName cannot be null.");
        const n = this.slots;
        for (let s = 0, r = n.length; s < r; s++) {
            const i = n[s];
            if (i.data.name == t) {
                let o = null;
                if (e && (o = this.getAttachment(s, e),
                    !o))
                    throw new Error(`Attachment not found: ${e}, for slot: ${t}`);
                i.setAttachment(o);
                return
            }
        }
        throw new Error(`Slot not found: ${t}`)
    }
    findIkConstraint(t) {
        if (!t)
            throw new Error("constraintName cannot be null.");
        const e = this.ikConstraints;
        for (let n = 0, s = e.length; n < s; n++) {
            const r = e[n];
            if (r.data.name == t)
                return r
        }
        return null
    }
    findTransformConstraint(t) {
        if (!t)
            throw new Error("constraintName cannot be null.");
        const e = this.transformConstraints;
        for (let n = 0, s = e.length; n < s; n++) {
            const r = e[n];
            if (r.data.name == t)
                return r
        }
        return null
    }
    findPathConstraint(t) {
        if (!t)
            throw new Error("constraintName cannot be null.");
        const e = this.pathConstraints;
        for (let n = 0, s = e.length; n < s; n++) {
            const r = e[n];
            if (r.data.name == t)
                return r
        }
        return null
    }
    getBoundsRect() {
        const t = new Fd
            , e = new Fd;
        return this.getBounds(t, e),
        {
            x: t.x,
            y: t.y,
            width: e.x,
            height: e.y
        }
    }
    getBounds(t, e, n = new Array(2)) {
        if (!t)
            throw new Error("offset cannot be null.");
        if (!e)
            throw new Error("size cannot be null.");
        const s = this.drawOrder;
        let r = Number.POSITIVE_INFINITY
            , i = Number.POSITIVE_INFINITY
            , o = Number.NEGATIVE_INFINITY
            , l = Number.NEGATIVE_INFINITY;
        for (let a = 0, c = s.length; a < c; a++) {
            const u = s[a];
            if (!u.bone.active)
                continue;
            let h = 0
                , d = null;
            const f = u.getAttachment();
            if (f instanceof Et)
                h = 8,
                    d = Q.setArraySize(n, h, 0),
                    f.computeWorldVertices(u, d, 0, 2);
            else if (f instanceof uc) {
                const p = f;
                h = p.worldVerticesLength,
                    d = Q.setArraySize(n, h, 0),
                    p.computeWorldVertices(u, 0, h, d, 0, 2)
            }
            if (d)
                for (let p = 0, m = d.length; p < m; p += 2) {
                    const g = d[p]
                        , b = d[p + 1];
                    r = Math.min(r, g),
                        i = Math.min(i, b),
                        o = Math.max(o, g),
                        l = Math.max(l, b)
                }
        }
        t.set(r, i),
            e.set(o - r, l - i)
    }
    get flipX() {
        return this.scaleX == -1
    }
    set flipX(t) {
        Uh.deprecatedWarning1 || (Uh.deprecatedWarning1 = !0,
            console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),
            this.scaleX = t ? 1 : -1
    }
    get flipY() {
        return this.scaleY == -1
    }
    set flipY(t) {
        Uh.deprecatedWarning1 || (Uh.deprecatedWarning1 = !0,
            console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),
            this.scaleY = t ? 1 : -1
    }
}
    ;
let hS = Uh;
hS.deprecatedWarning1 = !1;
class dS {
    constructor() {
        this.name = null,
            this.bones = new Array,
            this.slots = new Array,
            this.skins = new Array,
            this.defaultSkin = null,
            this.events = new Array,
            this.animations = new Array,
            this.ikConstraints = new Array,
            this.transformConstraints = new Array,
            this.pathConstraints = new Array,
            this.x = 0,
            this.y = 0,
            this.width = 0,
            this.height = 0,
            this.version = null,
            this.hash = null,
            this.fps = 0,
            this.imagesPath = null,
            this.audioPath = null
    }
    findBone(e) {
        if (!e)
            throw new Error("boneName cannot be null.");
        const n = this.bones;
        for (let s = 0, r = n.length; s < r; s++) {
            const i = n[s];
            if (i.name == e)
                return i
        }
        return null
    }
    findBoneIndex(e) {
        if (!e)
            throw new Error("boneName cannot be null.");
        const n = this.bones;
        for (let s = 0, r = n.length; s < r; s++)
            if (n[s].name == e)
                return s;
        return -1
    }
    findSlot(e) {
        if (!e)
            throw new Error("slotName cannot be null.");
        const n = this.slots;
        for (let s = 0, r = n.length; s < r; s++) {
            const i = n[s];
            if (i.name == e)
                return i
        }
        return null
    }
    findSlotIndex(e) {
        if (!e)
            throw new Error("slotName cannot be null.");
        const n = this.slots;
        for (let s = 0, r = n.length; s < r; s++)
            if (n[s].name == e)
                return s;
        return -1
    }
    findSkin(e) {
        if (!e)
            throw new Error("skinName cannot be null.");
        const n = this.skins;
        for (let s = 0, r = n.length; s < r; s++) {
            const i = n[s];
            if (i.name == e)
                return i
        }
        return null
    }
    findEvent(e) {
        if (!e)
            throw new Error("eventDataName cannot be null.");
        const n = this.events;
        for (let s = 0, r = n.length; s < r; s++) {
            const i = n[s];
            if (i.name == e)
                return i
        }
        return null
    }
    findAnimation(e) {
        if (!e)
            throw new Error("animationName cannot be null.");
        const n = this.animations;
        for (let s = 0, r = n.length; s < r; s++) {
            const i = n[s];
            if (i.name == e)
                return i
        }
        return null
    }
    findIkConstraint(e) {
        if (!e)
            throw new Error("constraintName cannot be null.");
        const n = this.ikConstraints;
        for (let s = 0, r = n.length; s < r; s++) {
            const i = n[s];
            if (i.name == e)
                return i
        }
        return null
    }
    findTransformConstraint(e) {
        if (!e)
            throw new Error("constraintName cannot be null.");
        const n = this.transformConstraints;
        for (let s = 0, r = n.length; s < r; s++) {
            const i = n[s];
            if (i.name == e)
                return i
        }
        return null
    }
    findPathConstraint(e) {
        if (!e)
            throw new Error("constraintName cannot be null.");
        const n = this.pathConstraints;
        for (let s = 0, r = n.length; s < r; s++) {
            const i = n[s];
            if (i.name == e)
                return i
        }
        return null
    }
    findPathConstraintIndex(e) {
        if (e == null)
            throw new Error("pathConstraintName cannot be null.");
        const n = this.pathConstraints;
        for (let s = 0, r = n.length; s < r; s++)
            if (n[s].name == e)
                return s;
        return -1
    }
}
class fS {
    constructor(e, n, s) {
        if (this.index = 0,
            this.color = new Se(1, 1, 1, 1),
            this.darkColor = null,
            this.attachmentName = null,
            this.blendMode = Oe.NORMAL,
            e < 0)
            throw new Error("index must be >= 0.");
        if (!n)
            throw new Error("name cannot be null.");
        if (!s)
            throw new Error("boneData cannot be null.");
        this.index = e,
            this.name = n,
            this.boneData = s
    }
}
class pS extends K_ {
    constructor(e) {
        super(e, 0, !1),
            this.bones = new Array,
            this._target = null,
            this.mixRotate = 0,
            this.mixX = 0,
            this.mixY = 0,
            this.mixScaleX = 0,
            this.mixScaleY = 0,
            this.mixShearY = 0,
            this.offsetRotation = 0,
            this.offsetX = 0,
            this.offsetY = 0,
            this.offsetScaleX = 0,
            this.offsetScaleY = 0,
            this.offsetShearY = 0,
            this.relative = !1,
            this.local = !1
    }
    set target(e) {
        this._target = e
    }
    get target() {
        if (this._target)
            return this._target;
        throw new Error("BoneData not set.")
    }
}
class Jb {
    constructor(e, n, s) {
        this.slotIndex = e,
            this.name = n,
            this.attachment = s
    }
}
class Gd {
    constructor(e) {
        if (this.attachments = new Array,
            this.bones = Array(),
            this.constraints = new Array,
            !e)
            throw new Error("name cannot be null.");
        this.name = e
    }
    setAttachment(e, n, s) {
        if (!s)
            throw new Error("attachment cannot be null.");
        const r = this.attachments;
        e >= r.length && (r.length = e + 1),
            r[e] || (r[e] = {}),
            r[e][n] = s
    }
    addSkin(e) {
        for (let s = 0; s < e.bones.length; s++) {
            const r = e.bones[s];
            let i = !1;
            for (let o = 0; o < this.bones.length; o++)
                if (this.bones[o] == r) {
                    i = !0;
                    break
                }
            i || this.bones.push(r)
        }
        for (let s = 0; s < e.constraints.length; s++) {
            const r = e.constraints[s];
            let i = !1;
            for (let o = 0; o < this.constraints.length; o++)
                if (this.constraints[o] == r) {
                    i = !0;
                    break
                }
            i || this.constraints.push(r)
        }
        const n = e.getAttachments();
        for (let s = 0; s < n.length; s++) {
            const r = n[s];
            this.setAttachment(r.slotIndex, r.name, r.attachment)
        }
    }
    copySkin(e) {
        for (let s = 0; s < e.bones.length; s++) {
            const r = e.bones[s];
            let i = !1;
            for (let o = 0; o < this.bones.length; o++)
                if (this.bones[o] == r) {
                    i = !0;
                    break
                }
            i || this.bones.push(r)
        }
        for (let s = 0; s < e.constraints.length; s++) {
            const r = e.constraints[s];
            let i = !1;
            for (let o = 0; o < this.constraints.length; o++)
                if (this.constraints[o] == r) {
                    i = !0;
                    break
                }
            i || this.constraints.push(r)
        }
        const n = e.getAttachments();
        for (let s = 0; s < n.length; s++) {
            const r = n[s];
            r.attachment && (r.attachment instanceof uc ? (r.attachment = r.attachment.newLinkedMesh(),
                this.setAttachment(r.slotIndex, r.name, r.attachment)) : (r.attachment = r.attachment.copy(),
                    this.setAttachment(r.slotIndex, r.name, r.attachment)))
        }
    }
    getAttachment(e, n) {
        const s = this.attachments[e];
        return s ? s[n] : null
    }
    removeAttachment(e, n) {
        const s = this.attachments[e];
        s && delete s[n]
    }
    getAttachments() {
        const e = new Array;
        for (let n = 0; n < this.attachments.length; n++) {
            const s = this.attachments[n];
            if (s)
                for (const r in s) {
                    const i = s[r];
                    i && e.push(new Jb(n, r, i))
                }
        }
        return e
    }
    getAttachmentsForSlot(e, n) {
        const s = this.attachments[e];
        if (s)
            for (const r in s) {
                const i = s[r];
                i && n.push(new Jb(e, r, i))
            }
    }
    clear() {
        this.attachments.length = 0,
            this.bones.length = 0,
            this.constraints.length = 0
    }
    attachAll(e, n) {
        let s = 0;
        for (let r = 0; r < e.slots.length; r++) {
            const i = e.slots[r]
                , o = i.getAttachment();
            if (o && s < n.attachments.length) {
                const l = n.attachments[s];
                for (const a in l) {
                    const c = l[a];
                    if (o == c) {
                        const u = this.getAttachment(s, a);
                        u && i.setAttachment(u);
                        break
                    }
                }
            }
            s++
        }
    }
}
class mS {
    constructor(e) {
        this.ver40 = !1,
            this.scale = 1,
            this.linkedMeshes = new Array,
            this.attachmentLoader = e
    }
    readSkeletonData(e) {
        const n = this.scale
            , s = new dS;
        s.name = "";
        const r = new Gm(e)
            , i = r.readInt32()
            , o = r.readInt32();
        s.hash = o == 0 && i == 0 ? null : o.toString(16) + i.toString(16),
            s.version = r.readString();
        const l = s.version.substr(0, 3);
        if (l !== "4.0" && l !== "4.1") {
            const h = `Spine 4.1 loader cant load version ${s.version}. Please configure your pixi-spine bundle`;
            console.error(h)
        }
        this.ver40 = l === "4.0",
            s.x = r.readFloat(),
            s.y = r.readFloat(),
            s.width = r.readFloat(),
            s.height = r.readFloat();
        const a = r.readBoolean();
        a && (s.fps = r.readFloat(),
            s.imagesPath = r.readString(),
            s.audioPath = r.readString());
        let c = 0;
        c = r.readInt(!0);
        for (let h = 0; h < c; h++) {
            const d = r.readString();
            if (!d)
                throw new Error("String in string table must not be null.");
            r.strings.push(d)
        }
        c = r.readInt(!0);
        for (let h = 0; h < c; h++) {
            const d = r.readString();
            if (!d)
                throw new Error("Bone name must not be null.");
            const f = h == 0 ? null : s.bones[r.readInt(!0)]
                , p = new oS(h, d, f);
            p.rotation = r.readFloat(),
                p.x = r.readFloat() * n,
                p.y = r.readFloat() * n,
                p.scaleX = r.readFloat(),
                p.scaleY = r.readFloat(),
                p.shearX = r.readFloat(),
                p.shearY = r.readFloat(),
                p.length = r.readFloat() * n,
                p.transformMode = r.readInt(!0),
                p.skinRequired = r.readBoolean(),
                a && Se.rgba8888ToColor(p.color, r.readInt32()),
                s.bones.push(p)
        }
        c = r.readInt(!0);
        for (let h = 0; h < c; h++) {
            const d = r.readString();
            if (!d)
                throw new Error("Slot name must not be null.");
            const f = s.bones[r.readInt(!0)]
                , p = new fS(h, d, f);
            Se.rgba8888ToColor(p.color, r.readInt32());
            const m = r.readInt32();
            m != -1 && Se.rgb888ToColor(p.darkColor = new Se, m),
                p.attachmentName = r.readStringRef(),
                p.blendMode = r.readInt(!0),
                s.slots.push(p)
        }
        c = r.readInt(!0);
        for (let h = 0, d; h < c; h++) {
            const f = r.readString();
            if (!f)
                throw new Error("IK constraint data name must not be null.");
            const p = new cS(f);
            p.order = r.readInt(!0),
                p.skinRequired = r.readBoolean(),
                d = r.readInt(!0);
            for (let m = 0; m < d; m++)
                p.bones.push(s.bones[r.readInt(!0)]);
            p.target = s.bones[r.readInt(!0)],
                p.mix = r.readFloat(),
                p.softness = r.readFloat() * n,
                p.bendDirection = r.readByte(),
                p.compress = r.readBoolean(),
                p.stretch = r.readBoolean(),
                p.uniform = r.readBoolean(),
                s.ikConstraints.push(p)
        }
        c = r.readInt(!0);
        for (let h = 0, d; h < c; h++) {
            const f = r.readString();
            if (!f)
                throw new Error("Transform constraint data name must not be null.");
            const p = new pS(f);
            p.order = r.readInt(!0),
                p.skinRequired = r.readBoolean(),
                d = r.readInt(!0);
            for (let m = 0; m < d; m++)
                p.bones.push(s.bones[r.readInt(!0)]);
            p.target = s.bones[r.readInt(!0)],
                p.local = r.readBoolean(),
                p.relative = r.readBoolean(),
                p.offsetRotation = r.readFloat(),
                p.offsetX = r.readFloat() * n,
                p.offsetY = r.readFloat() * n,
                p.offsetScaleX = r.readFloat(),
                p.offsetScaleY = r.readFloat(),
                p.offsetShearY = r.readFloat(),
                p.mixRotate = r.readFloat(),
                p.mixX = r.readFloat(),
                p.mixY = r.readFloat(),
                p.mixScaleX = r.readFloat(),
                p.mixScaleY = r.readFloat(),
                p.mixShearY = r.readFloat(),
                s.transformConstraints.push(p)
        }
        c = r.readInt(!0);
        for (let h = 0, d; h < c; h++) {
            const f = r.readString();
            if (!f)
                throw new Error("Path constraint data name must not be null.");
            const p = new uS(f);
            p.order = r.readInt(!0),
                p.skinRequired = r.readBoolean(),
                d = r.readInt(!0);
            for (let m = 0; m < d; m++)
                p.bones.push(s.bones[r.readInt(!0)]);
            p.target = s.slots[r.readInt(!0)],
                p.positionMode = r.readInt(!0),
                p.spacingMode = r.readInt(!0),
                p.rotateMode = r.readInt(!0),
                p.offsetRotation = r.readFloat(),
                p.position = r.readFloat(),
                p.positionMode == on.Fixed && (p.position *= n),
                p.spacing = r.readFloat(),
                (p.spacingMode == Rn.Length || p.spacingMode == Rn.Fixed) && (p.spacing *= n),
                p.mixRotate = r.readFloat(),
                p.mixX = r.readFloat(),
                p.mixY = r.readFloat(),
                s.pathConstraints.push(p)
        }
        const u = this.readSkin(r, s, !0, a);
        u && (s.defaultSkin = u,
            s.skins.push(u));
        {
            let h = s.skins.length;
            for (Q.setArraySize(s.skins, c = h + r.readInt(!0)); h < c; h++) {
                const d = this.readSkin(r, s, !1, a);
                if (!d)
                    throw new Error("readSkin() should not have returned null.");
                s.skins[h] = d
            }
        }
        c = this.linkedMeshes.length;
        for (let h = 0; h < c; h++) {
            const d = this.linkedMeshes[h]
                , f = d.skin ? s.findSkin(d.skin) : s.defaultSkin;
            if (!f)
                throw new Error("Not skin found for linked mesh.");
            if (!d.parent)
                throw new Error("Linked mesh parent must not be null");
            const p = f.getAttachment(d.slotIndex, d.parent);
            if (!p)
                throw new Error(`Parent mesh not found: ${d.parent}`);
            d.mesh.timelineAttachment = d.inheritTimeline ? p : d.mesh,
                d.mesh.setParentMesh(p)
        }
        this.linkedMeshes.length = 0,
            c = r.readInt(!0);
        for (let h = 0; h < c; h++) {
            const d = r.readStringRef();
            if (!d)
                throw new Error;
            const f = new lS(d);
            f.intValue = r.readInt(!1),
                f.floatValue = r.readFloat(),
                f.stringValue = r.readString(),
                f.audioPath = r.readString(),
                f.audioPath && (f.volume = r.readFloat(),
                    f.balance = r.readFloat()),
                s.events.push(f)
        }
        c = r.readInt(!0);
        for (let h = 0; h < c; h++) {
            const d = r.readString();
            if (!d)
                throw new Error("Animatio name must not be null.");
            s.animations.push(this.readAnimation(r, d, s))
        }
        return s
    }
    readSkin(e, n, s, r) {
        let i = null
            , o = 0;
        if (s) {
            if (o = e.readInt(!0),
                o == 0)
                return null;
            i = new Gd("default")
        } else {
            const l = e.readStringRef();
            if (!l)
                throw new Error("Skin name must not be null.");
            i = new Gd(l),
                i.bones.length = e.readInt(!0);
            for (let a = 0, c = i.bones.length; a < c; a++)
                i.bones[a] = n.bones[e.readInt(!0)];
            for (let a = 0, c = e.readInt(!0); a < c; a++)
                i.constraints.push(n.ikConstraints[e.readInt(!0)]);
            for (let a = 0, c = e.readInt(!0); a < c; a++)
                i.constraints.push(n.transformConstraints[e.readInt(!0)]);
            for (let a = 0, c = e.readInt(!0); a < c; a++)
                i.constraints.push(n.pathConstraints[e.readInt(!0)]);
            o = e.readInt(!0)
        }
        for (let l = 0; l < o; l++) {
            const a = e.readInt(!0);
            for (let c = 0, u = e.readInt(!0); c < u; c++) {
                const h = e.readStringRef();
                if (!h)
                    throw new Error("Attachment name must not be null");
                const d = this.readAttachment(e, n, i, a, h, r);
                d && i.setAttachment(a, h, d)
            }
        }
        return i
    }
    readAttachment(e, n, s, r, i, o) {
        const l = this.scale;
        let a = e.readStringRef();
        switch (a || (a = i),
        e.readByte()) {
            case ut.Region:
                {
                    let c = e.readStringRef();
                    const u = e.readFloat()
                        , h = e.readFloat()
                        , d = e.readFloat()
                        , f = e.readFloat()
                        , p = e.readFloat()
                        , m = e.readFloat()
                        , g = e.readFloat()
                        , b = e.readInt32()
                        , v = this.readSequence(e);
                    c || (c = a);
                    const _ = this.attachmentLoader.newRegionAttachment(s, a, c, v);
                    return _ ? (_.path = c,
                        _.x = h * l,
                        _.y = d * l,
                        _.scaleX = f,
                        _.scaleY = p,
                        _.rotation = u,
                        _.width = m * l,
                        _.height = g * l,
                        Se.rgba8888ToColor(_.color, b),
                        _.sequence = v,
                        v == null && _.updateRegion(),
                        _) : null
                }
            case ut.BoundingBox:
                {
                    const c = e.readInt(!0)
                        , u = this.readVertices(e, c)
                        , h = o ? e.readInt32() : 0
                        , d = this.attachmentLoader.newBoundingBoxAttachment(s, a);
                    return d ? (d.worldVerticesLength = c << 1,
                        d.vertices = u.vertices,
                        d.bones = u.bones,
                        o && Se.rgba8888ToColor(d.color, h),
                        d) : null
                }
            case ut.Mesh:
                {
                    let c = e.readStringRef();
                    const u = e.readInt32()
                        , h = e.readInt(!0)
                        , d = this.readFloatArray(e, h << 1, 1)
                        , f = this.readShortArray(e)
                        , p = this.readVertices(e, h)
                        , m = e.readInt(!0)
                        , g = this.readSequence(e);
                    let b = []
                        , v = 0
                        , _ = 0;
                    o && (b = this.readShortArray(e),
                        v = e.readFloat(),
                        _ = e.readFloat()),
                        c || (c = a);
                    const y = this.attachmentLoader.newMeshAttachment(s, a, c, g);
                    return y ? (y.path = c,
                        Se.rgba8888ToColor(y.color, u),
                        y.bones = p.bones,
                        y.vertices = p.vertices,
                        y.worldVerticesLength = h << 1,
                        y.triangles = f,
                        y.regionUVs = new Float32Array(d),
                        y.hullLength = m << 1,
                        y.sequence = g,
                        o && (y.edges = b,
                            y.width = v * l,
                            y.height = _ * l),
                        y) : null
                }
            case ut.LinkedMesh:
                {
                    let c = e.readStringRef();
                    const u = e.readInt32()
                        , h = e.readStringRef()
                        , d = e.readStringRef()
                        , f = e.readBoolean()
                        , p = this.readSequence(e);
                    let m = 0
                        , g = 0;
                    o && (m = e.readFloat(),
                        g = e.readFloat()),
                        c || (c = a);
                    const b = this.attachmentLoader.newMeshAttachment(s, a, c, p);
                    return b ? (b.path = c,
                        Se.rgba8888ToColor(b.color, u),
                        b.sequence = p,
                        o && (b.width = m * l,
                            b.height = g * l),
                        this.linkedMeshes.push(new khe(b, h, r, d, f)),
                        b) : null
                }
            case ut.Path:
                {
                    const c = e.readBoolean()
                        , u = e.readBoolean()
                        , h = e.readInt(!0)
                        , d = this.readVertices(e, h)
                        , f = Q.newArray(h / 3, 0);
                    for (let g = 0, b = f.length; g < b; g++)
                        f[g] = e.readFloat() * l;
                    const p = o ? e.readInt32() : 0
                        , m = this.attachmentLoader.newPathAttachment(s, a);
                    return m ? (m.closed = c,
                        m.constantSpeed = u,
                        m.worldVerticesLength = h << 1,
                        m.vertices = d.vertices,
                        m.bones = d.bones,
                        m.lengths = f,
                        o && Se.rgba8888ToColor(m.color, p),
                        m) : null
                }
            case ut.Point:
                {
                    const c = e.readFloat()
                        , u = e.readFloat()
                        , h = e.readFloat()
                        , d = o ? e.readInt32() : 0
                        , f = this.attachmentLoader.newPointAttachment(s, a);
                    return f ? (f.x = u * l,
                        f.y = h * l,
                        f.rotation = c,
                        o && Se.rgba8888ToColor(f.color, d),
                        f) : null
                }
            case ut.Clipping:
                {
                    const c = e.readInt(!0)
                        , u = e.readInt(!0)
                        , h = this.readVertices(e, u)
                        , d = o ? e.readInt32() : 0
                        , f = this.attachmentLoader.newClippingAttachment(s, a);
                    return f ? (f.endSlot = n.slots[c],
                        f.worldVerticesLength = u << 1,
                        f.vertices = h.vertices,
                        f.bones = h.bones,
                        o && Se.rgba8888ToColor(f.color, d),
                        f) : null
                }
        }
        return null
    }
    readSequence(e) {
        if (this.ver40 || !e.readBoolean())
            return null;
        const n = new X_(e.readInt(!0));
        return n.start = e.readInt(!0),
            n.digits = e.readInt(!0),
            n.setupIndex = e.readInt(!0),
            n
    }
    readDeformTimelineType(e) {
        return this.ver40 ? xA : e.readByte()
    }
    readVertices(e, n) {
        const s = this.scale
            , r = n << 1
            , i = new Rhe;
        if (!e.readBoolean())
            return i.vertices = this.readFloatArray(e, r, s),
                i;
        const o = new Array
            , l = new Array;
        for (let a = 0; a < n; a++) {
            const c = e.readInt(!0);
            l.push(c);
            for (let u = 0; u < c; u++)
                l.push(e.readInt(!0)),
                    o.push(e.readFloat() * s),
                    o.push(e.readFloat() * s),
                    o.push(e.readFloat())
        }
        return i.vertices = Q.toFloatArray(o),
            i.bones = l,
            i
    }
    readFloatArray(e, n, s) {
        const r = new Array(n);
        if (s == 1)
            for (let i = 0; i < n; i++)
                r[i] = e.readFloat();
        else
            for (let i = 0; i < n; i++)
                r[i] = e.readFloat() * s;
        return r
    }
    readShortArray(e) {
        const n = e.readInt(!0)
            , s = new Array(n);
        for (let r = 0; r < n; r++)
            s[r] = e.readShort();
        return s
    }
    readAnimation(e, n, s) {
        e.readInt(!0);
        const r = new Array
            , i = this.scale;
        for (let c = 0, u = e.readInt(!0); c < u; c++) {
            const h = e.readInt(!0);
            for (let d = 0, f = e.readInt(!0); d < f; d++) {
                const p = e.readByte()
                    , m = e.readInt(!0)
                    , g = m - 1;
                switch (p) {
                    case Vhe:
                        {
                            const b = new Bl(m, h);
                            for (let v = 0; v < m; v++)
                                b.setFrame(v, e.readFloat(), e.readStringRef());
                            r.push(b);
                            break
                        }
                    case Ghe:
                        {
                            const b = e.readInt(!0)
                                , v = new zw(m, b, h);
                            let _ = e.readFloat()
                                , y = e.readUnsignedByte() / 255
                                , x = e.readUnsignedByte() / 255
                                , w = e.readUnsignedByte() / 255
                                , S = e.readUnsignedByte() / 255;
                            for (let E = 0, C = 0; v.setFrame(E, _, y, x, w, S),
                                E != g; E++) {
                                const I = e.readFloat()
                                    , L = e.readUnsignedByte() / 255
                                    , k = e.readUnsignedByte() / 255
                                    , R = e.readUnsignedByte() / 255
                                    , U = e.readUnsignedByte() / 255;
                                switch (e.readByte()) {
                                    case qr:
                                        v.setStepped(E);
                                        break;
                                    case Kr:
                                        yt(e, v, C++, E, 0, _, I, y, L, 1),
                                            yt(e, v, C++, E, 1, _, I, x, k, 1),
                                            yt(e, v, C++, E, 2, _, I, w, R, 1),
                                            yt(e, v, C++, E, 3, _, I, S, U, 1)
                                }
                                _ = I,
                                    y = L,
                                    x = k,
                                    w = R,
                                    S = U
                            }
                            r.push(v);
                            break
                        }
                    case Hhe:
                        {
                            const b = e.readInt(!0)
                                , v = new qw(m, b, h);
                            let _ = e.readFloat()
                                , y = e.readUnsignedByte() / 255
                                , x = e.readUnsignedByte() / 255
                                , w = e.readUnsignedByte() / 255;
                            for (let S = 0, E = 0; v.setFrame(S, _, y, x, w),
                                S != g; S++) {
                                const C = e.readFloat()
                                    , I = e.readUnsignedByte() / 255
                                    , L = e.readUnsignedByte() / 255
                                    , k = e.readUnsignedByte() / 255;
                                switch (e.readByte()) {
                                    case qr:
                                        v.setStepped(S);
                                        break;
                                    case Kr:
                                        yt(e, v, E++, S, 0, _, C, y, I, 1),
                                            yt(e, v, E++, S, 1, _, C, x, L, 1),
                                            yt(e, v, E++, S, 2, _, C, w, k, 1)
                                }
                                _ = C,
                                    y = I,
                                    x = L,
                                    w = k
                            }
                            r.push(v);
                            break
                        }
                    case Whe:
                        {
                            const b = e.readInt(!0)
                                , v = new Jw(m, b, h);
                            let _ = e.readFloat()
                                , y = e.readUnsignedByte() / 255
                                , x = e.readUnsignedByte() / 255
                                , w = e.readUnsignedByte() / 255
                                , S = e.readUnsignedByte() / 255
                                , E = e.readUnsignedByte() / 255
                                , C = e.readUnsignedByte() / 255
                                , I = e.readUnsignedByte() / 255;
                            for (let L = 0, k = 0; v.setFrame(L, _, y, x, w, S, E, C, I),
                                L != g; L++) {
                                const R = e.readFloat()
                                    , U = e.readUnsignedByte() / 255
                                    , W = e.readUnsignedByte() / 255
                                    , H = e.readUnsignedByte() / 255
                                    , j = e.readUnsignedByte() / 255
                                    , z = e.readUnsignedByte() / 255
                                    , ee = e.readUnsignedByte() / 255
                                    , J = e.readUnsignedByte() / 255;
                                switch (e.readByte()) {
                                    case qr:
                                        v.setStepped(L);
                                        break;
                                    case Kr:
                                        yt(e, v, k++, L, 0, _, R, y, U, 1),
                                            yt(e, v, k++, L, 1, _, R, x, W, 1),
                                            yt(e, v, k++, L, 2, _, R, w, H, 1),
                                            yt(e, v, k++, L, 3, _, R, S, j, 1),
                                            yt(e, v, k++, L, 4, _, R, E, z, 1),
                                            yt(e, v, k++, L, 5, _, R, C, ee, 1),
                                            yt(e, v, k++, L, 6, _, R, I, J, 1)
                                }
                                _ = R,
                                    y = U,
                                    x = W,
                                    w = H,
                                    S = j,
                                    E = z,
                                    C = ee,
                                    I = J
                            }
                            r.push(v);
                            break
                        }
                    case Yhe:
                        {
                            const b = e.readInt(!0)
                                , v = new Zw(m, b, h);
                            let _ = e.readFloat()
                                , y = e.readUnsignedByte() / 255
                                , x = e.readUnsignedByte() / 255
                                , w = e.readUnsignedByte() / 255
                                , S = e.readUnsignedByte() / 255
                                , E = e.readUnsignedByte() / 255
                                , C = e.readUnsignedByte() / 255;
                            for (let I = 0, L = 0; v.setFrame(I, _, y, x, w, S, E, C),
                                I != g; I++) {
                                const k = e.readFloat()
                                    , R = e.readUnsignedByte() / 255
                                    , U = e.readUnsignedByte() / 255
                                    , W = e.readUnsignedByte() / 255
                                    , H = e.readUnsignedByte() / 255
                                    , j = e.readUnsignedByte() / 255
                                    , z = e.readUnsignedByte() / 255;
                                switch (e.readByte()) {
                                    case qr:
                                        v.setStepped(I);
                                        break;
                                    case Kr:
                                        yt(e, v, L++, I, 0, _, k, y, R, 1),
                                            yt(e, v, L++, I, 1, _, k, x, U, 1),
                                            yt(e, v, L++, I, 2, _, k, w, W, 1),
                                            yt(e, v, L++, I, 3, _, k, S, H, 1),
                                            yt(e, v, L++, I, 4, _, k, E, j, 1),
                                            yt(e, v, L++, I, 5, _, k, C, z, 1)
                                }
                                _ = k,
                                    y = R,
                                    x = U,
                                    w = W,
                                    S = H,
                                    E = j,
                                    C = z
                            }
                            r.push(v);
                            break
                        }
                    case Xhe:
                        {
                            const b = new Kw(m, e.readInt(!0), h);
                            let v = e.readFloat()
                                , _ = e.readUnsignedByte() / 255;
                            for (let y = 0, x = 0; b.setFrame(y, v, _),
                                y != g; y++) {
                                const w = e.readFloat()
                                    , S = e.readUnsignedByte() / 255;
                                switch (e.readByte()) {
                                    case qr:
                                        b.setStepped(y);
                                        break;
                                    case Kr:
                                        yt(e, b, x++, y, 0, v, w, _, S, 1)
                                }
                                v = w,
                                    _ = S
                            }
                            r.push(b)
                        }
                }
            }
        }
        for (let c = 0, u = e.readInt(!0); c < u; c++) {
            const h = e.readInt(!0);
            for (let d = 0, f = e.readInt(!0); d < f; d++) {
                const p = e.readByte()
                    , m = e.readInt(!0)
                    , g = e.readInt(!0);
                switch (p) {
                    case Mhe:
                        r.push(ro(e, new Vd(m, g, h), 1));
                        break;
                    case Phe:
                        r.push(I1(e, new $w(m, g, h), i));
                        break;
                    case Lhe:
                        r.push(ro(e, new Uw(m, g, h), i));
                        break;
                    case Ohe:
                        r.push(ro(e, new Vw(m, g, h), i));
                        break;
                    case Nhe:
                        r.push(I1(e, new Gw(m, g, h), 1));
                        break;
                    case Dhe:
                        r.push(ro(e, new Hw(m, g, h), 1));
                        break;
                    case Bhe:
                        r.push(ro(e, new Ww(m, g, h), 1));
                        break;
                    case Fhe:
                        r.push(I1(e, new Yw(m, g, h), 1));
                        break;
                    case $he:
                        r.push(ro(e, new Xw(m, g, h), 1));
                        break;
                    case Uhe:
                        r.push(ro(e, new jw(m, g, h), 1))
                }
            }
        }
        for (let c = 0, u = e.readInt(!0); c < u; c++) {
            const h = e.readInt(!0)
                , d = e.readInt(!0)
                , f = d - 1
                , p = new eS(d, e.readInt(!0), h);
            let m = e.readFloat()
                , g = e.readFloat()
                , b = e.readFloat() * i;
            for (let v = 0, _ = 0; p.setFrame(v, m, g, b, e.readByte(), e.readBoolean(), e.readBoolean()),
                v != f; v++) {
                const y = e.readFloat()
                    , x = e.readFloat()
                    , w = e.readFloat() * i;
                switch (e.readByte()) {
                    case qr:
                        p.setStepped(v);
                        break;
                    case Kr:
                        yt(e, p, _++, v, 0, m, y, g, x, 1),
                            yt(e, p, _++, v, 1, m, y, b, w, i)
                }
                m = y,
                    g = x,
                    b = w
            }
            r.push(p)
        }
        for (let c = 0, u = e.readInt(!0); c < u; c++) {
            const h = e.readInt(!0)
                , d = e.readInt(!0)
                , f = d - 1
                , p = new tS(d, e.readInt(!0), h);
            let m = e.readFloat()
                , g = e.readFloat()
                , b = e.readFloat()
                , v = e.readFloat()
                , _ = e.readFloat()
                , y = e.readFloat()
                , x = e.readFloat();
            for (let w = 0, S = 0; p.setFrame(w, m, g, b, v, _, y, x),
                w != f; w++) {
                const E = e.readFloat()
                    , C = e.readFloat()
                    , I = e.readFloat()
                    , L = e.readFloat()
                    , k = e.readFloat()
                    , R = e.readFloat()
                    , U = e.readFloat();
                switch (e.readByte()) {
                    case qr:
                        p.setStepped(w);
                        break;
                    case Kr:
                        yt(e, p, S++, w, 0, m, E, g, C, 1),
                            yt(e, p, S++, w, 1, m, E, b, I, 1),
                            yt(e, p, S++, w, 2, m, E, v, L, 1),
                            yt(e, p, S++, w, 3, m, E, _, k, 1),
                            yt(e, p, S++, w, 4, m, E, y, R, 1),
                            yt(e, p, S++, w, 5, m, E, x, U, 1)
                }
                m = E,
                    g = C,
                    b = I,
                    v = L,
                    _ = k,
                    y = R,
                    x = U
            }
            r.push(p)
        }
        for (let c = 0, u = e.readInt(!0); c < u; c++) {
            const h = e.readInt(!0)
                , d = s.pathConstraints[h];
            for (let f = 0, p = e.readInt(!0); f < p; f++)
                switch (e.readByte()) {
                    case zhe:
                        r.push(ro(e, new nS(e.readInt(!0), e.readInt(!0), h), d.positionMode == on.Fixed ? i : 1));
                        break;
                    case qhe:
                        r.push(ro(e, new sS(e.readInt(!0), e.readInt(!0), h), d.spacingMode == Rn.Length || d.spacingMode == Rn.Fixed ? i : 1));
                        break;
                    case Khe:
                        const m = new rS(e.readInt(!0), e.readInt(!0), h);
                        let g = e.readFloat()
                            , b = e.readFloat()
                            , v = e.readFloat()
                            , _ = e.readFloat();
                        for (let y = 0, x = 0, w = m.getFrameCount() - 1; m.setFrame(y, g, b, v, _),
                            y != w; y++) {
                            const S = e.readFloat()
                                , E = e.readFloat()
                                , C = e.readFloat()
                                , I = e.readFloat();
                            switch (e.readByte()) {
                                case qr:
                                    m.setStepped(y);
                                    break;
                                case Kr:
                                    yt(e, m, x++, y, 0, g, S, b, E, 1),
                                        yt(e, m, x++, y, 1, g, S, v, C, 1),
                                        yt(e, m, x++, y, 2, g, S, _, I, 1)
                            }
                            g = S,
                                b = E,
                                v = C,
                                _ = I
                        }
                        r.push(m)
                }
        }
        for (let c = 0, u = e.readInt(!0); c < u; c++) {
            const h = s.skins[e.readInt(!0)];
            for (let d = 0, f = e.readInt(!0); d < f; d++) {
                const p = e.readInt(!0);
                for (let m = 0, g = e.readInt(!0); m < g; m++) {
                    const b = e.readStringRef();
                    if (!b)
                        throw new Error("attachmentName must not be null.");
                    const v = h.getAttachment(p, b)
                        , _ = this.readDeformTimelineType(e)
                        , y = e.readInt(!0)
                        , x = y - 1;
                    switch (_) {
                        case xA:
                            {
                                const w = v
                                    , S = w.bones
                                    , E = w.vertices
                                    , C = S ? E.length / 3 * 2 : E.length
                                    , I = e.readInt(!0)
                                    , L = new Qw(y, I, p, w);
                                let k = e.readFloat();
                                for (let R = 0, U = 0; ; R++) {
                                    let W, H = e.readInt(!0);
                                    if (H == 0)
                                        W = S ? Q.newFloatArray(C) : E;
                                    else {
                                        W = Q.newFloatArray(C);
                                        const z = e.readInt(!0);
                                        if (H += z,
                                            i == 1)
                                            for (let ee = z; ee < H; ee++)
                                                W[ee] = e.readFloat();
                                        else
                                            for (let ee = z; ee < H; ee++)
                                                W[ee] = e.readFloat() * i;
                                        if (!S)
                                            for (let ee = 0, J = W.length; ee < J; ee++)
                                                W[ee] += E[ee]
                                    }
                                    if (L.setFrame(R, k, W),
                                        R == x)
                                        break;
                                    const j = e.readFloat();
                                    switch (e.readByte()) {
                                        case qr:
                                            L.setStepped(R);
                                            break;
                                        case Kr:
                                            yt(e, L, U++, R, 0, k, j, 0, 1, 1)
                                    }
                                    k = j
                                }
                                r.push(L);
                                break
                            }
                        case jhe:
                            {
                                const w = new yh(y, p, v);
                                for (let S = 0; S < y; S++) {
                                    const E = e.readFloat()
                                        , C = e.readInt32();
                                    w.setFrame(S, E, Fw[C & 15], C >> 4, e.readFloat())
                                }
                                r.push(w);
                                break
                            }
                    }
                }
            }
        }
        const o = e.readInt(!0);
        if (o > 0) {
            const c = new jl(o)
                , u = s.slots.length;
            for (let h = 0; h < o; h++) {
                const d = e.readFloat()
                    , f = e.readInt(!0)
                    , p = Q.newArray(u, 0);
                for (let v = u - 1; v >= 0; v--)
                    p[v] = -1;
                const m = Q.newArray(u - f, 0);
                let g = 0
                    , b = 0;
                for (let v = 0; v < f; v++) {
                    const _ = e.readInt(!0);
                    for (; g != _;)
                        m[b++] = g++;
                    p[g + e.readInt(!0)] = g++
                }
                for (; g < u;)
                    m[b++] = g++;
                for (let v = u - 1; v >= 0; v--)
                    p[v] == -1 && (p[v] = m[--b]);
                c.setFrame(h, d, p)
            }
            r.push(c)
        }
        const l = e.readInt(!0);
        if (l > 0) {
            const c = new wf(l);
            for (let u = 0; u < l; u++) {
                const h = e.readFloat()
                    , d = s.events[e.readInt(!0)]
                    , f = new aS(h, d);
                f.intValue = e.readInt(!1),
                    f.floatValue = e.readFloat(),
                    f.stringValue = e.readBoolean() ? e.readString() : d.stringValue,
                    f.data.audioPath && (f.volume = e.readFloat(),
                        f.balance = e.readFloat()),
                    c.setFrame(u, f)
            }
            r.push(c)
        }
        let a = 0;
        for (let c = 0, u = r.length; c < u; c++)
            a = Math.max(a, r[c].getDuration());
        return new j_(n, r, a)
    }
}
mS.BlendModeValues = [Oe.NORMAL, Oe.ADD, Oe.MULTIPLY, Oe.SCREEN];
let khe = class {
    constructor(e, n, s, r, i) {
        this.mesh = e,
            this.skin = n,
            this.slotIndex = s,
            this.parent = r,
            this.inheritTimeline = i
    }
}
    ;
class Rhe {
    constructor(e = null, n = null) {
        this.bones = e,
            this.vertices = n
    }
}
function ro(t, e, n) {
    let s = t.readFloat()
        , r = t.readFloat() * n;
    for (let i = 0, o = 0, l = e.getFrameCount() - 1; e.setFrame(i, s, r),
        i != l; i++) {
        const a = t.readFloat()
            , c = t.readFloat() * n;
        switch (t.readByte()) {
            case qr:
                e.setStepped(i);
                break;
            case Kr:
                yt(t, e, o++, i, 0, s, a, r, c, n)
        }
        s = a,
            r = c
    }
    return e
}
function I1(t, e, n) {
    let s = t.readFloat()
        , r = t.readFloat() * n
        , i = t.readFloat() * n;
    for (let o = 0, l = 0, a = e.getFrameCount() - 1; e.setFrame(o, s, r, i),
        o != a; o++) {
        const c = t.readFloat()
            , u = t.readFloat() * n
            , h = t.readFloat() * n;
        switch (t.readByte()) {
            case qr:
                e.setStepped(o);
                break;
            case Kr:
                yt(t, e, l++, o, 0, s, c, r, u, n),
                    yt(t, e, l++, o, 1, s, c, i, h, n)
        }
        s = c,
            r = u,
            i = h
    }
    return e
}
function yt(t, e, n, s, r, i, o, l, a, c) {
    e.setBezier(n, s, r, i, l, t.readFloat(), t.readFloat() * c, t.readFloat(), t.readFloat() * c, o, a)
}
const Mhe = 0
    , Phe = 1
    , Lhe = 2
    , Ohe = 3
    , Nhe = 4
    , Dhe = 5
    , Bhe = 6
    , Fhe = 7
    , $he = 8
    , Uhe = 9
    , Vhe = 0
    , Ghe = 1
    , Hhe = 2
    , Whe = 3
    , Yhe = 4
    , Xhe = 5
    , xA = 0
    , jhe = 1
    , zhe = 0
    , qhe = 1
    , Khe = 2
    , qr = 1
    , Kr = 2;
class Jhe extends aw {
}
class J_ {
    constructor(e) {
        this.scale = 1,
            this.linkedMeshes = new Array,
            this.attachmentLoader = e
    }
    readSkeletonData(e) {
        const n = this.scale
            , s = new dS
            , r = typeof e == "string" ? JSON.parse(e) : e
            , i = r.skeleton;
        if (i) {
            s.hash = i.hash,
                s.version = i.spine;
            const o = s.version.substr(0, 3);
            if (o !== "4.0" && o !== "4.1") {
                const l = `Spine 4.1 loader cant load version ${i.spine}. Please configure your pixi-spine bundle`;
                console.error(l)
            }
            s.x = i.x,
                s.y = i.y,
                s.width = i.width,
                s.height = i.height,
                s.fps = i.fps,
                s.imagesPath = i.images
        }
        if (r.bones)
            for (let o = 0; o < r.bones.length; o++) {
                const l = r.bones[o];
                let a = null;
                const c = se(l, "parent", null);
                if (c != null && (a = s.findBone(c),
                    a == null))
                    throw new Error(`Parent bone not found: ${c}`);
                const u = new oS(s.bones.length, l.name, a);
                u.length = se(l, "length", 0) * n,
                    u.x = se(l, "x", 0) * n,
                    u.y = se(l, "y", 0) * n,
                    u.rotation = se(l, "rotation", 0),
                    u.scaleX = se(l, "scaleX", 1),
                    u.scaleY = se(l, "scaleY", 1),
                    u.shearX = se(l, "shearX", 0),
                    u.shearY = se(l, "shearY", 0),
                    u.transformMode = Q.enumValue(Qe, se(l, "transform", "Normal")),
                    u.skinRequired = se(l, "skin", !1);
                const h = se(l, "color", null);
                h && u.color.setFromString(h),
                    s.bones.push(u)
            }
        if (r.slots)
            for (let o = 0; o < r.slots.length; o++) {
                const l = r.slots[o]
                    , a = s.findBone(l.bone);
                if (!a)
                    throw new Error(`Couldn't find bone ${l.bone} for slot ${l.name}`);
                const c = new fS(s.slots.length, l.name, a)
                    , u = se(l, "color", null);
                u && c.color.setFromString(u);
                const h = se(l, "dark", null);
                h && (c.darkColor = Se.fromString(h)),
                    c.attachmentName = se(l, "attachment", null),
                    c.blendMode = J_.blendModeFromString(se(l, "blend", "normal")),
                    s.slots.push(c)
            }
        if (r.ik)
            for (let o = 0; o < r.ik.length; o++) {
                const l = r.ik[o]
                    , a = new cS(l.name);
                a.order = se(l, "order", 0),
                    a.skinRequired = se(l, "skin", !1);
                for (let c = 0; c < l.bones.length; c++) {
                    const u = l.bones[c]
                        , h = s.findBone(u);
                    if (h == null)
                        throw new Error(`IK bone not found: ${u}`);
                    a.bones.push(h)
                }
                a.target = s.findBone(l.target),
                    a.mix = se(l, "mix", 1),
                    a.softness = se(l, "softness", 0) * n,
                    a.bendDirection = se(l, "bendPositive", !0) ? 1 : -1,
                    a.compress = se(l, "compress", !1),
                    a.stretch = se(l, "stretch", !1),
                    a.uniform = se(l, "uniform", !1),
                    s.ikConstraints.push(a)
            }
        if (r.transform)
            for (let o = 0; o < r.transform.length; o++) {
                const l = r.transform[o]
                    , a = new pS(l.name);
                a.order = se(l, "order", 0),
                    a.skinRequired = se(l, "skin", !1);
                for (let h = 0; h < l.bones.length; h++) {
                    const d = l.bones[h]
                        , f = s.findBone(d);
                    if (!f)
                        throw new Error(`Couldn't find bone ${d} for transform constraint ${l.name}.`);
                    a.bones.push(f)
                }
                const c = l.target
                    , u = s.findBone(c);
                if (!u)
                    throw new Error(`Couldn't find target bone ${c} for transform constraint ${l.name}.`);
                a.target = u,
                    a.local = se(l, "local", !1),
                    a.relative = se(l, "relative", !1),
                    a.offsetRotation = se(l, "rotation", 0),
                    a.offsetX = se(l, "x", 0) * n,
                    a.offsetY = se(l, "y", 0) * n,
                    a.offsetScaleX = se(l, "scaleX", 0),
                    a.offsetScaleY = se(l, "scaleY", 0),
                    a.offsetShearY = se(l, "shearY", 0),
                    a.mixRotate = se(l, "mixRotate", 1),
                    a.mixX = se(l, "mixX", 1),
                    a.mixY = se(l, "mixY", a.mixX),
                    a.mixScaleX = se(l, "mixScaleX", 1),
                    a.mixScaleY = se(l, "mixScaleY", a.mixScaleX),
                    a.mixShearY = se(l, "mixShearY", 1),
                    s.transformConstraints.push(a)
            }
        if (r.path)
            for (let o = 0; o < r.path.length; o++) {
                const l = r.path[o]
                    , a = new uS(l.name);
                a.order = se(l, "order", 0),
                    a.skinRequired = se(l, "skin", !1);
                for (let h = 0; h < l.bones.length; h++) {
                    const d = l.bones[h]
                        , f = s.findBone(d);
                    if (!f)
                        throw new Error(`Couldn't find bone ${d} for path constraint ${l.name}.`);
                    a.bones.push(f)
                }
                const c = l.target
                    , u = s.findSlot(c);
                if (!u)
                    throw new Error(`Couldn't find target slot ${c} for path constraint ${l.name}.`);
                a.target = u,
                    a.positionMode = Q.enumValue(on, se(l, "positionMode", "Percent")),
                    a.spacingMode = Q.enumValue(Rn, se(l, "spacingMode", "Length")),
                    a.rotateMode = Q.enumValue(bn, se(l, "rotateMode", "Tangent")),
                    a.offsetRotation = se(l, "rotation", 0),
                    a.position = se(l, "position", 0),
                    a.positionMode == on.Fixed && (a.position *= n),
                    a.spacing = se(l, "spacing", 0),
                    (a.spacingMode == Rn.Length || a.spacingMode == Rn.Fixed) && (a.spacing *= n),
                    a.mixRotate = se(l, "mixRotate", 1),
                    a.mixX = se(l, "mixX", 1),
                    a.mixY = se(l, "mixY", a.mixX),
                    s.pathConstraints.push(a)
            }
        if (r.skins)
            for (let o = 0; o < r.skins.length; o++) {
                const l = r.skins[o]
                    , a = new Gd(l.name);
                if (l.bones)
                    for (let c = 0; c < l.bones.length; c++) {
                        const u = l.bones[c]
                            , h = s.findBone(u);
                        if (!h)
                            throw new Error(`Couldn't find bone ${u} for skin ${l.name}.`);
                        a.bones.push(h)
                    }
                if (l.ik)
                    for (let c = 0; c < l.ik.length; c++) {
                        const u = l.ik[c]
                            , h = s.findIkConstraint(u);
                        if (!h)
                            throw new Error(`Couldn't find IK constraint ${u} for skin ${l.name}.`);
                        a.constraints.push(h)
                    }
                if (l.transform)
                    for (let c = 0; c < l.transform.length; c++) {
                        const u = l.transform[c]
                            , h = s.findTransformConstraint(u);
                        if (!h)
                            throw new Error(`Couldn't find transform constraint ${u} for skin ${l.name}.`);
                        a.constraints.push(h)
                    }
                if (l.path)
                    for (let c = 0; c < l.path.length; c++) {
                        const u = l.path[c]
                            , h = s.findPathConstraint(u);
                        if (!h)
                            throw new Error(`Couldn't find path constraint ${u} for skin ${l.name}.`);
                        a.constraints.push(h)
                    }
                for (const c in l.attachments) {
                    const u = s.findSlot(c);
                    if (!u)
                        throw new Error(`Couldn't find slot ${c} for skin ${l.name}.`);
                    const h = l.attachments[c];
                    for (const d in h) {
                        const f = this.readAttachment(h[d], a, u.index, d, s);
                        f && a.setAttachment(u.index, d, f)
                    }
                }
                s.skins.push(a),
                    a.name == "default" && (s.defaultSkin = a)
            }
        for (let o = 0, l = this.linkedMeshes.length; o < l; o++) {
            const a = this.linkedMeshes[o]
                , c = a.skin ? s.findSkin(a.skin) : s.defaultSkin;
            if (!c)
                throw new Error(`Skin not found: ${a.skin}`);
            const u = c.getAttachment(a.slotIndex, a.parent);
            if (!u)
                throw new Error(`Parent mesh not found: ${a.parent}`);
            a.mesh.timelineAttachment = a.inheritTimeline ? u : a.mesh,
                a.mesh.setParentMesh(u)
        }
        if (this.linkedMeshes.length = 0,
            r.events)
            for (const o in r.events) {
                const l = r.events[o]
                    , a = new lS(o);
                a.intValue = se(l, "int", 0),
                    a.floatValue = se(l, "float", 0),
                    a.stringValue = se(l, "string", ""),
                    a.audioPath = se(l, "audio", null),
                    a.audioPath && (a.volume = se(l, "volume", 1),
                        a.balance = se(l, "balance", 0)),
                    s.events.push(a)
            }
        if (r.animations)
            for (const o in r.animations) {
                const l = r.animations[o];
                this.readAnimation(l, o, s)
            }
        return s
    }
    readAttachment(e, n, s, r, i) {
        const o = this.scale;
        switch (r = se(e, "name", r),
        se(e, "type", "region")) {
            case "region":
                {
                    const l = se(e, "path", r)
                        , a = this.readSequence(se(e, "sequence", null))
                        , c = this.attachmentLoader.newRegionAttachment(n, r, l, a);
                    if (!c)
                        return null;
                    c.path = l,
                        c.x = se(e, "x", 0) * o,
                        c.y = se(e, "y", 0) * o,
                        c.scaleX = se(e, "scaleX", 1),
                        c.scaleY = se(e, "scaleY", 1),
                        c.rotation = se(e, "rotation", 0),
                        c.width = e.width * o,
                        c.height = e.height * o,
                        c.sequence = a;
                    const u = se(e, "color", null);
                    return u && c.color.setFromString(u),
                        c
                }
            case "boundingbox":
                {
                    const l = this.attachmentLoader.newBoundingBoxAttachment(n, r);
                    if (!l)
                        return null;
                    this.readVertices(e, l, e.vertexCount << 1);
                    const a = se(e, "color", null);
                    return a && l.color.setFromString(a),
                        l
                }
            case "mesh":
            case "linkedmesh":
                {
                    const l = se(e, "path", r)
                        , a = this.readSequence(se(e, "sequence", null))
                        , c = this.attachmentLoader.newMeshAttachment(n, r, l, a);
                    if (!c)
                        return null;
                    c.path = l;
                    const u = se(e, "color", null);
                    u && c.color.setFromString(u),
                        c.width = se(e, "width", 0) * o,
                        c.height = se(e, "height", 0) * o,
                        c.sequence = a;
                    const h = se(e, "parent", null);
                    if (h)
                        return this.linkedMeshes.push(new Zhe(c, se(e, "skin", null), s, h, se(e, "timelines", !0))),
                            c;
                    const d = e.uvs;
                    return this.readVertices(e, c, d.length),
                        c.triangles = e.triangles,
                        c.regionUVs = new Float32Array(d),
                        c.edges = se(e, "edges", null),
                        c.hullLength = se(e, "hull", 0) * 2,
                        c
                }
            case "path":
                {
                    const l = this.attachmentLoader.newPathAttachment(n, r);
                    if (!l)
                        return null;
                    l.closed = se(e, "closed", !1),
                        l.constantSpeed = se(e, "constantSpeed", !0);
                    const a = e.vertexCount;
                    this.readVertices(e, l, a << 1);
                    const c = Q.newArray(a / 3, 0);
                    for (let h = 0; h < e.lengths.length; h++)
                        c[h] = e.lengths[h] * o;
                    l.lengths = c;
                    const u = se(e, "color", null);
                    return u && l.color.setFromString(u),
                        l
                }
            case "point":
                {
                    const l = this.attachmentLoader.newPointAttachment(n, r);
                    if (!l)
                        return null;
                    l.x = se(e, "x", 0) * o,
                        l.y = se(e, "y", 0) * o,
                        l.rotation = se(e, "rotation", 0);
                    const a = se(e, "color", null);
                    return a && l.color.setFromString(a),
                        l
                }
            case "clipping":
                {
                    const l = this.attachmentLoader.newClippingAttachment(n, r);
                    if (!l)
                        return null;
                    const a = se(e, "end", null);
                    if (a != null) {
                        const h = i.findSlot(a);
                        if (h == null)
                            throw new Error(`Clipping end slot not found: ${a}`);
                        l.endSlot = h
                    }
                    const c = e.vertexCount;
                    this.readVertices(e, l, c << 1);
                    const u = se(e, "color", null);
                    return u && l.color.setFromString(u),
                        l
                }
        }
        return null
    }
    readSequence(e) {
        if (e == null)
            return null;
        const n = new X_(se(e, "count", 0));
        return n.start = se(e, "start", 1),
            n.digits = se(e, "digits", 0),
            n.setupIndex = se(e, "setup", 0),
            n
    }
    readVertices(e, n, s) {
        const r = this.scale;
        n.worldVerticesLength = s;
        const i = e.vertices;
        if (s == i.length) {
            const a = Q.toFloatArray(i);
            if (r != 1)
                for (let c = 0, u = i.length; c < u; c++)
                    a[c] *= r;
            n.vertices = a;
            return
        }
        const o = new Array
            , l = new Array;
        for (let a = 0, c = i.length; a < c;) {
            const u = i[a++];
            l.push(u);
            for (let h = a + u * 4; a < h; a += 4)
                l.push(i[a]),
                    o.push(i[a + 1] * r),
                    o.push(i[a + 2] * r),
                    o.push(i[a + 3])
        }
        n.bones = l,
            n.vertices = Q.toFloatArray(o)
    }
    readAnimation(e, n, s) {
        const r = this.scale
            , i = new Array;
        if (e.slots)
            for (const l in e.slots) {
                const a = e.slots[l]
                    , c = s.findSlot(l);
                if (!c)
                    throw new Error(`Slot not found: ${l}`);
                const u = c.index;
                for (const h in a) {
                    const d = a[h];
                    if (!d)
                        continue;
                    const f = d.length;
                    if (h == "attachment") {
                        const p = new Bl(f, u);
                        for (let m = 0; m < f; m++) {
                            const g = d[m];
                            p.setFrame(m, se(g, "time", 0), se(g, "name", null))
                        }
                        i.push(p)
                    } else if (h == "rgba") {
                        const p = new zw(f, f << 2, u);
                        let m = d[0]
                            , g = se(m, "time", 0)
                            , b = Se.fromString(m.color);
                        for (let v = 0, _ = 0; ; v++) {
                            p.setFrame(v, g, b.r, b.g, b.b, b.a);
                            const y = d[v + 1];
                            if (!y) {
                                p.shrink(_);
                                break
                            }
                            const x = se(y, "time", 0)
                                , w = Se.fromString(y.color)
                                , S = m.curve;
                            S && (_ = wt(S, p, _, v, 0, g, x, b.r, w.r, 1),
                                _ = wt(S, p, _, v, 1, g, x, b.g, w.g, 1),
                                _ = wt(S, p, _, v, 2, g, x, b.b, w.b, 1),
                                _ = wt(S, p, _, v, 3, g, x, b.a, w.a, 1)),
                                g = x,
                                b = w,
                                m = y
                        }
                        i.push(p)
                    } else if (h == "rgb") {
                        const p = new qw(f, f * 3, u);
                        let m = d[0]
                            , g = se(m, "time", 0)
                            , b = Se.fromString(m.color);
                        for (let v = 0, _ = 0; ; v++) {
                            p.setFrame(v, g, b.r, b.g, b.b);
                            const y = d[v + 1];
                            if (!y) {
                                p.shrink(_);
                                break
                            }
                            const x = se(y, "time", 0)
                                , w = Se.fromString(y.color)
                                , S = m.curve;
                            S && (_ = wt(S, p, _, v, 0, g, x, b.r, w.r, 1),
                                _ = wt(S, p, _, v, 1, g, x, b.g, w.g, 1),
                                _ = wt(S, p, _, v, 2, g, x, b.b, w.b, 1)),
                                g = x,
                                b = w,
                                m = y
                        }
                        i.push(p)
                    } else if (h == "alpha")
                        i.push(wi(d, new Kw(f, f, u), 0, 1));
                    else if (h == "rgba2") {
                        const p = new Jw(f, f * 7, u);
                        let m = d[0]
                            , g = se(m, "time", 0)
                            , b = Se.fromString(m.light)
                            , v = Se.fromString(m.dark);
                        for (let _ = 0, y = 0; ; _++) {
                            p.setFrame(_, g, b.r, b.g, b.b, b.a, v.r, v.g, v.b);
                            const x = d[_ + 1];
                            if (!x) {
                                p.shrink(y);
                                break
                            }
                            const w = se(x, "time", 0)
                                , S = Se.fromString(x.light)
                                , E = Se.fromString(x.dark)
                                , C = m.curve;
                            C && (y = wt(C, p, y, _, 0, g, w, b.r, S.r, 1),
                                y = wt(C, p, y, _, 1, g, w, b.g, S.g, 1),
                                y = wt(C, p, y, _, 2, g, w, b.b, S.b, 1),
                                y = wt(C, p, y, _, 3, g, w, b.a, S.a, 1),
                                y = wt(C, p, y, _, 4, g, w, v.r, E.r, 1),
                                y = wt(C, p, y, _, 5, g, w, v.g, E.g, 1),
                                y = wt(C, p, y, _, 6, g, w, v.b, E.b, 1)),
                                g = w,
                                b = S,
                                v = E,
                                m = x
                        }
                        i.push(p)
                    } else if (h == "rgb2") {
                        const p = new Zw(f, f * 6, u);
                        let m = d[0]
                            , g = se(m, "time", 0)
                            , b = Se.fromString(m.light)
                            , v = Se.fromString(m.dark);
                        for (let _ = 0, y = 0; ; _++) {
                            p.setFrame(_, g, b.r, b.g, b.b, v.r, v.g, v.b);
                            const x = d[_ + 1];
                            if (!x) {
                                p.shrink(y);
                                break
                            }
                            const w = se(x, "time", 0)
                                , S = Se.fromString(x.light)
                                , E = Se.fromString(x.dark)
                                , C = m.curve;
                            C && (y = wt(C, p, y, _, 0, g, w, b.r, S.r, 1),
                                y = wt(C, p, y, _, 1, g, w, b.g, S.g, 1),
                                y = wt(C, p, y, _, 2, g, w, b.b, S.b, 1),
                                y = wt(C, p, y, _, 3, g, w, v.r, E.r, 1),
                                y = wt(C, p, y, _, 4, g, w, v.g, E.g, 1),
                                y = wt(C, p, y, _, 5, g, w, v.b, E.b, 1)),
                                g = w,
                                b = S,
                                v = E,
                                m = x
                        }
                        i.push(p)
                    }
                }
            }
        if (e.bones)
            for (const l in e.bones) {
                const a = e.bones[l]
                    , c = s.findBone(l);
                if (!c)
                    throw new Error(`Bone not found: ${l}`);
                const u = c.index;
                for (const h in a) {
                    const d = a[h]
                        , f = d.length;
                    if (f != 0) {
                        if (h === "rotate")
                            i.push(wi(d, new Vd(f, f, u), 0, 1));
                        else if (h === "translate") {
                            const p = new $w(f, f << 1, u);
                            i.push(A1(d, p, "x", "y", 0, r))
                        } else if (h === "translatex") {
                            const p = new Uw(f, f, u);
                            i.push(wi(d, p, 0, r))
                        } else if (h === "translatey") {
                            const p = new Vw(f, f, u);
                            i.push(wi(d, p, 0, r))
                        } else if (h === "scale") {
                            const p = new Gw(f, f << 1, u);
                            i.push(A1(d, p, "x", "y", 1, 1))
                        } else if (h === "scalex") {
                            const p = new Hw(f, f, u);
                            i.push(wi(d, p, 1, 1))
                        } else if (h === "scaley") {
                            const p = new Ww(f, f, u);
                            i.push(wi(d, p, 1, 1))
                        } else if (h === "shear") {
                            const p = new Yw(f, f << 1, u);
                            i.push(A1(d, p, "x", "y", 0, 1))
                        } else if (h === "shearx") {
                            const p = new Xw(f, f, u);
                            i.push(wi(d, p, 0, 1))
                        } else if (h === "sheary") {
                            const p = new jw(f, f, u);
                            i.push(wi(d, p, 0, 1))
                        }
                    }
                }
            }
        if (e.ik)
            for (const l in e.ik) {
                const a = e.ik[l];
                let c = a[0];
                if (!c)
                    continue;
                const u = s.findIkConstraint(l);
                if (!u)
                    throw new Error(`IK Constraint not found: ${l}`);
                const h = s.ikConstraints.indexOf(u)
                    , d = new eS(a.length, a.length << 1, h);
                let f = se(c, "time", 0)
                    , p = se(c, "mix", 1)
                    , m = se(c, "softness", 0) * r;
                for (let g = 0, b = 0; ; g++) {
                    d.setFrame(g, f, p, m, se(c, "bendPositive", !0) ? 1 : -1, se(c, "compress", !1), se(c, "stretch", !1));
                    const v = a[g + 1];
                    if (!v) {
                        d.shrink(b);
                        break
                    }
                    const _ = se(v, "time", 0)
                        , y = se(v, "mix", 1)
                        , x = se(v, "softness", 0) * r
                        , w = c.curve;
                    w && (b = wt(w, d, b, g, 0, f, _, p, y, 1),
                        b = wt(w, d, b, g, 1, f, _, m, x, r)),
                        f = _,
                        p = y,
                        m = x,
                        c = v
                }
                i.push(d)
            }
        if (e.transform)
            for (const l in e.transform) {
                const a = e.transform[l];
                let c = a[0];
                if (!c)
                    continue;
                const u = s.findTransformConstraint(l);
                if (!u)
                    throw new Error(`Transform constraint not found: ${l}`);
                const h = s.transformConstraints.indexOf(u)
                    , d = new tS(a.length, a.length * 6, h);
                let f = se(c, "time", 0)
                    , p = se(c, "mixRotate", 1)
                    , m = se(c, "mixX", 1)
                    , g = se(c, "mixY", m)
                    , b = se(c, "mixScaleX", 1)
                    , v = se(c, "mixScaleY", b);
                const _ = se(c, "mixShearY", 1);
                for (let y = 0, x = 0; ; y++) {
                    d.setFrame(y, f, p, m, g, b, v, _);
                    const w = a[y + 1];
                    if (!w) {
                        d.shrink(x);
                        break
                    }
                    const S = se(w, "time", 0)
                        , E = se(w, "mixRotate", 1)
                        , C = se(w, "mixX", 1)
                        , I = se(w, "mixY", C)
                        , L = se(w, "mixScaleX", 1)
                        , k = se(w, "mixScaleY", L)
                        , R = se(w, "mixShearY", 1)
                        , U = c.curve;
                    U && (x = wt(U, d, x, y, 0, f, S, p, E, 1),
                        x = wt(U, d, x, y, 1, f, S, m, C, 1),
                        x = wt(U, d, x, y, 2, f, S, g, I, 1),
                        x = wt(U, d, x, y, 3, f, S, b, L, 1),
                        x = wt(U, d, x, y, 4, f, S, v, k, 1),
                        x = wt(U, d, x, y, 5, f, S, _, R, 1)),
                        f = S,
                        p = E,
                        m = C,
                        g = I,
                        b = L,
                        v = k,
                        b = L,
                        c = w
                }
                i.push(d)
            }
        if (e.path)
            for (const l in e.path) {
                const a = e.path[l]
                    , c = s.findPathConstraint(l);
                if (!c)
                    throw new Error(`Path constraint not found: ${l}`);
                const u = s.pathConstraints.indexOf(c);
                for (const h in a) {
                    const d = a[h];
                    let f = d[0];
                    if (!f)
                        continue;
                    const p = d.length;
                    if (h === "position") {
                        const m = new nS(p, p, u);
                        i.push(wi(d, m, 0, c.positionMode == on.Fixed ? r : 1))
                    } else if (h === "spacing") {
                        const m = new sS(p, p, u);
                        i.push(wi(d, m, 0, c.spacingMode == Rn.Length || c.spacingMode == Rn.Fixed ? r : 1))
                    } else if (h === "mix") {
                        const m = new rS(p, p * 3, u);
                        let g = se(f, "time", 0)
                            , b = se(f, "mixRotate", 1)
                            , v = se(f, "mixX", 1)
                            , _ = se(f, "mixY", v);
                        for (let y = 0, x = 0; ; y++) {
                            m.setFrame(y, g, b, v, _);
                            const w = d[y + 1];
                            if (!w) {
                                m.shrink(x);
                                break
                            }
                            const S = se(w, "time", 0)
                                , E = se(w, "mixRotate", 1)
                                , C = se(w, "mixX", 1)
                                , I = se(w, "mixY", C)
                                , L = f.curve;
                            L && (x = wt(L, m, x, y, 0, g, S, b, E, 1),
                                x = wt(L, m, x, y, 1, g, S, v, C, 1),
                                x = wt(L, m, x, y, 2, g, S, _, I, 1)),
                                g = S,
                                b = E,
                                v = C,
                                _ = I,
                                f = w
                        }
                        i.push(m)
                    }
                }
            }
        if (e.deform) {
            e.attachments = {};
            for (const l in e.deform) {
                const a = e.deform[l]
                    , c = e.attachments[l] = {};
                for (const u in a) {
                    const h = a[u]
                        , d = c[u] = {};
                    for (const f in h)
                        d[f] = {
                            deform: h[f]
                        }
                }
            }
        }
        if (e.attachments)
            for (const l in e.attachments) {
                const a = e.attachments[l]
                    , c = s.findSkin(l);
                if (c != null)
                    for (const u in a) {
                        const h = a[u]
                            , d = s.findSlot(u);
                        if (!d)
                            throw new Error(`Slot not found: ${u}`);
                        const f = d.index;
                        for (const p in h) {
                            const m = h[p]
                                , g = c.getAttachment(f, p);
                            for (const b in m) {
                                const v = m[b];
                                let _ = v[0];
                                if (_) {
                                    if (b == "deform") {
                                        const y = g.bones
                                            , x = g.vertices
                                            , w = y ? x.length / 3 * 2 : x.length
                                            , S = new Qw(v.length, v.length, f, g);
                                        let E = se(_, "time", 0);
                                        for (let C = 0, I = 0; ; C++) {
                                            let L;
                                            const k = se(_, "vertices", null);
                                            if (!k)
                                                L = y ? Q.newFloatArray(w) : x;
                                            else {
                                                L = Q.newFloatArray(w);
                                                const H = se(_, "offset", 0);
                                                if (Q.arrayCopy(k, 0, L, H, k.length),
                                                    r != 1)
                                                    for (let j = H, z = j + k.length; j < z; j++)
                                                        L[j] *= r;
                                                if (!y)
                                                    for (let j = 0; j < w; j++)
                                                        L[j] += x[j]
                                            }
                                            S.setFrame(C, E, L);
                                            const R = v[C + 1];
                                            if (!R) {
                                                S.shrink(I);
                                                break
                                            }
                                            const U = se(R, "time", 0)
                                                , W = _.curve;
                                            W && (I = wt(W, S, I, C, 0, E, U, 0, 1, 1)),
                                                E = U,
                                                _ = R
                                        }
                                        i.push(S)
                                    } else if (b == "sequence") {
                                        const y = new yh(v.length, f, g);
                                        let x = 0;
                                        for (let w = 0; w < v.length; w++) {
                                            const S = se(_, "delay", x)
                                                , E = se(_, "time", 0)
                                                , C = Mi[se(_, "mode", "hold")]
                                                , I = se(_, "index", 0);
                                            y.setFrame(w, E, C, I, S),
                                                x = S,
                                                _ = v[w + 1]
                                        }
                                        i.push(y)
                                    }
                                }
                            }
                        }
                    }
            }
        if (e.drawOrder) {
            const l = new jl(e.drawOrder.length)
                , a = s.slots.length;
            let c = 0;
            for (let u = 0; u < e.drawOrder.length; u++,
                c++) {
                const h = e.drawOrder[u];
                let d = null;
                const f = se(h, "offsets", null);
                if (f) {
                    d = Q.newArray(a, -1);
                    const p = Q.newArray(a - f.length, 0);
                    let m = 0
                        , g = 0;
                    for (let b = 0; b < f.length; b++) {
                        const v = f[b]
                            , _ = s.findSlot(v.slot);
                        if (!_)
                            throw new Error(`Slot not found: ${_}`);
                        const y = _.index;
                        for (; m != y;)
                            p[g++] = m++;
                        d[m + v.offset] = m++
                    }
                    for (; m < a;)
                        p[g++] = m++;
                    for (let b = a - 1; b >= 0; b--)
                        d[b] == -1 && (d[b] = p[--g])
                }
                l.setFrame(c, se(h, "time", 0), d)
            }
            i.push(l)
        }
        if (e.events) {
            const l = new wf(e.events.length);
            let a = 0;
            for (let c = 0; c < e.events.length; c++,
                a++) {
                const u = e.events[c]
                    , h = s.findEvent(u.name);
                if (!h)
                    throw new Error(`Event not found: ${u.name}`);
                const d = new aS(Q.toSinglePrecision(se(u, "time", 0)), h);
                d.intValue = se(u, "int", h.intValue),
                    d.floatValue = se(u, "float", h.floatValue),
                    d.stringValue = se(u, "string", h.stringValue),
                    d.data.audioPath && (d.volume = se(u, "volume", 1),
                        d.balance = se(u, "balance", 0)),
                    l.setFrame(a, d)
            }
            i.push(l)
        }
        let o = 0;
        for (let l = 0, a = i.length; l < a; l++)
            o = Math.max(o, i[l].getDuration());
        if (isNaN(o))
            throw new Error("Error while parsing animation, duration is NaN");
        s.animations.push(new j_(n, i, o))
    }
    static blendModeFromString(e) {
        if (e = e.toLowerCase(),
            e == "normal")
            return Oe.NORMAL;
        if (e == "additive")
            return Oe.ADD;
        if (e == "multiply")
            return Oe.MULTIPLY;
        if (e == "screen")
            return Oe.SCREEN;
        throw new Error(`Unknown blend mode: ${e}`)
    }
}
class Zhe {
    constructor(e, n, s, r, i) {
        this.mesh = e,
            this.skin = n,
            this.slotIndex = s,
            this.parent = r,
            this.inheritTimeline = i
    }
}
function wi(t, e, n, s) {
    let r = t[0]
        , i = se(r, "time", 0)
        , o = se(r, "value", n) * s
        , l = 0;
    for (let a = 0; ; a++) {
        e.setFrame(a, i, o);
        const c = t[a + 1];
        if (!c)
            return e.shrink(l),
                e;
        const u = se(c, "time", 0)
            , h = se(c, "value", n) * s;
        r.curve && (l = wt(r.curve, e, l, a, 0, i, u, o, h, s)),
            i = u,
            o = h,
            r = c
    }
}
function A1(t, e, n, s, r, i) {
    let o = t[0]
        , l = se(o, "time", 0)
        , a = se(o, n, r) * i
        , c = se(o, s, r) * i
        , u = 0;
    for (let h = 0; ; h++) {
        e.setFrame(h, l, a, c);
        const d = t[h + 1];
        if (!d)
            return e.shrink(u),
                e;
        const f = se(d, "time", 0)
            , p = se(d, n, r) * i
            , m = se(d, s, r) * i
            , g = o.curve;
        g && (u = wt(g, e, u, h, 0, l, f, a, p, i),
            u = wt(g, e, u, h, 1, l, f, c, m, i)),
            l = f,
            a = p,
            c = m,
            o = d
    }
}
function wt(t, e, n, s, r, i, o, l, a, c) {
    if (t == "stepped")
        return e.setStepped(s),
            n;
    const u = r << 2
        , h = t[u]
        , d = t[u + 1] * c
        , f = t[u + 2]
        , p = t[u + 3] * c;
    return e.setBezier(n, s, r, i, l, h, d, f, p, o, a),
        n + 1
}
function se(t, e, n) {
    return t[e] !== void 0 ? t[e] : n
}
let Qhe = class extends ph {
    createSkeleton(e) {
        this.skeleton = new hS(e),
            this.skeleton.updateWorldTransform(),
            this.stateData = new fL(e),
            this.state = new bh(this.stateData)
    }
}
    ;
const ede = Object.freeze(Object.defineProperty({
    __proto__: null,
    AlphaTimeline: Kw,
    Animation: j_,
    AnimationState: bh,
    AnimationStateAdapter: Che,
    AnimationStateData: fL,
    AtlasAttachmentLoader: iS,
    Attachment: Bw,
    AttachmentTimeline: Bl,
    Bone: Kb,
    BoneData: oS,
    BoundingBoxAttachment: H_,
    ClippingAttachment: W_,
    ConstraintData: K_,
    CurveTimeline: gi,
    CurveTimeline1: _i,
    CurveTimeline2: z_,
    DeformTimeline: Qw,
    DrawOrderTimeline: jl,
    Event: aS,
    EventData: lS,
    EventQueue: dL,
    EventTimeline: wf,
    EventType: Vs,
    IkConstraint: pL,
    IkConstraintData: cS,
    IkConstraintTimeline: eS,
    MeshAttachment: uc,
    PathAttachment: hc,
    PathConstraint: vh,
    PathConstraintData: uS,
    PathConstraintMixTimeline: rS,
    PathConstraintPositionTimeline: nS,
    PathConstraintSpacingTimeline: sS,
    PointAttachment: Y_,
    RGB2Timeline: Zw,
    RGBA2Timeline: Jw,
    RGBATimeline: zw,
    RGBTimeline: qw,
    RegionAttachment: Et,
    RotateTimeline: Vd,
    ScaleTimeline: Gw,
    ScaleXTimeline: Hw,
    ScaleYTimeline: Ww,
    Sequence: X_,
    SequenceMode: Mi,
    SequenceModeValues: Fw,
    SequenceTimeline: yh,
    ShearTimeline: Yw,
    ShearXTimeline: Xw,
    ShearYTimeline: jw,
    Skeleton: hS,
    SkeletonBinary: mS,
    SkeletonBounds: Jhe,
    SkeletonData: dS,
    SkeletonJson: J_,
    Skin: Gd,
    SkinEntry: Jb,
    Slot: mL,
    SlotData: fS,
    SpacingMode: Rn,
    Spine: Qhe,
    Timeline: fn,
    TrackEntry: q_,
    TransformConstraint: gL,
    TransformConstraintData: pS,
    TransformConstraintTimeline: tS,
    TranslateTimeline: $w,
    TranslateXTimeline: Uw,
    TranslateYTimeline: Vw,
    VertexAttachment: di
}, Symbol.toStringTag, {
    value: "Module"
}));
var Cr = (t => (t[t.UNKNOWN = 0] = "UNKNOWN",
    t[t.VER37 = 37] = "VER37",
    t[t.VER38 = 38] = "VER38",
    t[t.VER40 = 40] = "VER40",
    t[t.VER41 = 41] = "VER41",
    t))(Cr || {});
function lg(t) {
    const e = t.substr(0, 3)
        , n = Math.floor(Number(e) * 10 + .001);
    return e === "3.7" ? 37 : e === "3.8" ? 38 : e === "4.0" ? 40 : e === "4.1" ? 41 : n < 37 ? 37 : 0
}
class tde {
    constructor() {
        this.scale = 1
    }
    readSkeletonData(e, n) {
        let s = null
            , r = this.readVersionOldFormat(n)
            , i = lg(r);
        if (i === Cr.VER38 && (s = new Sn(new xw(e))),
            r = this.readVersionNewFormat(n),
            i = lg(r),
            (i === Cr.VER40 || i === Cr.VER41) && (s = new mS(new iS(e))),
            !s) {
            const o = `Unsupported version of spine model ${r}, please update pixi-spine`;
            console.error(o)
        }
        return s.scale = this.scale,
            s.readSkeletonData(n)
    }
    readVersionOldFormat(e) {
        const n = new Gm(e);
        let s;
        try {
            n.readString(),
                s = n.readString()
        } catch {
            s = ""
        }
        return s || ""
    }
    readVersionNewFormat(e) {
        const n = new Gm(e);
        n.readInt32(),
            n.readInt32();
        let s;
        try {
            s = n.readString()
        } catch {
            s = ""
        }
        return s || ""
    }
}
class nde {
    constructor() {
        this.scale = 1
    }
    readSkeletonData(e, n) {
        const s = n.skeleton.spine
            , r = lg(s);
        let i = null;
        if (r === Cr.VER37 && (i = new aL(new q5(e))),
            r === Cr.VER38 && (i = new D5(new xw(e))),
            (r === Cr.VER40 || r === Cr.VER41) && (i = new J_(new iS(e))),
            !i) {
            const o = `Unsupported version of spine model ${s}, please update pixi-spine`;
            console.error(o)
        }
        return i.scale = this.scale,
            i.readSkeletonData(n)
    }
}
class sde extends hhe {
    createBinaryParser() {
        return new tde
    }
    createJsonParser() {
        return new nde
    }
    parseData(e, n, s) {
        return {
            spineData: e.readSkeletonData(n, s),
            spineAtlas: n
        }
    }
}
class _L extends ph {
    createSkeleton(e) {
        const n = lg(e.version);
        let s = null;
        if (n === Cr.VER37 && (s = The),
            n === Cr.VER38 && (s = bhe),
            (n === Cr.VER40 || n === Cr.VER41) && (s = ede),
            !s) {
            const r = `Cant detect version of spine model ${e.version}`;
            console.error(r)
        }
        this.skeleton = new s.Skeleton(e),
            this.skeleton.updateWorldTransform(),
            this.stateData = new s.AnimationStateData(e),
            this.state = new s.AnimationState(this.stateData)
    }
}
new sde().installLoader();
const yL = new Bt;
ln.prototype._cacheAsBitmap = !1;
ln.prototype._cacheData = null;
ln.prototype._cacheAsBitmapResolution = null;
ln.prototype._cacheAsBitmapMultisample = null;
class rde {
    constructor() {
        this.textureCacheId = null,
            this.originalRender = null,
            this.originalRenderCanvas = null,
            this.originalCalculateBounds = null,
            this.originalGetLocalBounds = null,
            this.originalUpdateTransform = null,
            this.originalDestroy = null,
            this.originalMask = null,
            this.originalFilterArea = null,
            this.originalContainsPoint = null,
            this.sprite = null
    }
}
Object.defineProperties(ln.prototype, {
    cacheAsBitmapResolution: {
        get() {
            return this._cacheAsBitmapResolution
        },
        set(t) {
            t !== this._cacheAsBitmapResolution && (this._cacheAsBitmapResolution = t,
                this.cacheAsBitmap && (this.cacheAsBitmap = !1,
                    this.cacheAsBitmap = !0))
        }
    },
    cacheAsBitmapMultisample: {
        get() {
            return this._cacheAsBitmapMultisample
        },
        set(t) {
            t !== this._cacheAsBitmapMultisample && (this._cacheAsBitmapMultisample = t,
                this.cacheAsBitmap && (this.cacheAsBitmap = !1,
                    this.cacheAsBitmap = !0))
        }
    },
    cacheAsBitmap: {
        get() {
            return this._cacheAsBitmap
        },
        set(t) {
            if (this._cacheAsBitmap === t)
                return;
            this._cacheAsBitmap = t;
            let e;
            t ? (this._cacheData || (this._cacheData = new rde),
                e = this._cacheData,
                e.originalRender = this.render,
                e.originalRenderCanvas = this.renderCanvas,
                e.originalUpdateTransform = this.updateTransform,
                e.originalCalculateBounds = this.calculateBounds,
                e.originalGetLocalBounds = this.getLocalBounds,
                e.originalDestroy = this.destroy,
                e.originalContainsPoint = this.containsPoint,
                e.originalMask = this._mask,
                e.originalFilterArea = this.filterArea,
                this.render = this._renderCached,
                this.renderCanvas = this._renderCachedCanvas,
                this.destroy = this._cacheAsBitmapDestroy) : (e = this._cacheData,
                    e.sprite && this._destroyCachedDisplayObject(),
                    this.render = e.originalRender,
                    this.renderCanvas = e.originalRenderCanvas,
                    this.calculateBounds = e.originalCalculateBounds,
                    this.getLocalBounds = e.originalGetLocalBounds,
                    this.destroy = e.originalDestroy,
                    this.updateTransform = e.originalUpdateTransform,
                    this.containsPoint = e.originalContainsPoint,
                    this._mask = e.originalMask,
                    this.filterArea = e.originalFilterArea)
        }
    }
});
ln.prototype._renderCached = function (t) {
    !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObject(t),
        this._cacheData.sprite.transform._worldID = this.transform._worldID,
        this._cacheData.sprite.worldAlpha = this.worldAlpha,
        this._cacheData.sprite._render(t))
}
    ;
ln.prototype._initCachedDisplayObject = function (t) {
    var d, f;
    if ((d = this._cacheData) != null && d.sprite)
        return;
    const e = this.alpha;
    this.alpha = 1,
        t.batch.flush();
    const n = this.getLocalBounds(new nt, !0);
    if ((f = this.filters) != null && f.length) {
        const p = this.filters[0].padding;
        n.pad(p)
    }
    const s = this.cacheAsBitmapResolution || t.resolution;
    n.ceil(s),
        n.width = Math.max(n.width, 1 / s),
        n.height = Math.max(n.height, 1 / s);
    const r = t.renderTexture.current
        , i = t.renderTexture.sourceFrame.clone()
        , o = t.renderTexture.destinationFrame.clone()
        , l = t.projection.transform
        , a = Sc.create({
            width: n.width,
            height: n.height,
            resolution: s,
            multisample: this.cacheAsBitmapMultisample ?? t.multisample
        })
        , c = `cacheAsBitmap_${lc()}`;
    this._cacheData.textureCacheId = c,
        st.addToCache(a.baseTexture, c),
        $e.addToCache(a, c);
    const u = this.transform.localTransform.copyTo(yL).invert().translate(-n.x, -n.y);
    this.render = this._cacheData.originalRender,
        t.render(this, {
            renderTexture: a,
            clear: !0,
            transform: u,
            skipUpdateTransform: !1
        }),
        t.framebuffer.blit(),
        t.projection.transform = l,
        t.renderTexture.bind(r, i, o),
        this.render = this._renderCached,
        this.updateTransform = this.displayObjectUpdateTransform,
        this.calculateBounds = this._calculateCachedBounds,
        this.getLocalBounds = this._getCachedLocalBounds,
        this._mask = null,
        this.filterArea = null,
        this.alpha = e;
    const h = new Tc(a);
    h.transform.worldTransform = this.transform.worldTransform,
        h.anchor.x = -(n.x / n.width),
        h.anchor.y = -(n.y / n.height),
        h.alpha = e,
        h._bounds = this._bounds,
        this._cacheData.sprite = h,
        this.transform._parentID = -1,
        this.parent ? this.updateTransform() : (this.enableTempParent(),
            this.updateTransform(),
            this.disableTempParent(null)),
        this.containsPoint = h.containsPoint.bind(h)
}
    ;
ln.prototype._renderCachedCanvas = function (t) {
    !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObjectCanvas(t),
        this._cacheData.sprite.worldAlpha = this.worldAlpha,
        this._cacheData.sprite._renderCanvas(t))
}
    ;
ln.prototype._initCachedDisplayObjectCanvas = function (t) {
    var u;
    if ((u = this._cacheData) != null && u.sprite)
        return;
    const e = this.getLocalBounds(new nt, !0)
        , n = this.alpha;
    this.alpha = 1;
    const s = t.canvasContext.activeContext
        , r = t._projTransform
        , i = this.cacheAsBitmapResolution || t.resolution;
    e.ceil(i),
        e.width = Math.max(e.width, 1 / i),
        e.height = Math.max(e.height, 1 / i);
    const o = Sc.create({
        width: e.width,
        height: e.height,
        resolution: i
    })
        , l = `cacheAsBitmap_${lc()}`;
    this._cacheData.textureCacheId = l,
        st.addToCache(o.baseTexture, l),
        $e.addToCache(o, l);
    const a = yL;
    this.transform.localTransform.copyTo(a),
        a.invert(),
        a.tx -= e.x,
        a.ty -= e.y,
        this.renderCanvas = this._cacheData.originalRenderCanvas,
        t.render(this, {
            renderTexture: o,
            clear: !0,
            transform: a,
            skipUpdateTransform: !1
        }),
        t.canvasContext.activeContext = s,
        t._projTransform = r,
        this.renderCanvas = this._renderCachedCanvas,
        this.updateTransform = this.displayObjectUpdateTransform,
        this.calculateBounds = this._calculateCachedBounds,
        this.getLocalBounds = this._getCachedLocalBounds,
        this._mask = null,
        this.filterArea = null,
        this.alpha = n;
    const c = new Tc(o);
    c.transform.worldTransform = this.transform.worldTransform,
        c.anchor.x = -(e.x / e.width),
        c.anchor.y = -(e.y / e.height),
        c.alpha = n,
        c._bounds = this._bounds,
        this._cacheData.sprite = c,
        this.transform._parentID = -1,
        this.parent ? this.updateTransform() : (this.parent = t._tempDisplayObjectParent,
            this.updateTransform(),
            this.parent = null),
        this.containsPoint = c.containsPoint.bind(c)
}
    ;
ln.prototype._calculateCachedBounds = function () {
    this._bounds.clear(),
        this._cacheData.sprite.transform._worldID = this.transform._worldID,
        this._cacheData.sprite._calculateBounds(),
        this._bounds.updateID = this._boundsID
}
    ;
ln.prototype._getCachedLocalBounds = function () {
    return this._cacheData.sprite.getLocalBounds(null)
}
    ;
ln.prototype._destroyCachedDisplayObject = function () {
    this._cacheData.sprite._texture.destroy(!0),
        this._cacheData.sprite = null,
        st.removeFromCache(this._cacheData.textureCacheId),
        $e.removeFromCache(this._cacheData.textureCacheId),
        this._cacheData.textureCacheId = null
}
    ;
ln.prototype._cacheAsBitmapDestroy = function (t) {
    this.cacheAsBitmap = !1,
        this.destroy(t)
}
    ;
ln.prototype.name = null;
ks.prototype.getChildByName = function (t, e) {
    for (let n = 0, s = this.children.length; n < s; n++)
        if (this.children[n].name === t)
            return this.children[n];
    if (e)
        for (let n = 0, s = this.children.length; n < s; n++) {
            const r = this.children[n];
            if (!r.getChildByName)
                continue;
            const i = r.getChildByName(t, !0);
            if (i)
                return i
        }
    return null
}
    ;
ln.prototype.getGlobalPosition = function (t = new At, e = !1) {
    return this.parent ? this.parent.toGlobal(this.position, t, e) : (t.x = this.position.x,
        t.y = this.position.y),
        t
}
    ;
var ide = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform float uAlpha;

void main(void)
{
   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;
}
`;
class ode extends As {
    constructor(e = 1) {
        super(qce, ide, {
            uAlpha: 1
        }),
            this.alpha = e
    }
    get alpha() {
        return this.uniforms.uAlpha
    }
    set alpha(e) {
        this.uniforms.uAlpha = e
    }
}
const ade = {
    5: [.153388, .221461, .250301],
    7: [.071303, .131514, .189879, .214607],
    9: [.028532, .067234, .124009, .179044, .20236],
    11: [.0093, .028002, .065984, .121703, .175713, .198596],
    13: [.002406, .009255, .027867, .065666, .121117, .174868, .197641],
    15: [489e-6, .002403, .009246, .02784, .065602, .120999, .174697, .197448]
}
    , lde = ["varying vec2 vBlurTexCoords[%size%];", "uniform sampler2D uSampler;", "void main(void)", "{", "    gl_FragColor = vec4(0.0);", "    %blur%", "}"].join(`
`);
function cde(t) {
    const e = ade[t]
        , n = e.length;
    let s = lde
        , r = "";
    const i = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;";
    let o;
    for (let l = 0; l < t; l++) {
        let a = i.replace("%index%", l.toString());
        o = l,
            l >= n && (o = t - l - 1),
            a = a.replace("%value%", e[o].toString()),
            r += a,
            r += `
`
    }
    return s = s.replace("%blur%", r),
        s = s.replace("%size%", t.toString()),
        s
}
const ude = `
    attribute vec2 aVertexPosition;

    uniform mat3 projectionMatrix;

    uniform float strength;

    varying vec2 vBlurTexCoords[%size%];

    uniform vec4 inputSize;
    uniform vec4 outputFrame;

    vec4 filterVertexPosition( void )
    {
        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
    }

    vec2 filterTextureCoord( void )
    {
        return aVertexPosition * (outputFrame.zw * inputSize.zw);
    }

    void main(void)
    {
        gl_Position = filterVertexPosition();

        vec2 textureCoord = filterTextureCoord();
        %blur%
    }`;
function hde(t, e) {
    const n = Math.ceil(t / 2);
    let s = ude, r = "", i;
    e ? i = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);" : i = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);";
    for (let o = 0; o < t; o++) {
        let l = i.replace("%index%", o.toString());
        l = l.replace("%sampleIndex%", `${o - (n - 1)}.0`),
            r += l,
            r += `
`
    }
    return s = s.replace("%blur%", r),
        s = s.replace("%size%", t.toString()),
        s
}
class Zb extends As {
    constructor(e, n = 8, s = 4, r = As.defaultResolution, i = 5) {
        const o = hde(i, e)
            , l = cde(i);
        super(o, l),
            this.horizontal = e,
            this.resolution = r,
            this._quality = 0,
            this.quality = s,
            this.blur = n
    }
    apply(e, n, s, r) {
        if (s ? this.horizontal ? this.uniforms.strength = 1 / s.width * (s.width / n.width) : this.uniforms.strength = 1 / s.height * (s.height / n.height) : this.horizontal ? this.uniforms.strength = 1 / e.renderer.width * (e.renderer.width / n.width) : this.uniforms.strength = 1 / e.renderer.height * (e.renderer.height / n.height),
            this.uniforms.strength *= this.strength,
            this.uniforms.strength /= this.passes,
            this.passes === 1)
            e.applyFilter(this, n, s, r);
        else {
            const i = e.getFilterTexture()
                , o = e.renderer;
            let l = n
                , a = i;
            this.state.blend = !1,
                e.applyFilter(this, l, a, Oi.CLEAR);
            for (let c = 1; c < this.passes - 1; c++) {
                e.bindAndClear(l, Oi.BLIT),
                    this.uniforms.uSampler = a;
                const u = a;
                a = l,
                    l = u,
                    o.shader.bind(this),
                    o.geometry.draw(5)
            }
            this.state.blend = !0,
                e.applyFilter(this, a, s, r),
                e.returnFilterTexture(i)
        }
    }
    get blur() {
        return this.strength
    }
    set blur(e) {
        this.padding = 1 + Math.abs(e) * 2,
            this.strength = e
    }
    get quality() {
        return this._quality
    }
    set quality(e) {
        this._quality = e,
            this.passes = e
    }
}
class dde extends As {
    constructor(e = 8, n = 4, s = As.defaultResolution, r = 5) {
        super(),
            this._repeatEdgePixels = !1,
            this.blurXFilter = new Zb(!0, e, n, s, r),
            this.blurYFilter = new Zb(!1, e, n, s, r),
            this.resolution = s,
            this.quality = n,
            this.blur = e,
            this.repeatEdgePixels = !1
    }
    apply(e, n, s, r) {
        const i = Math.abs(this.blurXFilter.strength)
            , o = Math.abs(this.blurYFilter.strength);
        if (i && o) {
            const l = e.getFilterTexture();
            this.blurXFilter.apply(e, n, l, Oi.CLEAR),
                this.blurYFilter.apply(e, l, s, r),
                e.returnFilterTexture(l)
        } else
            o ? this.blurYFilter.apply(e, n, s, r) : this.blurXFilter.apply(e, n, s, r)
    }
    updatePadding() {
        this._repeatEdgePixels ? this.padding = 0 : this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2
    }
    get blur() {
        return this.blurXFilter.blur
    }
    set blur(e) {
        this.blurXFilter.blur = this.blurYFilter.blur = e,
            this.updatePadding()
    }
    get quality() {
        return this.blurXFilter.quality
    }
    set quality(e) {
        this.blurXFilter.quality = this.blurYFilter.quality = e
    }
    get blurX() {
        return this.blurXFilter.blur
    }
    set blurX(e) {
        this.blurXFilter.blur = e,
            this.updatePadding()
    }
    get blurY() {
        return this.blurYFilter.blur
    }
    set blurY(e) {
        this.blurYFilter.blur = e,
            this.updatePadding()
    }
    get blendMode() {
        return this.blurYFilter.blendMode
    }
    set blendMode(e) {
        this.blurYFilter.blendMode = e
    }
    get repeatEdgePixels() {
        return this._repeatEdgePixels
    }
    set repeatEdgePixels(e) {
        this._repeatEdgePixels = e,
            this.updatePadding()
    }
}
var fde = `varying vec2 vTextureCoord;
uniform sampler2D uSampler;
uniform float m[20];
uniform float uAlpha;

void main(void)
{
    vec4 c = texture2D(uSampler, vTextureCoord);

    if (uAlpha == 0.0) {
        gl_FragColor = c;
        return;
    }

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (c.a > 0.0) {
      c.rgb /= c.a;
    }

    vec4 result;

    result.r = (m[0] * c.r);
        result.r += (m[1] * c.g);
        result.r += (m[2] * c.b);
        result.r += (m[3] * c.a);
        result.r += m[4];

    result.g = (m[5] * c.r);
        result.g += (m[6] * c.g);
        result.g += (m[7] * c.b);
        result.g += (m[8] * c.a);
        result.g += m[9];

    result.b = (m[10] * c.r);
       result.b += (m[11] * c.g);
       result.b += (m[12] * c.b);
       result.b += (m[13] * c.a);
       result.b += m[14];

    result.a = (m[15] * c.r);
       result.a += (m[16] * c.g);
       result.a += (m[17] * c.b);
       result.a += (m[18] * c.a);
       result.a += m[19];

    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);

    // Premultiply alpha again.
    rgb *= result.a;

    gl_FragColor = vec4(rgb, result.a);
}
`;
class Qb extends As {
    constructor() {
        const e = {
            m: new Float32Array([1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]),
            uAlpha: 1
        };
        super(t5, fde, e),
            this.alpha = 1
    }
    _loadMatrix(e, n = !1) {
        let s = e;
        n && (this._multiply(s, this.uniforms.m, e),
            s = this._colorMatrix(s)),
            this.uniforms.m = s
    }
    _multiply(e, n, s) {
        return e[0] = n[0] * s[0] + n[1] * s[5] + n[2] * s[10] + n[3] * s[15],
            e[1] = n[0] * s[1] + n[1] * s[6] + n[2] * s[11] + n[3] * s[16],
            e[2] = n[0] * s[2] + n[1] * s[7] + n[2] * s[12] + n[3] * s[17],
            e[3] = n[0] * s[3] + n[1] * s[8] + n[2] * s[13] + n[3] * s[18],
            e[4] = n[0] * s[4] + n[1] * s[9] + n[2] * s[14] + n[3] * s[19] + n[4],
            e[5] = n[5] * s[0] + n[6] * s[5] + n[7] * s[10] + n[8] * s[15],
            e[6] = n[5] * s[1] + n[6] * s[6] + n[7] * s[11] + n[8] * s[16],
            e[7] = n[5] * s[2] + n[6] * s[7] + n[7] * s[12] + n[8] * s[17],
            e[8] = n[5] * s[3] + n[6] * s[8] + n[7] * s[13] + n[8] * s[18],
            e[9] = n[5] * s[4] + n[6] * s[9] + n[7] * s[14] + n[8] * s[19] + n[9],
            e[10] = n[10] * s[0] + n[11] * s[5] + n[12] * s[10] + n[13] * s[15],
            e[11] = n[10] * s[1] + n[11] * s[6] + n[12] * s[11] + n[13] * s[16],
            e[12] = n[10] * s[2] + n[11] * s[7] + n[12] * s[12] + n[13] * s[17],
            e[13] = n[10] * s[3] + n[11] * s[8] + n[12] * s[13] + n[13] * s[18],
            e[14] = n[10] * s[4] + n[11] * s[9] + n[12] * s[14] + n[13] * s[19] + n[14],
            e[15] = n[15] * s[0] + n[16] * s[5] + n[17] * s[10] + n[18] * s[15],
            e[16] = n[15] * s[1] + n[16] * s[6] + n[17] * s[11] + n[18] * s[16],
            e[17] = n[15] * s[2] + n[16] * s[7] + n[17] * s[12] + n[18] * s[17],
            e[18] = n[15] * s[3] + n[16] * s[8] + n[17] * s[13] + n[18] * s[18],
            e[19] = n[15] * s[4] + n[16] * s[9] + n[17] * s[14] + n[18] * s[19] + n[19],
            e
    }
    _colorMatrix(e) {
        const n = new Float32Array(e);
        return n[4] /= 255,
            n[9] /= 255,
            n[14] /= 255,
            n[19] /= 255,
            n
    }
    brightness(e, n) {
        const s = [e, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(s, n)
    }
    tint(e, n) {
        const [s, r, i] = Yt.shared.setValue(e).toArray()
            , o = [s, 0, 0, 0, 0, 0, r, 0, 0, 0, 0, 0, i, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(o, n)
    }
    greyscale(e, n) {
        const s = [e, e, e, 0, 0, e, e, e, 0, 0, e, e, e, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(s, n)
    }
    blackAndWhite(e) {
        const n = [.3, .6, .1, 0, 0, .3, .6, .1, 0, 0, .3, .6, .1, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(n, e)
    }
    hue(e, n) {
        e = (e || 0) / 180 * Math.PI;
        const s = Math.cos(e)
            , r = Math.sin(e)
            , i = Math.sqrt
            , o = 1 / 3
            , l = i(o)
            , a = s + (1 - s) * o
            , c = o * (1 - s) - l * r
            , u = o * (1 - s) + l * r
            , h = o * (1 - s) + l * r
            , d = s + o * (1 - s)
            , f = o * (1 - s) - l * r
            , p = o * (1 - s) - l * r
            , m = o * (1 - s) + l * r
            , g = s + o * (1 - s)
            , b = [a, c, u, 0, 0, h, d, f, 0, 0, p, m, g, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(b, n)
    }
    contrast(e, n) {
        const s = (e || 0) + 1
            , r = -.5 * (s - 1)
            , i = [s, 0, 0, 0, r, 0, s, 0, 0, r, 0, 0, s, 0, r, 0, 0, 0, 1, 0];
        this._loadMatrix(i, n)
    }
    saturate(e = 0, n) {
        const s = e * 2 / 3 + 1
            , r = (s - 1) * -.5
            , i = [s, r, r, 0, 0, r, s, r, 0, 0, r, r, s, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(i, n)
    }
    desaturate() {
        this.saturate(-1)
    }
    negative(e) {
        const n = [-1, 0, 0, 1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(n, e)
    }
    sepia(e) {
        const n = [.393, .7689999, .18899999, 0, 0, .349, .6859999, .16799999, 0, 0, .272, .5339999, .13099999, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(n, e)
    }
    technicolor(e) {
        const n = [1.9125277891456083, -.8545344976951645, -.09155508482755585, 0, 11.793603434377337, -.3087833385928097, 1.7658908555458428, -.10601743074722245, 0, -70.35205161461398, -.231103377548616, -.7501899197440212, 1.847597816108189, 0, 30.950940869491138, 0, 0, 0, 1, 0];
        this._loadMatrix(n, e)
    }
    polaroid(e) {
        const n = [1.438, -.062, -.062, 0, 0, -.122, 1.378, -.122, 0, 0, -.016, -.016, 1.483, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(n, e)
    }
    toBGR(e) {
        const n = [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(n, e)
    }
    kodachrome(e) {
        const n = [1.1285582396593525, -.3967382283601348, -.03992559172921793, 0, 63.72958762196502, -.16404339962244616, 1.0835251566291304, -.05498805115633132, 0, 24.732407896706203, -.16786010706155763, -.5603416277695248, 1.6014850761964943, 0, 35.62982807460946, 0, 0, 0, 1, 0];
        this._loadMatrix(n, e)
    }
    browni(e) {
        const n = [.5997023498159715, .34553243048391263, -.2708298674538042, 0, 47.43192855600873, -.037703249837783157, .8609577587992641, .15059552388459913, 0, -36.96841498319127, .24113635128153335, -.07441037908422492, .44972182064877153, 0, -7.562075277591283, 0, 0, 0, 1, 0];
        this._loadMatrix(n, e)
    }
    vintage(e) {
        const n = [.6279345635605994, .3202183420819367, -.03965408211312453, 0, 9.651285835294123, .02578397704808868, .6441188644374771, .03259127616149294, 0, 7.462829176470591, .0466055556782719, -.0851232987247891, .5241648018700465, 0, 5.159190588235296, 0, 0, 0, 1, 0];
        this._loadMatrix(n, e)
    }
    colorTone(e, n, s, r, i) {
        e = e || .2,
            n = n || .15,
            s = s || 16770432,
            r = r || 3375104;
        const o = Yt.shared
            , [l, a, c] = o.setValue(s).toArray()
            , [u, h, d] = o.setValue(r).toArray()
            , f = [.3, .59, .11, 0, 0, l, a, c, e, 0, u, h, d, n, 0, l - u, a - h, c - d, 0, 0];
        this._loadMatrix(f, i)
    }
    night(e, n) {
        e = e || .1;
        const s = [e * -2, -e, 0, 0, 0, -e, 0, e, 0, 0, 0, e, e * 2, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(s, n)
    }
    predator(e, n) {
        const s = [11.224130630493164 * e, -4.794486999511719 * e, -2.8746118545532227 * e, 0 * e, .40342438220977783 * e, -3.6330697536468506 * e, 9.193157196044922 * e, -2.951810836791992 * e, 0 * e, -1.316135048866272 * e, -3.2184197902679443 * e, -4.2375030517578125 * e, 7.476448059082031 * e, 0 * e, .8044459223747253 * e, 0, 0, 0, 1, 0];
        this._loadMatrix(s, n)
    }
    lsd(e) {
        const n = [2, -.4, .5, 0, 0, -.5, 2, -.4, 0, 0, -.4, -.5, 3, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(n, e)
    }
    reset() {
        const e = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(e, !1)
    }
    get matrix() {
        return this.uniforms.m
    }
    set matrix(e) {
        this.uniforms.m = e
    }
    get alpha() {
        return this.uniforms.uAlpha
    }
    set alpha(e) {
        this.uniforms.uAlpha = e
    }
}
Qb.prototype.grayscale = Qb.prototype.greyscale;
var pde = `varying vec2 vFilterCoord;
varying vec2 vTextureCoord;

uniform vec2 scale;
uniform mat2 rotation;
uniform sampler2D uSampler;
uniform sampler2D mapSampler;

uniform highp vec4 inputSize;
uniform vec4 inputClamp;

void main(void)
{
  vec4 map =  texture2D(mapSampler, vFilterCoord);

  map -= 0.5;
  map.xy = scale * inputSize.zw * (rotation * map.xy);

  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));
}
`
    , mde = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;
uniform mat3 filterMatrix;

varying vec2 vTextureCoord;
varying vec2 vFilterCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
	gl_Position = filterVertexPosition();
	vTextureCoord = filterTextureCoord();
	vFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;
}
`;
class gde extends As {
    constructor(e, n) {
        const s = new Bt;
        e.renderable = !1,
            super(mde, pde, {
                mapSampler: e._texture,
                filterMatrix: s,
                scale: {
                    x: 1,
                    y: 1
                },
                rotation: new Float32Array([1, 0, 0, 1])
            }),
            this.maskSprite = e,
            this.maskMatrix = s,
            n == null && (n = 20),
            this.scale = new At(n, n)
    }
    apply(e, n, s, r) {
        this.uniforms.filterMatrix = e.calculateSpriteMatrix(this.maskMatrix, this.maskSprite),
            this.uniforms.scale.x = this.scale.x,
            this.uniforms.scale.y = this.scale.y;
        const i = this.maskSprite.worldTransform
            , o = Math.sqrt(i.a * i.a + i.b * i.b)
            , l = Math.sqrt(i.c * i.c + i.d * i.d);
        o !== 0 && l !== 0 && (this.uniforms.rotation[0] = i.a / o,
            this.uniforms.rotation[1] = i.b / o,
            this.uniforms.rotation[2] = i.c / l,
            this.uniforms.rotation[3] = i.d / l),
            e.applyFilter(this, n, s, r)
    }
    get map() {
        return this.uniforms.mapSampler
    }
    set map(e) {
        this.uniforms.mapSampler = e
    }
}
var _de = `varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;
uniform sampler2D uSampler;
uniform highp vec4 inputSize;


/**
 Basic FXAA implementation based on the code on geeks3d.com with the
 modification that the texture2DLod stuff was removed since it's
 unsupported by WebGL.

 --

 From:
 https://github.com/mitsuhiko/webgl-meincraft

 Copyright (c) 2011 by Armin Ronacher.

 Some rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are
 met:

 * Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above
 copyright notice, this list of conditions and the following
 disclaimer in the documentation and/or other materials provided
 with the distribution.

 * The names of the contributors may not be used to endorse or
 promote products derived from this software without specific
 prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef FXAA_REDUCE_MIN
#define FXAA_REDUCE_MIN   (1.0/ 128.0)
#endif
#ifndef FXAA_REDUCE_MUL
#define FXAA_REDUCE_MUL   (1.0 / 8.0)
#endif
#ifndef FXAA_SPAN_MAX
#define FXAA_SPAN_MAX     8.0
#endif

//optimized version for mobile, where dependent
//texture reads can be a bottleneck
vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,
          vec2 v_rgbNW, vec2 v_rgbNE,
          vec2 v_rgbSW, vec2 v_rgbSE,
          vec2 v_rgbM) {
    vec4 color;
    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;
    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;
    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;
    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;
    vec4 texColor = texture2D(tex, v_rgbM);
    vec3 rgbM  = texColor.xyz;
    vec3 luma = vec3(0.299, 0.587, 0.114);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM  = dot(rgbM,  luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

    mediump vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *
                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);

    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),
              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
                  dir * rcpDirMin)) * inverseVP;

    vec3 rgbA = 0.5 * (
                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +
                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);
    vec3 rgbB = rgbA * 0.5 + 0.25 * (
                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +
                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);

    float lumaB = dot(rgbB, luma);
    if ((lumaB < lumaMin) || (lumaB > lumaMax))
        color = vec4(rgbA, texColor.a);
    else
        color = vec4(rgbB, texColor.a);
    return color;
}

void main() {

      vec4 color;

      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);

      gl_FragColor = color;
}
`
    , yde = `
attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

void texcoords(vec2 fragCoord, vec2 inverseVP,
               out vec2 v_rgbNW, out vec2 v_rgbNE,
               out vec2 v_rgbSW, out vec2 v_rgbSE,
               out vec2 v_rgbM) {
    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;
    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;
    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;
    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;
    v_rgbM = vec2(fragCoord * inverseVP);
}

void main(void) {

   gl_Position = filterVertexPosition();

   vFragCoord = aVertexPosition * outputFrame.zw;

   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);
}
`;
class bde extends As {
    constructor() {
        super(yde, _de)
    }
}
var vde = `precision highp float;

varying vec2 vTextureCoord;
varying vec4 vColor;

uniform float uNoise;
uniform float uSeed;
uniform sampler2D uSampler;

float rand(vec2 co)
{
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

void main()
{
    vec4 color = texture2D(uSampler, vTextureCoord);
    float randomValue = rand(gl_FragCoord.xy * uSeed);
    float diff = (randomValue - 0.5) * uNoise;

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (color.a > 0.0) {
        color.rgb /= color.a;
    }

    color.r += diff;
    color.g += diff;
    color.b += diff;

    // Premultiply alpha again.
    color.rgb *= color.a;

    gl_FragColor = color;
}
`;
class xde extends As {
    constructor(e = .5, n = Math.random()) {
        super(t5, vde, {
            uNoise: 0,
            uSeed: 0
        }),
            this.noise = e,
            this.seed = n
    }
    get noise() {
        return this.uniforms.uNoise
    }
    set noise(e) {
        this.uniforms.uNoise = e
    }
    get seed() {
        return this.uniforms.uSeed
    }
    set seed(e) {
        this.uniforms.uSeed = e
    }
}
const wA = {
    AlphaFilter: ode,
    BlurFilter: dde,
    BlurFilterPass: Zb,
    ColorMatrixFilter: Qb,
    DisplacementFilter: gde,
    FXAAFilter: bde,
    NoiseFilter: xde
};
Object.entries(wA).forEach(([t, e]) => {
    Object.defineProperty(wA, t, {
        get() {
            return dt("7.1.0", `filters.${t} has moved to ${t}`),
                e
        }
    })
}
);
class wde {
    constructor() {
        this.interactionFrequency = 10,
            this._deltaTime = 0,
            this._didMove = !1,
            this.tickerAdded = !1,
            this._pauseUpdate = !0
    }
    init(e) {
        this.removeTickerListener(),
            this.events = e,
            this.interactionFrequency = 10,
            this._deltaTime = 0,
            this._didMove = !1,
            this.tickerAdded = !1,
            this._pauseUpdate = !0
    }
    get pauseUpdate() {
        return this._pauseUpdate
    }
    set pauseUpdate(e) {
        this._pauseUpdate = e
    }
    addTickerListener() {
        this.tickerAdded || !this.domElement || (lr.system.add(this.tickerUpdate, this, cc.INTERACTION),
            this.tickerAdded = !0)
    }
    removeTickerListener() {
        this.tickerAdded && (lr.system.remove(this.tickerUpdate, this),
            this.tickerAdded = !1)
    }
    pointerMoved() {
        this._didMove = !0
    }
    update() {
        if (!this.domElement || this._pauseUpdate)
            return;
        if (this._didMove) {
            this._didMove = !1;
            return
        }
        const e = this.events.rootPointerEvent;
        this.events.supportsTouchEvents && e.pointerType === "touch" || globalThis.document.dispatchEvent(new PointerEvent("pointermove", {
            clientX: e.clientX,
            clientY: e.clientY
        }))
    }
    tickerUpdate(e) {
        this._deltaTime += e,
            !(this._deltaTime < this.interactionFrequency) && (this._deltaTime = 0,
                this.update())
    }
}
const Aa = new wde;
class Sf {
    constructor(e) {
        this.bubbles = !0,
            this.cancelBubble = !0,
            this.cancelable = !1,
            this.composed = !1,
            this.defaultPrevented = !1,
            this.eventPhase = Sf.prototype.NONE,
            this.propagationStopped = !1,
            this.propagationImmediatelyStopped = !1,
            this.layer = new At,
            this.page = new At,
            this.NONE = 0,
            this.CAPTURING_PHASE = 1,
            this.AT_TARGET = 2,
            this.BUBBLING_PHASE = 3,
            this.manager = e
    }
    get layerX() {
        return this.layer.x
    }
    get layerY() {
        return this.layer.y
    }
    get pageX() {
        return this.page.x
    }
    get pageY() {
        return this.page.y
    }
    get data() {
        return this
    }
    composedPath() {
        return this.manager && (!this.path || this.path[this.path.length - 1] !== this.target) && (this.path = this.target ? this.manager.propagationPath(this.target) : []),
            this.path
    }
    initEvent(e, n, s) {
        throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.")
    }
    initUIEvent(e, n, s, r, i) {
        throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.")
    }
    preventDefault() {
        this.nativeEvent instanceof Event && this.nativeEvent.cancelable && this.nativeEvent.preventDefault(),
            this.defaultPrevented = !0
    }
    stopImmediatePropagation() {
        this.propagationImmediatelyStopped = !0
    }
    stopPropagation() {
        this.propagationStopped = !0
    }
}
class cg extends Sf {
    constructor() {
        super(...arguments),
            this.client = new At,
            this.movement = new At,
            this.offset = new At,
            this.global = new At,
            this.screen = new At
    }
    get clientX() {
        return this.client.x
    }
    get clientY() {
        return this.client.y
    }
    get x() {
        return this.clientX
    }
    get y() {
        return this.clientY
    }
    get movementX() {
        return this.movement.x
    }
    get movementY() {
        return this.movement.y
    }
    get offsetX() {
        return this.offset.x
    }
    get offsetY() {
        return this.offset.y
    }
    get globalX() {
        return this.global.x
    }
    get globalY() {
        return this.global.y
    }
    get screenX() {
        return this.screen.x
    }
    get screenY() {
        return this.screen.y
    }
    getLocalPosition(e, n, s) {
        return e.worldTransform.applyInverse(s || this.global, n)
    }
    getModifierState(e) {
        return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(e)
    }
    initMouseEvent(e, n, s, r, i, o, l, a, c, u, h, d, f, p, m) {
        throw new Error("Method not implemented.")
    }
}
class zr extends cg {
    constructor() {
        super(...arguments),
            this.width = 0,
            this.height = 0,
            this.isPrimary = !1
    }
    getCoalescedEvents() {
        return this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove" ? [this] : []
    }
    getPredictedEvents() {
        throw new Error("getPredictedEvents is not supported!")
    }
}
class Iu extends cg {
    constructor() {
        super(...arguments),
            this.DOM_DELTA_PIXEL = 0,
            this.DOM_DELTA_LINE = 1,
            this.DOM_DELTA_PAGE = 2
    }
}
Iu.DOM_DELTA_PIXEL = 0,
    Iu.DOM_DELTA_LINE = 1,
    Iu.DOM_DELTA_PAGE = 2;
const Sde = 2048
    , Ede = new At
    , k1 = new At;
class Tde {
    constructor(e) {
        this.dispatch = new yf,
            this.moveOnAll = !1,
            this.enableGlobalMoveEvents = !0,
            this.mappingState = {
                trackingData: {}
            },
            this.eventPool = new Map,
            this._allInteractiveElements = [],
            this._hitElements = [],
            this._isPointerMoveEvent = !1,
            this.rootTarget = e,
            this.hitPruneFn = this.hitPruneFn.bind(this),
            this.hitTestFn = this.hitTestFn.bind(this),
            this.mapPointerDown = this.mapPointerDown.bind(this),
            this.mapPointerMove = this.mapPointerMove.bind(this),
            this.mapPointerOut = this.mapPointerOut.bind(this),
            this.mapPointerOver = this.mapPointerOver.bind(this),
            this.mapPointerUp = this.mapPointerUp.bind(this),
            this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this),
            this.mapWheel = this.mapWheel.bind(this),
            this.mappingTable = {},
            this.addEventMapping("pointerdown", this.mapPointerDown),
            this.addEventMapping("pointermove", this.mapPointerMove),
            this.addEventMapping("pointerout", this.mapPointerOut),
            this.addEventMapping("pointerleave", this.mapPointerOut),
            this.addEventMapping("pointerover", this.mapPointerOver),
            this.addEventMapping("pointerup", this.mapPointerUp),
            this.addEventMapping("pointerupoutside", this.mapPointerUpOutside),
            this.addEventMapping("wheel", this.mapWheel)
    }
    addEventMapping(e, n) {
        this.mappingTable[e] || (this.mappingTable[e] = []),
            this.mappingTable[e].push({
                fn: n,
                priority: 0
            }),
            this.mappingTable[e].sort((s, r) => s.priority - r.priority)
    }
    dispatchEvent(e, n) {
        e.propagationStopped = !1,
            e.propagationImmediatelyStopped = !1,
            this.propagate(e, n),
            this.dispatch.emit(n || e.type, e)
    }
    mapEvent(e) {
        if (!this.rootTarget)
            return;
        const n = this.mappingTable[e.type];
        if (n)
            for (let s = 0, r = n.length; s < r; s++)
                n[s].fn(e);
        else
            console.warn(`[EventBoundary]: Event mapping not defined for ${e.type}`)
    }
    hitTest(e, n) {
        Aa.pauseUpdate = !0;
        const s = this._isPointerMoveEvent && this.enableGlobalMoveEvents ? "hitTestMoveRecursive" : "hitTestRecursive"
            , r = this[s](this.rootTarget, this.rootTarget.eventMode, Ede.set(e, n), this.hitTestFn, this.hitPruneFn);
        return r && r[0]
    }
    propagate(e, n) {
        if (!e.target)
            return;
        const s = e.composedPath();
        e.eventPhase = e.CAPTURING_PHASE;
        for (let r = 0, i = s.length - 1; r < i; r++)
            if (e.currentTarget = s[r],
                this.notifyTarget(e, n),
                e.propagationStopped || e.propagationImmediatelyStopped)
                return;
        if (e.eventPhase = e.AT_TARGET,
            e.currentTarget = e.target,
            this.notifyTarget(e, n),
            !(e.propagationStopped || e.propagationImmediatelyStopped)) {
            e.eventPhase = e.BUBBLING_PHASE;
            for (let r = s.length - 2; r >= 0; r--)
                if (e.currentTarget = s[r],
                    this.notifyTarget(e, n),
                    e.propagationStopped || e.propagationImmediatelyStopped)
                    return
        }
    }
    all(e, n, s = this._allInteractiveElements) {
        if (s.length === 0)
            return;
        e.eventPhase = e.BUBBLING_PHASE;
        const r = Array.isArray(n) ? n : [n];
        for (let i = s.length - 1; i >= 0; i--)
            r.forEach(o => {
                e.currentTarget = s[i],
                    this.notifyTarget(e, o)
            }
            )
    }
    propagationPath(e) {
        const n = [e];
        for (let s = 0; s < Sde && e !== this.rootTarget; s++) {
            if (!e.parent)
                throw new Error("Cannot find propagation path to disconnected target");
            n.push(e.parent),
                e = e.parent
        }
        return n.reverse(),
            n
    }
    hitTestMoveRecursive(e, n, s, r, i, o = !1) {
        let l = !1;
        if (this._interactivePrune(e))
            return null;
        if ((e.eventMode === "dynamic" || n === "dynamic") && (Aa.pauseUpdate = !1),
            e.interactiveChildren && e.children) {
            const u = e.children;
            for (let h = u.length - 1; h >= 0; h--) {
                const d = u[h]
                    , f = this.hitTestMoveRecursive(d, this._isInteractive(n) ? n : d.eventMode, s, r, i, o || i(e, s));
                if (f) {
                    if (f.length > 0 && !f[f.length - 1].parent)
                        continue;
                    const p = e.isInteractive();
                    (f.length > 0 || p) && (p && this._allInteractiveElements.push(e),
                        f.push(e)),
                        this._hitElements.length === 0 && (this._hitElements = f),
                        l = !0
                }
            }
        }
        const a = this._isInteractive(n)
            , c = e.isInteractive();
        return a && c && this._allInteractiveElements.push(e),
            o || this._hitElements.length > 0 ? null : l ? this._hitElements : a && !i(e, s) && r(e, s) ? c ? [e] : [] : null
    }
    hitTestRecursive(e, n, s, r, i) {
        if (this._interactivePrune(e) || i(e, s))
            return null;
        if ((e.eventMode === "dynamic" || n === "dynamic") && (Aa.pauseUpdate = !1),
            e.interactiveChildren && e.children) {
            const a = e.children;
            for (let c = a.length - 1; c >= 0; c--) {
                const u = a[c]
                    , h = this.hitTestRecursive(u, this._isInteractive(n) ? n : u.eventMode, s, r, i);
                if (h) {
                    if (h.length > 0 && !h[h.length - 1].parent)
                        continue;
                    const d = e.isInteractive();
                    return (h.length > 0 || d) && h.push(e),
                        h
                }
            }
        }
        const o = this._isInteractive(n)
            , l = e.isInteractive();
        return o && r(e, s) ? l ? [e] : [] : null
    }
    _isInteractive(e) {
        return e === "static" || e === "dynamic"
    }
    _interactivePrune(e) {
        return !!(!e || e.isMask || !e.visible || !e.renderable || e.eventMode === "none" || e.eventMode === "passive" && !e.interactiveChildren || e.isMask)
    }
    hitPruneFn(e, n) {
        var s;
        if (e.hitArea && (e.worldTransform.applyInverse(n, k1),
            !e.hitArea.contains(k1.x, k1.y)))
            return !0;
        if (e._mask) {
            const r = e._mask.isMaskData ? e._mask.maskObject : e._mask;
            if (r && !((s = r.containsPoint) != null && s.call(r, n)))
                return !0
        }
        return !1
    }
    hitTestFn(e, n) {
        return e.eventMode === "passive" ? !1 : e.hitArea ? !0 : e.containsPoint ? e.containsPoint(n) : !1
    }
    notifyTarget(e, n) {
        var i, o;
        n = n ?? e.type;
        const s = `on${n}`;
        (o = (i = e.currentTarget)[s]) == null || o.call(i, e);
        const r = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${n}capture` : n;
        this.notifyListeners(e, r),
            e.eventPhase === e.AT_TARGET && this.notifyListeners(e, n)
    }
    mapPointerDown(e) {
        if (!(e instanceof zr)) {
            console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        const n = this.createPointerEvent(e);
        if (this.dispatchEvent(n, "pointerdown"),
            n.pointerType === "touch")
            this.dispatchEvent(n, "touchstart");
        else if (n.pointerType === "mouse" || n.pointerType === "pen") {
            const r = n.button === 2;
            this.dispatchEvent(n, r ? "rightdown" : "mousedown")
        }
        const s = this.trackingData(e.pointerId);
        s.pressTargetsByButton[e.button] = n.composedPath(),
            this.freeEvent(n)
    }
    mapPointerMove(e) {
        var a, c;
        if (!(e instanceof zr)) {
            console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        this._allInteractiveElements.length = 0,
            this._hitElements.length = 0,
            this._isPointerMoveEvent = !0;
        const n = this.createPointerEvent(e);
        this._isPointerMoveEvent = !1;
        const s = n.pointerType === "mouse" || n.pointerType === "pen"
            , r = this.trackingData(e.pointerId)
            , i = this.findMountedTarget(r.overTargets);
        if (((a = r.overTargets) == null ? void 0 : a.length) > 0 && i !== n.target) {
            const u = e.type === "mousemove" ? "mouseout" : "pointerout"
                , h = this.createPointerEvent(e, u, i);
            if (this.dispatchEvent(h, "pointerout"),
                s && this.dispatchEvent(h, "mouseout"),
                !n.composedPath().includes(i)) {
                const d = this.createPointerEvent(e, "pointerleave", i);
                for (d.eventPhase = d.AT_TARGET; d.target && !n.composedPath().includes(d.target);)
                    d.currentTarget = d.target,
                        this.notifyTarget(d),
                        s && this.notifyTarget(d, "mouseleave"),
                        d.target = d.target.parent;
                this.freeEvent(d)
            }
            this.freeEvent(h)
        }
        if (i !== n.target) {
            const u = e.type === "mousemove" ? "mouseover" : "pointerover"
                , h = this.clonePointerEvent(n, u);
            this.dispatchEvent(h, "pointerover"),
                s && this.dispatchEvent(h, "mouseover");
            let d = i == null ? void 0 : i.parent;
            for (; d && d !== this.rootTarget.parent && d !== n.target;)
                d = d.parent;
            if (!d || d === this.rootTarget.parent) {
                const f = this.clonePointerEvent(n, "pointerenter");
                for (f.eventPhase = f.AT_TARGET; f.target && f.target !== i && f.target !== this.rootTarget.parent;)
                    f.currentTarget = f.target,
                        this.notifyTarget(f),
                        s && this.notifyTarget(f, "mouseenter"),
                        f.target = f.target.parent;
                this.freeEvent(f)
            }
            this.freeEvent(h)
        }
        const o = []
            , l = this.enableGlobalMoveEvents ?? !0;
        this.moveOnAll ? o.push("pointermove") : this.dispatchEvent(n, "pointermove"),
            l && o.push("globalpointermove"),
            n.pointerType === "touch" && (this.moveOnAll ? o.splice(1, 0, "touchmove") : this.dispatchEvent(n, "touchmove"),
                l && o.push("globaltouchmove")),
            s && (this.moveOnAll ? o.splice(1, 0, "mousemove") : this.dispatchEvent(n, "mousemove"),
                l && o.push("globalmousemove"),
                this.cursor = (c = n.target) == null ? void 0 : c.cursor),
            o.length > 0 && this.all(n, o),
            this._allInteractiveElements.length = 0,
            this._hitElements.length = 0,
            r.overTargets = n.composedPath(),
            this.freeEvent(n)
    }
    mapPointerOver(e) {
        var o;
        if (!(e instanceof zr)) {
            console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        const n = this.trackingData(e.pointerId)
            , s = this.createPointerEvent(e)
            , r = s.pointerType === "mouse" || s.pointerType === "pen";
        this.dispatchEvent(s, "pointerover"),
            r && this.dispatchEvent(s, "mouseover"),
            s.pointerType === "mouse" && (this.cursor = (o = s.target) == null ? void 0 : o.cursor);
        const i = this.clonePointerEvent(s, "pointerenter");
        for (i.eventPhase = i.AT_TARGET; i.target && i.target !== this.rootTarget.parent;)
            i.currentTarget = i.target,
                this.notifyTarget(i),
                r && this.notifyTarget(i, "mouseenter"),
                i.target = i.target.parent;
        n.overTargets = s.composedPath(),
            this.freeEvent(s),
            this.freeEvent(i)
    }
    mapPointerOut(e) {
        if (!(e instanceof zr)) {
            console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        const n = this.trackingData(e.pointerId);
        if (n.overTargets) {
            const s = e.pointerType === "mouse" || e.pointerType === "pen"
                , r = this.findMountedTarget(n.overTargets)
                , i = this.createPointerEvent(e, "pointerout", r);
            this.dispatchEvent(i),
                s && this.dispatchEvent(i, "mouseout");
            const o = this.createPointerEvent(e, "pointerleave", r);
            for (o.eventPhase = o.AT_TARGET; o.target && o.target !== this.rootTarget.parent;)
                o.currentTarget = o.target,
                    this.notifyTarget(o),
                    s && this.notifyTarget(o, "mouseleave"),
                    o.target = o.target.parent;
            n.overTargets = null,
                this.freeEvent(i),
                this.freeEvent(o)
        }
        this.cursor = null
    }
    mapPointerUp(e) {
        if (!(e instanceof zr)) {
            console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        const n = performance.now()
            , s = this.createPointerEvent(e);
        if (this.dispatchEvent(s, "pointerup"),
            s.pointerType === "touch")
            this.dispatchEvent(s, "touchend");
        else if (s.pointerType === "mouse" || s.pointerType === "pen") {
            const l = s.button === 2;
            this.dispatchEvent(s, l ? "rightup" : "mouseup")
        }
        const r = this.trackingData(e.pointerId)
            , i = this.findMountedTarget(r.pressTargetsByButton[e.button]);
        let o = i;
        if (i && !s.composedPath().includes(i)) {
            let l = i;
            for (; l && !s.composedPath().includes(l);) {
                if (s.currentTarget = l,
                    this.notifyTarget(s, "pointerupoutside"),
                    s.pointerType === "touch")
                    this.notifyTarget(s, "touchendoutside");
                else if (s.pointerType === "mouse" || s.pointerType === "pen") {
                    const a = s.button === 2;
                    this.notifyTarget(s, a ? "rightupoutside" : "mouseupoutside")
                }
                l = l.parent
            }
            delete r.pressTargetsByButton[e.button],
                o = l
        }
        if (o) {
            const l = this.clonePointerEvent(s, "click");
            l.target = o,
                l.path = null,
                r.clicksByButton[e.button] || (r.clicksByButton[e.button] = {
                    clickCount: 0,
                    target: l.target,
                    timeStamp: n
                });
            const a = r.clicksByButton[e.button];
            if (a.target === l.target && n - a.timeStamp < 200 ? ++a.clickCount : a.clickCount = 1,
                a.target = l.target,
                a.timeStamp = n,
                l.detail = a.clickCount,
                l.pointerType === "mouse") {
                const c = l.button === 2;
                this.dispatchEvent(l, c ? "rightclick" : "click")
            } else
                l.pointerType === "touch" && this.dispatchEvent(l, "tap");
            this.dispatchEvent(l, "pointertap"),
                this.freeEvent(l)
        }
        this.freeEvent(s)
    }
    mapPointerUpOutside(e) {
        if (!(e instanceof zr)) {
            console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        const n = this.trackingData(e.pointerId)
            , s = this.findMountedTarget(n.pressTargetsByButton[e.button])
            , r = this.createPointerEvent(e);
        if (s) {
            let i = s;
            for (; i;)
                r.currentTarget = i,
                    this.notifyTarget(r, "pointerupoutside"),
                    r.pointerType === "touch" ? this.notifyTarget(r, "touchendoutside") : (r.pointerType === "mouse" || r.pointerType === "pen") && this.notifyTarget(r, r.button === 2 ? "rightupoutside" : "mouseupoutside"),
                    i = i.parent;
            delete n.pressTargetsByButton[e.button]
        }
        this.freeEvent(r)
    }
    mapWheel(e) {
        if (!(e instanceof Iu)) {
            console.warn("EventBoundary cannot map a non-wheel event as a wheel event");
            return
        }
        const n = this.createWheelEvent(e);
        this.dispatchEvent(n),
            this.freeEvent(n)
    }
    findMountedTarget(e) {
        if (!e)
            return null;
        let n = e[0];
        for (let s = 1; s < e.length && e[s].parent === n; s++)
            n = e[s];
        return n
    }
    createPointerEvent(e, n, s) {
        const r = this.allocateEvent(zr);
        return this.copyPointerData(e, r),
            this.copyMouseData(e, r),
            this.copyData(e, r),
            r.nativeEvent = e.nativeEvent,
            r.originalEvent = e,
            r.target = s ?? this.hitTest(r.global.x, r.global.y) ?? this._hitElements[0],
            typeof n == "string" && (r.type = n),
            r
    }
    createWheelEvent(e) {
        const n = this.allocateEvent(Iu);
        return this.copyWheelData(e, n),
            this.copyMouseData(e, n),
            this.copyData(e, n),
            n.nativeEvent = e.nativeEvent,
            n.originalEvent = e,
            n.target = this.hitTest(n.global.x, n.global.y),
            n
    }
    clonePointerEvent(e, n) {
        const s = this.allocateEvent(zr);
        return s.nativeEvent = e.nativeEvent,
            s.originalEvent = e.originalEvent,
            this.copyPointerData(e, s),
            this.copyMouseData(e, s),
            this.copyData(e, s),
            s.target = e.target,
            s.path = e.composedPath().slice(),
            s.type = n ?? s.type,
            s
    }
    copyWheelData(e, n) {
        n.deltaMode = e.deltaMode,
            n.deltaX = e.deltaX,
            n.deltaY = e.deltaY,
            n.deltaZ = e.deltaZ
    }
    copyPointerData(e, n) {
        e instanceof zr && n instanceof zr && (n.pointerId = e.pointerId,
            n.width = e.width,
            n.height = e.height,
            n.isPrimary = e.isPrimary,
            n.pointerType = e.pointerType,
            n.pressure = e.pressure,
            n.tangentialPressure = e.tangentialPressure,
            n.tiltX = e.tiltX,
            n.tiltY = e.tiltY,
            n.twist = e.twist)
    }
    copyMouseData(e, n) {
        e instanceof cg && n instanceof cg && (n.altKey = e.altKey,
            n.button = e.button,
            n.buttons = e.buttons,
            n.client.copyFrom(e.client),
            n.ctrlKey = e.ctrlKey,
            n.metaKey = e.metaKey,
            n.movement.copyFrom(e.movement),
            n.screen.copyFrom(e.screen),
            n.shiftKey = e.shiftKey,
            n.global.copyFrom(e.global))
    }
    copyData(e, n) {
        n.isTrusted = e.isTrusted,
            n.srcElement = e.srcElement,
            n.timeStamp = performance.now(),
            n.type = e.type,
            n.detail = e.detail,
            n.view = e.view,
            n.which = e.which,
            n.layer.copyFrom(e.layer),
            n.page.copyFrom(e.page)
    }
    trackingData(e) {
        return this.mappingState.trackingData[e] || (this.mappingState.trackingData[e] = {
            pressTargetsByButton: {},
            clicksByButton: {},
            overTarget: null
        }),
            this.mappingState.trackingData[e]
    }
    allocateEvent(e) {
        this.eventPool.has(e) || this.eventPool.set(e, []);
        const n = this.eventPool.get(e).pop() || new e(this);
        return n.eventPhase = n.NONE,
            n.currentTarget = null,
            n.path = null,
            n.target = null,
            n
    }
    freeEvent(e) {
        if (e.manager !== this)
            throw new Error("It is illegal to free an event not managed by this EventBoundary!");
        const n = e.constructor;
        this.eventPool.has(n) || this.eventPool.set(n, []),
            this.eventPool.get(n).push(e)
    }
    notifyListeners(e, n) {
        const s = e.currentTarget._events[n];
        if (s && e.currentTarget.isInteractive())
            if ("fn" in s)
                s.once && e.currentTarget.removeListener(n, s.fn, void 0, !0),
                    s.fn.call(s.context, e);
            else
                for (let r = 0, i = s.length; r < i && !e.propagationImmediatelyStopped; r++)
                    s[r].once && e.currentTarget.removeListener(n, s[r].fn, void 0, !0),
                        s[r].fn.call(s[r].context, e)
    }
}
const Cde = 1
    , Ide = {
        touchstart: "pointerdown",
        touchend: "pointerup",
        touchendoutside: "pointerupoutside",
        touchmove: "pointermove",
        touchcancel: "pointercancel"
    }
    , ev = class tv {
        constructor(e) {
            this.supportsTouchEvents = "ontouchstart" in globalThis,
                this.supportsPointerEvents = !!globalThis.PointerEvent,
                this.domElement = null,
                this.resolution = 1,
                this.renderer = e,
                this.rootBoundary = new Tde(null),
                Aa.init(this),
                this.autoPreventDefault = !0,
                this.eventsAdded = !1,
                this.rootPointerEvent = new zr(null),
                this.rootWheelEvent = new Iu(null),
                this.cursorStyles = {
                    default: "inherit",
                    pointer: "pointer"
                },
                this.features = new Proxy({
                    ...tv.defaultEventFeatures
                }, {
                    set: (n, s, r) => (s === "globalMove" && (this.rootBoundary.enableGlobalMoveEvents = r),
                        n[s] = r,
                        !0)
                }),
                this.onPointerDown = this.onPointerDown.bind(this),
                this.onPointerMove = this.onPointerMove.bind(this),
                this.onPointerUp = this.onPointerUp.bind(this),
                this.onPointerOverOut = this.onPointerOverOut.bind(this),
                this.onWheel = this.onWheel.bind(this)
        }
        static get defaultEventMode() {
            return this._defaultEventMode
        }
        init(e) {
            const { view: n, resolution: s } = this.renderer;
            this.setTargetElement(n),
                this.resolution = s,
                tv._defaultEventMode = e.eventMode ?? "auto",
                Object.assign(this.features, e.eventFeatures ?? {}),
                this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove
        }
        resolutionChange(e) {
            this.resolution = e
        }
        destroy() {
            this.setTargetElement(null),
                this.renderer = null
        }
        setCursor(e) {
            e = e || "default";
            let n = !0;
            if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas && (n = !1),
                this.currentCursor === e)
                return;
            this.currentCursor = e;
            const s = this.cursorStyles[e];
            if (s)
                switch (typeof s) {
                    case "string":
                        n && (this.domElement.style.cursor = s);
                        break;
                    case "function":
                        s(e);
                        break;
                    case "object":
                        n && Object.assign(this.domElement.style, s);
                        break
                }
            else
                n && typeof e == "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, e) && (this.domElement.style.cursor = e)
        }
        get pointer() {
            return this.rootPointerEvent
        }
        onPointerDown(e) {
            if (!this.features.click)
                return;
            this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
            const n = this.normalizeToPointerData(e);
            this.autoPreventDefault && n[0].isNormalized && (e.cancelable || !("cancelable" in e)) && e.preventDefault();
            for (let s = 0, r = n.length; s < r; s++) {
                const i = n[s]
                    , o = this.bootstrapEvent(this.rootPointerEvent, i);
                this.rootBoundary.mapEvent(o)
            }
            this.setCursor(this.rootBoundary.cursor)
        }
        onPointerMove(e) {
            if (!this.features.move)
                return;
            this.rootBoundary.rootTarget = this.renderer.lastObjectRendered,
                Aa.pointerMoved();
            const n = this.normalizeToPointerData(e);
            for (let s = 0, r = n.length; s < r; s++) {
                const i = this.bootstrapEvent(this.rootPointerEvent, n[s]);
                this.rootBoundary.mapEvent(i)
            }
            this.setCursor(this.rootBoundary.cursor)
        }
        onPointerUp(e) {
            if (!this.features.click)
                return;
            this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
            let n = e.target;
            e.composedPath && e.composedPath().length > 0 && (n = e.composedPath()[0]);
            const s = n !== this.domElement ? "outside" : ""
                , r = this.normalizeToPointerData(e);
            for (let i = 0, o = r.length; i < o; i++) {
                const l = this.bootstrapEvent(this.rootPointerEvent, r[i]);
                l.type += s,
                    this.rootBoundary.mapEvent(l)
            }
            this.setCursor(this.rootBoundary.cursor)
        }
        onPointerOverOut(e) {
            if (!this.features.click)
                return;
            this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
            const n = this.normalizeToPointerData(e);
            for (let s = 0, r = n.length; s < r; s++) {
                const i = this.bootstrapEvent(this.rootPointerEvent, n[s]);
                this.rootBoundary.mapEvent(i)
            }
            this.setCursor(this.rootBoundary.cursor)
        }
        onWheel(e) {
            if (!this.features.wheel)
                return;
            const n = this.normalizeWheelEvent(e);
            this.rootBoundary.rootTarget = this.renderer.lastObjectRendered,
                this.rootBoundary.mapEvent(n)
        }
        setTargetElement(e) {
            this.removeEvents(),
                this.domElement = e,
                Aa.domElement = e,
                this.addEvents()
        }
        addEvents() {
            if (this.eventsAdded || !this.domElement)
                return;
            Aa.addTickerListener();
            const e = this.domElement.style;
            e && (globalThis.navigator.msPointerEnabled ? (e.msContentZooming = "none",
                e.msTouchAction = "none") : this.supportsPointerEvents && (e.touchAction = "none")),
                this.supportsPointerEvents ? (globalThis.document.addEventListener("pointermove", this.onPointerMove, !0),
                    this.domElement.addEventListener("pointerdown", this.onPointerDown, !0),
                    this.domElement.addEventListener("pointerleave", this.onPointerOverOut, !0),
                    this.domElement.addEventListener("pointerover", this.onPointerOverOut, !0),
                    globalThis.addEventListener("pointerup", this.onPointerUp, !0)) : (globalThis.document.addEventListener("mousemove", this.onPointerMove, !0),
                        this.domElement.addEventListener("mousedown", this.onPointerDown, !0),
                        this.domElement.addEventListener("mouseout", this.onPointerOverOut, !0),
                        this.domElement.addEventListener("mouseover", this.onPointerOverOut, !0),
                        globalThis.addEventListener("mouseup", this.onPointerUp, !0),
                        this.supportsTouchEvents && (this.domElement.addEventListener("touchstart", this.onPointerDown, !0),
                            this.domElement.addEventListener("touchend", this.onPointerUp, !0),
                            this.domElement.addEventListener("touchmove", this.onPointerMove, !0))),
                this.domElement.addEventListener("wheel", this.onWheel, {
                    passive: !0,
                    capture: !0
                }),
                this.eventsAdded = !0
        }
        removeEvents() {
            if (!this.eventsAdded || !this.domElement)
                return;
            Aa.removeTickerListener();
            const e = this.domElement.style;
            globalThis.navigator.msPointerEnabled ? (e.msContentZooming = "",
                e.msTouchAction = "") : this.supportsPointerEvents && (e.touchAction = ""),
                this.supportsPointerEvents ? (globalThis.document.removeEventListener("pointermove", this.onPointerMove, !0),
                    this.domElement.removeEventListener("pointerdown", this.onPointerDown, !0),
                    this.domElement.removeEventListener("pointerleave", this.onPointerOverOut, !0),
                    this.domElement.removeEventListener("pointerover", this.onPointerOverOut, !0),
                    globalThis.removeEventListener("pointerup", this.onPointerUp, !0)) : (globalThis.document.removeEventListener("mousemove", this.onPointerMove, !0),
                        this.domElement.removeEventListener("mousedown", this.onPointerDown, !0),
                        this.domElement.removeEventListener("mouseout", this.onPointerOverOut, !0),
                        this.domElement.removeEventListener("mouseover", this.onPointerOverOut, !0),
                        globalThis.removeEventListener("mouseup", this.onPointerUp, !0),
                        this.supportsTouchEvents && (this.domElement.removeEventListener("touchstart", this.onPointerDown, !0),
                            this.domElement.removeEventListener("touchend", this.onPointerUp, !0),
                            this.domElement.removeEventListener("touchmove", this.onPointerMove, !0))),
                this.domElement.removeEventListener("wheel", this.onWheel, !0),
                this.domElement = null,
                this.eventsAdded = !1
        }
        mapPositionToPoint(e, n, s) {
            const r = this.domElement.isConnected ? this.domElement.getBoundingClientRect() : {
                x: 0,
                y: 0,
                width: this.domElement.width,
                height: this.domElement.height,
                left: 0,
                top: 0
            }
                , i = 1 / this.resolution;
            e.x = (n - r.left) * (this.domElement.width / r.width) * i,
                e.y = (s - r.top) * (this.domElement.height / r.height) * i
        }
        normalizeToPointerData(e) {
            const n = [];
            if (this.supportsTouchEvents && e instanceof TouchEvent)
                for (let s = 0, r = e.changedTouches.length; s < r; s++) {
                    const i = e.changedTouches[s];
                    typeof i.button > "u" && (i.button = 0),
                        typeof i.buttons > "u" && (i.buttons = 1),
                        typeof i.isPrimary > "u" && (i.isPrimary = e.touches.length === 1 && e.type === "touchstart"),
                        typeof i.width > "u" && (i.width = i.radiusX || 1),
                        typeof i.height > "u" && (i.height = i.radiusY || 1),
                        typeof i.tiltX > "u" && (i.tiltX = 0),
                        typeof i.tiltY > "u" && (i.tiltY = 0),
                        typeof i.pointerType > "u" && (i.pointerType = "touch"),
                        typeof i.pointerId > "u" && (i.pointerId = i.identifier || 0),
                        typeof i.pressure > "u" && (i.pressure = i.force || .5),
                        typeof i.twist > "u" && (i.twist = 0),
                        typeof i.tangentialPressure > "u" && (i.tangentialPressure = 0),
                        typeof i.layerX > "u" && (i.layerX = i.offsetX = i.clientX),
                        typeof i.layerY > "u" && (i.layerY = i.offsetY = i.clientY),
                        i.isNormalized = !0,
                        i.type = e.type,
                        n.push(i)
                }
            else if (!globalThis.MouseEvent || e instanceof MouseEvent && (!this.supportsPointerEvents || !(e instanceof globalThis.PointerEvent))) {
                const s = e;
                typeof s.isPrimary > "u" && (s.isPrimary = !0),
                    typeof s.width > "u" && (s.width = 1),
                    typeof s.height > "u" && (s.height = 1),
                    typeof s.tiltX > "u" && (s.tiltX = 0),
                    typeof s.tiltY > "u" && (s.tiltY = 0),
                    typeof s.pointerType > "u" && (s.pointerType = "mouse"),
                    typeof s.pointerId > "u" && (s.pointerId = Cde),
                    typeof s.pressure > "u" && (s.pressure = .5),
                    typeof s.twist > "u" && (s.twist = 0),
                    typeof s.tangentialPressure > "u" && (s.tangentialPressure = 0),
                    s.isNormalized = !0,
                    n.push(s)
            } else
                n.push(e);
            return n
        }
        normalizeWheelEvent(e) {
            const n = this.rootWheelEvent;
            return this.transferMouseData(n, e),
                n.deltaX = e.deltaX,
                n.deltaY = e.deltaY,
                n.deltaZ = e.deltaZ,
                n.deltaMode = e.deltaMode,
                this.mapPositionToPoint(n.screen, e.clientX, e.clientY),
                n.global.copyFrom(n.screen),
                n.offset.copyFrom(n.screen),
                n.nativeEvent = e,
                n.type = e.type,
                n
        }
        bootstrapEvent(e, n) {
            return e.originalEvent = null,
                e.nativeEvent = n,
                e.pointerId = n.pointerId,
                e.width = n.width,
                e.height = n.height,
                e.isPrimary = n.isPrimary,
                e.pointerType = n.pointerType,
                e.pressure = n.pressure,
                e.tangentialPressure = n.tangentialPressure,
                e.tiltX = n.tiltX,
                e.tiltY = n.tiltY,
                e.twist = n.twist,
                this.transferMouseData(e, n),
                this.mapPositionToPoint(e.screen, n.clientX, n.clientY),
                e.global.copyFrom(e.screen),
                e.offset.copyFrom(e.screen),
                e.isTrusted = n.isTrusted,
                e.type === "pointerleave" && (e.type = "pointerout"),
                e.type.startsWith("mouse") && (e.type = e.type.replace("mouse", "pointer")),
                e.type.startsWith("touch") && (e.type = Ide[e.type] || e.type),
                e
        }
        transferMouseData(e, n) {
            e.isTrusted = n.isTrusted,
                e.srcElement = n.srcElement,
                e.timeStamp = performance.now(),
                e.type = n.type,
                e.altKey = n.altKey,
                e.button = n.button,
                e.buttons = n.buttons,
                e.client.x = n.clientX,
                e.client.y = n.clientY,
                e.ctrlKey = n.ctrlKey,
                e.metaKey = n.metaKey,
                e.movement.x = n.movementX,
                e.movement.y = n.movementY,
                e.page.x = n.pageX,
                e.page.y = n.pageY,
                e.relatedTarget = null,
                e.shiftKey = n.shiftKey
        }
    }
    ;
ev.extension = {
    name: "events",
    type: [Ae.RendererSystem, Ae.CanvasRendererSystem]
},
    ev.defaultEventFeatures = {
        move: !0,
        globalMove: !0,
        click: !0,
        wheel: !0
    };
let nv = ev;
Ue.add(nv);
function SA(t) {
    return t === "dynamic" || t === "static"
}
const Ade = {
    onclick: null,
    onmousedown: null,
    onmouseenter: null,
    onmouseleave: null,
    onmousemove: null,
    onglobalmousemove: null,
    onmouseout: null,
    onmouseover: null,
    onmouseup: null,
    onmouseupoutside: null,
    onpointercancel: null,
    onpointerdown: null,
    onpointerenter: null,
    onpointerleave: null,
    onpointermove: null,
    onglobalpointermove: null,
    onpointerout: null,
    onpointerover: null,
    onpointertap: null,
    onpointerup: null,
    onpointerupoutside: null,
    onrightclick: null,
    onrightdown: null,
    onrightup: null,
    onrightupoutside: null,
    ontap: null,
    ontouchcancel: null,
    ontouchend: null,
    ontouchendoutside: null,
    ontouchmove: null,
    onglobaltouchmove: null,
    ontouchstart: null,
    onwheel: null,
    _internalInteractive: void 0,
    get interactive() {
        return this._internalInteractive ?? SA(nv.defaultEventMode)
    },
    set interactive(t) {
        dt("7.2.0", "Setting interactive is deprecated, use eventMode = 'none'/'passive'/'auto'/'static'/'dynamic' instead."),
            this._internalInteractive = t,
            this.eventMode = t ? "static" : "auto"
    },
    _internalEventMode: void 0,
    get eventMode() {
        return this._internalEventMode ?? nv.defaultEventMode
    },
    set eventMode(t) {
        this._internalInteractive = SA(t),
            this._internalEventMode = t
    },
    isInteractive() {
        return this.eventMode === "static" || this.eventMode === "dynamic"
    },
    interactiveChildren: !0,
    hitArea: null,
    addEventListener(t, e, n) {
        const s = typeof n == "boolean" && n || typeof n == "object" && n.capture
            , r = typeof n == "object" ? n.signal : void 0
            , i = typeof n == "object" ? n.once === !0 : !1
            , o = typeof e == "function" ? void 0 : e;
        t = s ? `${t}capture` : t;
        const l = typeof e == "function" ? e : e.handleEvent
            , a = this;
        r && r.addEventListener("abort", () => {
            a.off(t, l, o)
        }
        ),
            i ? a.once(t, l, o) : a.on(t, l, o)
    },
    removeEventListener(t, e, n) {
        const s = typeof n == "boolean" && n || typeof n == "object" && n.capture
            , r = typeof e == "function" ? void 0 : e;
        t = s ? `${t}capture` : t,
            e = typeof e == "function" ? e : e.handleEvent,
            this.off(t, e, r)
    },
    dispatchEvent(t) {
        if (!(t instanceof Sf))
            throw new Error("DisplayObject cannot propagate events outside of the Federated Events API");
        return t.defaultPrevented = !1,
            t.path = null,
            t.target = this,
            t.manager.dispatchEvent(t),
            !t.defaultPrevented
    }
};
ln.mixin(Ade);
const kde = {
    accessible: !1,
    accessibleTitle: null,
    accessibleHint: null,
    tabIndex: 0,
    _accessibleActive: !1,
    _accessibleDiv: null,
    accessibleType: "button",
    accessiblePointerEvents: "auto",
    accessibleChildren: !0,
    renderId: -1
};
ln.mixin(kde);
const Rde = 9
    , yp = 100
    , Mde = 0
    , Pde = 0
    , EA = 2
    , TA = 1
    , Lde = -1e3
    , Ode = -1e3
    , Nde = 2;
class bL {
    constructor(e) {
        this.debug = !1,
            this._isActive = !1,
            this._isMobileAccessibility = !1,
            this.pool = [],
            this.renderId = 0,
            this.children = [],
            this.androidUpdateCount = 0,
            this.androidUpdateFrequency = 500,
            this._hookDiv = null,
            (xo.tablet || xo.phone) && this.createTouchHook();
        const n = document.createElement("div");
        n.style.width = `${yp}px`,
            n.style.height = `${yp}px`,
            n.style.position = "absolute",
            n.style.top = `${Mde}px`,
            n.style.left = `${Pde}px`,
            n.style.zIndex = EA.toString(),
            this.div = n,
            this.renderer = e,
            this._onKeyDown = this._onKeyDown.bind(this),
            this._onMouseMove = this._onMouseMove.bind(this),
            globalThis.addEventListener("keydown", this._onKeyDown, !1)
    }
    get isActive() {
        return this._isActive
    }
    get isMobileAccessibility() {
        return this._isMobileAccessibility
    }
    createTouchHook() {
        const e = document.createElement("button");
        e.style.width = `${TA}px`,
            e.style.height = `${TA}px`,
            e.style.position = "absolute",
            e.style.top = `${Lde}px`,
            e.style.left = `${Ode}px`,
            e.style.zIndex = Nde.toString(),
            e.style.backgroundColor = "#FF0000",
            e.title = "select to enable accessibility for this content",
            e.addEventListener("focus", () => {
                this._isMobileAccessibility = !0,
                    this.activate(),
                    this.destroyTouchHook()
            }
            ),
            document.body.appendChild(e),
            this._hookDiv = e
    }
    destroyTouchHook() {
        this._hookDiv && (document.body.removeChild(this._hookDiv),
            this._hookDiv = null)
    }
    activate() {
        var e;
        this._isActive || (this._isActive = !0,
            globalThis.document.addEventListener("mousemove", this._onMouseMove, !0),
            globalThis.removeEventListener("keydown", this._onKeyDown, !1),
            this.renderer.on("postrender", this.update, this),
            (e = this.renderer.view.parentNode) == null || e.appendChild(this.div))
    }
    deactivate() {
        var e;
        !this._isActive || this._isMobileAccessibility || (this._isActive = !1,
            globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0),
            globalThis.addEventListener("keydown", this._onKeyDown, !1),
            this.renderer.off("postrender", this.update),
            (e = this.div.parentNode) == null || e.removeChild(this.div))
    }
    updateAccessibleObjects(e) {
        if (!e.visible || !e.accessibleChildren)
            return;
        e.accessible && e.isInteractive() && (e._accessibleActive || this.addChild(e),
            e.renderId = this.renderId);
        const n = e.children;
        if (n)
            for (let s = 0; s < n.length; s++)
                this.updateAccessibleObjects(n[s])
    }
    update() {
        const e = performance.now();
        if (xo.android.device && e < this.androidUpdateCount || (this.androidUpdateCount = e + this.androidUpdateFrequency,
            !this.renderer.renderingToScreen))
            return;
        this.renderer.lastObjectRendered && this.updateAccessibleObjects(this.renderer.lastObjectRendered);
        const { x: n, y: s, width: r, height: i } = this.renderer.view.getBoundingClientRect()
            , { width: o, height: l, resolution: a } = this.renderer
            , c = r / o * a
            , u = i / l * a;
        let h = this.div;
        h.style.left = `${n}px`,
            h.style.top = `${s}px`,
            h.style.width = `${o}px`,
            h.style.height = `${l}px`;
        for (let d = 0; d < this.children.length; d++) {
            const f = this.children[d];
            if (f.renderId !== this.renderId)
                f._accessibleActive = !1,
                    wu(this.children, d, 1),
                    this.div.removeChild(f._accessibleDiv),
                    this.pool.push(f._accessibleDiv),
                    f._accessibleDiv = null,
                    d--;
            else {
                h = f._accessibleDiv;
                let p = f.hitArea;
                const m = f.worldTransform;
                f.hitArea ? (h.style.left = `${(m.tx + p.x * m.a) * c}px`,
                    h.style.top = `${(m.ty + p.y * m.d) * u}px`,
                    h.style.width = `${p.width * m.a * c}px`,
                    h.style.height = `${p.height * m.d * u}px`) : (p = f.getBounds(),
                        this.capHitArea(p),
                        h.style.left = `${p.x * c}px`,
                        h.style.top = `${p.y * u}px`,
                        h.style.width = `${p.width * c}px`,
                        h.style.height = `${p.height * u}px`,
                        h.title !== f.accessibleTitle && f.accessibleTitle !== null && (h.title = f.accessibleTitle),
                        h.getAttribute("aria-label") !== f.accessibleHint && f.accessibleHint !== null && h.setAttribute("aria-label", f.accessibleHint)),
                    (f.accessibleTitle !== h.title || f.tabIndex !== h.tabIndex) && (h.title = f.accessibleTitle,
                        h.tabIndex = f.tabIndex,
                        this.debug && this.updateDebugHTML(h))
            }
        }
        this.renderId++
    }
    updateDebugHTML(e) {
        e.innerHTML = `type: ${e.type}</br> title : ${e.title}</br> tabIndex: ${e.tabIndex}`
    }
    capHitArea(e) {
        e.x < 0 && (e.width += e.x,
            e.x = 0),
            e.y < 0 && (e.height += e.y,
                e.y = 0);
        const { width: n, height: s } = this.renderer;
        e.x + e.width > n && (e.width = n - e.x),
            e.y + e.height > s && (e.height = s - e.y)
    }
    addChild(e) {
        let n = this.pool.pop();
        n || (n = document.createElement("button"),
            n.style.width = `${yp}px`,
            n.style.height = `${yp}px`,
            n.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent",
            n.style.position = "absolute",
            n.style.zIndex = EA.toString(),
            n.style.borderStyle = "none",
            navigator.userAgent.toLowerCase().includes("chrome") ? n.setAttribute("aria-live", "off") : n.setAttribute("aria-live", "polite"),
            navigator.userAgent.match(/rv:.*Gecko\//) ? n.setAttribute("aria-relevant", "additions") : n.setAttribute("aria-relevant", "text"),
            n.addEventListener("click", this._onClick.bind(this)),
            n.addEventListener("focus", this._onFocus.bind(this)),
            n.addEventListener("focusout", this._onFocusOut.bind(this))),
            n.style.pointerEvents = e.accessiblePointerEvents,
            n.type = e.accessibleType,
            e.accessibleTitle && e.accessibleTitle !== null ? n.title = e.accessibleTitle : (!e.accessibleHint || e.accessibleHint === null) && (n.title = `displayObject ${e.tabIndex}`),
            e.accessibleHint && e.accessibleHint !== null && n.setAttribute("aria-label", e.accessibleHint),
            this.debug && this.updateDebugHTML(n),
            e._accessibleActive = !0,
            e._accessibleDiv = n,
            n.displayObject = e,
            this.children.push(e),
            this.div.appendChild(e._accessibleDiv),
            e._accessibleDiv.tabIndex = e.tabIndex
    }
    _dispatchEvent(e, n) {
        const { displayObject: s } = e.target
            , r = this.renderer.events.rootBoundary
            , i = Object.assign(new Sf(r), {
                target: s
            });
        r.rootTarget = this.renderer.lastObjectRendered,
            n.forEach(o => r.dispatchEvent(i, o))
    }
    _onClick(e) {
        this._dispatchEvent(e, ["click", "pointertap", "tap"])
    }
    _onFocus(e) {
        e.target.getAttribute("aria-live") || e.target.setAttribute("aria-live", "assertive"),
            this._dispatchEvent(e, ["mouseover"])
    }
    _onFocusOut(e) {
        e.target.getAttribute("aria-live") || e.target.setAttribute("aria-live", "polite"),
            this._dispatchEvent(e, ["mouseout"])
    }
    _onKeyDown(e) {
        e.keyCode === Rde && this.activate()
    }
    _onMouseMove(e) {
        e.movementX === 0 && e.movementY === 0 || this.deactivate()
    }
    destroy() {
        this.destroyTouchHook(),
            this.div = null,
            globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0),
            globalThis.removeEventListener("keydown", this._onKeyDown),
            this.pool = null,
            this.children = null,
            this.renderer = null
    }
}
bL.extension = {
    name: "accessibility",
    type: [Ae.RendererPlugin, Ae.CanvasRendererPlugin]
};
Ue.add(bL);
const vL = class sv {
    constructor(e) {
        this.stage = new ks,
            e = Object.assign({
                forceCanvas: !1
            }, e),
            this.renderer = Xce(e),
            sv._plugins.forEach(n => {
                n.init.call(this, e)
            }
            )
    }
    render() {
        this.renderer.render(this.stage)
    }
    get view() {
        var e;
        return (e = this.renderer) == null ? void 0 : e.view
    }
    get screen() {
        var e;
        return (e = this.renderer) == null ? void 0 : e.screen
    }
    destroy(e, n) {
        const s = sv._plugins.slice(0);
        s.reverse(),
            s.forEach(r => {
                r.destroy.call(this)
            }
            ),
            this.stage.destroy(n),
            this.stage = null,
            this.renderer.destroy(e),
            this.renderer = null
    }
}
    ;
vL._plugins = [];
let gS = vL;
Ue.handleByList(Ae.Application, gS._plugins);
class xL {
    static init(e) {
        Object.defineProperty(this, "resizeTo", {
            set(n) {
                globalThis.removeEventListener("resize", this.queueResize),
                    this._resizeTo = n,
                    n && (globalThis.addEventListener("resize", this.queueResize),
                        this.resize())
            },
            get() {
                return this._resizeTo
            }
        }),
            this.queueResize = () => {
                this._resizeTo && (this.cancelResize(),
                    this._resizeId = requestAnimationFrame(() => this.resize()))
            }
            ,
            this.cancelResize = () => {
                this._resizeId && (cancelAnimationFrame(this._resizeId),
                    this._resizeId = null)
            }
            ,
            this.resize = () => {
                if (!this._resizeTo)
                    return;
                this.cancelResize();
                let n, s;
                if (this._resizeTo === globalThis.window)
                    n = globalThis.innerWidth,
                        s = globalThis.innerHeight;
                else {
                    const { clientWidth: r, clientHeight: i } = this._resizeTo;
                    n = r,
                        s = i
                }
                this.renderer.resize(n, s),
                    this.render()
            }
            ,
            this._resizeId = null,
            this._resizeTo = null,
            this.resizeTo = e.resizeTo || null
    }
    static destroy() {
        globalThis.removeEventListener("resize", this.queueResize),
            this.cancelResize(),
            this.cancelResize = null,
            this.queueResize = null,
            this.resizeTo = null,
            this.resize = null
    }
}
xL.extension = Ae.Application;
Ue.add(xL);
var Qn = (t => (t[t.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT",
    t[t.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT",
    t[t.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT",
    t[t.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT",
    t[t.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT",
    t[t.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT",
    t[t.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT",
    t[t.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT",
    t[t.COMPRESSED_R11_EAC = 37488] = "COMPRESSED_R11_EAC",
    t[t.COMPRESSED_SIGNED_R11_EAC = 37489] = "COMPRESSED_SIGNED_R11_EAC",
    t[t.COMPRESSED_RG11_EAC = 37490] = "COMPRESSED_RG11_EAC",
    t[t.COMPRESSED_SIGNED_RG11_EAC = 37491] = "COMPRESSED_SIGNED_RG11_EAC",
    t[t.COMPRESSED_RGB8_ETC2 = 37492] = "COMPRESSED_RGB8_ETC2",
    t[t.COMPRESSED_RGBA8_ETC2_EAC = 37496] = "COMPRESSED_RGBA8_ETC2_EAC",
    t[t.COMPRESSED_SRGB8_ETC2 = 37493] = "COMPRESSED_SRGB8_ETC2",
    t[t.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC",
    t[t.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2",
    t[t.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2",
    t[t.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG",
    t[t.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG",
    t[t.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG",
    t[t.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG",
    t[t.COMPRESSED_RGB_ETC1_WEBGL = 36196] = "COMPRESSED_RGB_ETC1_WEBGL",
    t[t.COMPRESSED_RGB_ATC_WEBGL = 35986] = "COMPRESSED_RGB_ATC_WEBGL",
    t[t.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35987] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL",
    t[t.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL",
    t[t.COMPRESSED_RGBA_ASTC_4x4_KHR = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR",
    t[t.COMPRESSED_RGBA_BPTC_UNORM_EXT = 36492] = "COMPRESSED_RGBA_BPTC_UNORM_EXT",
    t[t.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT = 36493] = "COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT",
    t[t.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT = 36494] = "COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT",
    t[t.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT = 36495] = "COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT",
    t))(Qn || {});
const ug = {
    33776: .5,
    33777: .5,
    33778: 1,
    33779: 1,
    35916: .5,
    35917: .5,
    35918: 1,
    35919: 1,
    37488: .5,
    37489: .5,
    37490: 1,
    37491: 1,
    37492: .5,
    37496: 1,
    37493: .5,
    37497: 1,
    37494: .5,
    37495: .5,
    35840: .5,
    35842: .5,
    35841: .25,
    35843: .25,
    36196: .5,
    35986: .5,
    35987: 1,
    34798: 1,
    37808: 1,
    36492: 1,
    36493: 1,
    36494: 1,
    36495: 1
};
let Ii, jc;
function CA() {
    jc = {
        bptc: Ii.getExtension("EXT_texture_compression_bptc"),
        astc: Ii.getExtension("WEBGL_compressed_texture_astc"),
        etc: Ii.getExtension("WEBGL_compressed_texture_etc"),
        s3tc: Ii.getExtension("WEBGL_compressed_texture_s3tc"),
        s3tc_sRGB: Ii.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
        pvrtc: Ii.getExtension("WEBGL_compressed_texture_pvrtc") || Ii.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
        etc1: Ii.getExtension("WEBGL_compressed_texture_etc1"),
        atc: Ii.getExtension("WEBGL_compressed_texture_atc")
    }
}
const Dde = {
    extension: {
        type: Ae.DetectionParser,
        priority: 2
    },
    test: async () => {
        const t = Le.ADAPTER.createCanvas().getContext("webgl");
        return t ? (Ii = t,
            !0) : (console.warn("WebGL not available for compressed textures."),
                !1)
    }
    ,
    add: async t => {
        jc || CA();
        const e = [];
        for (const n in jc)
            jc[n] && e.push(n);
        return [...e, ...t]
    }
    ,
    remove: async t => (jc || CA(),
        t.filter(e => !(e in jc)))
};
Ue.add(Dde);
class Bde extends k_ {
    constructor(e, n = {
        width: 1,
        height: 1,
        autoLoad: !0
    }) {
        let s, r;
        typeof e == "string" ? (s = e,
            r = new Uint8Array) : (s = null,
                r = e),
            super(r, n),
            this.origin = s,
            this.buffer = r ? new yb(r) : null,
            this._load = null,
            this.loaded = !1,
            this.origin !== null && n.autoLoad !== !1 && this.load(),
            this.origin === null && this.buffer && (this._load = Promise.resolve(this),
                this.loaded = !0,
                this.onBlobLoaded(this.buffer.rawBinaryData))
    }
    onBlobLoaded(e) { }
    load() {
        return this._load ? this._load : (this._load = fetch(this.origin).then(e => e.blob()).then(e => e.arrayBuffer()).then(e => (this.data = new Uint32Array(e),
            this.buffer = new yb(e),
            this.loaded = !0,
            this.onBlobLoaded(e),
            this.update(),
            this)),
            this._load)
    }
}
class zl extends Bde {
    constructor(e, n) {
        super(e, n),
            this.format = n.format,
            this.levels = n.levels || 1,
            this._width = n.width,
            this._height = n.height,
            this._extension = zl._formatToExtension(this.format),
            (n.levelBuffers || this.buffer) && (this._levelBuffers = n.levelBuffers || zl._createLevelBuffers(e instanceof Uint8Array ? e : this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height))
    }
    upload(e, n, s) {
        const r = e.gl;
        if (!e.context.extensions[this._extension])
            throw new Error(`${this._extension} textures are not supported on the current machine`);
        if (!this._levelBuffers)
            return !1;
        r.pixelStorei(r.UNPACK_ALIGNMENT, 4);
        for (let i = 0, o = this.levels; i < o; i++) {
            const { levelID: l, levelWidth: a, levelHeight: c, levelBuffer: u } = this._levelBuffers[i];
            r.compressedTexImage2D(r.TEXTURE_2D, l, this.format, a, c, 0, u)
        }
        return !0
    }
    onBlobLoaded() {
        this._levelBuffers = zl._createLevelBuffers(this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height)
    }
    static _formatToExtension(e) {
        if (e >= 33776 && e <= 33779)
            return "s3tc";
        if (e >= 35916 && e <= 35919)
            return "s3tc_sRGB";
        if (e >= 37488 && e <= 37497)
            return "etc";
        if (e >= 35840 && e <= 35843)
            return "pvrtc";
        if (e === 36196)
            return "etc1";
        if (e === 35986 || e === 35987 || e === 34798)
            return "atc";
        if (e >= 36492 && e <= 36495)
            return "bptc";
        if (e === 37808)
            return "astc";
        throw new Error(`Invalid (compressed) texture format given: ${e}`)
    }
    static _createLevelBuffers(e, n, s, r, i, o, l) {
        const a = new Array(s);
        let c = e.byteOffset
            , u = o
            , h = l
            , d = u + r - 1 & ~(r - 1)
            , f = h + i - 1 & ~(i - 1)
            , p = d * f * ug[n];
        for (let m = 0; m < s; m++)
            a[m] = {
                levelID: m,
                levelWidth: s > 1 ? u : d,
                levelHeight: s > 1 ? h : f,
                levelBuffer: new Uint8Array(e.buffer, c, p)
            },
                c += p,
                u = u >> 1 || 1,
                h = h >> 1 || 1,
                d = u + r - 1 & ~(r - 1),
                f = h + i - 1 & ~(i - 1),
                p = d * f * ug[n];
        return a
    }
}
const R1 = 4
    , bp = 124
    , Fde = 32
    , IA = 20
    , $de = 542327876
    , vp = {
        SIZE: 1,
        FLAGS: 2,
        HEIGHT: 3,
        WIDTH: 4,
        MIPMAP_COUNT: 7,
        PIXEL_FORMAT: 19
    }
    , Ude = {
        SIZE: 0,
        FLAGS: 1,
        FOURCC: 2,
        RGB_BITCOUNT: 3,
        R_BIT_MASK: 4,
        G_BIT_MASK: 5,
        B_BIT_MASK: 6,
        A_BIT_MASK: 7
    }
    , xp = {
        DXGI_FORMAT: 0,
        RESOURCE_DIMENSION: 1,
        MISC_FLAG: 2,
        ARRAY_SIZE: 3,
        MISC_FLAGS2: 4
    }
    , Vde = 1
    , Gde = 2
    , Hde = 4
    , Wde = 64
    , Yde = 512
    , Xde = 131072
    , jde = 827611204
    , zde = 861165636
    , qde = 894720068
    , Kde = 808540228
    , Jde = 4
    , Zde = {
        [jde]: Qn.COMPRESSED_RGBA_S3TC_DXT1_EXT,
        [zde]: Qn.COMPRESSED_RGBA_S3TC_DXT3_EXT,
        [qde]: Qn.COMPRESSED_RGBA_S3TC_DXT5_EXT
    }
    , Qde = {
        70: Qn.COMPRESSED_RGBA_S3TC_DXT1_EXT,
        71: Qn.COMPRESSED_RGBA_S3TC_DXT1_EXT,
        73: Qn.COMPRESSED_RGBA_S3TC_DXT3_EXT,
        74: Qn.COMPRESSED_RGBA_S3TC_DXT3_EXT,
        76: Qn.COMPRESSED_RGBA_S3TC_DXT5_EXT,
        77: Qn.COMPRESSED_RGBA_S3TC_DXT5_EXT,
        72: Qn.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
        75: Qn.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
        78: Qn.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT,
        96: Qn.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT,
        95: Qn.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT,
        98: Qn.COMPRESSED_RGBA_BPTC_UNORM_EXT,
        99: Qn.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
    };
function efe(t) {
    const e = new Uint32Array(t);
    if (e[0] !== $de)
        throw new Error("Invalid DDS file magic word");
    const n = new Uint32Array(t, 0, bp / Uint32Array.BYTES_PER_ELEMENT)
        , s = n[vp.HEIGHT]
        , r = n[vp.WIDTH]
        , i = n[vp.MIPMAP_COUNT]
        , o = new Uint32Array(t, vp.PIXEL_FORMAT * Uint32Array.BYTES_PER_ELEMENT, Fde / Uint32Array.BYTES_PER_ELEMENT)
        , l = o[Vde];
    if (l & Hde) {
        const a = o[Ude.FOURCC];
        if (a !== Kde) {
            const v = Zde[a]
                , _ = R1 + bp
                , y = new Uint8Array(t, _);
            return [new zl(y, {
                format: v,
                width: r,
                height: s,
                levels: i
            })]
        }
        const c = R1 + bp
            , u = new Uint32Array(e.buffer, c, IA / Uint32Array.BYTES_PER_ELEMENT)
            , h = u[xp.DXGI_FORMAT]
            , d = u[xp.RESOURCE_DIMENSION]
            , f = u[xp.MISC_FLAG]
            , p = u[xp.ARRAY_SIZE]
            , m = Qde[h];
        if (m === void 0)
            throw new Error(`DDSParser cannot parse texture data with DXGI format ${h}`);
        if (f === Jde)
            throw new Error("DDSParser does not support cubemap textures");
        if (d === 6)
            throw new Error("DDSParser does not supported 3D texture data");
        const g = new Array
            , b = R1 + bp + IA;
        if (p === 1)
            g.push(new Uint8Array(t, b));
        else {
            const v = ug[m];
            let _ = 0
                , y = r
                , x = s;
            for (let S = 0; S < i; S++) {
                const E = Math.max(1, y + 3 & -4)
                    , C = Math.max(1, x + 3 & -4)
                    , I = E * C * v;
                _ += I,
                    y = y >>> 1,
                    x = x >>> 1
            }
            let w = b;
            for (let S = 0; S < p; S++)
                g.push(new Uint8Array(t, w, _)),
                    w += _
        }
        return g.map(v => new zl(v, {
            format: m,
            width: r,
            height: s,
            levels: i
        }))
    }
    throw l & Wde ? new Error("DDSParser does not support uncompressed texture data.") : l & Yde ? new Error("DDSParser does not supported YUV uncompressed texture data.") : l & Xde ? new Error("DDSParser does not support single-channel (lumninance) texture data!") : l & Gde ? new Error("DDSParser does not support single-channel (alpha) texture data!") : new Error("DDSParser failed to load a texture file due to an unknown reason!")
}
const AA = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10]
    , tfe = 67305985
    , $r = {
        FILE_IDENTIFIER: 0,
        ENDIANNESS: 12,
        GL_TYPE: 16,
        GL_TYPE_SIZE: 20,
        GL_FORMAT: 24,
        GL_INTERNAL_FORMAT: 28,
        GL_BASE_INTERNAL_FORMAT: 32,
        PIXEL_WIDTH: 36,
        PIXEL_HEIGHT: 40,
        PIXEL_DEPTH: 44,
        NUMBER_OF_ARRAY_ELEMENTS: 48,
        NUMBER_OF_FACES: 52,
        NUMBER_OF_MIPMAP_LEVELS: 56,
        BYTES_OF_KEY_VALUE_DATA: 60
    }
    , rv = 64
    , kA = {
        [Ge.UNSIGNED_BYTE]: 1,
        [Ge.UNSIGNED_SHORT]: 2,
        [Ge.INT]: 4,
        [Ge.UNSIGNED_INT]: 4,
        [Ge.FLOAT]: 4,
        [Ge.HALF_FLOAT]: 8
    }
    , nfe = {
        [Ee.RGBA]: 4,
        [Ee.RGB]: 3,
        [Ee.RG]: 2,
        [Ee.RED]: 1,
        [Ee.LUMINANCE]: 1,
        [Ee.LUMINANCE_ALPHA]: 2,
        [Ee.ALPHA]: 1
    }
    , sfe = {
        [Ge.UNSIGNED_SHORT_4_4_4_4]: 2,
        [Ge.UNSIGNED_SHORT_5_5_5_1]: 2,
        [Ge.UNSIGNED_SHORT_5_6_5]: 2
    };
function rfe(t, e, n = !1) {
    const s = new DataView(e);
    if (!ife(t, s))
        return null;
    const r = s.getUint32($r.ENDIANNESS, !0) === tfe
        , i = s.getUint32($r.GL_TYPE, r)
        , o = s.getUint32($r.GL_FORMAT, r)
        , l = s.getUint32($r.GL_INTERNAL_FORMAT, r)
        , a = s.getUint32($r.PIXEL_WIDTH, r)
        , c = s.getUint32($r.PIXEL_HEIGHT, r) || 1
        , u = s.getUint32($r.PIXEL_DEPTH, r) || 1
        , h = s.getUint32($r.NUMBER_OF_ARRAY_ELEMENTS, r) || 1
        , d = s.getUint32($r.NUMBER_OF_FACES, r)
        , f = s.getUint32($r.NUMBER_OF_MIPMAP_LEVELS, r)
        , p = s.getUint32($r.BYTES_OF_KEY_VALUE_DATA, r);
    if (c === 0 || u !== 1)
        throw new Error("Only 2D textures are supported");
    if (d !== 1)
        throw new Error("CubeTextures are not supported by KTXLoader yet!");
    if (h !== 1)
        throw new Error("WebGL does not support array textures");
    const m = 4
        , g = 4
        , b = a + 3 & -4
        , v = c + 3 & -4
        , _ = new Array(h);
    let y = a * c;
    i === 0 && (y = b * v);
    let x;
    if (i !== 0 ? kA[i] ? x = kA[i] * nfe[o] : x = sfe[i] : x = ug[l],
        x === void 0)
        throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");
    const w = n ? afe(s, p, r) : null;
    let S = y * x
        , E = a
        , C = c
        , I = b
        , L = v
        , k = rv + p;
    for (let R = 0; R < f; R++) {
        const U = s.getUint32(k, r);
        let W = k + 4;
        for (let H = 0; H < h; H++) {
            let j = _[H];
            j || (j = _[H] = new Array(f)),
                j[R] = {
                    levelID: R,
                    levelWidth: f > 1 || i !== 0 ? E : I,
                    levelHeight: f > 1 || i !== 0 ? C : L,
                    levelBuffer: new Uint8Array(e, W, S)
                },
                W += S
        }
        k += U + 4,
            k = k % 4 !== 0 ? k + 4 - k % 4 : k,
            E = E >> 1 || 1,
            C = C >> 1 || 1,
            I = E + m - 1 & ~(m - 1),
            L = C + g - 1 & ~(g - 1),
            S = I * L * x
    }
    return i !== 0 ? {
        uncompressed: _.map(R => {
            let U = R[0].levelBuffer
                , W = !1;
            return i === Ge.FLOAT ? U = new Float32Array(R[0].levelBuffer.buffer, R[0].levelBuffer.byteOffset, R[0].levelBuffer.byteLength / 4) : i === Ge.UNSIGNED_INT ? (W = !0,
                U = new Uint32Array(R[0].levelBuffer.buffer, R[0].levelBuffer.byteOffset, R[0].levelBuffer.byteLength / 4)) : i === Ge.INT && (W = !0,
                    U = new Int32Array(R[0].levelBuffer.buffer, R[0].levelBuffer.byteOffset, R[0].levelBuffer.byteLength / 4)),
            {
                resource: new k_(U, {
                    width: R[0].levelWidth,
                    height: R[0].levelHeight
                }),
                type: i,
                format: W ? ofe(o) : o
            }
        }
        ),
        kvData: w
    } : {
        compressed: _.map(R => new zl(null, {
            format: l,
            width: a,
            height: c,
            levels: f,
            levelBuffers: R
        })),
        kvData: w
    }
}
function ife(t, e) {
    for (let n = 0; n < AA.length; n++)
        if (e.getUint8(n) !== AA[n])
            return console.error(`${t} is not a valid *.ktx file!`),
                !1;
    return !0
}
function ofe(t) {
    switch (t) {
        case Ee.RGBA:
            return Ee.RGBA_INTEGER;
        case Ee.RGB:
            return Ee.RGB_INTEGER;
        case Ee.RG:
            return Ee.RG_INTEGER;
        case Ee.RED:
            return Ee.RED_INTEGER;
        default:
            return t
    }
}
function afe(t, e, n) {
    const s = new Map;
    let r = 0;
    for (; r < e;) {
        const i = t.getUint32(rv + r, n)
            , o = rv + r + 4
            , l = 3 - (i + 3) % 4;
        if (i === 0 || i > e - r) {
            console.error("KTXLoader: keyAndValueByteSize out of bounds");
            break
        }
        let a = 0;
        for (; a < i && t.getUint8(o + a) !== 0; a++)
            ;
        if (a === -1) {
            console.error("KTXLoader: Failed to find null byte terminating kvData key");
            break
        }
        const c = new TextDecoder().decode(new Uint8Array(t.buffer, o, a))
            , u = new DataView(t.buffer, o + a + 1, i - a - 1);
        s.set(c, u),
            r += 4 + i + l
    }
    return s
}
const lfe = {
    extension: {
        type: Ae.LoadParser,
        priority: _r.High
    },
    name: "loadDDS",
    test(t) {
        return zs(t, ".dds")
    },
    async load(t, e, n) {
        const s = await (await Le.ADAPTER.fetch(t)).arrayBuffer()
            , r = efe(s).map(i => {
                const o = new st(i, {
                    mipmap: ci.OFF,
                    alphaMode: Is.NO_PREMULTIPLIED_ALPHA,
                    resolution: Vo(t),
                    ...e.data
                });
                return xf(o, n, t)
            }
            );
        return r.length === 1 ? r[0] : r
    },
    unload(t) {
        Array.isArray(t) ? t.forEach(e => e.destroy(!0)) : t.destroy(!0)
    }
};
Ue.add(lfe);
const cfe = {
    extension: {
        type: Ae.LoadParser,
        priority: _r.High
    },
    name: "loadKTX",
    test(t) {
        return zs(t, ".ktx")
    },
    async load(t, e, n) {
        const s = await (await Le.ADAPTER.fetch(t)).arrayBuffer()
            , { compressed: r, uncompressed: i, kvData: o } = rfe(t, s)
            , l = r ?? i
            , a = {
                mipmap: ci.OFF,
                alphaMode: Is.NO_PREMULTIPLIED_ALPHA,
                resolution: Vo(t),
                ...e.data
            }
            , c = l.map(u => {
                l === i && Object.assign(a, {
                    type: u.type,
                    format: u.format
                });
                const h = u.resource ?? u
                    , d = new st(h, a);
                return d.ktxKeyValueData = o,
                    xf(d, n, t)
            }
            );
        return c.length === 1 ? c[0] : c
    },
    unload(t) {
        Array.isArray(t) ? t.forEach(e => e.destroy(!0)) : t.destroy(!0)
    }
};
Ue.add(cfe);
const ufe = ["s3tc", "s3tc_sRGB", "etc", "etc1", "pvrtc", "atc", "astc", "bptc"]
    , hfe = {
        extension: Ae.ResolveParser,
        test: t => {
            const e = zt.extname(t).slice(1);
            return ["basis", "ktx", "dds"].includes(e)
        }
        ,
        parse: t => {
            var s, r;
            const e = t.split(".")
                , n = e.pop();
            if (["ktx", "dds"].includes(n)) {
                const i = e.pop();
                if (ufe.includes(i))
                    return {
                        resolution: parseFloat(((s = Le.RETINA_PREFIX.exec(t)) == null ? void 0 : s[1]) ?? "1"),
                        format: i,
                        src: t
                    }
            }
            return {
                resolution: parseFloat(((r = Le.RETINA_PREFIX.exec(t)) == null ? void 0 : r[1]) ?? "1"),
                format: n,
                src: t
            }
        }
    };
Ue.add(hfe);
const wp = new nt
    , dfe = 4
    , wL = class Vh {
        constructor(e) {
            this.renderer = e,
                this._rendererPremultipliedAlpha = !1
        }
        contextChange() {
            var n;
            const e = (n = this.renderer) == null ? void 0 : n.gl.getContextAttributes();
            this._rendererPremultipliedAlpha = !!(e && e.alpha && e.premultipliedAlpha)
        }
        async image(e, n, s, r) {
            const i = new Image;
            return i.src = await this.base64(e, n, s, r),
                i
        }
        async base64(e, n, s, r) {
            const i = this.canvas(e, r);
            if (i.toBlob !== void 0)
                return new Promise((o, l) => {
                    i.toBlob(a => {
                        if (!a) {
                            l(new Error("ICanvas.toBlob failed!"));
                            return
                        }
                        const c = new FileReader;
                        c.onload = () => o(c.result),
                            c.onerror = l,
                            c.readAsDataURL(a)
                    }
                        , n, s)
                }
                );
            if (i.toDataURL !== void 0)
                return i.toDataURL(n, s);
            if (i.convertToBlob !== void 0) {
                const o = await i.convertToBlob({
                    type: n,
                    quality: s
                });
                return new Promise((l, a) => {
                    const c = new FileReader;
                    c.onload = () => l(c.result),
                        c.onerror = a,
                        c.readAsDataURL(o)
                }
                )
            }
            throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented")
        }
        canvas(e, n) {
            const { pixels: s, width: r, height: i, flipY: o, premultipliedAlpha: l } = this._rawPixels(e, n);
            o && Vh._flipY(s, r, i),
                l && Vh._unpremultiplyAlpha(s);
            const a = new Ole(r, i, 1)
                , c = new ImageData(new Uint8ClampedArray(s.buffer), r, i);
            return a.context.putImageData(c, 0, 0),
                a.canvas
        }
        pixels(e, n) {
            const { pixels: s, width: r, height: i, flipY: o, premultipliedAlpha: l } = this._rawPixels(e, n);
            return o && Vh._flipY(s, r, i),
                l && Vh._unpremultiplyAlpha(s),
                s
        }
        _rawPixels(e, n) {
            const s = this.renderer;
            if (!s)
                throw new Error("The Extract has already been destroyed");
            let r, i = !1, o = !1, l, a = !1;
            e && (e instanceof Sc ? l = e : (l = s.generateTexture(e, {
                region: n,
                resolution: s.resolution,
                multisample: s.multisample
            }),
                a = !0,
                n && (wp.width = n.width,
                    wp.height = n.height,
                    n = wp)));
            const c = s.gl;
            if (l) {
                if (r = l.baseTexture.resolution,
                    n = n ?? l.frame,
                    i = !1,
                    o = l.baseTexture.alphaMode > 0 && l.baseTexture.format === Ee.RGBA,
                    !a) {
                    s.renderTexture.bind(l);
                    const f = l.framebuffer.glFramebuffers[s.CONTEXT_UID];
                    f.blitFramebuffer && s.framebuffer.bind(f.blitFramebuffer)
                }
            } else
                r = s.resolution,
                    n || (n = wp,
                        n.width = s.width / r,
                        n.height = s.height / r),
                    i = !0,
                    o = this._rendererPremultipliedAlpha,
                    s.renderTexture.bind();
            const u = Math.max(Math.round(n.width * r), 1)
                , h = Math.max(Math.round(n.height * r), 1)
                , d = new Uint8Array(dfe * u * h);
            return c.readPixels(Math.round(n.x * r), Math.round(n.y * r), u, h, c.RGBA, c.UNSIGNED_BYTE, d),
                a && (l == null || l.destroy(!0)),
            {
                pixels: d,
                width: u,
                height: h,
                flipY: i,
                premultipliedAlpha: o
            }
        }
        destroy() {
            this.renderer = null
        }
        static _flipY(e, n, s) {
            const r = n << 2
                , i = s >> 1
                , o = new Uint8Array(r);
            for (let l = 0; l < i; l++) {
                const a = l * r
                    , c = (s - l - 1) * r;
                o.set(e.subarray(a, a + r)),
                    e.copyWithin(a, c, c + r),
                    e.set(o, c)
            }
        }
        static _unpremultiplyAlpha(e) {
            e instanceof Uint8ClampedArray && (e = new Uint8Array(e.buffer));
            const n = e.length;
            for (let s = 0; s < n; s += 4) {
                const r = e[s + 3];
                if (r !== 0) {
                    const i = 255.001 / r;
                    e[s] = e[s] * i + .5,
                        e[s + 1] = e[s + 1] * i + .5,
                        e[s + 2] = e[s + 2] * i + .5
                }
            }
        }
    }
    ;
wL.extension = {
    name: "extract",
    type: Ae.RendererSystem
};
let ffe = wL;
Ue.add(ffe);
class RA {
    constructor(e, n, s) {
        this.geometry = new ja,
            this.indexBuffer = null,
            this.size = s,
            this.dynamicProperties = [],
            this.staticProperties = [];
        for (let r = 0; r < e.length; ++r) {
            let i = e[r];
            i = {
                attributeName: i.attributeName,
                size: i.size,
                uploadFunction: i.uploadFunction,
                type: i.type || Ge.FLOAT,
                offset: i.offset
            },
                n[r] ? this.dynamicProperties.push(i) : this.staticProperties.push(i)
        }
        this.staticStride = 0,
            this.staticBuffer = null,
            this.staticData = null,
            this.staticDataUint32 = null,
            this.dynamicStride = 0,
            this.dynamicBuffer = null,
            this.dynamicData = null,
            this.dynamicDataUint32 = null,
            this._updateID = 0,
            this.initBuffers()
    }
    initBuffers() {
        const e = this.geometry;
        let n = 0;
        this.indexBuffer = new _n(Ple(this.size), !0, !0),
            e.addIndex(this.indexBuffer),
            this.dynamicStride = 0;
        for (let o = 0; o < this.dynamicProperties.length; ++o) {
            const l = this.dynamicProperties[o];
            l.offset = n,
                n += l.size,
                this.dynamicStride += l.size
        }
        const s = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
        this.dynamicData = new Float32Array(s),
            this.dynamicDataUint32 = new Uint32Array(s),
            this.dynamicBuffer = new _n(this.dynamicData, !1, !1);
        let r = 0;
        this.staticStride = 0;
        for (let o = 0; o < this.staticProperties.length; ++o) {
            const l = this.staticProperties[o];
            l.offset = r,
                r += l.size,
                this.staticStride += l.size
        }
        const i = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
        this.staticData = new Float32Array(i),
            this.staticDataUint32 = new Uint32Array(i),
            this.staticBuffer = new _n(this.staticData, !0, !1);
        for (let o = 0; o < this.dynamicProperties.length; ++o) {
            const l = this.dynamicProperties[o];
            e.addAttribute(l.attributeName, this.dynamicBuffer, 0, l.type === Ge.UNSIGNED_BYTE, l.type, this.dynamicStride * 4, l.offset * 4)
        }
        for (let o = 0; o < this.staticProperties.length; ++o) {
            const l = this.staticProperties[o];
            e.addAttribute(l.attributeName, this.staticBuffer, 0, l.type === Ge.UNSIGNED_BYTE, l.type, this.staticStride * 4, l.offset * 4)
        }
    }
    uploadDynamic(e, n, s) {
        for (let r = 0; r < this.dynamicProperties.length; r++) {
            const i = this.dynamicProperties[r];
            i.uploadFunction(e, n, s, i.type === Ge.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, i.offset)
        }
        this.dynamicBuffer._updateID++
    }
    uploadStatic(e, n, s) {
        for (let r = 0; r < this.staticProperties.length; r++) {
            const i = this.staticProperties[r];
            i.uploadFunction(e, n, s, i.type === Ge.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, i.offset)
        }
        this.staticBuffer._updateID++
    }
    destroy() {
        this.indexBuffer = null,
            this.dynamicProperties = null,
            this.dynamicBuffer = null,
            this.dynamicData = null,
            this.dynamicDataUint32 = null,
            this.staticProperties = null,
            this.staticBuffer = null,
            this.staticData = null,
            this.staticDataUint32 = null,
            this.geometry.destroy()
    }
}
var pfe = `varying vec2 vTextureCoord;
varying vec4 vColor;

uniform sampler2D uSampler;

void main(void){
    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;
    gl_FragColor = color;
}`
    , mfe = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;

attribute vec2 aPositionCoord;
attribute float aRotation;

uniform mat3 translationMatrix;
uniform vec4 uColor;

varying vec2 vTextureCoord;
varying vec4 vColor;

void main(void){
    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);
    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);

    vec2 v = vec2(x, y);
    v = v + aPositionCoord;

    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vColor = aColor * uColor;
}
`;
class SL extends O_ {
    constructor(e) {
        super(e),
            this.shader = null,
            this.properties = null,
            this.tempMatrix = new Bt,
            this.properties = [{
                attributeName: "aVertexPosition",
                size: 2,
                uploadFunction: this.uploadVertices,
                offset: 0
            }, {
                attributeName: "aPositionCoord",
                size: 2,
                uploadFunction: this.uploadPosition,
                offset: 0
            }, {
                attributeName: "aRotation",
                size: 1,
                uploadFunction: this.uploadRotation,
                offset: 0
            }, {
                attributeName: "aTextureCoord",
                size: 2,
                uploadFunction: this.uploadUvs,
                offset: 0
            }, {
                attributeName: "aColor",
                size: 1,
                type: Ge.UNSIGNED_BYTE,
                uploadFunction: this.uploadTint,
                offset: 0
            }],
            this.shader = Hi.from(mfe, pfe, {}),
            this.state = Ji.for2d()
    }
    render(e) {
        const n = e.children
            , s = e._maxSize
            , r = e._batchSize
            , i = this.renderer;
        let o = n.length;
        if (o === 0)
            return;
        o > s && !e.autoResize && (o = s);
        let l = e._buffers;
        l || (l = e._buffers = this.generateBuffers(e));
        const a = n[0]._texture.baseTexture
            , c = a.alphaMode > 0;
        this.state.blendMode = x6(e.blendMode, c),
            i.state.set(this.state);
        const u = i.gl
            , h = e.worldTransform.copyTo(this.tempMatrix);
        h.prepend(i.globalUniforms.uniforms.projectionMatrix),
            this.shader.uniforms.translationMatrix = h.toArray(!0),
            this.shader.uniforms.uColor = Yt.shared.setValue(e.tintRgb).premultiply(e.worldAlpha, c).toArray(this.shader.uniforms.uColor),
            this.shader.uniforms.uSampler = a,
            this.renderer.shader.bind(this.shader);
        let d = !1;
        for (let f = 0, p = 0; f < o; f += r,
            p += 1) {
            let m = o - f;
            m > r && (m = r),
                p >= l.length && l.push(this._generateOneMoreBuffer(e));
            const g = l[p];
            g.uploadDynamic(n, f, m);
            const b = e._bufferUpdateIDs[p] || 0;
            d = d || g._updateID < b,
                d && (g._updateID = e._updateID,
                    g.uploadStatic(n, f, m)),
                i.geometry.bind(g.geometry),
                u.drawElements(u.TRIANGLES, m * 6, u.UNSIGNED_SHORT, 0)
        }
    }
    generateBuffers(e) {
        const n = []
            , s = e._maxSize
            , r = e._batchSize
            , i = e._properties;
        for (let o = 0; o < s; o += r)
            n.push(new RA(this.properties, i, r));
        return n
    }
    _generateOneMoreBuffer(e) {
        const n = e._batchSize
            , s = e._properties;
        return new RA(this.properties, s, n)
    }
    uploadVertices(e, n, s, r, i, o) {
        let l = 0
            , a = 0
            , c = 0
            , u = 0;
        for (let h = 0; h < s; ++h) {
            const d = e[n + h]
                , f = d._texture
                , p = d.scale.x
                , m = d.scale.y
                , g = f.trim
                , b = f.orig;
            g ? (a = g.x - d.anchor.x * b.width,
                l = a + g.width,
                u = g.y - d.anchor.y * b.height,
                c = u + g.height) : (l = b.width * (1 - d.anchor.x),
                    a = b.width * -d.anchor.x,
                    c = b.height * (1 - d.anchor.y),
                    u = b.height * -d.anchor.y),
                r[o] = a * p,
                r[o + 1] = u * m,
                r[o + i] = l * p,
                r[o + i + 1] = u * m,
                r[o + i * 2] = l * p,
                r[o + i * 2 + 1] = c * m,
                r[o + i * 3] = a * p,
                r[o + i * 3 + 1] = c * m,
                o += i * 4
        }
    }
    uploadPosition(e, n, s, r, i, o) {
        for (let l = 0; l < s; l++) {
            const a = e[n + l].position;
            r[o] = a.x,
                r[o + 1] = a.y,
                r[o + i] = a.x,
                r[o + i + 1] = a.y,
                r[o + i * 2] = a.x,
                r[o + i * 2 + 1] = a.y,
                r[o + i * 3] = a.x,
                r[o + i * 3 + 1] = a.y,
                o += i * 4
        }
    }
    uploadRotation(e, n, s, r, i, o) {
        for (let l = 0; l < s; l++) {
            const a = e[n + l].rotation;
            r[o] = a,
                r[o + i] = a,
                r[o + i * 2] = a,
                r[o + i * 3] = a,
                o += i * 4
        }
    }
    uploadUvs(e, n, s, r, i, o) {
        for (let l = 0; l < s; ++l) {
            const a = e[n + l]._texture._uvs;
            a ? (r[o] = a.x0,
                r[o + 1] = a.y0,
                r[o + i] = a.x1,
                r[o + i + 1] = a.y1,
                r[o + i * 2] = a.x2,
                r[o + i * 2 + 1] = a.y2,
                r[o + i * 3] = a.x3,
                r[o + i * 3 + 1] = a.y3,
                o += i * 4) : (r[o] = 0,
                    r[o + 1] = 0,
                    r[o + i] = 0,
                    r[o + i + 1] = 0,
                    r[o + i * 2] = 0,
                    r[o + i * 2 + 1] = 0,
                    r[o + i * 3] = 0,
                    r[o + i * 3 + 1] = 0,
                    o += i * 4)
        }
    }
    uploadTint(e, n, s, r, i, o) {
        for (let l = 0; l < s; ++l) {
            const a = e[n + l]
                , c = Yt.shared.setValue(a._tintRGB).toPremultiplied(a.alpha, a.texture.baseTexture.alphaMode > 0);
            r[o] = c,
                r[o + i] = c,
                r[o + i * 2] = c,
                r[o + i * 3] = c,
                o += i * 4
        }
    }
    destroy() {
        super.destroy(),
            this.shader && (this.shader.destroy(),
                this.shader = null),
            this.tempMatrix = null
    }
}
SL.extension = {
    name: "particle",
    type: Ae.RendererPlugin
};
Ue.add(SL);
var Z_ = (t => (t[t.LINEAR_VERTICAL = 0] = "LINEAR_VERTICAL",
    t[t.LINEAR_HORIZONTAL = 1] = "LINEAR_HORIZONTAL",
    t))(Z_ || {});
const Sp = {
    willReadFrequently: !0
}
    , Ai = class Ve {
        static get experimentalLetterSpacingSupported() {
            let e = Ve._experimentalLetterSpacingSupported;
            if (e !== void 0) {
                const n = Le.ADAPTER.getCanvasRenderingContext2D().prototype;
                e = Ve._experimentalLetterSpacingSupported = "letterSpacing" in n || "textLetterSpacing" in n
            }
            return e
        }
        constructor(e, n, s, r, i, o, l, a, c) {
            this.text = e,
                this.style = n,
                this.width = s,
                this.height = r,
                this.lines = i,
                this.lineWidths = o,
                this.lineHeight = l,
                this.maxLineWidth = a,
                this.fontProperties = c
        }
        static measureText(e, n, s, r = Ve._canvas) {
            s = s ?? n.wordWrap;
            const i = n.toFontString()
                , o = Ve.measureFont(i);
            o.fontSize === 0 && (o.fontSize = n.fontSize,
                o.ascent = n.fontSize);
            const l = r.getContext("2d", Sp);
            l.font = i;
            const a = (s ? Ve.wordWrap(e, n, r) : e).split(/(?:\r\n|\r|\n)/)
                , c = new Array(a.length);
            let u = 0;
            for (let p = 0; p < a.length; p++) {
                const m = Ve._measureText(a[p], n.letterSpacing, l);
                c[p] = m,
                    u = Math.max(u, m)
            }
            let h = u + n.strokeThickness;
            n.dropShadow && (h += n.dropShadowDistance);
            const d = n.lineHeight || o.fontSize + n.strokeThickness;
            let f = Math.max(d, o.fontSize + n.strokeThickness * 2) + n.leading + (a.length - 1) * (d + n.leading);
            return n.dropShadow && (f += n.dropShadowDistance),
                new Ve(e, n, h, f, a, c, d + n.leading, u, o)
        }
        static _measureText(e, n, s) {
            let r = !1;
            Ve.experimentalLetterSpacingSupported && (Ve.experimentalLetterSpacing ? (s.letterSpacing = `${n}px`,
                s.textLetterSpacing = `${n}px`,
                r = !0) : (s.letterSpacing = "0px",
                    s.textLetterSpacing = "0px"));
            let i = s.measureText(e).width;
            return i > 0 && (r ? i -= n : i += (Ve.graphemeSegmenter(e).length - 1) * n),
                i
        }
        static wordWrap(e, n, s = Ve._canvas) {
            const r = s.getContext("2d", Sp);
            let i = 0
                , o = ""
                , l = "";
            const a = Object.create(null)
                , { letterSpacing: c, whiteSpace: u } = n
                , h = Ve.collapseSpaces(u)
                , d = Ve.collapseNewlines(u);
            let f = !h;
            const p = n.wordWrapWidth + c
                , m = Ve.tokenize(e);
            for (let g = 0; g < m.length; g++) {
                let b = m[g];
                if (Ve.isNewline(b)) {
                    if (!d) {
                        l += Ve.addLine(o),
                            f = !h,
                            o = "",
                            i = 0;
                        continue
                    }
                    b = " "
                }
                if (h) {
                    const _ = Ve.isBreakingSpace(b)
                        , y = Ve.isBreakingSpace(o[o.length - 1]);
                    if (_ && y)
                        continue
                }
                const v = Ve.getFromCache(b, c, a, r);
                if (v > p)
                    if (o !== "" && (l += Ve.addLine(o),
                        o = "",
                        i = 0),
                        Ve.canBreakWords(b, n.breakWords)) {
                        const _ = Ve.wordWrapSplit(b);
                        for (let y = 0; y < _.length; y++) {
                            let x = _[y]
                                , w = x
                                , S = 1;
                            for (; _[y + S];) {
                                const C = _[y + S];
                                if (!Ve.canBreakChars(w, C, b, y, n.breakWords))
                                    x += C;
                                else
                                    break;
                                w = C,
                                    S++
                            }
                            y += S - 1;
                            const E = Ve.getFromCache(x, c, a, r);
                            E + i > p && (l += Ve.addLine(o),
                                f = !1,
                                o = "",
                                i = 0),
                                o += x,
                                i += E
                        }
                    } else {
                        o.length > 0 && (l += Ve.addLine(o),
                            o = "",
                            i = 0);
                        const _ = g === m.length - 1;
                        l += Ve.addLine(b, !_),
                            f = !1,
                            o = "",
                            i = 0
                    }
                else
                    v + i > p && (f = !1,
                        l += Ve.addLine(o),
                        o = "",
                        i = 0),
                        (o.length > 0 || !Ve.isBreakingSpace(b) || f) && (o += b,
                            i += v)
            }
            return l += Ve.addLine(o, !1),
                l
        }
        static addLine(e, n = !0) {
            return e = Ve.trimRight(e),
                e = n ? `${e}
` : e,
                e
        }
        static getFromCache(e, n, s, r) {
            let i = s[e];
            return typeof i != "number" && (i = Ve._measureText(e, n, r) + n,
                s[e] = i),
                i
        }
        static collapseSpaces(e) {
            return e === "normal" || e === "pre-line"
        }
        static collapseNewlines(e) {
            return e === "normal"
        }
        static trimRight(e) {
            if (typeof e != "string")
                return "";
            for (let n = e.length - 1; n >= 0; n--) {
                const s = e[n];
                if (!Ve.isBreakingSpace(s))
                    break;
                e = e.slice(0, -1)
            }
            return e
        }
        static isNewline(e) {
            return typeof e != "string" ? !1 : Ve._newlines.includes(e.charCodeAt(0))
        }
        static isBreakingSpace(e, n) {
            return typeof e != "string" ? !1 : Ve._breakingSpaces.includes(e.charCodeAt(0))
        }
        static tokenize(e) {
            const n = [];
            let s = "";
            if (typeof e != "string")
                return n;
            for (let r = 0; r < e.length; r++) {
                const i = e[r]
                    , o = e[r + 1];
                if (Ve.isBreakingSpace(i, o) || Ve.isNewline(i)) {
                    s !== "" && (n.push(s),
                        s = ""),
                        n.push(i);
                    continue
                }
                s += i
            }
            return s !== "" && n.push(s),
                n
        }
        static canBreakWords(e, n) {
            return n
        }
        static canBreakChars(e, n, s, r, i) {
            return !0
        }
        static wordWrapSplit(e) {
            return Ve.graphemeSegmenter(e)
        }
        static measureFont(e) {
            if (Ve._fonts[e])
                return Ve._fonts[e];
            const n = {
                ascent: 0,
                descent: 0,
                fontSize: 0
            }
                , s = Ve._canvas
                , r = Ve._context;
            r.font = e;
            const i = Ve.METRICS_STRING + Ve.BASELINE_SYMBOL
                , o = Math.ceil(r.measureText(i).width);
            let l = Math.ceil(r.measureText(Ve.BASELINE_SYMBOL).width);
            const a = Math.ceil(Ve.HEIGHT_MULTIPLIER * l);
            if (l = l * Ve.BASELINE_MULTIPLIER | 0,
                o === 0 || a === 0)
                return Ve._fonts[e] = n,
                    n;
            s.width = o,
                s.height = a,
                r.fillStyle = "#f00",
                r.fillRect(0, 0, o, a),
                r.font = e,
                r.textBaseline = "alphabetic",
                r.fillStyle = "#000",
                r.fillText(i, 0, l);
            const c = r.getImageData(0, 0, o, a).data
                , u = c.length
                , h = o * 4;
            let d = 0
                , f = 0
                , p = !1;
            for (d = 0; d < l; ++d) {
                for (let m = 0; m < h; m += 4)
                    if (c[f + m] !== 255) {
                        p = !0;
                        break
                    }
                if (!p)
                    f += h;
                else
                    break
            }
            for (n.ascent = l - d,
                f = u - h,
                p = !1,
                d = a; d > l; --d) {
                for (let m = 0; m < h; m += 4)
                    if (c[f + m] !== 255) {
                        p = !0;
                        break
                    }
                if (!p)
                    f -= h;
                else
                    break
            }
            return n.descent = d - l,
                n.fontSize = n.ascent + n.descent,
                Ve._fonts[e] = n,
                n
        }
        static clearMetrics(e = "") {
            e ? delete Ve._fonts[e] : Ve._fonts = {}
        }
        static get _canvas() {
            var e;
            if (!Ve.__canvas) {
                let n;
                try {
                    const s = new OffscreenCanvas(0, 0);
                    if ((e = s.getContext("2d", Sp)) != null && e.measureText)
                        return Ve.__canvas = s,
                            s;
                    n = Le.ADAPTER.createCanvas()
                } catch {
                    n = Le.ADAPTER.createCanvas()
                }
                n.width = n.height = 10,
                    Ve.__canvas = n
            }
            return Ve.__canvas
        }
        static get _context() {
            return Ve.__context || (Ve.__context = Ve._canvas.getContext("2d", Sp)),
                Ve.__context
        }
    }
    ;
Ai.METRICS_STRING = "|q",
    Ai.BASELINE_SYMBOL = "M",
    Ai.BASELINE_MULTIPLIER = 1.4,
    Ai.HEIGHT_MULTIPLIER = 2,
    Ai.graphemeSegmenter = (() => {
        if (typeof (Intl == null ? void 0 : Intl.Segmenter) == "function") {
            const t = new Intl.Segmenter;
            return e => [...t.segment(e)].map(n => n.segment)
        }
        return t => [...t]
    }
    )(),
    Ai.experimentalLetterSpacing = !1,
    Ai._fonts = {},
    Ai._newlines = [10, 13],
    Ai._breakingSpaces = [9, 32, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8200, 8201, 8202, 8287, 12288];
let wa = Ai;
const gfe = ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui"]
    , EL = class Gh {
        constructor(e) {
            this.styleID = 0,
                this.reset(),
                P1(this, e, e)
        }
        clone() {
            const e = {};
            return P1(e, this, Gh.defaultStyle),
                new Gh(e)
        }
        reset() {
            P1(this, Gh.defaultStyle, Gh.defaultStyle)
        }
        get align() {
            return this._align
        }
        set align(e) {
            this._align !== e && (this._align = e,
                this.styleID++)
        }
        get breakWords() {
            return this._breakWords
        }
        set breakWords(e) {
            this._breakWords !== e && (this._breakWords = e,
                this.styleID++)
        }
        get dropShadow() {
            return this._dropShadow
        }
        set dropShadow(e) {
            this._dropShadow !== e && (this._dropShadow = e,
                this.styleID++)
        }
        get dropShadowAlpha() {
            return this._dropShadowAlpha
        }
        set dropShadowAlpha(e) {
            this._dropShadowAlpha !== e && (this._dropShadowAlpha = e,
                this.styleID++)
        }
        get dropShadowAngle() {
            return this._dropShadowAngle
        }
        set dropShadowAngle(e) {
            this._dropShadowAngle !== e && (this._dropShadowAngle = e,
                this.styleID++)
        }
        get dropShadowBlur() {
            return this._dropShadowBlur
        }
        set dropShadowBlur(e) {
            this._dropShadowBlur !== e && (this._dropShadowBlur = e,
                this.styleID++)
        }
        get dropShadowColor() {
            return this._dropShadowColor
        }
        set dropShadowColor(e) {
            const n = M1(e);
            this._dropShadowColor !== n && (this._dropShadowColor = n,
                this.styleID++)
        }
        get dropShadowDistance() {
            return this._dropShadowDistance
        }
        set dropShadowDistance(e) {
            this._dropShadowDistance !== e && (this._dropShadowDistance = e,
                this.styleID++)
        }
        get fill() {
            return this._fill
        }
        set fill(e) {
            const n = M1(e);
            this._fill !== n && (this._fill = n,
                this.styleID++)
        }
        get fillGradientType() {
            return this._fillGradientType
        }
        set fillGradientType(e) {
            this._fillGradientType !== e && (this._fillGradientType = e,
                this.styleID++)
        }
        get fillGradientStops() {
            return this._fillGradientStops
        }
        set fillGradientStops(e) {
            _fe(this._fillGradientStops, e) || (this._fillGradientStops = e,
                this.styleID++)
        }
        get fontFamily() {
            return this._fontFamily
        }
        set fontFamily(e) {
            this.fontFamily !== e && (this._fontFamily = e,
                this.styleID++)
        }
        get fontSize() {
            return this._fontSize
        }
        set fontSize(e) {
            this._fontSize !== e && (this._fontSize = e,
                this.styleID++)
        }
        get fontStyle() {
            return this._fontStyle
        }
        set fontStyle(e) {
            this._fontStyle !== e && (this._fontStyle = e,
                this.styleID++)
        }
        get fontVariant() {
            return this._fontVariant
        }
        set fontVariant(e) {
            this._fontVariant !== e && (this._fontVariant = e,
                this.styleID++)
        }
        get fontWeight() {
            return this._fontWeight
        }
        set fontWeight(e) {
            this._fontWeight !== e && (this._fontWeight = e,
                this.styleID++)
        }
        get letterSpacing() {
            return this._letterSpacing
        }
        set letterSpacing(e) {
            this._letterSpacing !== e && (this._letterSpacing = e,
                this.styleID++)
        }
        get lineHeight() {
            return this._lineHeight
        }
        set lineHeight(e) {
            this._lineHeight !== e && (this._lineHeight = e,
                this.styleID++)
        }
        get leading() {
            return this._leading
        }
        set leading(e) {
            this._leading !== e && (this._leading = e,
                this.styleID++)
        }
        get lineJoin() {
            return this._lineJoin
        }
        set lineJoin(e) {
            this._lineJoin !== e && (this._lineJoin = e,
                this.styleID++)
        }
        get miterLimit() {
            return this._miterLimit
        }
        set miterLimit(e) {
            this._miterLimit !== e && (this._miterLimit = e,
                this.styleID++)
        }
        get padding() {
            return this._padding
        }
        set padding(e) {
            this._padding !== e && (this._padding = e,
                this.styleID++)
        }
        get stroke() {
            return this._stroke
        }
        set stroke(e) {
            const n = M1(e);
            this._stroke !== n && (this._stroke = n,
                this.styleID++)
        }
        get strokeThickness() {
            return this._strokeThickness
        }
        set strokeThickness(e) {
            this._strokeThickness !== e && (this._strokeThickness = e,
                this.styleID++)
        }
        get textBaseline() {
            return this._textBaseline
        }
        set textBaseline(e) {
            this._textBaseline !== e && (this._textBaseline = e,
                this.styleID++)
        }
        get trim() {
            return this._trim
        }
        set trim(e) {
            this._trim !== e && (this._trim = e,
                this.styleID++)
        }
        get whiteSpace() {
            return this._whiteSpace
        }
        set whiteSpace(e) {
            this._whiteSpace !== e && (this._whiteSpace = e,
                this.styleID++)
        }
        get wordWrap() {
            return this._wordWrap
        }
        set wordWrap(e) {
            this._wordWrap !== e && (this._wordWrap = e,
                this.styleID++)
        }
        get wordWrapWidth() {
            return this._wordWrapWidth
        }
        set wordWrapWidth(e) {
            this._wordWrapWidth !== e && (this._wordWrapWidth = e,
                this.styleID++)
        }
        toFontString() {
            const e = typeof this.fontSize == "number" ? `${this.fontSize}px` : this.fontSize;
            let n = this.fontFamily;
            Array.isArray(this.fontFamily) || (n = this.fontFamily.split(","));
            for (let s = n.length - 1; s >= 0; s--) {
                let r = n[s].trim();
                !/([\"\'])[^\'\"]+\1/.test(r) && !gfe.includes(r) && (r = `"${r}"`),
                    n[s] = r
            }
            return `${this.fontStyle} ${this.fontVariant} ${this.fontWeight} ${e} ${n.join(",")}`
        }
    }
    ;
EL.defaultStyle = {
    align: "left",
    breakWords: !1,
    dropShadow: !1,
    dropShadowAlpha: 1,
    dropShadowAngle: Math.PI / 6,
    dropShadowBlur: 0,
    dropShadowColor: "black",
    dropShadowDistance: 5,
    fill: "black",
    fillGradientType: Z_.LINEAR_VERTICAL,
    fillGradientStops: [],
    fontFamily: "Arial",
    fontSize: 26,
    fontStyle: "normal",
    fontVariant: "normal",
    fontWeight: "normal",
    leading: 0,
    letterSpacing: 0,
    lineHeight: 0,
    lineJoin: "miter",
    miterLimit: 10,
    padding: 0,
    stroke: "black",
    strokeThickness: 0,
    textBaseline: "alphabetic",
    trim: !1,
    whiteSpace: "pre",
    wordWrap: !1,
    wordWrapWidth: 100
};
let qa = EL;
function M1(t) {
    const e = Yt.shared
        , n = s => {
            const r = e.setValue(s);
            return r.alpha === 1 ? r.toHex() : r.toRgbaString()
        }
        ;
    return Array.isArray(t) ? t.map(n) : n(t)
}
function _fe(t, e) {
    if (!Array.isArray(t) || !Array.isArray(e) || t.length !== e.length)
        return !1;
    for (let n = 0; n < t.length; ++n)
        if (t[n] !== e[n])
            return !1;
    return !0
}
function P1(t, e, n) {
    for (const s in n)
        Array.isArray(e[s]) ? t[s] = e[s].slice() : t[s] = e[s]
}
const yfe = {
    texture: !0,
    children: !1,
    baseTexture: !0
}
    , TL = class iv extends Tc {
        constructor(e, n, s) {
            let r = !1;
            s || (s = Le.ADAPTER.createCanvas(),
                r = !0),
                s.width = 3,
                s.height = 3;
            const i = $e.from(s);
            i.orig = new nt,
                i.trim = new nt,
                super(i),
                this._ownCanvas = r,
                this.canvas = s,
                this.context = s.getContext("2d", {
                    willReadFrequently: !0
                }),
                this._resolution = iv.defaultResolution ?? Le.RESOLUTION,
                this._autoResolution = iv.defaultAutoResolution,
                this._text = null,
                this._style = null,
                this._styleListener = null,
                this._font = "",
                this.text = e,
                this.style = n,
                this.localStyleID = -1
        }
        static get experimentalLetterSpacing() {
            return wa.experimentalLetterSpacing
        }
        static set experimentalLetterSpacing(e) {
            dt("7.1.0", "Text.experimentalLetterSpacing is deprecated, use TextMetrics.experimentalLetterSpacing"),
                wa.experimentalLetterSpacing = e
        }
        updateText(e) {
            const n = this._style;
            if (this.localStyleID !== n.styleID && (this.dirty = !0,
                this.localStyleID = n.styleID),
                !this.dirty && e)
                return;
            this._font = this._style.toFontString();
            const s = this.context
                , r = wa.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas)
                , i = r.width
                , o = r.height
                , l = r.lines
                , a = r.lineHeight
                , c = r.lineWidths
                , u = r.maxLineWidth
                , h = r.fontProperties;
            this.canvas.width = Math.ceil(Math.ceil(Math.max(1, i) + n.padding * 2) * this._resolution),
                this.canvas.height = Math.ceil(Math.ceil(Math.max(1, o) + n.padding * 2) * this._resolution),
                s.scale(this._resolution, this._resolution),
                s.clearRect(0, 0, this.canvas.width, this.canvas.height),
                s.font = this._font,
                s.lineWidth = n.strokeThickness,
                s.textBaseline = n.textBaseline,
                s.lineJoin = n.lineJoin,
                s.miterLimit = n.miterLimit;
            let d, f;
            const p = n.dropShadow ? 2 : 1;
            for (let m = 0; m < p; ++m) {
                const g = n.dropShadow && m === 0
                    , b = g ? Math.ceil(Math.max(1, o) + n.padding * 2) : 0
                    , v = b * this._resolution;
                if (g) {
                    s.fillStyle = "black",
                        s.strokeStyle = "black";
                    const y = n.dropShadowColor
                        , x = n.dropShadowBlur * this._resolution
                        , w = n.dropShadowDistance * this._resolution;
                    s.shadowColor = Yt.shared.setValue(y).setAlpha(n.dropShadowAlpha).toRgbaString(),
                        s.shadowBlur = x,
                        s.shadowOffsetX = Math.cos(n.dropShadowAngle) * w,
                        s.shadowOffsetY = Math.sin(n.dropShadowAngle) * w + v
                } else
                    s.fillStyle = this._generateFillStyle(n, l, r),
                        s.strokeStyle = n.stroke,
                        s.shadowColor = "black",
                        s.shadowBlur = 0,
                        s.shadowOffsetX = 0,
                        s.shadowOffsetY = 0;
                let _ = (a - h.fontSize) / 2;
                a - h.fontSize < 0 && (_ = 0);
                for (let y = 0; y < l.length; y++)
                    d = n.strokeThickness / 2,
                        f = n.strokeThickness / 2 + y * a + h.ascent + _,
                        n.align === "right" ? d += u - c[y] : n.align === "center" && (d += (u - c[y]) / 2),
                        n.stroke && n.strokeThickness && this.drawLetterSpacing(l[y], d + n.padding, f + n.padding - b, !0),
                        n.fill && this.drawLetterSpacing(l[y], d + n.padding, f + n.padding - b)
            }
            this.updateTexture()
        }
        drawLetterSpacing(e, n, s, r = !1) {
            const i = this._style.letterSpacing;
            let o = !1;
            if (wa.experimentalLetterSpacingSupported && (wa.experimentalLetterSpacing ? (this.context.letterSpacing = `${i}px`,
                this.context.textLetterSpacing = `${i}px`,
                o = !0) : (this.context.letterSpacing = "0px",
                    this.context.textLetterSpacing = "0px")),
                i === 0 || o) {
                r ? this.context.strokeText(e, n, s) : this.context.fillText(e, n, s);
                return
            }
            let l = n;
            const a = wa.graphemeSegmenter(e);
            let c = this.context.measureText(e).width
                , u = 0;
            for (let h = 0; h < a.length; ++h) {
                const d = a[h];
                r ? this.context.strokeText(d, l, s) : this.context.fillText(d, l, s);
                let f = "";
                for (let p = h + 1; p < a.length; ++p)
                    f += a[p];
                u = this.context.measureText(f).width,
                    l += c - u + i,
                    c = u
            }
        }
        updateTexture() {
            const e = this.canvas;
            if (this._style.trim) {
                const o = Dle(e);
                o.data && (e.width = o.width,
                    e.height = o.height,
                    this.context.putImageData(o.data, 0, 0))
            }
            const n = this._texture
                , s = this._style
                , r = s.trim ? 0 : s.padding
                , i = n.baseTexture;
            n.trim.width = n._frame.width = e.width / this._resolution,
                n.trim.height = n._frame.height = e.height / this._resolution,
                n.trim.x = -r,
                n.trim.y = -r,
                n.orig.width = n._frame.width - r * 2,
                n.orig.height = n._frame.height - r * 2,
                this._onTextureUpdate(),
                i.setRealSize(e.width, e.height, this._resolution),
                n.updateUvs(),
                this.dirty = !1
        }
        _render(e) {
            this._autoResolution && this._resolution !== e.resolution && (this._resolution = e.resolution,
                this.dirty = !0),
                this.updateText(!0),
                super._render(e)
        }
        updateTransform() {
            this.updateText(!0),
                super.updateTransform()
        }
        getBounds(e, n) {
            return this.updateText(!0),
                this._textureID === -1 && (e = !1),
                super.getBounds(e, n)
        }
        getLocalBounds(e) {
            return this.updateText(!0),
                super.getLocalBounds.call(this, e)
        }
        _calculateBounds() {
            this.calculateVertices(),
                this._bounds.addQuad(this.vertexData)
        }
        _generateFillStyle(e, n, s) {
            const r = e.fill;
            if (Array.isArray(r)) {
                if (r.length === 1)
                    return r[0]
            } else
                return r;
            let i;
            const o = e.dropShadow ? e.dropShadowDistance : 0
                , l = e.padding || 0
                , a = this.canvas.width / this._resolution - o - l * 2
                , c = this.canvas.height / this._resolution - o - l * 2
                , u = r.slice()
                , h = e.fillGradientStops.slice();
            if (!h.length) {
                const d = u.length + 1;
                for (let f = 1; f < d; ++f)
                    h.push(f / d)
            }
            if (u.unshift(r[0]),
                h.unshift(0),
                u.push(r[r.length - 1]),
                h.push(1),
                e.fillGradientType === Z_.LINEAR_VERTICAL) {
                i = this.context.createLinearGradient(a / 2, l, a / 2, c + l);
                const d = s.fontProperties.fontSize + e.strokeThickness;
                for (let f = 0; f < n.length; f++) {
                    const p = s.lineHeight * (f - 1) + d
                        , m = s.lineHeight * f;
                    let g = m;
                    f > 0 && p > m && (g = (m + p) / 2);
                    const b = m + d
                        , v = s.lineHeight * (f + 1);
                    let _ = b;
                    f + 1 < n.length && v < b && (_ = (b + v) / 2);
                    const y = (_ - g) / c;
                    for (let x = 0; x < u.length; x++) {
                        let w = 0;
                        typeof h[x] == "number" ? w = h[x] : w = x / u.length;
                        let S = Math.min(1, Math.max(0, g / c + w * y));
                        S = Number(S.toFixed(5)),
                            i.addColorStop(S, u[x])
                    }
                }
            } else {
                i = this.context.createLinearGradient(l, c / 2, a + l, c / 2);
                const d = u.length + 1;
                let f = 1;
                for (let p = 0; p < u.length; p++) {
                    let m;
                    typeof h[p] == "number" ? m = h[p] : m = f / d,
                        i.addColorStop(m, u[p]),
                        f++
                }
            }
            return i
        }
        destroy(e) {
            typeof e == "boolean" && (e = {
                children: e
            }),
                e = Object.assign({}, yfe, e),
                super.destroy(e),
                this._ownCanvas && (this.canvas.height = this.canvas.width = 0),
                this.context = null,
                this.canvas = null,
                this._style = null
        }
        get width() {
            return this.updateText(!0),
                Math.abs(this.scale.x) * this._texture.orig.width
        }
        set width(e) {
            this.updateText(!0);
            const n = Ra(this.scale.x) || 1;
            this.scale.x = n * e / this._texture.orig.width,
                this._width = e
        }
        get height() {
            return this.updateText(!0),
                Math.abs(this.scale.y) * this._texture.orig.height
        }
        set height(e) {
            this.updateText(!0);
            const n = Ra(this.scale.y) || 1;
            this.scale.y = n * e / this._texture.orig.height,
                this._height = e
        }
        get style() {
            return this._style
        }
        set style(e) {
            e = e || {},
                e instanceof qa ? this._style = e : this._style = new qa(e),
                this.localStyleID = -1,
                this.dirty = !0
        }
        get text() {
            return this._text
        }
        set text(e) {
            e = String(e ?? ""),
                this._text !== e && (this._text = e,
                    this.dirty = !0)
        }
        get resolution() {
            return this._resolution
        }
        set resolution(e) {
            this._autoResolution = !1,
                this._resolution !== e && (this._resolution = e,
                    this.dirty = !0)
        }
    }
    ;
TL.defaultAutoResolution = !0;
let CL = TL;
class bfe {
    constructor(e) {
        this.maxItemsPerFrame = e,
            this.itemsLeft = 0
    }
    beginFrame() {
        this.itemsLeft = this.maxItemsPerFrame
    }
    allowedToUpload() {
        return this.itemsLeft-- > 0
    }
}
function vfe(t, e) {
    var s;
    let n = !1;
    if ((s = t == null ? void 0 : t._textures) != null && s.length) {
        for (let r = 0; r < t._textures.length; r++)
            if (t._textures[r] instanceof $e) {
                const i = t._textures[r].baseTexture;
                e.includes(i) || (e.push(i),
                    n = !0)
            }
    }
    return n
}
function xfe(t, e) {
    if (t.baseTexture instanceof st) {
        const n = t.baseTexture;
        return e.includes(n) || e.push(n),
            !0
    }
    return !1
}
function wfe(t, e) {
    if (t._texture && t._texture instanceof $e) {
        const n = t._texture.baseTexture;
        return e.includes(n) || e.push(n),
            !0
    }
    return !1
}
function Sfe(t, e) {
    return e instanceof CL ? (e.updateText(!0),
        !0) : !1
}
function Efe(t, e) {
    if (e instanceof qa) {
        const n = e.toFontString();
        return wa.measureFont(n),
            !0
    }
    return !1
}
function Tfe(t, e) {
    if (t instanceof CL) {
        e.includes(t.style) || e.push(t.style),
            e.includes(t) || e.push(t);
        const n = t._texture.baseTexture;
        return e.includes(n) || e.push(n),
            !0
    }
    return !1
}
function Cfe(t, e) {
    return t instanceof qa ? (e.includes(t) || e.push(t),
        !0) : !1
}
const IL = class AL {
    constructor(e) {
        this.limiter = new bfe(AL.uploadsPerFrame),
            this.renderer = e,
            this.uploadHookHelper = null,
            this.queue = [],
            this.addHooks = [],
            this.uploadHooks = [],
            this.completes = [],
            this.ticking = !1,
            this.delayedTick = () => {
                this.queue && this.prepareItems()
            }
            ,
            this.registerFindHook(Tfe),
            this.registerFindHook(Cfe),
            this.registerFindHook(vfe),
            this.registerFindHook(xfe),
            this.registerFindHook(wfe),
            this.registerUploadHook(Sfe),
            this.registerUploadHook(Efe)
    }
    upload(e) {
        return new Promise(n => {
            e && this.add(e),
                this.queue.length ? (this.completes.push(n),
                    this.ticking || (this.ticking = !0,
                        lr.system.addOnce(this.tick, this, cc.UTILITY))) : n()
        }
        )
    }
    tick() {
        setTimeout(this.delayedTick, 0)
    }
    prepareItems() {
        for (this.limiter.beginFrame(); this.queue.length && this.limiter.allowedToUpload();) {
            const e = this.queue[0];
            let n = !1;
            if (e && !e._destroyed) {
                for (let s = 0, r = this.uploadHooks.length; s < r; s++)
                    if (this.uploadHooks[s](this.uploadHookHelper, e)) {
                        this.queue.shift(),
                            n = !0;
                        break
                    }
            }
            n || this.queue.shift()
        }
        if (this.queue.length)
            lr.system.addOnce(this.tick, this, cc.UTILITY);
        else {
            this.ticking = !1;
            const e = this.completes.slice(0);
            this.completes.length = 0;
            for (let n = 0, s = e.length; n < s; n++)
                e[n]()
        }
    }
    registerFindHook(e) {
        return e && this.addHooks.push(e),
            this
    }
    registerUploadHook(e) {
        return e && this.uploadHooks.push(e),
            this
    }
    add(e) {
        for (let n = 0, s = this.addHooks.length; n < s && !this.addHooks[n](e, this.queue); n++)
            ;
        if (e instanceof ks)
            for (let n = e.children.length - 1; n >= 0; n--)
                this.add(e.children[n]);
        return this
    }
    destroy() {
        this.ticking && lr.system.remove(this.tick, this),
            this.ticking = !1,
            this.addHooks = null,
            this.uploadHooks = null,
            this.renderer = null,
            this.completes = null,
            this.queue = null,
            this.limiter = null,
            this.uploadHookHelper = null
    }
}
    ;
IL.uploadsPerFrame = 4;
let ov = IL;
Object.defineProperties(Le, {
    UPLOADS_PER_FRAME: {
        get() {
            return ov.uploadsPerFrame
        },
        set(t) {
            dt("7.1.0", "settings.UPLOADS_PER_FRAME is deprecated, use prepare.BasePrepare.uploadsPerFrame"),
                ov.uploadsPerFrame = t
        }
    }
});
function kL(t, e) {
    return e instanceof st ? (e._glTextures[t.CONTEXT_UID] || t.texture.bind(e),
        !0) : !1
}
function Ife(t, e) {
    if (!(e instanceof hw))
        return !1;
    const { geometry: n } = e;
    e.finishPoly(),
        n.updateBatches();
    const { batches: s } = n;
    for (let r = 0; r < s.length; r++) {
        const { texture: i } = s[r].style;
        i && kL(t, i.baseTexture)
    }
    return n.batchable || t.geometry.bind(n, e._resolveDirectShader(t)),
        !0
}
function Afe(t, e) {
    return t instanceof hw ? (e.push(t),
        !0) : !1
}
class RL extends ov {
    constructor(e) {
        super(e),
            this.uploadHookHelper = this.renderer,
            this.registerFindHook(Afe),
            this.registerUploadHook(kL),
            this.registerUploadHook(Ife)
    }
}
RL.extension = {
    name: "prepare",
    type: Ae.RendererSystem
};
Ue.add(RL);
var kfe = `#version 300 es
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

in vec2 vTextureCoord;

out vec4 fragmentColor;

uniform sampler2D uSampler;
uniform vec4 uColor;
uniform mat3 uMapCoord;
uniform vec4 uClampFrame;
uniform vec2 uClampOffset;

void main(void)
{
    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);
    coord = (uMapCoord * vec3(coord, 1.0)).xy;
    vec2 unclamped = coord;
    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0

    fragmentColor = texSample * uColor;
}
`
    , Rfe = `#version 300 es
#define SHADER_NAME Tiling-Sprite-300

precision lowp float;

in vec2 aVertexPosition;
in vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTransform;

out vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;
}
`
    , Mfe = `#version 100
#ifdef GL_EXT_shader_texture_lod
    #extension GL_EXT_shader_texture_lod : enable
#endif
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform vec4 uColor;
uniform mat3 uMapCoord;
uniform vec4 uClampFrame;
uniform vec2 uClampOffset;

void main(void)
{
    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);
    coord = (uMapCoord * vec3(coord, 1.0)).xy;
    vec2 unclamped = coord;
    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

    #ifdef GL_EXT_shader_texture_lod
        vec4 texSample = unclamped == coord
            ? texture2D(uSampler, coord) 
            : texture2DLodEXT(uSampler, coord, 0);
    #else
        vec4 texSample = texture2D(uSampler, coord);
    #endif

    gl_FragColor = texSample * uColor;
}
`
    , MA = `#version 100
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTransform;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;
}
`
    , Pfe = `#version 100
#define SHADER_NAME Tiling-Sprite-Simple-100

precision lowp float;

varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform vec4 uColor;

void main(void)
{
    vec4 texSample = texture2D(uSampler, vTextureCoord);
    gl_FragColor = texSample * uColor;
}
`;
const Ep = new Bt;
class ML extends O_ {
    constructor(e) {
        super(e),
            e.runners.contextChange.add(this),
            this.quad = new O6,
            this.state = Ji.for2d()
    }
    contextChange() {
        const e = this.renderer
            , n = {
                globals: e.globalUniforms
            };
        this.simpleShader = Hi.from(MA, Pfe, n),
            this.shader = e.context.webGLVersion > 1 ? Hi.from(Rfe, kfe, n) : Hi.from(MA, Mfe, n)
    }
    render(e) {
        const n = this.renderer
            , s = this.quad;
        let r = s.vertices;
        r[0] = r[6] = e._width * -e.anchor.x,
            r[1] = r[3] = e._height * -e.anchor.y,
            r[2] = r[4] = e._width * (1 - e.anchor.x),
            r[5] = r[7] = e._height * (1 - e.anchor.y);
        const i = e.uvRespectAnchor ? e.anchor.x : 0
            , o = e.uvRespectAnchor ? e.anchor.y : 0;
        r = s.uvs,
            r[0] = r[6] = -i,
            r[1] = r[3] = -o,
            r[2] = r[4] = 1 - i,
            r[5] = r[7] = 1 - o,
            s.invalidate();
        const l = e._texture
            , a = l.baseTexture
            , c = a.alphaMode > 0
            , u = e.tileTransform.localTransform
            , h = e.uvMatrix;
        let d = a.isPowerOfTwo && l.frame.width === a.width && l.frame.height === a.height;
        d && (a._glTextures[n.CONTEXT_UID] ? d = a.wrapMode !== Ua.CLAMP : a.wrapMode === Ua.CLAMP && (a.wrapMode = Ua.REPEAT));
        const f = d ? this.simpleShader : this.shader
            , p = l.width
            , m = l.height
            , g = e._width
            , b = e._height;
        Ep.set(u.a * p / g, u.b * p / b, u.c * m / g, u.d * m / b, u.tx / g, u.ty / b),
            Ep.invert(),
            d ? Ep.prepend(h.mapCoord) : (f.uniforms.uMapCoord = h.mapCoord.toArray(!0),
                f.uniforms.uClampFrame = h.uClampFrame,
                f.uniforms.uClampOffset = h.uClampOffset),
            f.uniforms.uTransform = Ep.toArray(!0),
            f.uniforms.uColor = Yt.shared.setValue(e.tint).premultiply(e.worldAlpha, c).toArray(f.uniforms.uColor),
            f.uniforms.translationMatrix = e.transform.worldTransform.toArray(!0),
            f.uniforms.uSampler = l,
            n.shader.bind(f),
            n.geometry.bind(s),
            this.state.blendMode = x6(e.blendMode, c),
            n.state.set(this.state),
            n.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0)
    }
}
ML.extension = {
    name: "tilingSprite",
    type: Ae.RendererPlugin
};
Ue.add(ML);
const PL = class Hh {
    constructor(e, n, s) {
        this.linkedSheets = [],
            (e instanceof st || e instanceof $e) && (e = {
                texture: e,
                data: n,
                resolutionFilename: s
            });
        const { texture: r, data: i, resolutionFilename: o = null, cachePrefix: l = "" } = e;
        this.cachePrefix = l,
            this._texture = r instanceof $e ? r : null,
            this.baseTexture = r instanceof st ? r : this._texture.baseTexture,
            this.textures = {},
            this.animations = {},
            this.data = i;
        const a = this.baseTexture.resource;
        this.resolution = this._updateResolution(o || (a ? a.url : null)),
            this._frames = this.data.frames,
            this._frameKeys = Object.keys(this._frames),
            this._batchIndex = 0,
            this._callback = null
    }
    _updateResolution(e = null) {
        const { scale: n } = this.data.meta;
        let s = Vo(e, null);
        return s === null && (s = typeof n == "number" ? n : parseFloat(n ?? "1")),
            s !== 1 && this.baseTexture.setResolution(s),
            s
    }
    parse() {
        return new Promise(e => {
            this._callback = e,
                this._batchIndex = 0,
                this._frameKeys.length <= Hh.BATCH_SIZE ? (this._processFrames(0),
                    this._processAnimations(),
                    this._parseComplete()) : this._nextBatch()
        }
        )
    }
    _processFrames(e) {
        let n = e;
        const s = Hh.BATCH_SIZE;
        for (; n - e < s && n < this._frameKeys.length;) {
            const r = this._frameKeys[n]
                , i = this._frames[r]
                , o = i.frame;
            if (o) {
                let l = null
                    , a = null;
                const c = i.trimmed !== !1 && i.sourceSize ? i.sourceSize : i.frame
                    , u = new nt(0, 0, Math.floor(c.w) / this.resolution, Math.floor(c.h) / this.resolution);
                i.rotated ? l = new nt(Math.floor(o.x) / this.resolution, Math.floor(o.y) / this.resolution, Math.floor(o.h) / this.resolution, Math.floor(o.w) / this.resolution) : l = new nt(Math.floor(o.x) / this.resolution, Math.floor(o.y) / this.resolution, Math.floor(o.w) / this.resolution, Math.floor(o.h) / this.resolution),
                    i.trimmed !== !1 && i.spriteSourceSize && (a = new nt(Math.floor(i.spriteSourceSize.x) / this.resolution, Math.floor(i.spriteSourceSize.y) / this.resolution, Math.floor(o.w) / this.resolution, Math.floor(o.h) / this.resolution)),
                    this.textures[r] = new $e(this.baseTexture, l, u, a, i.rotated ? 2 : 0, i.anchor, i.borders),
                    $e.addToCache(this.textures[r], this.cachePrefix + r.toString())
            }
            n++
        }
    }
    _processAnimations() {
        const e = this.data.animations || {};
        for (const n in e) {
            this.animations[n] = [];
            for (let s = 0; s < e[n].length; s++) {
                const r = e[n][s];
                this.animations[n].push(this.textures[r])
            }
        }
    }
    _parseComplete() {
        const e = this._callback;
        this._callback = null,
            this._batchIndex = 0,
            e.call(this, this.textures)
    }
    _nextBatch() {
        this._processFrames(this._batchIndex * Hh.BATCH_SIZE),
            this._batchIndex++,
            setTimeout(() => {
                this._batchIndex * Hh.BATCH_SIZE < this._frameKeys.length ? this._nextBatch() : (this._processAnimations(),
                    this._parseComplete())
            }
                , 0)
    }
    destroy(e = !1) {
        var n;
        for (const s in this.textures)
            this.textures[s].destroy();
        this._frames = null,
            this._frameKeys = null,
            this.data = null,
            this.textures = null,
            e && ((n = this._texture) == null || n.destroy(),
                this.baseTexture.destroy()),
            this._texture = null,
            this.baseTexture = null,
            this.linkedSheets = []
    }
}
    ;
PL.BATCH_SIZE = 1e3;
let PA = PL;
const Lfe = ["jpg", "png", "jpeg", "avif", "webp", "s3tc", "s3tc_sRGB", "etc", "etc1", "pvrtc", "atc", "astc", "bptc"];
function LL(t, e, n) {
    const s = {};
    if (t.forEach(r => {
        s[r] = e
    }
    ),
        Object.keys(e.textures).forEach(r => {
            s[`${e.cachePrefix}${r}`] = e.textures[r]
        }
        ),
        !n) {
        const r = zt.dirname(t[0]);
        e.linkedSheets.forEach((i, o) => {
            Object.assign(s, LL([`${r}/${e.data.meta.related_multi_packs[o]}`], i, !0))
        }
        )
    }
    return s
}
const Ofe = {
    extension: Ae.Asset,
    cache: {
        test: t => t instanceof PA,
        getCacheableAssets: (t, e) => LL(t, e, !1)
    },
    resolver: {
        test: t => {
            const e = t.split("?")[0].split(".")
                , n = e.pop()
                , s = e.pop();
            return n === "json" && Lfe.includes(s)
        }
        ,
        parse: t => {
            var n;
            const e = t.split(".");
            return {
                resolution: parseFloat(((n = Le.RETINA_PREFIX.exec(t)) == null ? void 0 : n[1]) ?? "1"),
                format: e[e.length - 2],
                src: t
            }
        }
    },
    loader: {
        name: "spritesheetLoader",
        extension: {
            type: Ae.LoadParser,
            priority: _r.Normal
        },
        async testParse(t, e) {
            return zt.extname(e.src).toLowerCase() === ".json" && !!t.frames
        },
        async parse(t, e, n) {
            var u, h;
            const { texture: s, imageFilename: r, cachePrefix: i } = (e == null ? void 0 : e.data) ?? {};
            let o = zt.dirname(e.src);
            o && o.lastIndexOf("/") !== o.length - 1 && (o += "/");
            let l;
            if (s && s.baseTexture)
                l = s;
            else {
                const d = Ub(o + (r ?? t.meta.image), e.src);
                l = (await n.load([d]))[d]
            }
            const a = new PA({
                texture: l.baseTexture,
                data: t,
                resolutionFilename: e.src,
                cachePrefix: i
            });
            await a.parse();
            const c = (u = t == null ? void 0 : t.meta) == null ? void 0 : u.related_multi_packs;
            if (Array.isArray(c)) {
                const d = [];
                for (const p of c) {
                    if (typeof p != "string")
                        continue;
                    let m = o + p;
                    (h = e.data) != null && h.ignoreMultiPack || (m = Ub(m, e.src),
                        d.push(n.load({
                            src: m,
                            data: {
                                ignoreMultiPack: !0
                            }
                        })))
                }
                const f = await Promise.all(d);
                a.linkedSheets = f,
                    f.forEach(p => {
                        p.linkedSheets = [a].concat(a.linkedSheets.filter(m => m !== p))
                    }
                    )
            }
            return a
        },
        unload(t) {
            t.destroy(!0)
        }
    }
};
Ue.add(Ofe);
class hg {
    constructor() {
        this.info = [],
            this.common = [],
            this.page = [],
            this.char = [],
            this.kerning = [],
            this.distanceField = []
    }
}
class sm {
    static test(e) {
        return typeof e == "string" && e.startsWith("info face=")
    }
    static parse(e) {
        const n = e.match(/^[a-z]+\s+.+$/gm)
            , s = {
                info: [],
                common: [],
                page: [],
                char: [],
                chars: [],
                kerning: [],
                kernings: [],
                distanceField: []
            };
        for (const i in n) {
            const o = n[i].match(/^[a-z]+/gm)[0]
                , l = n[i].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm)
                , a = {};
            for (const c in l) {
                const u = l[c].split("=")
                    , h = u[0]
                    , d = u[1].replace(/"/gm, "")
                    , f = parseFloat(d)
                    , p = isNaN(f) ? d : f;
                a[h] = p
            }
            s[o].push(a)
        }
        const r = new hg;
        return s.info.forEach(i => r.info.push({
            face: i.face,
            size: parseInt(i.size, 10)
        })),
            s.common.forEach(i => r.common.push({
                lineHeight: parseInt(i.lineHeight, 10)
            })),
            s.page.forEach(i => r.page.push({
                id: parseInt(i.id, 10),
                file: i.file
            })),
            s.char.forEach(i => r.char.push({
                id: parseInt(i.id, 10),
                page: parseInt(i.page, 10),
                x: parseInt(i.x, 10),
                y: parseInt(i.y, 10),
                width: parseInt(i.width, 10),
                height: parseInt(i.height, 10),
                xoffset: parseInt(i.xoffset, 10),
                yoffset: parseInt(i.yoffset, 10),
                xadvance: parseInt(i.xadvance, 10)
            })),
            s.kerning.forEach(i => r.kerning.push({
                first: parseInt(i.first, 10),
                second: parseInt(i.second, 10),
                amount: parseInt(i.amount, 10)
            })),
            s.distanceField.forEach(i => r.distanceField.push({
                distanceRange: parseInt(i.distanceRange, 10),
                fieldType: i.fieldType
            })),
            r
    }
}
class av {
    static test(e) {
        const n = e;
        return typeof e != "string" && "getElementsByTagName" in e && n.getElementsByTagName("page").length && n.getElementsByTagName("info")[0].getAttribute("face") !== null
    }
    static parse(e) {
        const n = new hg
            , s = e.getElementsByTagName("info")
            , r = e.getElementsByTagName("common")
            , i = e.getElementsByTagName("page")
            , o = e.getElementsByTagName("char")
            , l = e.getElementsByTagName("kerning")
            , a = e.getElementsByTagName("distanceField");
        for (let c = 0; c < s.length; c++)
            n.info.push({
                face: s[c].getAttribute("face"),
                size: parseInt(s[c].getAttribute("size"), 10)
            });
        for (let c = 0; c < r.length; c++)
            n.common.push({
                lineHeight: parseInt(r[c].getAttribute("lineHeight"), 10)
            });
        for (let c = 0; c < i.length; c++)
            n.page.push({
                id: parseInt(i[c].getAttribute("id"), 10) || 0,
                file: i[c].getAttribute("file")
            });
        for (let c = 0; c < o.length; c++) {
            const u = o[c];
            n.char.push({
                id: parseInt(u.getAttribute("id"), 10),
                page: parseInt(u.getAttribute("page"), 10) || 0,
                x: parseInt(u.getAttribute("x"), 10),
                y: parseInt(u.getAttribute("y"), 10),
                width: parseInt(u.getAttribute("width"), 10),
                height: parseInt(u.getAttribute("height"), 10),
                xoffset: parseInt(u.getAttribute("xoffset"), 10),
                yoffset: parseInt(u.getAttribute("yoffset"), 10),
                xadvance: parseInt(u.getAttribute("xadvance"), 10)
            })
        }
        for (let c = 0; c < l.length; c++)
            n.kerning.push({
                first: parseInt(l[c].getAttribute("first"), 10),
                second: parseInt(l[c].getAttribute("second"), 10),
                amount: parseInt(l[c].getAttribute("amount"), 10)
            });
        for (let c = 0; c < a.length; c++)
            n.distanceField.push({
                fieldType: a[c].getAttribute("fieldType"),
                distanceRange: parseInt(a[c].getAttribute("distanceRange"), 10)
            });
        return n
    }
}
class lv {
    static test(e) {
        return typeof e == "string" && e.includes("<font>") ? av.test(Le.ADAPTER.parseXML(e)) : !1
    }
    static parse(e) {
        return av.parse(Le.ADAPTER.parseXML(e))
    }
}
const L1 = [sm, av, lv];
function Nfe(t) {
    for (let e = 0; e < L1.length; e++)
        if (L1[e].test(t))
            return L1[e];
    return null
}
function Dfe(t, e, n, s, r, i) {
    const o = n.fill;
    if (Array.isArray(o)) {
        if (o.length === 1)
            return o[0]
    } else
        return o;
    let l;
    const a = n.dropShadow ? n.dropShadowDistance : 0
        , c = n.padding || 0
        , u = t.width / s - a - c * 2
        , h = t.height / s - a - c * 2
        , d = o.slice()
        , f = n.fillGradientStops.slice();
    if (!f.length) {
        const p = d.length + 1;
        for (let m = 1; m < p; ++m)
            f.push(m / p)
    }
    if (d.unshift(o[0]),
        f.unshift(0),
        d.push(o[o.length - 1]),
        f.push(1),
        n.fillGradientType === Z_.LINEAR_VERTICAL) {
        l = e.createLinearGradient(u / 2, c, u / 2, h + c);
        let p = 0;
        const m = (i.fontProperties.fontSize + n.strokeThickness) / h;
        for (let g = 0; g < r.length; g++) {
            const b = i.lineHeight * g;
            for (let v = 0; v < d.length; v++) {
                let _ = 0;
                typeof f[v] == "number" ? _ = f[v] : _ = v / d.length;
                const y = b / h + _ * m;
                let x = Math.max(p, y);
                x = Math.min(x, 1),
                    l.addColorStop(x, d[v]),
                    p = x
            }
        }
    } else {
        l = e.createLinearGradient(c, h / 2, u + c, h / 2);
        const p = d.length + 1;
        let m = 1;
        for (let g = 0; g < d.length; g++) {
            let b;
            typeof f[g] == "number" ? b = f[g] : b = m / p,
                l.addColorStop(b, d[g]),
                m++
        }
    }
    return l
}
function Bfe(t, e, n, s, r, i, o) {
    const l = n.text
        , a = n.fontProperties;
    e.translate(s, r),
        e.scale(i, i);
    const c = o.strokeThickness / 2
        , u = -(o.strokeThickness / 2);
    if (e.font = o.toFontString(),
        e.lineWidth = o.strokeThickness,
        e.textBaseline = o.textBaseline,
        e.lineJoin = o.lineJoin,
        e.miterLimit = o.miterLimit,
        e.fillStyle = Dfe(t, e, o, i, [l], n),
        e.strokeStyle = o.stroke,
        o.dropShadow) {
        const h = o.dropShadowColor
            , d = o.dropShadowBlur * i
            , f = o.dropShadowDistance * i;
        e.shadowColor = Yt.shared.setValue(h).setAlpha(o.dropShadowAlpha).toRgbaString(),
            e.shadowBlur = d,
            e.shadowOffsetX = Math.cos(o.dropShadowAngle) * f,
            e.shadowOffsetY = Math.sin(o.dropShadowAngle) * f
    } else
        e.shadowColor = "black",
            e.shadowBlur = 0,
            e.shadowOffsetX = 0,
            e.shadowOffsetY = 0;
    o.stroke && o.strokeThickness && e.strokeText(l, c, u + n.lineHeight - a.descent),
        o.fill && e.fillText(l, c, u + n.lineHeight - a.descent),
        e.setTransform(1, 0, 0, 1, 0, 0),
        e.fillStyle = "rgba(0, 0, 0, 0)"
}
function rm(t) {
    return t.codePointAt ? t.codePointAt(0) : t.charCodeAt(0)
}
function OL(t) {
    return Array.from ? Array.from(t) : t.split("")
}
function Ffe(t) {
    typeof t == "string" && (t = [t]);
    const e = [];
    for (let n = 0, s = t.length; n < s; n++) {
        const r = t[n];
        if (Array.isArray(r)) {
            if (r.length !== 2)
                throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${r.length}.`);
            const i = r[0].charCodeAt(0)
                , o = r[1].charCodeAt(0);
            if (o < i)
                throw new Error("[BitmapFont]: Invalid character range.");
            for (let l = i, a = o; l <= a; l++)
                e.push(String.fromCharCode(l))
        } else
            e.push(...OL(r))
    }
    if (e.length === 0)
        throw new Error("[BitmapFont]: Empty set when resolving characters.");
    return e
}
const ua = class ki {
    constructor(e, n, s) {
        var u;
        const [r] = e.info
            , [i] = e.common
            , [o] = e.page
            , [l] = e.distanceField
            , a = Vo(o.file)
            , c = {};
        this._ownsTextures = s,
            this.font = r.face,
            this.size = r.size,
            this.lineHeight = i.lineHeight / a,
            this.chars = {},
            this.pageTextures = c;
        for (let h = 0; h < e.page.length; h++) {
            const { id: d, file: f } = e.page[h];
            c[d] = n instanceof Array ? n[h] : n[f],
                l != null && l.fieldType && l.fieldType !== "none" && (c[d].baseTexture.alphaMode = Is.NO_PREMULTIPLIED_ALPHA,
                    c[d].baseTexture.mipmap = ci.OFF)
        }
        for (let h = 0; h < e.char.length; h++) {
            const { id: d, page: f } = e.char[h];
            let { x: p, y: m, width: g, height: b, xoffset: v, yoffset: _, xadvance: y } = e.char[h];
            p /= a,
                m /= a,
                g /= a,
                b /= a,
                v /= a,
                _ /= a,
                y /= a;
            const x = new nt(p + c[f].frame.x / a, m + c[f].frame.y / a, g, b);
            this.chars[d] = {
                xOffset: v,
                yOffset: _,
                xAdvance: y,
                kerning: {},
                texture: new $e(c[f].baseTexture, x),
                page: f
            }
        }
        for (let h = 0; h < e.kerning.length; h++) {
            let { first: d, second: f, amount: p } = e.kerning[h];
            d /= a,
                f /= a,
                p /= a,
                this.chars[f] && (this.chars[f].kerning[d] = p)
        }
        this.distanceFieldRange = l == null ? void 0 : l.distanceRange,
            this.distanceFieldType = ((u = l == null ? void 0 : l.fieldType) == null ? void 0 : u.toLowerCase()) ?? "none"
    }
    destroy() {
        for (const e in this.chars)
            this.chars[e].texture.destroy(),
                this.chars[e].texture = null;
        for (const e in this.pageTextures)
            this._ownsTextures && this.pageTextures[e].destroy(!0),
                this.pageTextures[e] = null;
        this.chars = null,
            this.pageTextures = null
    }
    static install(e, n, s) {
        let r;
        if (e instanceof hg)
            r = e;
        else {
            const o = Nfe(e);
            if (!o)
                throw new Error("Unrecognized data format for font.");
            r = o.parse(e)
        }
        n instanceof $e && (n = [n]);
        const i = new ki(r, n, s);
        return ki.available[i.font] = i,
            i
    }
    static uninstall(e) {
        const n = ki.available[e];
        if (!n)
            throw new Error(`No font found named '${e}'`);
        n.destroy(),
            delete ki.available[e]
    }
    static from(e, n, s) {
        if (!e)
            throw new Error("[BitmapFont] Property `name` is required.");
        const { chars: r, padding: i, resolution: o, textureWidth: l, textureHeight: a, ...c } = Object.assign({}, ki.defaultOptions, s)
            , u = Ffe(r)
            , h = n instanceof qa ? n : new qa(n)
            , d = l
            , f = new hg;
        f.info[0] = {
            face: h.fontFamily,
            size: h.fontSize
        },
            f.common[0] = {
                lineHeight: h.fontSize
            };
        let p = 0, m = 0, g, b, v, _ = 0;
        const y = [];
        for (let w = 0; w < u.length; w++) {
            g || (g = Le.ADAPTER.createCanvas(),
                g.width = l,
                g.height = a,
                b = g.getContext("2d"),
                v = new st(g, {
                    resolution: o,
                    ...c
                }),
                y.push(new $e(v)),
                f.page.push({
                    id: y.length - 1,
                    file: ""
                }));
            const S = u[w]
                , E = wa.measureText(S, h, !1, g)
                , C = E.width
                , I = Math.ceil(E.height)
                , L = Math.ceil((h.fontStyle === "italic" ? 2 : 1) * C);
            if (m >= a - I * o) {
                if (m === 0)
                    throw new Error(`[BitmapFont] textureHeight ${a}px is too small (fontFamily: '${h.fontFamily}', fontSize: ${h.fontSize}px, char: '${S}')`);
                --w,
                    g = null,
                    b = null,
                    v = null,
                    m = 0,
                    p = 0,
                    _ = 0;
                continue
            }
            if (_ = Math.max(I + E.fontProperties.descent, _),
                L * o + p >= d) {
                if (p === 0)
                    throw new Error(`[BitmapFont] textureWidth ${l}px is too small (fontFamily: '${h.fontFamily}', fontSize: ${h.fontSize}px, char: '${S}')`);
                --w,
                    m += _ * o,
                    m = Math.ceil(m),
                    p = 0,
                    _ = 0;
                continue
            }
            Bfe(g, b, E, p, m, o, h);
            const k = rm(E.text);
            f.char.push({
                id: k,
                page: y.length - 1,
                x: p / o,
                y: m / o,
                width: L,
                height: I,
                xoffset: 0,
                yoffset: 0,
                xadvance: C - (h.dropShadow ? h.dropShadowDistance : 0) - (h.stroke ? h.strokeThickness : 0)
            }),
                p += (L + 2 * i) * o,
                p = Math.ceil(p)
        }
        if (!(s != null && s.skipKerning))
            for (let w = 0, S = u.length; w < S; w++) {
                const E = u[w];
                for (let C = 0; C < S; C++) {
                    const I = u[C]
                        , L = b.measureText(E).width
                        , k = b.measureText(I).width
                        , R = b.measureText(E + I).width - (L + k);
                    R && f.kerning.push({
                        first: rm(E),
                        second: rm(I),
                        amount: R
                    })
                }
            }
        const x = new ki(f, y, !0);
        return ki.available[e] !== void 0 && ki.uninstall(e),
            ki.available[e] = x,
            x
    }
}
    ;
ua.ALPHA = [["a", "z"], ["A", "Z"], " "],
    ua.NUMERIC = [["0", "9"]],
    ua.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "],
    ua.ASCII = [[" ", "~"]],
    ua.defaultOptions = {
        resolution: 1,
        textureWidth: 512,
        textureHeight: 512,
        padding: 4,
        chars: ua.ALPHANUMERIC
    },
    ua.available = {};
let ha = ua;
var $fe = `// Pixi texture info\r
varying vec2 vTextureCoord;\r
uniform sampler2D uSampler;\r
\r
// Tint\r
uniform vec4 uColor;\r
\r
// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r
uniform float uFWidth;\r
\r
void main(void) {\r
\r
  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r
  vec4 texColor = texture2D(uSampler, vTextureCoord);\r
\r
  // MSDF\r
  float median = texColor.r + texColor.g + texColor.b -\r
                  min(texColor.r, min(texColor.g, texColor.b)) -\r
                  max(texColor.r, max(texColor.g, texColor.b));\r
  // SDF\r
  median = min(median, texColor.a);\r
\r
  float screenPxDistance = uFWidth * (median - 0.5);\r
  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r
  if (median < 0.01) {\r
    alpha = 0.0;\r
  } else if (median > 0.99) {\r
    alpha = 1.0;\r
  }\r
\r
  // Gamma correction for coverage-like alpha\r
  float luma = dot(uColor.rgb, vec3(0.299, 0.587, 0.114));\r
  float gamma = mix(1.0, 1.0 / 2.2, luma);\r
  float coverage = pow(uColor.a * alpha, gamma);  \r
\r
  // NPM Textures, NPM outputs\r
  gl_FragColor = vec4(uColor.rgb, coverage);\r
}\r
`
    , Ufe = `// Mesh material default fragment\r
attribute vec2 aVertexPosition;\r
attribute vec2 aTextureCoord;\r
\r
uniform mat3 projectionMatrix;\r
uniform mat3 translationMatrix;\r
uniform mat3 uTextureMatrix;\r
\r
varying vec2 vTextureCoord;\r
\r
void main(void)\r
{\r
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r
\r
    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r
}\r
`;
const LA = []
    , OA = []
    , NA = []
    , Vfe = class NL extends ks {
        constructor(e, n = {}) {
            super();
            const { align: s, tint: r, maxWidth: i, letterSpacing: o, fontName: l, fontSize: a } = Object.assign({}, NL.styleDefaults, n);
            if (!ha.available[l])
                throw new Error(`Missing BitmapFont "${l}"`);
            this._activePagesMeshData = [],
                this._textWidth = 0,
                this._textHeight = 0,
                this._align = s,
                this._tintColor = new Yt(r),
                this._font = void 0,
                this._fontName = l,
                this._fontSize = a,
                this.text = e,
                this._maxWidth = i,
                this._maxLineHeight = 0,
                this._letterSpacing = o,
                this._anchor = new wo(() => {
                    this.dirty = !0
                }
                    , this, 0, 0),
                this._roundPixels = Le.ROUND_PIXELS,
                this.dirty = !0,
                this._resolution = Le.RESOLUTION,
                this._autoResolution = !0,
                this._textureCache = {}
        }
        updateText() {
            var L;
            const e = ha.available[this._fontName]
                , n = this.fontSize
                , s = n / e.size
                , r = new At
                , i = []
                , o = []
                , l = []
                , a = this._text.replace(/(?:\r\n|\r)/g, `
`) || " "
                , c = OL(a)
                , u = this._maxWidth * e.size / n
                , h = e.distanceFieldType === "none" ? LA : OA;
            let d = null
                , f = 0
                , p = 0
                , m = 0
                , g = -1
                , b = 0
                , v = 0
                , _ = 0
                , y = 0;
            for (let k = 0; k < c.length; k++) {
                const R = c[k]
                    , U = rm(R);
                if (/(?:\s)/.test(R) && (g = k,
                    b = f,
                    y++),
                    R === "\r" || R === `
`) {
                    o.push(f),
                        l.push(-1),
                        p = Math.max(p, f),
                        ++m,
                        ++v,
                        r.x = 0,
                        r.y += e.lineHeight,
                        d = null,
                        y = 0;
                    continue
                }
                const W = e.chars[U];
                if (!W)
                    continue;
                d && W.kerning[d] && (r.x += W.kerning[d]);
                const H = NA.pop() || {
                    texture: $e.EMPTY,
                    line: 0,
                    charCode: 0,
                    prevSpaces: 0,
                    position: new At
                };
                H.texture = W.texture,
                    H.line = m,
                    H.charCode = U,
                    H.position.x = Math.round(r.x + W.xOffset + this._letterSpacing / 2),
                    H.position.y = Math.round(r.y + W.yOffset),
                    H.prevSpaces = y,
                    i.push(H),
                    f = H.position.x + Math.max(W.xAdvance - W.xOffset, W.texture.orig.width),
                    r.x += W.xAdvance + this._letterSpacing,
                    _ = Math.max(_, W.yOffset + W.texture.height),
                    d = U,
                    g !== -1 && u > 0 && r.x > u && (++v,
                        wu(i, 1 + g - v, 1 + k - g),
                        k = g,
                        g = -1,
                        o.push(b),
                        l.push(i.length > 0 ? i[i.length - 1].prevSpaces : 0),
                        p = Math.max(p, b),
                        m++,
                        r.x = 0,
                        r.y += e.lineHeight,
                        d = null,
                        y = 0)
            }
            const x = c[c.length - 1];
            x !== "\r" && x !== `
` && (/(?:\s)/.test(x) && (f = b),
                    o.push(f),
                    p = Math.max(p, f),
                    l.push(-1));
            const w = [];
            for (let k = 0; k <= m; k++) {
                let R = 0;
                this._align === "right" ? R = p - o[k] : this._align === "center" ? R = (p - o[k]) / 2 : this._align === "justify" && (R = l[k] < 0 ? 0 : (p - o[k]) / l[k]),
                    w.push(R)
            }
            const S = i.length
                , E = {}
                , C = []
                , I = this._activePagesMeshData;
            h.push(...I);
            for (let k = 0; k < S; k++) {
                const R = i[k].texture
                    , U = R.baseTexture.uid;
                if (!E[U]) {
                    let W = h.pop();
                    if (!W) {
                        const j = new p5;
                        let z, ee;
                        e.distanceFieldType === "none" ? (z = new Fb($e.EMPTY),
                            ee = Oe.NORMAL) : (z = new Fb($e.EMPTY, {
                                program: So.from(Ufe, $fe),
                                uniforms: {
                                    uFWidth: 0
                                }
                            }),
                                ee = Oe.NORMAL_NPM);
                        const J = new Bb(j, z);
                        J.blendMode = ee,
                            W = {
                                index: 0,
                                indexCount: 0,
                                vertexCount: 0,
                                uvsCount: 0,
                                total: 0,
                                mesh: J,
                                vertices: null,
                                uvs: null,
                                indices: null
                            }
                    }
                    W.index = 0,
                        W.indexCount = 0,
                        W.vertexCount = 0,
                        W.uvsCount = 0,
                        W.total = 0;
                    const { _textureCache: H } = this;
                    H[U] = H[U] || new $e(R.baseTexture),
                        W.mesh.texture = H[U],
                        W.mesh.tint = this._tintColor.value,
                        C.push(W),
                        E[U] = W
                }
                E[U].total++
            }
            for (let k = 0; k < I.length; k++)
                C.includes(I[k]) || this.removeChild(I[k].mesh);
            for (let k = 0; k < C.length; k++)
                C[k].mesh.parent !== this && this.addChild(C[k].mesh);
            this._activePagesMeshData = C;
            for (const k in E) {
                const R = E[k]
                    , U = R.total;
                if (!(((L = R.indices) == null ? void 0 : L.length) > 6 * U) || R.vertices.length < Bb.BATCHABLE_SIZE * 2)
                    R.vertices = new Float32Array(4 * 2 * U),
                        R.uvs = new Float32Array(4 * 2 * U),
                        R.indices = new Uint16Array(6 * U);
                else {
                    const W = R.total
                        , H = R.vertices;
                    for (let j = W * 4 * 2; j < H.length; j++)
                        H[j] = 0
                }
                R.mesh.size = 6 * U
            }
            for (let k = 0; k < S; k++) {
                const R = i[k];
                let U = R.position.x + w[R.line] * (this._align === "justify" ? R.prevSpaces : 1);
                this._roundPixels && (U = Math.round(U));
                const W = U * s
                    , H = R.position.y * s
                    , j = R.texture
                    , z = E[j.baseTexture.uid]
                    , ee = j.frame
                    , J = j._uvs
                    , Y = z.index++;
                z.indices[Y * 6 + 0] = 0 + Y * 4,
                    z.indices[Y * 6 + 1] = 1 + Y * 4,
                    z.indices[Y * 6 + 2] = 2 + Y * 4,
                    z.indices[Y * 6 + 3] = 0 + Y * 4,
                    z.indices[Y * 6 + 4] = 2 + Y * 4,
                    z.indices[Y * 6 + 5] = 3 + Y * 4,
                    z.vertices[Y * 8 + 0] = W,
                    z.vertices[Y * 8 + 1] = H,
                    z.vertices[Y * 8 + 2] = W + ee.width * s,
                    z.vertices[Y * 8 + 3] = H,
                    z.vertices[Y * 8 + 4] = W + ee.width * s,
                    z.vertices[Y * 8 + 5] = H + ee.height * s,
                    z.vertices[Y * 8 + 6] = W,
                    z.vertices[Y * 8 + 7] = H + ee.height * s,
                    z.uvs[Y * 8 + 0] = J.x0,
                    z.uvs[Y * 8 + 1] = J.y0,
                    z.uvs[Y * 8 + 2] = J.x1,
                    z.uvs[Y * 8 + 3] = J.y1,
                    z.uvs[Y * 8 + 4] = J.x2,
                    z.uvs[Y * 8 + 5] = J.y2,
                    z.uvs[Y * 8 + 6] = J.x3,
                    z.uvs[Y * 8 + 7] = J.y3
            }
            this._textWidth = p * s,
                this._textHeight = (r.y + e.lineHeight) * s;
            for (const k in E) {
                const R = E[k];
                if (this.anchor.x !== 0 || this.anchor.y !== 0) {
                    let j = 0;
                    const z = this._textWidth * this.anchor.x
                        , ee = this._textHeight * this.anchor.y;
                    for (let J = 0; J < R.total; J++)
                        R.vertices[j++] -= z,
                            R.vertices[j++] -= ee,
                            R.vertices[j++] -= z,
                            R.vertices[j++] -= ee,
                            R.vertices[j++] -= z,
                            R.vertices[j++] -= ee,
                            R.vertices[j++] -= z,
                            R.vertices[j++] -= ee
                }
                this._maxLineHeight = _ * s;
                const U = R.mesh.geometry.getBuffer("aVertexPosition")
                    , W = R.mesh.geometry.getBuffer("aTextureCoord")
                    , H = R.mesh.geometry.getIndex();
                U.data = R.vertices,
                    W.data = R.uvs,
                    H.data = R.indices,
                    U.update(),
                    W.update(),
                    H.update()
            }
            for (let k = 0; k < i.length; k++)
                NA.push(i[k]);
            this._font = e,
                this.dirty = !1
        }
        updateTransform() {
            this.validate(),
                this.containerUpdateTransform()
        }
        _render(e) {
            this._autoResolution && this._resolution !== e.resolution && (this._resolution = e.resolution,
                this.dirty = !0);
            const { distanceFieldRange: n, distanceFieldType: s, size: r } = ha.available[this._fontName];
            if (s !== "none") {
                const { a: i, b: o, c: l, d: a } = this.worldTransform
                    , c = Math.sqrt(i * i + o * o)
                    , u = Math.sqrt(l * l + a * a)
                    , h = (Math.abs(c) + Math.abs(u)) / 2
                    , d = this.fontSize / r
                    , f = e._view.resolution;
                for (const p of this._activePagesMeshData)
                    p.mesh.shader.uniforms.uFWidth = h * n * d * f
            }
            super._render(e)
        }
        getLocalBounds() {
            return this.validate(),
                super.getLocalBounds()
        }
        validate() {
            const e = ha.available[this._fontName];
            if (!e)
                throw new Error(`Missing BitmapFont "${this._fontName}"`);
            this._font !== e && (this.dirty = !0),
                this.dirty && this.updateText()
        }
        get tint() {
            return this._tintColor.value
        }
        set tint(e) {
            if (this.tint !== e) {
                this._tintColor.setValue(e);
                for (let n = 0; n < this._activePagesMeshData.length; n++)
                    this._activePagesMeshData[n].mesh.tint = e
            }
        }
        get align() {
            return this._align
        }
        set align(e) {
            this._align !== e && (this._align = e,
                this.dirty = !0)
        }
        get fontName() {
            return this._fontName
        }
        set fontName(e) {
            if (!ha.available[e])
                throw new Error(`Missing BitmapFont "${e}"`);
            this._fontName !== e && (this._fontName = e,
                this.dirty = !0)
        }
        get fontSize() {
            return this._fontSize ?? ha.available[this._fontName].size
        }
        set fontSize(e) {
            this._fontSize !== e && (this._fontSize = e,
                this.dirty = !0)
        }
        get anchor() {
            return this._anchor
        }
        set anchor(e) {
            typeof e == "number" ? this._anchor.set(e) : this._anchor.copyFrom(e)
        }
        get text() {
            return this._text
        }
        set text(e) {
            e = String(e ?? ""),
                this._text !== e && (this._text = e,
                    this.dirty = !0)
        }
        get maxWidth() {
            return this._maxWidth
        }
        set maxWidth(e) {
            this._maxWidth !== e && (this._maxWidth = e,
                this.dirty = !0)
        }
        get maxLineHeight() {
            return this.validate(),
                this._maxLineHeight
        }
        get textWidth() {
            return this.validate(),
                this._textWidth
        }
        get letterSpacing() {
            return this._letterSpacing
        }
        set letterSpacing(e) {
            this._letterSpacing !== e && (this._letterSpacing = e,
                this.dirty = !0)
        }
        get roundPixels() {
            return this._roundPixels
        }
        set roundPixels(e) {
            e !== this._roundPixels && (this._roundPixels = e,
                this.dirty = !0)
        }
        get textHeight() {
            return this.validate(),
                this._textHeight
        }
        get resolution() {
            return this._resolution
        }
        set resolution(e) {
            this._autoResolution = !1,
                this._resolution !== e && (this._resolution = e,
                    this.dirty = !0)
        }
        destroy(e) {
            const { _textureCache: n } = this
                , s = ha.available[this._fontName].distanceFieldType === "none" ? LA : OA;
            s.push(...this._activePagesMeshData);
            for (const r of this._activePagesMeshData)
                this.removeChild(r.mesh);
            this._activePagesMeshData = [],
                s.filter(r => n[r.mesh.texture.baseTexture.uid]).forEach(r => {
                    r.mesh.texture = $e.EMPTY
                }
                );
            for (const r in n)
                n[r].destroy(),
                    delete n[r];
            this._font = null,
                this._tintColor = null,
                this._textureCache = null,
                super.destroy(e)
        }
    }
    ;
Vfe.styleDefaults = {
    align: "left",
    tint: 16777215,
    maxWidth: 0,
    letterSpacing: 0
};
const Gfe = [".xml", ".fnt"]
    , Hfe = {
        extension: {
            type: Ae.LoadParser,
            priority: _r.Normal
        },
        name: "loadBitmapFont",
        test(t) {
            return Gfe.includes(zt.extname(t).toLowerCase())
        },
        async testParse(t) {
            return sm.test(t) || lv.test(t)
        },
        async parse(t, e, n) {
            const s = sm.test(t) ? sm.parse(t) : lv.parse(t)
                , { src: r } = e
                , { page: i } = s
                , o = [];
            for (let c = 0; c < i.length; ++c) {
                const u = i[c].file;
                let h = zt.join(zt.dirname(r), u);
                h = Ub(h, r),
                    o.push(h)
            }
            const l = await n.load(o)
                , a = o.map(c => l[c]);
            return ha.install(s, a, !0)
        },
        async load(t, e) {
            return (await Le.ADAPTER.fetch(t)).text()
        },
        unload(t) {
            t.destroy()
        }
    };
Ue.add(Hfe);
const cv = class zc extends qa {
    constructor() {
        super(...arguments),
            this._fonts = [],
            this._overrides = [],
            this._stylesheet = "",
            this.fontsDirty = !1
    }
    static from(e) {
        return new zc(Object.keys(zc.defaultOptions).reduce((n, s) => ({
            ...n,
            [s]: e[s]
        }), {}))
    }
    cleanFonts() {
        this._fonts.length > 0 && (this._fonts.forEach(e => {
            URL.revokeObjectURL(e.src),
                e.refs--,
                e.refs === 0 && (e.fontFace && document.fonts.delete(e.fontFace),
                    delete zc.availableFonts[e.originalUrl])
        }
        ),
            this.fontFamily = "Arial",
            this._fonts.length = 0,
            this.styleID++,
            this.fontsDirty = !0)
    }
    loadFont(e, n = {}) {
        const { availableFonts: s } = zc;
        if (s[e]) {
            const r = s[e];
            return this._fonts.push(r),
                r.refs++,
                this.styleID++,
                this.fontsDirty = !0,
                Promise.resolve()
        }
        return Le.ADAPTER.fetch(e).then(r => r.blob()).then(async r => new Promise((i, o) => {
            const l = URL.createObjectURL(r)
                , a = new FileReader;
            a.onload = () => i([l, a.result]),
                a.onerror = o,
                a.readAsDataURL(r)
        }
        )).then(async ([r, i]) => {
            const o = Object.assign({
                family: zt.basename(e, zt.extname(e)),
                weight: "normal",
                style: "normal",
                display: "auto",
                src: r,
                dataSrc: i,
                refs: 1,
                originalUrl: e,
                fontFace: null
            }, n);
            s[e] = o,
                this._fonts.push(o),
                this.styleID++;
            const l = new FontFace(o.family, `url(${o.src})`, {
                weight: o.weight,
                style: o.style,
                display: o.display
            });
            o.fontFace = l,
                await l.load(),
                document.fonts.add(l),
                await document.fonts.ready,
                this.styleID++,
                this.fontsDirty = !0
        }
        )
    }
    addOverride(...e) {
        const n = e.filter(s => !this._overrides.includes(s));
        n.length > 0 && (this._overrides.push(...n),
            this.styleID++)
    }
    removeOverride(...e) {
        const n = e.filter(s => this._overrides.includes(s));
        n.length > 0 && (this._overrides = this._overrides.filter(s => !n.includes(s)),
            this.styleID++)
    }
    toCSS(e) {
        return [`transform: scale(${e})`, "transform-origin: top left", "display: inline-block", `color: ${this.normalizeColor(this.fill)}`, `font-size: ${this.fontSize}px`, `font-family: ${this.fontFamily}`, `font-weight: ${this.fontWeight}`, `font-style: ${this.fontStyle}`, `font-variant: ${this.fontVariant}`, `letter-spacing: ${this.letterSpacing}px`, `text-align: ${this.align}`, `padding: ${this.padding}px`, `white-space: ${this.whiteSpace}`, ...this.lineHeight ? [`line-height: ${this.lineHeight}px`] : [], ...this.wordWrap ? [`word-wrap: ${this.breakWords ? "break-all" : "break-word"}`, `max-width: ${this.wordWrapWidth}px`] : [], ...this.strokeThickness ? [`-webkit-text-stroke-width: ${this.strokeThickness}px`, `-webkit-text-stroke-color: ${this.normalizeColor(this.stroke)}`, `text-stroke-width: ${this.strokeThickness}px`, `text-stroke-color: ${this.normalizeColor(this.stroke)}`, "paint-order: stroke"] : [], ...this.dropShadow ? [this.dropShadowToCSS()] : [], ...this._overrides].join(";")
    }
    toGlobalCSS() {
        return this._fonts.reduce((e, n) => `${e}
            @font-face {
                font-family: "${n.family}";
                src: url('${n.dataSrc}');
                font-weight: ${n.weight};
                font-style: ${n.style};
                font-display: ${n.display};
            }`, this._stylesheet)
    }
    get stylesheet() {
        return this._stylesheet
    }
    set stylesheet(e) {
        this._stylesheet !== e && (this._stylesheet = e,
            this.styleID++)
    }
    normalizeColor(e) {
        return Array.isArray(e) && (e = Kp(e)),
            typeof e == "number" ? Rle(e) : e
    }
    dropShadowToCSS() {
        let e = this.normalizeColor(this.dropShadowColor);
        const n = this.dropShadowAlpha
            , s = Math.round(Math.cos(this.dropShadowAngle) * this.dropShadowDistance)
            , r = Math.round(Math.sin(this.dropShadowAngle) * this.dropShadowDistance);
        e.startsWith("#") && n < 1 && (e += (n * 255 | 0).toString(16).padStart(2, "0"));
        const i = `${s}px ${r}px`;
        return this.dropShadowBlur > 0 ? `text-shadow: ${i} ${this.dropShadowBlur}px ${e}` : `text-shadow: ${i} ${e}`
    }
    reset() {
        Object.assign(this, zc.defaultOptions)
    }
    onBeforeDraw() {
        const { fontsDirty: e } = this;
        return this.fontsDirty = !1,
            this.isSafari && this._fonts.length > 0 && e ? new Promise(n => setTimeout(n, 100)) : Promise.resolve()
    }
    get isSafari() {
        const { userAgent: e } = Le.ADAPTER.getNavigator();
        return /^((?!chrome|android).)*safari/i.test(e)
    }
    set fillGradientStops(e) {
        console.warn("[HTMLTextStyle] fillGradientStops is not supported by HTMLText")
    }
    get fillGradientStops() {
        return super.fillGradientStops
    }
    set fillGradientType(e) {
        console.warn("[HTMLTextStyle] fillGradientType is not supported by HTMLText")
    }
    get fillGradientType() {
        return super.fillGradientType
    }
    set miterLimit(e) {
        console.warn("[HTMLTextStyle] miterLimit is not supported by HTMLText")
    }
    get miterLimit() {
        return super.miterLimit
    }
    set trim(e) {
        console.warn("[HTMLTextStyle] trim is not supported by HTMLText")
    }
    get trim() {
        return super.trim
    }
    set textBaseline(e) {
        console.warn("[HTMLTextStyle] textBaseline is not supported by HTMLText")
    }
    get textBaseline() {
        return super.textBaseline
    }
    set leading(e) {
        console.warn("[HTMLTextStyle] leading is not supported by HTMLText")
    }
    get leading() {
        return super.leading
    }
    set lineJoin(e) {
        console.warn("[HTMLTextStyle] lineJoin is not supported by HTMLText")
    }
    get lineJoin() {
        return super.lineJoin
    }
}
    ;
cv.availableFonts = {},
    cv.defaultOptions = {
        align: "left",
        breakWords: !1,
        dropShadow: !1,
        dropShadowAlpha: 1,
        dropShadowAngle: Math.PI / 6,
        dropShadowBlur: 0,
        dropShadowColor: "black",
        dropShadowDistance: 5,
        fill: "black",
        fontFamily: "Arial",
        fontSize: 26,
        fontStyle: "normal",
        fontVariant: "normal",
        fontWeight: "normal",
        letterSpacing: 0,
        lineHeight: 0,
        padding: 0,
        stroke: "black",
        strokeThickness: 0,
        whiteSpace: "normal",
        wordWrap: !1,
        wordWrapWidth: 100
    };
let O1 = cv;
const Tp = class qc extends Tc {
    constructor(e = "", n = {}) {
        super($e.EMPTY),
            this._text = null,
            this._style = null,
            this._autoResolution = !0,
            this.localStyleID = -1,
            this.dirty = !1,
            this._updateID = 0,
            this.ownsStyle = !1;
        const s = new Image
            , r = $e.from(s, {
                scaleMode: Le.SCALE_MODE,
                resourceOptions: {
                    autoLoad: !1
                }
            });
        r.orig = new nt,
            r.trim = new nt,
            this.texture = r;
        const i = "http://www.w3.org/2000/svg"
            , o = "http://www.w3.org/1999/xhtml"
            , l = document.createElementNS(i, "svg")
            , a = document.createElementNS(i, "foreignObject")
            , c = document.createElementNS(o, "div")
            , u = document.createElementNS(o, "style");
        a.setAttribute("width", "10000"),
            a.setAttribute("height", "10000"),
            a.style.overflow = "hidden",
            l.appendChild(a),
            this.maxWidth = qc.defaultMaxWidth,
            this.maxHeight = qc.defaultMaxHeight,
            this._domElement = c,
            this._styleElement = u,
            this._svgRoot = l,
            this._foreignObject = a,
            this._foreignObject.appendChild(u),
            this._foreignObject.appendChild(c),
            this._image = s,
            this._loadImage = new Image,
            this._autoResolution = qc.defaultAutoResolution,
            this._resolution = qc.defaultResolution ?? Le.RESOLUTION,
            this.text = e,
            this.style = n
    }
    measureText(e) {
        var u, h;
        const { text: n, style: s, resolution: r } = Object.assign({
            text: this._text,
            style: this._style,
            resolution: this._resolution
        }, e);
        Object.assign(this._domElement, {
            innerHTML: n,
            style: s.toCSS(r)
        }),
            this._styleElement.textContent = s.toGlobalCSS(),
            document.body.appendChild(this._svgRoot);
        const i = this._domElement.getBoundingClientRect();
        this._svgRoot.remove();
        const { width: o, height: l } = i;
        (o > this.maxWidth || l > this.maxHeight) && console.warn("[HTMLText] Large expanse of text, increase HTMLText.maxWidth or HTMLText.maxHeight property.");
        const a = Math.min(this.maxWidth, Math.ceil(o))
            , c = Math.min(this.maxHeight, Math.ceil(l));
        return this._svgRoot.setAttribute("width", a.toString()),
            this._svgRoot.setAttribute("height", c.toString()),
            n !== this._text && (this._domElement.innerHTML = this._text),
            s !== this._style && (Object.assign(this._domElement, {
                style: (u = this._style) == null ? void 0 : u.toCSS(r)
            }),
                this._styleElement.textContent = (h = this._style) == null ? void 0 : h.toGlobalCSS()),
        {
            width: a + s.padding * 2,
            height: c + s.padding * 2
        }
    }
    async updateText(e = !0) {
        const { style: n, _image: s, _loadImage: r } = this;
        if (this.localStyleID !== n.styleID && (this.dirty = !0,
            this.localStyleID = n.styleID),
            !this.dirty && e)
            return;
        const { width: i, height: o } = this.measureText();
        s.width = r.width = Math.ceil(Math.max(1, i)),
            s.height = r.height = Math.ceil(Math.max(1, o)),
            this._updateID++;
        const l = this._updateID;
        await new Promise(a => {
            r.onload = async () => {
                if (l < this._updateID) {
                    a();
                    return
                }
                await n.onBeforeDraw(),
                    s.src = r.src,
                    r.onload = null,
                    r.src = "",
                    this.updateTexture(),
                    a()
            }
                ;
            const c = new XMLSerializer().serializeToString(this._svgRoot);
            r.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(c)}`
        }
        )
    }
    get source() {
        return this._image
    }
    updateTexture() {
        const { style: e, texture: n, _image: s, resolution: r } = this
            , { padding: i } = e
            , { baseTexture: o } = n;
        n.trim.width = n._frame.width = s.width / r,
            n.trim.height = n._frame.height = s.height / r,
            n.trim.x = -i,
            n.trim.y = -i,
            n.orig.width = n._frame.width - i * 2,
            n.orig.height = n._frame.height - i * 2,
            this._onTextureUpdate(),
            o.setRealSize(s.width, s.height, r),
            this.dirty = !1
    }
    _render(e) {
        this._autoResolution && this._resolution !== e.resolution && (this._resolution = e.resolution,
            this.dirty = !0),
            this.updateText(!0),
            super._render(e)
    }
    _renderCanvas(e) {
        this._autoResolution && this._resolution !== e.resolution && (this._resolution = e.resolution,
            this.dirty = !0),
            this.updateText(!0),
            super._renderCanvas(e)
    }
    getLocalBounds(e) {
        return this.updateText(!0),
            super.getLocalBounds(e)
    }
    _calculateBounds() {
        this.updateText(!0),
            this.calculateVertices(),
            this._bounds.addQuad(this.vertexData)
    }
    _onStyleChange() {
        this.dirty = !0
    }
    destroy(e) {
        var s, r, i, o, l;
        typeof e == "boolean" && (e = {
            children: e
        }),
            e = Object.assign({}, qc.defaultDestroyOptions, e),
            super.destroy(e);
        const n = null;
        this.ownsStyle && ((s = this._style) == null || s.cleanFonts()),
            this._style = n,
            (r = this._svgRoot) == null || r.remove(),
            this._svgRoot = n,
            (i = this._domElement) == null || i.remove(),
            this._domElement = n,
            (o = this._foreignObject) == null || o.remove(),
            this._foreignObject = n,
            (l = this._styleElement) == null || l.remove(),
            this._styleElement = n,
            this._loadImage.src = "",
            this._loadImage.onload = null,
            this._loadImage = n,
            this._image.src = "",
            this._image = n
    }
    get width() {
        return this.updateText(!0),
            Math.abs(this.scale.x) * this._image.width / this.resolution
    }
    set width(e) {
        this.updateText(!0);
        const n = Ra(this.scale.x) || 1;
        this.scale.x = n * e / this._image.width / this.resolution,
            this._width = e
    }
    get height() {
        return this.updateText(!0),
            Math.abs(this.scale.y) * this._image.height / this.resolution
    }
    set height(e) {
        this.updateText(!0);
        const n = Ra(this.scale.y) || 1;
        this.scale.y = n * e / this._image.height / this.resolution,
            this._height = e
    }
    get style() {
        return this._style
    }
    set style(e) {
        this._style !== e && (e = e || {},
            e instanceof O1 ? (this.ownsStyle = !1,
                this._style = e) : e instanceof qa ? (console.warn("[HTMLText] Cloning TextStyle, if this is not what you want, use HTMLTextStyle"),
                    this.ownsStyle = !0,
                    this._style = O1.from(e)) : (this.ownsStyle = !0,
                        this._style = new O1(e)),
            this.localStyleID = -1,
            this.dirty = !0)
    }
    get text() {
        return this._text
    }
    set text(e) {
        e = String(e === "" || e === null || e === void 0 ? " " : e),
            e = this.sanitiseText(e),
            this._text !== e && (this._text = e,
                this.dirty = !0)
    }
    get resolution() {
        return this._resolution
    }
    set resolution(e) {
        this._autoResolution = !1,
            this._resolution !== e && (this._resolution = e,
                this.dirty = !0)
    }
    sanitiseText(e) {
        return e.replace(/<br>/gi, "<br/>").replace(/<hr>/gi, "<hr/>").replace(/&nbsp;/gi, "&#160;")
    }
}
    ;
Tp.defaultDestroyOptions = {
    texture: !0,
    children: !1,
    baseTexture: !0
},
    Tp.defaultMaxWidth = 2024,
    Tp.defaultMaxHeight = 2024,
    Tp.defaultAutoResolution = !0;
const Wfe = {
    name: "SlapMainGirl",
    props: {
        leftBalance: Number,
        spineAsset: {
            type: String,
            required: !0
        },
        animationLayers: {
            type: Array,
            required: !0
        },
        scale: {
            type: Number,
            default: .78
        },
        position: {
            type: Object,
            default: {
                x: 1 / 2,
                y: 1
            }
        },
        slapBySide: Boolean,
        disableSlap: Boolean,
        hint: String
    },
    components: {
        Loader: ol
    },
    emits: ["slap", "ready", "onDisabledSlap"],
    data() {
        const t = Ye();
        return {
            isLoaded: !1,
            animationIdleEntryCount: 0,
            globalStore: t,
            slapPower: t.slapPower,
            animation: null,
            application: null,
            isFaceAnimated: !1,
            animationId: 0,
            showBooble: !1,
            slapLastClickTime: 0,
            tempHint: null
        }
    },
    computed: {
        animationDependencies() {
            return {
                spineAsset: this.spineAsset,
                animationLayers: this.animationLayers
            }
        },
        isBalanceZero() {
            return this.leftBalance <= 0
        }
    },
    methods: {
        reloadAnimation() {
            this.isLoaded = !1,
                this.animation && (this.application.stage.removeChild(this.animation),
                    this.animation.destroy(),
                    this.animation = null),
                this.clearStage(),
                this.spineInit()
        },
        clearStage() {
            this.application.stage.removeChildren()
        },
        spineInit() {
            this.application || (this.application = new gS({
                height: 1600,
                width: 692,
                backgroundAlpha: 0
            }),
                this.application.stage.interactive = !0,
                this.$refs.area.prepend(this.application.view)),
                ru.load(`${this.spineAsset}/standard_v2_2x_faceai.json`).then(t => {
                    const e = this.animation;
                    this.animation = new _L(t.spineData),
                        this.initSkin(this.animationLayers),
                        e && (this.application.stage.removeChild(e),
                            e.destroy()),
                        this.application.stage.addChild(this.animation),
                        this.animation.state.hasAnimation("Idle") && (this.animation.state.setAnimation(0, "Idle", !0),
                            this.animation.state.timeScale = 1,
                            this.animation.autoUpdate = !0),
                        this.animation.interactive = !0,
                        this.animation.state.addListener({
                            complete: n => {
                                n.animation.name !== "Hit_Face" && (this.animation.state.setAnimation(0, "Idle", !0),
                                    n.animation.name === "Idle" && (this.animationIdleEntryCount += 1,
                                        this.animationIdleEntryCount > 2 && this.animation.state.setAnimation(0, "Wait", !0)))
                            }
                            ,
                            start: n => {
                                n.animation.name !== "Idle" && (this.animationIdleEntryCount = 0)
                            }
                            ,
                            interrupt: n => { }
                            ,
                            end: () => { }
                        }),
                        this.isLoaded = !0,
                        this.$emit("ready")
                }
                ).catch(t => {
                    console.error(t)
                }
                )
        },
        initSkin(t) {
            const e = new Gd("combined-skin");
            t.forEach(n => {
                e.addSkin(this.animation.spineData.findSkin(n))
            }
            ),
                this.animation.skeleton.setSkin(e),
                this.animation.skeleton.setSlotsToSetupPose(),
                this.animation.scale.set(this.scale, this.scale),
                this.animation.position.set(this.application.screen.width * this.position.x, this.application.screen.height * this.position.y)
        },
        createTapPoint(t, e) {
            const n = document.createElement("span");
            n.classList.add("tap-point");
            let s = this.slapPower;
            this.leftBalance < this.slapPower && (s = this.leftBalance),
                !(Math.round(this.leftBalance) <= 0) && (n.textContent = Math.round(s),
                    document.body.appendChild(n),
                    n.style.left = `${t}px`,
                    n.style.top = `${e}px`,
                    setTimeout(() => {
                        n.classList.add("tap-point--move")
                    }
                        , 10),
                    setTimeout(() => {
                        n.remove()
                    }
                        , 910))
        },
        onSlap(t, e) {
            if (this != null && this.disableSlap) {
                this.showTemporaryHint(this.$t("girls.hint.change_girl_position")),
                    this.$emit("onDisabledSlap");
                return
            } else if (this.isBalanceZero) {
                this.showTemporaryHint(this.$t("girls.hint.no_balance"));
                return
            }
            this.createTapPoint(t.clientX, t.clientY),
                e && (this.animation.state.hasAnimation("Hit_L") || this.animation.state.hasAnimation("Hit_R")) ? this.animation.state.setAnimation(0, e === "left" ? "Hit_L" : "Hit_R", !1) : this.animation.state.hasAnimation("Hit") ? this.animation.state.setAnimation(0, "Hit", !1) : this.animation.state.hasAnimation("Hit_1") && this.animation.state.setAnimation(0, "Hit_1", !1),
                !this.slapBySide && !this.isFaceAnimated && this.animation.state.hasAnimation("Hit_Face") && (this.isFaceAnimated = !0,
                    this.animation.state.setAnimation(1, "Hit_Face", !1),
                    setTimeout(() => {
                        this.isFaceAnimated = !1
                    }
                        , 700)),
                this.$emit("slap")
        },
        showTemporaryHint(t) {
            this.tempHint = t,
                clearTimeout(this.hideHintTimeout),
                this.hideHintTimeout = setTimeout(() => {
                    this.tempHint = null
                }
                    , 4e3)
        }
    },
    watch: {
        animationDependencies: {
            handler() {
                this.tempHint = null,
                    this.reloadAnimation()
            },
            deep: !0,
            immediate: !1
        }
    },
    mounted() {
        this.spineInit()
    },
    unmounted() {
        var t, e;
        (t = this.application) == null || t.stop(),
            (e = this.application) == null || e.destroy(),
            this.application = null
    }
};
function Yfe(t, e, n, s, r, i) {
    const o = q("Loader");
    return A(),
        N(Ie, null, [vn(T("div", {
            class: Te([{
                "sl-main-girl--loaded": r.isLoaded,
                "sl-main-girl--to-right": n.spineAsset !== "spine"
            }, "sl-main-girl"]),
            ref: "area"
        }, [n.slapBySide ? (A(),
            N(Ie, {
                key: 0
            }, [T("div", {
                class: "sl-main-girl__slapable-area-by-side sl-main-girl__slapable-area-by-side--left",
                onPointerdown: e[0] || (e[0] = l => i.onSlap(l, "left"))
            }, null, 32), T("div", {
                class: "sl-main-girl__slapable-area-by-side sl-main-girl__slapable-area-by-side--right",
                onPointerdown: e[1] || (e[1] = l => i.onSlap(l, "right"))
            }, null, 32)], 64)) : (A(),
                N("div", {
                    key: 1,
                    class: "sl-main-girl__slapable-area",
                    onPointerdown: e[2] || (e[2] = l => i.onSlap(l))
                }, null, 32)), T("div", {
                    class: Te(["sl-main-girl__hint transition-all op opacity-0 invisible", {
                        "opacity-100 !visible": !!n.hint || !!r.tempHint
                    }])
                }, $(r.tempHint || n.hint), 3)], 2), [[Ru, r.isLoaded]]), r.isLoaded ? te("", !0) : (A(),
                    fe(o, {
                        key: 0,
                        class: "fixed left-1/2 top-1/2 transform -translate-x-1/2 -translate-y-1/2"
                    }))], 64)
}
const Xfe = _e(Wfe, [["render", Yfe], ["__scopeId", "data-v-2b25203d"]])
    , jfe = {
        name: "AnimateGirlDisplay",
        components: {
            MainGirl: Xfe
        },
        props: {
            activeGirl: {
                type: Object,
                required: !0
            },
            hint: String
        },
        emits: ["slap", "ready", "onDisabledSlap"],
        computed: {
            animationData() {
                const t = this.activeGirl.activePose;
                return t && this.activeGirl.poses[t] ? this.activeGirl.poses[t] : null
            }
        }
    };
function zfe(t, e, n, s, r, i) {
    var l, a, c;
    const o = q("MainGirl");
    return (l = i.animationData) != null && l.spineAsset && ((a = i.animationData) != null && a.animationLayers) ? (A(),
        fe(o, {
            key: 0,
            spineAsset: i.animationData.spineAsset,
            animationLayers: i.animationData.animationLayers,
            scale: i.animationData.scale,
            position: i.animationData.position,
            leftBalance: n.activeGirl.leftBalance,
            disableSlap: (c = this.animationData) == null ? void 0 : c.disableSlap,
            hint: n.hint,
            slapBySide: n.activeGirl.activePose === 2,
            onSlap: e[0] || (e[0] = u => t.$emit("slap")),
            onReady: e[1] || (e[1] = u => t.$emit("ready")),
            onOnDisabledSlap: e[2] || (e[2] = u => t.$emit("onDisabledSlap"))
        }, null, 8, ["spineAsset", "animationLayers", "scale", "position", "leftBalance", "disableSlap", "hint", "slapBySide"])) : te("", !0)
}
const qfe = _e(jfe, [["render", zfe]]);
function Kfe(t, e, n) {
    if (t.slot === null)
        return t.balance;
    const s = Math.max(n - t.timestamp, 0)
        , r = id(t.boosts[ns.PROFIT], n) ? t.boosts[ns.PROFIT] : null
        , i = r ? Math.max(Math.min(r.end_timestamp, n) - t.timestamp, 0) : 0
        , o = Math.max(s - i, 0)
        , l = r && e ? t.rate * e[r.tier].bonus * i : 0;
    return Math.floor(Math.min(t.capacity, t.balance + l + t.rate * o))
}
function _S(t) {
    const e = ls()
        , n = Xs()
        , s = si();
    return ve(() => {
        let r = [];
        return t ? r = Array.isArray(t) ? t : [t] : r = e.girls,
            r.map(i => ({
                ...i,
                balance: Kfe(i, n.config.profit, s.unixTime)
            }))
    }
    )
}
const Jfe = {}
    , Zfe = {
        width: "24",
        height: "24",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }
    , Qfe = T("path", {
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        d: "M12 21.1667C6.93739 21.1667 2.83333 17.0626 2.83333 12C2.83333 6.93739 6.93739 2.83333 12 2.83333C17.0626 2.83333 21.1667 6.93739 21.1667 12C21.1667 17.0626 17.0626 21.1667 12 21.1667ZM1 12C1 5.92487 5.92487 1 12 1C18.0751 1 23 5.92487 23 12C23 18.0751 18.0751 23 12 23C5.92487 23 1 18.0751 1 12ZM13.875 7.96875C13.9531 7.80729 13.9922 7.625 13.9922 7.42188C13.9922 7.25 13.9557 7.09115 13.8828 6.94531C13.8151 6.79948 13.7188 6.67448 13.5938 6.57031C13.474 6.46094 13.3307 6.3776 13.1641 6.32031C12.9974 6.25781 12.8151 6.22656 12.6172 6.22656C12.4036 6.22656 12.2057 6.25781 12.0234 6.32031C11.8411 6.38281 11.6823 6.47396 11.5469 6.59375C11.4167 6.70833 11.3125 6.84635 11.2344 7.00781C11.1615 7.16927 11.125 7.35156 11.125 7.55469C11.125 7.72656 11.1589 7.88542 11.2266 8.03125C11.2995 8.17708 11.3958 8.30469 11.5156 8.41406C11.6406 8.51823 11.7865 8.60156 11.9531 8.66406C12.125 8.72135 12.3099 8.75 12.5078 8.75C12.7161 8.75 12.9089 8.71875 13.0859 8.65625C13.2682 8.59375 13.4245 8.50521 13.5547 8.39062C13.6901 8.27083 13.7969 8.13021 13.875 7.96875ZM12.8516 18.0078C12.9766 17.9818 13.0859 17.9557 13.1797 17.9297C13.2474 17.6172 13.3125 17.3099 13.375 17.0078C13.4375 16.7005 13.5026 16.3906 13.5703 16.0781C13.4557 16.125 13.3281 16.1641 13.1875 16.1953C13.0521 16.2214 12.9167 16.2344 12.7812 16.2344C12.6198 16.2344 12.4766 16.1953 12.3516 16.1172C12.2266 16.0391 12.1641 15.901 12.1641 15.7031C12.1641 15.5365 12.1875 15.3411 12.2344 15.1172C12.2812 14.888 12.3255 14.6823 12.3672 14.5L13.3203 10H10.8203C10.7995 10.0885 10.763 10.2526 10.7109 10.4922C10.6641 10.7266 10.6068 10.9974 10.5391 11.3047C10.4766 11.612 10.4089 11.9375 10.3359 12.2812C10.263 12.6198 10.1927 12.9427 10.125 13.25C10.0625 13.5573 10.0052 13.8307 9.95312 14.0703C9.90625 14.3047 9.8724 14.4661 9.85156 14.5547C9.82031 14.7005 9.78906 14.8542 9.75781 15.0156C9.73177 15.1719 9.70833 15.3281 9.6875 15.4844C9.66667 15.6354 9.64844 15.7812 9.63281 15.9219C9.6224 16.0625 9.61719 16.1901 9.61719 16.3047C9.61719 16.5755 9.65365 16.8255 9.72656 17.0547C9.80469 17.2786 9.92448 17.474 10.0859 17.6406C10.2474 17.8021 10.4505 17.9271 10.6953 18.0156C10.9453 18.1094 11.2448 18.1562 11.5938 18.1562C11.7396 18.1562 11.8854 18.1484 12.0312 18.1328C12.1823 18.1224 12.3255 18.1042 12.4609 18.0781C12.6016 18.0573 12.7318 18.0339 12.8516 18.0078Z",
        fill: "white",
        "fill-opacity": "0.48"
    }, null, -1)
    , epe = [Qfe];
function tpe(t, e) {
    return A(),
        N("svg", Zfe, epe)
}
const DL = _e(Jfe, [["render", tpe]])
    , npe = {}
    , spe = {
        width: "15",
        height: "16",
        viewBox: "0 0 15 16",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }
    , rpe = T("path", {
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        d: "M0.846571 6.57747C1.16731 6.23609 1.68679 6.22984 1.99882 6.56195L5.01971 9.77722C5.15225 9.91829 5.37054 9.9152 5.50603 9.771C5.64151 9.62679 5.64442 9.39445 5.51188 9.25338L1.05511 4.50983C0.743076 4.17772 0.748949 3.62482 1.06969 3.28344C1.39043 2.94206 1.90991 2.93581 2.22194 3.26792L5.7233 6.99457C5.85584 7.13565 6.07413 7.13255 6.20962 6.98835C6.3451 6.84414 6.34801 6.61181 6.21547 6.47073L2.2364 2.23563C1.92437 1.90352 1.93025 1.35062 2.25099 1.00924C2.57173 0.667862 3.09121 0.661612 3.40324 0.993719L7.86001 5.73727C7.99256 5.87834 8.21085 5.87525 8.34633 5.73104C8.48182 5.58684 8.48473 5.3545 8.35219 5.21343L4.85083 1.48677C4.5388 1.15467 4.54467 0.601762 4.86541 0.260384C5.18616 -0.0809949 5.70563 -0.0872446 6.01766 0.244863L12.0456 6.66071L12.1626 5.14897C12.2575 3.71371 12.6007 2.77825 13.5595 2.73934C14.1707 2.73074 14.218 3.68975 14.2736 4.81644C14.2781 4.90721 14.2827 4.99906 14.2875 5.09159C14.3012 5.35215 14.3375 5.72489 14.3807 6.16948C14.5361 7.76713 14.7817 10.2925 14.3938 11.8734C14.3938 11.8734 14.2468 12.6999 13.586 13.4032L12.0044 15.0866C10.7298 16.4433 8.79011 16.28 7.2631 14.6547L0.82922 7.80681C0.519955 7.47176 0.525829 6.91885 0.846571 6.57747Z"
    }, null, -1)
    , ipe = [rpe];
function ope(t, e) {
    return A(),
        N("svg", spe, ipe)
}
const yS = _e(npe, [["render", ope]])
    , ape = {
        name: "LockAvatar",
        components: {
            IconLock: C_
        }
    }
    , lpe = {
        class: "lock-avatar border-background-secondary flex items-center justify-center"
    };
function cpe(t, e, n, s, r, i) {
    const o = q("IconLock");
    return A(),
        N("div", lpe, [G(o, {
            class: "lock-avatar__icon text-white/[.2]"
        })])
}
const bS = _e(ape, [["render", cpe], ["__scopeId", "data-v-2aa0c7f4"]])
    , upe = {
        name: "GirlAvatar",
        components: {
            LockAvatar: bS
        },
        data() {
            return {
                globalStore: Ye()
            }
        },
        props: {
            isCollapsed: Boolean,
            shrinkOnCollapse: {
                type: Boolean,
                required: !1,
                default: !1
            },
            alwaysShowEmpty: {
                type: Boolean,
                required: !1,
                default: !1
            },
            onGirlAvatarClick: Function,
            girl: Object
        }
    }
    , hpe = t => (Wo("data-v-97e986b4"),
        t = t(),
        Yo(),
        t)
    , dpe = hpe(() => T("div", {
        class: "girl-avatar__empty-light"
    }, null, -1))
    , fpe = [dpe]
    , ppe = ["src"];
function mpe(t, e, n, s, r, i) {
    return A(),
        N(Ie, null, [n.girl == null && (!n.isCollapsed || n.alwaysShowEmpty) ? (A(),
            N("div", {
                key: 0,
                class: Te(["girl-avatar empty w-10 h-10", [n.alwaysShowEmpty && "z-[1]"]])
            }, fpe, 2)) : te("", !0), n.girl != null ? (A(),
                N("div", {
                    key: 1,
                    class: Te(["girl-avatar", [n.shrinkOnCollapse && n.isCollapsed ? "w-6 h-6" : "w-10 h-10"]]),
                    onClick: e[0] || (e[0] = o => {
                        var l;
                        return (l = n.onGirlAvatarClick) == null ? void 0 : l.call(n, n.girl)
                    }
                    )
                }, [T("div", {
                    class: Te(["girl-avatar__light", `tier-${n.girl.tier}`])
                }, null, 2), T("div", {
                    class: Te(["girl-avatar__img-wrapper", [n.shrinkOnCollapse && n.isCollapsed ? "w-6 h-6" : "w-10 h-10"]])
                }, [T("img", {
                    src: n.girl.path
                }, null, 8, ppe)], 2)], 2)) : te("", !0)], 64)
}
const vS = _e(upe, [["render", mpe], ["__scopeId", "data-v-97e986b4"]])
    , gpe = {
        name: "CharacteristicsPopup",
        components: {
            GirlAvatar: vS,
            IconPrimary: yS,
            IconWarning: b4,
            Popup: il
        },
        props: {
            isVisible: Boolean,
            close: Function
        },
        computed: {
            girl() {
                return this.girlsStore.selectedGirl
            },
            slapPower() {
                return this.globalStore.slapPower
            }
        },
        data() {
            return {
                girlsStore: ls(),
                globalStore: Ye()
            }
        }
    }
    , _pe = {
        class: "w-full"
    }
    , ype = {
        class: "flex items-center"
    }
    , bpe = {
        class: "ml-2"
    }
    , vpe = {
        class: "text-base text-left font-bold capitalize text-white"
    }
    , xpe = {
        class: "font-xs text-white/[.6] capitalize"
    }
    , wpe = {
        class: "bg-[#1a1a2e] rounded-lg px-3 py-2 space-y-1 mt-3"
    }
    , Spe = {
        class: "flex items-center justify-between"
    }
    , Epe = {
        class: "text-white/[.6] capitalize"
    }
    , Tpe = {
        class: "flex items-center space-x-2"
    }
    , Cpe = {
        class: "text-white font-semibold"
    }
    , Ipe = {
        class: "flex items-center justify-between"
    }
    , Ape = {
        class: "text-white/[.6]"
    }
    , kpe = {
        class: "flex items-center space-x-2"
    }
    , Rpe = {
        class: "text-coin font-semibold"
    }
    , Mpe = {
        key: 0,
        class: "text-white font-normal"
    }
    , Ppe = {
        class: "flex items-center justify-between"
    }
    , Lpe = {
        class: "text-white/[.6]"
    }
    , Ope = {
        class: "flex items-center space-x-2"
    }
    , Npe = {
        class: "text-coin font-semibold"
    }
    , Dpe = {
        key: 0,
        class: "text-white font-normal"
    };
function Bpe(t, e, n, s, r, i) {
    const o = q("GirlAvatar")
        , l = q("IconPrimary")
        , a = q("IconCoin")
        , c = q("Popup");
    return A(),
        fe(c, {
            "is-visible": n.isVisible,
            onClose: n.close
        }, {
            default: Ce(() => [T("div", _pe, [T("div", ype, [G(o, {
                girl: i.girl,
                isCollapsed: !1,
                onGirlAvatarClick: () => { }
            }, null, 8, ["girl"]), T("div", bpe, [T("h2", vpe, $(t.$t(`girls.names.${i.girl.name}`)), 1), T("p", xpe, $(t.$t(`girls.rarity.${i.girl.tier}`)), 1)])]), T("div", wpe, [T("div", Spe, [T("p", Epe, $(t.$t("characteristics.slap_power")) + ": ", 1), T("div", Tpe, [G(l, {
                class: "w-5 h-5 fill-white"
            }), T("span", Cpe, $(i.slapPower), 1)])]), T("div", Ipe, [T("p", Ape, $(t.$t("characteristics.slap_per_hour")) + ": ", 1), T("div", kpe, [G(a, {
                class: "w-5 h-5"
            }), T("span", Rpe, $(i.girl.basePerHour), 1), i.girl.bonusPerHour > 0 ? (A(),
                N("span", Mpe, "+ " + $(i.girl.bonusPerHour), 1)) : te("", !0)])]), T("div", Ppe, [T("p", Lpe, $(t.$t("characteristics.capacity")) + ":", 1), T("div", Ope, [G(a, {
                    class: "w-5 h-5"
                }), T("span", Npe, $(i.girl.baseCapacity), 1), i.girl.bonusCapacity > 0 ? (A(),
                    N("span", Dpe, "+ " + $(i.girl.bonusCapacity), 1)) : te("", !0)])])])])]),
            _: 1
        }, 8, ["is-visible", "onClose"])
}
const Fpe = _e(gpe, [["render", Bpe]])
    , $pe = {
        __name: "LevelUpButton",
        setup(t) {
            return (e, n) => (A(),
                fe(hh, {
                    glow: "common"
                }, {
                    default: Ce(() => [G(Yx)]),
                    _: 1
                }))
        }
    }
    , Upe = {
        class: "text-white font-bold text-2xl capitalize"
    }
    , Vpe = {
        class: "flex flex-col gap-4 overflow-y-auto pb-4"
    }
    , Gpe = {
        class: "flex flex-col justify-center w-full text-center"
    }
    , Hpe = {
        class: "mt-3 px-4 grid grid-cols-3 auto-rows-max gap-2 grow"
    }
    , Wpe = {
        class: "text-white text-2xl font-semibold"
    }
    , Ype = {
        class: "text-white/60 text-xs mt-1"
    }
    , Xpe = {
        class: "mt-3 px-4 grid grid-cols-3 auto-rows-max gap-2 grow"
    }
    , jpe = {
        __name: "BoostOverlay",
        props: {
            isVisible: Boolean
        },
        emits: ["close", "confirm"],
        setup(t, { emit: e }) {
            const n = e
                , { t: s } = gt()
                , r = Ye()
                , i = _s()
                , o = Xs()
                , l = ls()
                , a = ve(() => l.energyBoostsForSelectedGirl)
                , c = ve(() => l.profitBoostsForSelectedGirl)
                , u = ve(() => {
                    var d;
                    return i.isOnboardingInProgress && ((d = i.currentStep) == null ? void 0 : d.stepId) === Be.USE_BOOST_1
                }
                )
                , h = async d => {
                    if (!d)
                        return;
                    const f = setTimeout(() => r.setShowLoadingOverlay(!0), 200);
                    await o.consumeBoost(d, l.selectedGirlId),
                        n("confirm", d),
                        clearTimeout(f),
                        r.setShowLoadingOverlay(!1),
                        n("close")
                }
                ;
            return (d, f) => (A(),
                fe(ch, {
                    isVisible: t.isVisible,
                    onClose: f[0] || (f[0] = p => n("close")),
                    class: "bg-gradient-to-b from-black to-[#1B1235]",
                    bodyClass: "!justify-start overflow-hidden",
                    isCloseDisabled: u.value
                }, {
                    header: Ce(() => [T("h3", Upe, $(de(s)("boosts.header")), 1)]),
                    default: Ce(() => [T("div", Vpe, [T("div", Gpe, [T("h3", {
                        class: Te(["text-white text-2xl font-semibold", {
                            "opacity-30 pointer-events-none": u.value
                        }])
                    }, $(de(s)("boosts.profit_boost")), 3), T("p", {
                        class: Te(["text-white/60 text-xs mt-1", {
                            "opacity-30 pointer-events-none": u.value
                        }])
                    }, $(de(s)("boosts.profit_boost_description")), 3), T("div", Hpe, [(A(!0),
                        N(Ie, null, mt(c.value, (p, m) => (A(),
                            fe(jx, Ms({
                                key: p.tier,
                                ref_for: !0
                            }, p, {
                                class: {
                                    "opacity-30 pointer-events-none": u.value && m !== 0
                                },
                                onClick: g => h(p)
                            }), null, 16, ["class", "onClick"]))), 128))])]), T("div", {
                                class: Te(["flex flex-col justify-center w-full text-center", {
                                    "opacity-30 pointer-events-none": u.value
                                }])
                            }, [T("h3", Wpe, $(de(s)("boosts.energy_boost")), 1), T("p", Ype, $(de(s)("boosts.energy_boost_description")), 1), T("div", Xpe, [(A(!0),
                                N(Ie, null, mt(a.value, p => (A(),
                                    fe(Wx, Ms({
                                        key: p.tier,
                                        ref_for: !0
                                    }, p, {
                                        onClick: m => h(p)
                                    }), null, 16, ["onClick"]))), 128))])], 2)]), u.value ? (A(),
                                        fe(al, {
                                            key: 0,
                                            class: "onboarding-block-hand"
                                        })) : te("", !0)]),
                    _: 1
                }, 8, ["isVisible", "isCloseDisabled"]))
        }
    }
    , xS = "/icons/icon-fortune-wheel.webp"
    , zo = Ds("fortuneWheel", {
        state: () => ({
            show: !1,
            wheel: null,
            wheels: [],
            rewardTypes: [],
            sponsors: []
        }),
        getters: {
            luckPercentage(t) {
                var e;
                return (e = t.wheelUserData) == null ? void 0 : e.luck_percentage
            },
            spinsWithoutJackpot(t) {
                var e;
                return (e = t.wheelUserData) == null ? void 0 : e.spins_without_jackpot
            },
            spinBalance(t) {
                var e;
                return ((e = t.wheelUserData) == null ? void 0 : e.spin_balance) || 0
            },
            wheelUserData(t) {
                var n;
                return Ye().getWheelUserData((n = t.wheel) == null ? void 0 : n.name)
            },
            spinsWithoutJackpotPercentage(t) {
                var e;
                return t.wheel ? ((e = t.wheelUserData) == null ? void 0 : e.spins_without_jackpot) / t.wheel.guaranteed_pitty * 100 : 0
            },
            isGuaranteedJackpot(t) {
                return t.spinsWithoutJackpotPercentage === 100
            }
        },
        actions: {
            decreaseSpinBalance() {
                this.setWheelUserData({
                    ...this.wheelUserData,
                    spin_balance: this.spinBalance - 1
                })
            },
            increaseSpinBalance(t) {
                this.setWheelUserData({
                    ...this.wheelUserData,
                    spin_balance: this.spinBalance + t
                })
            },
            setWheels(t) {
                this.wheels = t
            },
            setWheel(t) {
                var n;
                const e = this.wheels.find(s => s.name === t);
                if (e == null)
                    throw new Error(`There is no wheel with name ${t}`);
                this.wheel = e,
                    this.wheel.sectors = (n = this.wheel.sectors) == null ? void 0 : n.sort((s, r) => +s.position - +r.position)
            },
            setWheelUserData(t) {
                var n;
                Ye().setWheelUserData((n = this.wheel) == null ? void 0 : n.name, t)
            },
            getSponsorName(t) {
                var e;
                return (e = this.sponsors.find(n => n.id === t)) == null ? void 0 : e.name
            },
            setSponsors(t) {
                this.sponsors = t
            },
            setRewardTypes(t) {
                this.rewardTypes = t
            },
            async spinFortuneWheel() {
                var r;
                const t = Ye();
                this.decreaseSpinBalance();
                const { data: { reward: e, sector_id: n, user: s } } = await Ls({
                    action: async () => Bn(t.telegramAppFunctions, "spin_fortune_wheel_call")({
                        wheel_id: this.wheel.name
                    })
                }) || {
                    data: {
                        reward: null,
                        sector_id: null,
                        user: null
                    }
                };
                return t.setUserData(s),
                    this.setWheelUserData(s.fortune_wheels[(r = this.wheel) == null ? void 0 : r.name]),
                {
                    sector_id: n,
                    reward: e
                }
            }
        }
    })
    , zpe = T("img", {
        src: xS,
        class: "w-10 h-10"
    }, null, -1)
    , qpe = {
        __name: "FortuneWheelButton",
        setup(t) {
            const e = zo()
                , n = _s()
                , s = ve(() => e.spinBalance > 0)
                , r = () => {
                    n.isOnboardingInProgress && (e.setWheel(rd.STARTER),
                        n.goToNextStep()),
                        e.show = !0
                }
                ;
            return (i, o) => (A(),
                fe(hh, {
                    glow: "epic",
                    showNotification: s.value,
                    onClick: r
                }, {
                    default: Ce(() => [zpe]),
                    _: 1
                }, 8, ["showNotification"]))
        }
    }
    , Kpe = "/icons/icon-leaderboard.webp"
    , Jpe = T("img", {
        src: Kpe,
        class: "w-10 h-10"
    }, null, -1)
    , Zpe = {
        __name: "LeaderboardButton",
        setup(t) {
            const e = Ld()
                , n = Fn()
                , s = () => {
                    n.logEvent("open_leaderboard"),
                        e.push(ft.LEADERBOARD)
                }
                ;
            return (r, i) => (A(),
                fe(hh, {
                    glow: "legendary",
                    onClick: s
                }, {
                    default: Ce(() => [Jpe]),
                    _: 1
                }))
        }
    }
    , Qpe = 500
    , eme = {
        name: "SlapMainPage",
        components: {
            LeaderboardButton: Zpe,
            BoostOverlay: jpe,
            BoostCard: Gx,
            LevelUpButton: $pe,
            CharacteristicsPopup: Fpe,
            IconInfo: DL,
            AnimateGirlDisplay: qfe,
            DailyOverlay: yie,
            MainHeader: oc,
            MainFooter: jo,
            IconCapacity: Rse,
            CollectionsFooter: Ese,
            IconArrowLeft: Fx,
            BoostButton: Wse,
            TaskButton: Zse,
            PoseButton: ore,
            SlapGifts: Cre,
            IconHand: al,
            ActiveBoostStatus: Dse,
            FortuneWheelButton: qpe,
            ButtonPrimary: Lr
        },
        data() {
            return {
                showSlides: !0,
                slides: [{
                    title: this.$t("onboarding.slides.1.title"),
                    subtitle: this.$t("onboarding.slides.1.subtitle"),
                    image: "/onboarding/onboarding1.webp"
                }, {
                    title: this.$t("onboarding.slides.2.title"),
                    subtitle: this.$t("onboarding.slides.2.subtitle"),
                    image: "/onboarding/onboarding2.webp"
                }, {
                    title: this.$t("onboarding.slides.3.title"),
                    subtitle: this.$t("onboarding.slides.3.subtitle"),
                    image: "/onboarding/onboarding3.webp"
                }, {
                    title: this.$t("onboarding.slides.4.title"),
                    subtitle: this.$t("onboarding.slides.4.subtitle"),
                    image: "/onboarding/onboarding4.webp"
                }, {
                    title: this.$t("onboarding.slides.4.title"),
                    subtitle: this.$t("onboarding.slides.4.subtitle"),
                    image: "/onboarding/onboarding4.webp"
                }],
                activeSlideIndex: 0,
                interval: null,
                duration: 8e3,
                elapsedTime: 0,
                globalStore: Ye(),
                onboardingStore: _s(),
                girlsStore: ls(),
                timerStore: si(),
                boostsStore: Xs(),
                dailyClaimsStore: gf(),
                analyticsStore: Fn(),
                isPageReady: !1,
                accumulatedBalance: 0,
                balancePersistTimeout: null,
                wantSelectIndex: null,
                boobleText: "",
                boobleDisplayedText: "",
                boobleTextCurrentIndex: 0,
                boobleTypingSpeed: 25,
                forceShowBooble: !1,
                showNeedClickToNextButton: !1,
                isFirstTimeOnApp: !1,
                onboardingLastClickTime: 0,
                slapLastClickTime: 0,
                pickCoinsTriggered: 0,
                showDailyModal: !1,
                requestSlapQueue: [],
                isPickingCoinsInProgress: !1,
                isCharacteristicsModalOpen: !1,
                isChangePoseButtonHighlighted: !1
            }
        },
        computed: {
            ONBOARDING_STEPS() {
                return Be
            },
            progressWidth() {
                return `${this.elapsedTime / this.duration * 100}%`
            },
            isHelpPagesNotActive() {
                return !this.boostsStore.showBoostsOverlay && !this.globalStore.isGiftActivated
            },
            isHelpPagesNotActiveWithoutGift() {
                return !this.boostsStore.showBoostsOverlay
            },
            userData() {
                return this.globalStore.userData
            },
            selectedSlotIndex() {
                var t;
                return ((t = this.girlsStore.selectedGirl) == null ? void 0 : t.slot) || 0
            },
            activeGirlData() {
                var s;
                const t = this.girlsStore.getGirlBySlot(this.selectedSlotIndex);
                if (!t)
                    return {};
                const e = (s = _S(t).value) == null ? void 0 : s[0]
                    , n = Math.max(0, e.balance - this.accumulatedBalance);
                return {
                    ...e,
                    leftBalance: n
                }
            },
            girls() {
                return this.girlsStore.girlsInSlots
            },
            requireBooble() {
                var t;
                return ((t = this.onboardingStore.currentStep) == null ? void 0 : t.showGirlText) || this.forceShowBooble
            },
            hasActiveSlot() {
                return this.selectedSlotIndex !== null
            }
        },
        methods: {
            startSliding(t) {
                if (this.activeSlideIndex === 4) {
                    this.stopSlide();
                    return
                }
                this.elapsedTime = t || 0,
                    this.interval = setInterval(() => {
                        this.elapsedTime += 100,
                            this.elapsedTime >= this.duration && (this.onSlideRightClick(),
                                this.elapsedTime = 0)
                    }
                        , 100)
            },
            stopSlide() {
                clearInterval(this.interval),
                    this.interval = null
            },
            onSlideLeftClick() {
                this.activeSlideIndex = Math.max(0, this.activeSlideIndex - 1),
                    this.elapsedTime = 0
            },
            onSlideCenterStart() {
                this.stopSlide()
            },
            onSlideCenterEnd() {
                this.startSliding(this.elapsedTime)
            },
            onSlideRightClick() {
                this.activeSlideIndex = Math.min(4, this.activeSlideIndex + 1),
                    this.elapsedTime = 0,
                    this.activeSlideIndex === 4 ? setTimeout(() => {
                        this.showSlides = !1
                    }
                        , 300) : this.interval === null && this.startSliding()
            },
            onGiftUsed() {
                this.onboardingStore.isOnboardingInProgress && this.updateBooble(Be.USE_GIFT_2)
            },
            updateBooble(t, e = void 0) {
                var n;
                this.showNeedClickToNextButton = !1,
                    this.boobleDisplayedText = "",
                    this.boobleTextCurrentIndex = 0,
                    this.onboardingStore.setStep(t),
                    this.boobleText = this.$t(`onboarding.steps_bubbles.${t}`),
                    this.typeBoobleText(e, (n = this.onboardingStore.currentStep) == null ? void 0 : n.needClickToNextButton)
            },
            typeBoobleText(t, e) {
                this.boobleTextCurrentIndex < this.boobleText.length && (this.boobleDisplayedText += this.boobleText[this.boobleTextCurrentIndex],
                    this.boobleTextCurrentIndex++,
                    setTimeout(() => {
                        this.typeBoobleText(t, e)
                    }
                        , this.boobleTypingSpeed));
                const n = this.boobleTextCurrentIndex === this.boobleText.length;
                n && e && (this.showNeedClickToNextButton = !0),
                    t && n && t()
            },
            onGirlReady() {
                var t;
                this.$emit("ready"),
                    this.onboardingStore.isOnboardingInProgress && this.updateBooble((t = this.onboardingStore.currentStep) == null ? void 0 : t.stepId)
            },
            setFinalBoobleText() {
                this.boobleDisplayedText = this.boobleText,
                    this.boobleTextCurrentIndex = this.boobleText.length
            },
            onboardingClick() {
                var e, n;
                if ([Be.HI, Be.STASH_SLAP, Be.MAIN_RESOURCE, Be.PER_HOUR, Be.CANT_HOLD, Be.START_LESSON, Be.NICE].includes((e = this.onboardingStore.currentStep) == null ? void 0 : e.stepId)) {
                    if (this.boobleTextCurrentIndex < this.boobleText.length) {
                        this.setFinalBoobleText();
                        return
                    }
                    this.updateBooble((n = this.onboardingStore.nextStep) == null ? void 0 : n.stepId)
                }
            },
            onGiftBack() {
                this.globalStore.setIsGiftActivated(!1),
                    this.onboardingStore.isOnboardingInProgress && (this.boostsStore.profitBoosts.some(e => e.amount > 0) ? this.updateBooble(Be.USE_BOOST) : this.updateBooble(Be.SECOND_GIRL));
                const t = window.Telegram.WebApp.BackButton;
                t && !this.onboardingStore.isOnboardingInProgress && (t.hide(),
                    t.offClick(this.onGiftBack))
            },
            onGiftClick() {
                this.onboardingStore.isOnboardingInProgress && this.updateBooble(Be.USE_GIFT_1),
                    this.globalStore.setIsGiftActivated(!0),
                    this.analyticsStore.logEvent("open_gifts");
                const t = window.Telegram.WebApp.BackButton;
                t && !this.onboardingStore.isOnboardingInProgress && (t.show(),
                    t.onClick(this.onGiftBack))
            },
            onBoostBack() {
                this.boostsStore.setShowBoostsOverlay(!1),
                    this.setOffAppBackButton(this.onBoostBack)
            },
            onBoostApply(t) {
                const e = `tier-${t.tier}`;
                if (setTimeout(() => {
                    document.querySelector(".sl-layout__background").classList.add(e, "activated")
                }
                    , 200),
                    setTimeout(() => {
                        document.querySelector(".sl-layout__background").classList.remove(e, "activated")
                    }
                        , 700),
                    this.onboardingStore.isOnboardingInProgress)
                    this.updateBooble(Be.SECOND_GIRL);
                else if (t.type === ns.ENERGY) {
                    const n = this.$tm(`boosts.energy_boost_replica.${t.tier}`);
                    this.showTemporaryGirlHint(n[Math.floor(Math.random() * n.length)])
                }
            },
            onBoostClick() {
                if (this.onboardingStore.isOnboardingInProgress && this.updateBooble(Be.USE_BOOST_1),
                    this.selectedSlotIndex === null) {
                    this.globalStore.showModal(this.$t("main.validation.no_girl_in_slots"));
                    return
                }
                this.boostsStore.setShowBoostsOverlay(!0),
                    this.setAppBackButton(this.onBoostBack)
            },
            setAppBackButton(t) {
                const e = window.Telegram.WebApp.BackButton;
                e && !this.onboardingStore.isOnboardingInProgress && (e.show(),
                    e.onClick(t))
            },
            setOffAppBackButton(t) {
                const e = window.Telegram.WebApp.BackButton;
                e && !this.onboardingStore.isOnboardingInProgress && (e.hide(),
                    e.offClick(t))
            },
            showTemporaryGirlHint(t) {
                this.boobleText = t,
                    this.boobleDisplayedText = t,
                    this.forceShowBooble = !0,
                    clearTimeout(this.hideHintTimeout),
                    this.hideHintTimeout = setTimeout(() => {
                        this.boobleText = "",
                            this.boobleDisplayedText = "",
                            this.forceShowBooble = !1
                    }
                        , 4e3)
            },
            onPoseChange() {
                this.isChangePoseButtonHighlighted = !1;
                const t = this.activeGirlData.activePose + 1 <= this.activeGirlData.posesNum ? this.activeGirlData.activePose + 1 : 1;
                this.girlsStore.updateGirlRequest(this.activeGirlData.id, {
                    active_pose: t
                })
            },
            clickOnSlot(t) {
                var s;
                if (this.onboardingStore.isOnboardingInProgress && this.updateBooble(Be.SECOND_GIRL),
                    t !== this.selectedSlotIndex && this.accumulatedBalance && this.pickCoins(),
                    !(this.girlsStore.slotsByGirlIndexMap[t] === null)) {
                    if (this.selectedSlotIndex === t) {
                        this.wantSelectIndex = t,
                            this.$router.push(ft.GIRLS);
                        return
                    }
                    const r = (s = this.girlsStore.getGirlBySlot(t)) == null ? void 0 : s.id;
                    this.girlsStore.updateSelectedGirlId(r);
                    return
                }
                if (!this.girlsStore.girls.some(r => r.slot === null)) {
                    try {
                        this.globalStore.showModal(this.$t("main.validation.all_girls_in_slots"))
                    } catch {
                        alert(this.$t("main.validation.all_girls_in_slots"))
                    }
                    return
                }
                this.$router.push(ft.GIRLS)
            },
            async pickCoins() {
                if (this.isPickingCoinsInProgress)
                    return;
                this.isPickingCoinsInProgress = !0;
                const t = Bn(this.globalStore.telegramAppFunctions, "slap_pick_coins_call");
                try {
                    let e;
                    const n = this.selectedSlotIndex;
                    for (; this.accumulatedBalance > 0;) {
                        const s = this.accumulatedBalance;
                        if (this.accumulatedBalance = 0,
                            this.girlsStore.updateGirl(this.activeGirlData.id, {
                                balance: this.activeGirlData.balance - s,
                                timestamp: this.timerStore.unixTime
                            }),
                            e = await bk(() => t({
                                slot: n,
                                amount: s
                            }), {
                                retries: 3,
                                onFailedAttempt: r => {
                                    r.retriesLeft || No(r, {
                                        requestAmount: s,
                                        girlId: this.activeGirlData.id,
                                        girlCurrentBalance: this.activeGirlData.balance,
                                        girlTimestamp: this.activeGirlData.timestamp,
                                        requestTimestamp: Bo()
                                    }),
                                        !this.globalStore.isDevMode && r.retriesLeft === 0 && this.globalStore.showErrorModal()
                                }
                            }),
                            this.balancePersistTimeout)
                            break
                    }
                    if (this.accumulatedBalance === 0 && e && e.data.user.balance !== this.globalStore.balance)
                        throw new Error("balance unsync")
                } catch (e) {
                    No(e),
                        console.error("Failed to pick coins:", e)
                } finally {
                    this.isPickingCoinsInProgress = !1
                }
            },
            async onBack() {
                const t = window.Telegram.WebApp.BackButton;
                t && (t.hide(),
                    t.offClick(this.onBack))
            },
            onSlap() {
                var e;
                if (Math.floor(this.activeGirlData.leftBalance) <= 0)
                    return;
                const t = Math.min(this.activeGirlData.leftBalance, this.globalStore.slapPower);
                this.accumulatedBalance += t,
                    this.globalStore.setBalance(this.globalStore.balance + t),
                    this.balancePersistTimeout && clearTimeout(this.balancePersistTimeout),
                    this.balancePersistTimeout = setTimeout(() => {
                        this.balancePersistTimeout = null,
                            this.pickCoins()
                    }
                        , Qpe),
                    window.Telegram.WebApp.HapticFeedback.impactOccurred("heavy"),
                    ((e = this.onboardingStore.currentStep) == null ? void 0 : e.stepId) === Be.DONT_LEAVE && this.isSlapOnboardingCompleted() && this.updateBooble(Be.NICE, () => {
                        setTimeout(() => {
                            this.updateBooble(Be.GO_TO_WHEEL)
                        }
                            , 2500)
                    }
                    )
            },
            isSlapOnboardingCompleted() {
                const t = 19 * this.globalStore.baseSlapPower;
                return this.activeGirlData.leftBalance < this.activeGirlData.capacity - t
            },
            finishOnboarding() {
                this.globalStore.setIsNewUser(!1),
                    this.onboardingStore.finishOnboarding()
            },
            onTaskClick() {
                this.showDailyModal = !0,
                    this.onboardingStore.goToNextStep();
                const t = window.Telegram.WebApp.BackButton;
                t && !this.onboardingStore.isOnboardingInProgress && (t.show(),
                    t.onClick(this.onTaskBack))
            },
            onTaskBack() {
                this.dailyClaimsStore.ui.showPopup ? this.dailyClaimsStore.closeDailyRewardPopup() : this.showDailyModal = !1,
                    this.onboardingStore.isOnboardingInProgress && (this.updateBooble(Be.DONE),
                        setTimeout(() => {
                            this.finishOnboarding()
                        }
                            , 3e3));
                const t = window.Telegram.WebApp.BackButton;
                t && !this.onboardingStore.isOnboardingInProgress && (t.hide(),
                    t.offClick(this.onTaskBack))
            },
            onInfoClick() {
                this.isCharacteristicsModalOpen = !0
            },
            onInfoClose() {
                this.isCharacteristicsModalOpen = !1
            },
            onDisabledSlap() {
                this.isChangePoseButtonHighlighted = !0,
                    setTimeout(() => {
                        this.isChangePoseButtonHighlighted = !1
                    }
                        , 2e3)
            }
        },
        async mounted() {
            var t, e, n;
            if (document.querySelector(".sl-layout").classList.add("after-h-0", "before-h-180"),
                this.globalStore.setMainMenuHasNotification(!1),
                this.initialBackground = this.globalStore.globalBackground,
                this.globalStore.setGlobalBackground(this.initialBackground),
                ((t = this.onboardingStore.currentStep) == null ? void 0 : t.stepId) === Be.LOOTBOX_OPENED && ((e = this.globalStore.userData) != null && e.gifts)) {
                const s = this.globalStore.userData.gifts;
                s.common || s.rare || s.epic || s.legendary ? this.updateBooble(Be.USE_GIFT) : this.boostsStore.profitBoosts.some(r => r.amount > 0) ? this.updateBooble(Be.USE_BOOST) : this.updateBooble(Be.SECOND_GIRL)
            }
            ((n = this.onboardingStore.currentStep) == null ? void 0 : n.stepId) === Be.SECOND_GIRL_EQUIPPED && this.updateBooble(Be.GO_EARN)
        },
        unmounted() {
            this.stopSlide(),
                document.querySelector(".sl-layout").classList.remove("after-h-0", "before-h-180"),
                clearInterval(this.interval);
            const t = window.Telegram.WebApp.BackButton;
            t && (t.hide(),
                t.offClick(this.onBack))
        },
        watch: {
            "globalStore.isNewUser"(t) {
                console.log(`globalStore.isNewUser watch triggered, new value: ${t}`),
                    t && this.startSliding()
            },
            isCollectionActivated(t) {
                var n;
                const e = (n = window.Telegram.WebApp) == null ? void 0 : n.BackButton;
                t ? this.globalStore.isNewUser || (e.show(),
                    e.onClick(this.onBack)) : (e.hide(),
                        e.offClick(this.onBack))
            },
            "dailyClaimsStore.dayStreak"(t, e) {
                t === 1 && e === 0 && this.onboardingStore.isOnboardingInProgress && (this.dailyClaimsStore.closeDailyRewardPopup(),
                    this.onTaskBack())
            }
        }
    }
    , tme = t => (Wo("data-v-7c9b5022"),
        t = t(),
        Yo(),
        t)
    , nme = {
        key: 0,
        class: "sl-main-page__slides"
    }
    , sme = {
        class: "sl-main-page__slides-progress"
    }
    , rme = {
        class: "sl-main-page__slides-progress-item"
    }
    , ime = {
        class: "sl-main-page__slides-item"
    }
    , ome = {
        class: "sl-main-page__slides-title"
    }
    , ame = {
        key: 0
    }
    , lme = {
        class: "sl-main-page__capacity-right"
    }
    , cme = {
        class: "sl-main-page__capacity-value"
    }
    , ume = tme(() => T("img", {
        class: "mr-1 w-[24px] h-[24px]",
        src: S4,
        alt: ""
    }, null, -1))
    , hme = {
        class: "font-bold text-coin"
    }
    , dme = {
        class: "ml-2"
    };
function fme(t, e, n, s, r, i) {
    var C, I, L;
    const o = q("IconHand")
        , l = q("AnimateGirlDisplay")
        , a = q("MainFooter")
        , c = q("MainHeader")
        , u = q("CollectionsFooter")
        , h = q("PoseButton")
        , d = q("FortuneWheelButton")
        , f = q("LeaderboardButton")
        , p = q("BoostButton")
        , m = q("LevelUpButton")
        , g = q("TaskButton")
        , b = q("ActiveBoostStatus")
        , v = q("IconInfo")
        , _ = q("CharacteristicsPopup")
        , y = q("DailyOverlay")
        , x = q("BoostOverlay")
        , w = q("SlapGifts")
        , S = q("IconArrowLeft")
        , E = q("ButtonPrimary");
    return A(),
        N("div", {
            class: Te(["sl-main-page", [`sl-main-page--onboarding-step-${(C = r.onboardingStore.currentStep) == null ? void 0 : C.stepId}`, r.onboardingStore.isOnboardingInProgress && r.showSlides ? "" : "is-not-new-user"]])
        }, [r.onboardingStore.isOnboardingInProgress && r.showSlides && ((I = r.onboardingStore.currentStep) == null ? void 0 : I.stepId) === i.ONBOARDING_STEPS.HI ? (A(),
            N("div", nme, [T("div", sme, [(A(!0),
                N(Ie, null, mt(r.slides, (k, R) => (A(),
                    N("div", rme, [T("div", {
                        class: Te(["sl-main-page__slides-progress-item-inner", {
                            "is-full": r.activeSlideIndex > R,
                            "not-started": r.activeSlideIndex < R
                        }]),
                        style: Wt({
                            width: i.progressWidth
                        })
                    }, null, 6)]))), 256))]), (A(!0),
                        N(Ie, null, mt(r.slides, (k, R) => (A(),
                            N("div", ime, [R === r.activeSlideIndex ? (A(),
                                N(Ie, {
                                    key: 0
                                }, [T("div", ome, $(k.title), 1), T("div", {
                                    class: "sl-main-page__slides-image",
                                    style: Wt({
                                        backgroundImage: `url('${k.image}')`
                                    })
                                }, null, 4)], 64)) : te("", !0)]))), 256)), T("div", {
                                    class: "sl-main-page__slides-button-left",
                                    onClick: e[0] || (e[0] = (...k) => i.onSlideLeftClick && i.onSlideLeftClick(...k))
                                }), T("div", {
                                    class: "sl-main-page__slides-button-center",
                                    onTouchstart: e[1] || (e[1] = (...k) => i.onSlideCenterStart && i.onSlideCenterStart(...k)),
                                    onTouchend: e[2] || (e[2] = (...k) => i.onSlideCenterEnd && i.onSlideCenterEnd(...k))
                                }, null, 32), T("div", {
                                    class: "sl-main-page__slides-button-right",
                                    onClick: e[3] || (e[3] = (...k) => i.onSlideRightClick && i.onSlideRightClick(...k))
                                })])) : te("", !0), r.onboardingStore.isOnboardingInProgress ? (A(),
                                    N("div", {
                                        key: 1,
                                        class: "sl-main-page__onboarding-block",
                                        onClick: e[4] || (e[4] = (...k) => i.onboardingClick && i.onboardingClick(...k))
                                    }, [T("div", {
                                        class: Te([{
                                            "opacity-0 invisible": !r.showNeedClickToNextButton
                                        }, "sl-main-page__onboarding-block-text"])
                                    }, $(t.$t("onboarding.press_to_continue")), 3)])) : te("", !0), r.onboardingStore.isOnboardingInProgress ? (A(),
                                        fe(o, {
                                            key: 2,
                                            class: Te([{
                                                "want-select": r.wantSelectIndex
                                            }, "sl-main-page__onboarding-block-hand"])
                                        }, null, 8, ["class"])) : te("", !0), T("div", {
                                            class: Te(["sl-main-page__girl transition-[0.3s]", {
                                                "opacity-0 invisible": !i.hasActiveSlot,
                                                "pointer-events-none": r.globalStore.isGiftActivated
                                            }])
                                        }, [i.activeGirlData ? (A(),
                                            fe(l, {
                                                key: 0,
                                                activeGirl: i.activeGirlData,
                                                hint: i.requireBooble ? r.boobleDisplayedText : void 0,
                                                onSlap: i.onSlap,
                                                onReady: i.onGirlReady,
                                                onOnDisabledSlap: i.onDisabledSlap
                                            }, null, 8, ["activeGirl", "hint", "onSlap", "onReady", "onOnDisabledSlap"])) : te("", !0)], 2), G(is, {
                                                name: "fade"
                                            }, {
                                                default: Ce(() => [i.isHelpPagesNotActive ? (A(),
                                                    fe(a, {
                                                        key: 0,
                                                        class: "will-change-auto",
                                                        "has-actions": ""
                                                    })) : te("", !0)]),
                                                _: 1
                                            }), G(is, {
                                                name: "fade"
                                            }, {
                                                default: Ce(() => [i.isHelpPagesNotActive ? (A(),
                                                    N("div", ame, [G(c), G(u, {
                                                        "selected-slot-index": i.selectedSlotIndex,
                                                        onClickOnIndex: i.clickOnSlot
                                                    }, null, 8, ["selected-slot-index", "onClickOnIndex"]), i.activeGirlData.posesNum > 1 ? (A(),
                                                        fe(h, {
                                                            key: 0,
                                                            highlighted: r.isChangePoseButtonHighlighted,
                                                            class: "sl-main-page__pose top-[80px] right-4",
                                                            onClick: i.onPoseChange
                                                        }, null, 8, ["highlighted", "onClick"])) : te("", !0), G(d, {
                                                            class: "sl-main-page__fortune-wheel top-[144px] right-4"
                                                        }), G(f, {
                                                            class: "sl-main-page__leaderboard top-[208px] right-4"
                                                        }), G(p, {
                                                            class: "sl-main-page__boost fixed bottom-[228px] right-4",
                                                            onClick: i.onBoostClick
                                                        }, null, 8, ["onClick"]), G(m, {
                                                            class: "sl-main-page__gift fixed bottom-[164px] right-4",
                                                            onClick: i.onGiftClick
                                                        }, null, 8, ["onClick"]), G(g, {
                                                            class: "sl-main-page__task fixed bottom-[100px] right-4",
                                                            onClick: i.onTaskClick
                                                        }, null, 8, ["onClick"]), G(b, {
                                                            class: "fixed bottom-[150px] left-4 z-[5]"
                                                        })])) : te("", !0)]),
                                                _: 1
                                            }), i.isHelpPagesNotActiveWithoutGift && i.userData && i.girls[i.selectedSlotIndex] ? (A(),
                                                N("div", {
                                                    key: 3,
                                                    class: Te(["sl-main-page__capacity backdrop-blur-md", {
                                                        "sl-main-page__capacity--for-gifts": r.globalStore.isGiftActivated
                                                    }])
                                                }, [T("div", lme, [T("div", cme, [ume, T("span", hme, $(i.activeGirlData.leftBalance) + " / " + $(i.activeGirlData.capacity), 1)]), T("div", {
                                                    class: Te(["sl-main-page__capacity-recovery", {
                                                        "sl-main-page__capacity-recovery--bonused": ((L = i.activeGirlData.boosts.profit) == null ? void 0 : L.end_timestamp) > r.timerStore.unixTime
                                                    }])
                                                }, " (+" + $(Math.round(i.activeGirlData.perHour)) + "/" + $(t.$t("hour_short")) + ") ", 3), T("div", dme, [G(v, {
                                                    onClick: i.onInfoClick
                                                }, null, 8, ["onClick"])])])], 2)) : te("", !0), G(_, {
                                                    "is-visible": r.isCharacteristicsModalOpen,
                                                    close: i.onInfoClose
                                                }, null, 8, ["is-visible", "close"]), r.showDailyModal ? (A(),
                                                    fe(y, {
                                                        key: 4,
                                                        isVisible: r.showDailyModal,
                                                        onClose: i.onTaskBack,
                                                        class: "daily-overlay"
                                                    }, null, 8, ["isVisible", "onClose"])) : te("", !0), G(x, {
                                                        isVisible: r.boostsStore.showBoostsOverlay,
                                                        onClose: i.onBoostBack,
                                                        onConfirm: i.onBoostApply
                                                    }, null, 8, ["isVisible", "onClose", "onConfirm"]), G(w, {
                                                        isGiftActivated: r.globalStore.isGiftActivated,
                                                        onBack: i.onGiftBack,
                                                        onGiftUsed: i.onGiftUsed
                                                    }, null, 8, ["isGiftActivated", "onBack", "onGiftUsed"]), G(is, {
                                                        name: "fade"
                                                    }, {
                                                        default: Ce(() => [r.globalStore.isGiftActivated ? (A(),
                                                            fe(E, {
                                                                key: 0,
                                                                class: "sl-main-page__actions sl-main-page__actions-item--back !w-auto",
                                                                type: "dark",
                                                                size: "l",
                                                                onClick: i.onGiftBack
                                                            }, {
                                                                default: Ce(() => [G(S, {
                                                                    class: "mr-1"
                                                                }), Fe(" " + $(t.$t("common.back")), 1)]),
                                                                _: 1
                                                            }, 8, ["onClick"])) : te("", !0)]),
                                                        _: 1
                                                    })], 2)
}
const pme = _e(eme, [["render", fme], ["__scopeId", "data-v-7c9b5022"]])
    , mme = {
        name: "SlapEarnTabs",
        props: {
            items: Array,
            selectedTab: String
        }
    }
    , gme = {
        class: "slap-earn-tabs flex justify-around"
    }
    , _me = ["onClick"];
function yme(t, e, n, s, r, i) {
    return A(),
        N("div", gme, [(A(!0),
            N(Ie, null, mt(n.items, o => (A(),
                N("div", {
                    class: Te(["slap-earn-tabs__item", {
                        "slap-earn-tabs__item--active": o.title === n.selectedTab
                    }]),
                    key: o.title,
                    onClick: l => t.$emit("select", o.title)
                }, $(o.title), 11, _me))), 128))])
}
const bme = _e(mme, [["render", yme], ["__scopeId", "data-v-a3401862"]])
    , vme = {
        name: "SlapEarnBody",
        components: {
            EarnTabs: bme
        },
        data() {
            return {
                tabItems: [{
                    title: "Academy"
                }, {
                    title: "Ministerium"
                }, {
                    title: "Specials"
                }],
                selectedTab: "Academy"
            }
        },
        methods: {
            changeSelectTab(t) {
                this.selectedTab = t
            }
        }
    }
    , xme = {
        class: "slap-earn-body"
    };
function wme(t, e, n, s, r, i) {
    const o = q("EarnTabs");
    return A(),
        N("div", xme, [G(o, {
            items: r.tabItems,
            "selected-tab": r.selectedTab,
            onSelect: i.changeSelectTab
        }, null, 8, ["items", "selected-tab", "onSelect"])])
}
const Sme = _e(vme, [["render", wme], ["__scopeId", "data-v-b7293cf3"]])
    , Eme = {
        name: "SlapEarnPage",
        emits: ["ready"],
        components: {
            MainHeader: oc,
            MainFooter: jo,
            EarnBody: Sme
        },
        mounted() {
            this.$emit("ready")
        }
    }
    , Tme = {
        class: "slap-earn-page"
    };
function Cme(t, e, n, s, r, i) {
    const o = q("MainHeader")
        , l = q("EarnBody")
        , a = q("MainFooter");
    return A(),
        N("div", Tme, [G(o, {
            "no-level": "",
            "no-buttons": ""
        }), G(l, {
            class: "slap-earn-page__body overflow auto"
        }), G(a)])
}
const Ime = _e(Eme, [["render", Cme]])
    , Ef = {
        methods: {
            redirectToMainPage() {
                this.$router.push(ft.MAIN)
            },
            _defaultBackButtonHandler() {
                this.redirectToMainPage()
            },
            replaceBackButtonHandler(t) {
                const e = window.Telegram.WebApp.BackButton;
                e && (e.offClick(this._defaultBackButtonHandler),
                    e.onClick(t))
            },
            resetBackButtonHandler(t) {
                const e = window.Telegram.WebApp.BackButton;
                e && (e.offClick(t),
                    e.onClick(this._defaultBackButtonHandler))
            }
        },
        data() {
            return {
                onboardingStore: _s()
            }
        },
        mounted() {
            const t = window.Telegram.WebApp.BackButton;
            t && !this.onboardingStore.isOnboardingInProgress && (t.show(),
                t.onClick(this._defaultBackButtonHandler))
        },
        unmounted() {
            const t = window.Telegram.WebApp.BackButton;
            t && (t.hide(),
                t.offClick(this._defaultBackButtonHandler))
        }
    }
    , Ame = {
        name: "CountdownTimer",
        props: {
            targetDate: {
                type: Date,
                required: !0
            },
            noMonth: {
                type: Boolean,
                required: !1
            }
        },
        data() {
            return {
                intervalId: null,
                months: 0,
                days: 0,
                hours: 0,
                minutes: 0,
                seconds: 0
            }
        },
        mounted() {
            this.startTimer()
        },
        beforeUnmount() {
            this.stopTimer()
        },
        methods: {
            startTimer() {
                this.updateTimer(),
                    this.intervalId = setInterval(() => {
                        this.updateTimer()
                    }
                        , 1e3)
            },
            stopTimer() {
                clearInterval(this.intervalId)
            },
            updateTimer() {
                const t = new Date
                    , n = new Date(this.targetDate).getTime() - t.getTime();
                if (n <= 0) {
                    this.stopTimer(),
                        this.months = 0,
                        this.days = 0,
                        this.hours = 0,
                        this.minutes = 0,
                        this.seconds = 0;
                    return
                }
                const s = Math.floor(n / 1e3);
                if (this.seconds = s % 60,
                    this.minutes = Math.floor(s / 60) % 60,
                    this.hours = Math.floor(s / 3600) % 24,
                    this.noMonth) {
                    const r = Math.floor(s / 60);
                    this.days = Math.floor(r / 1440)
                } else
                    this.days = Math.floor(s / 86400) % 30,
                        this.months = Math.floor(s / 2592e3)
            }
        }
    }
    , kme = t => (Wo("data-v-e6162323"),
        t = t(),
        Yo(),
        t)
    , Rme = {
        key: 0,
        class: "slap-countdown__item"
    }
    , Mme = {
        class: "slap-countdown__value"
    }
    , Pme = kme(() => T("span", {
        class: "slap-countdown__label"
    }, "Mo", -1))
    , Lme = {
        class: "slap-countdown__item"
    }
    , Ome = {
        class: "slap-countdown__value"
    }
    , Nme = {
        class: "slap-countdown__label"
    }
    , Dme = {
        class: "slap-countdown__item"
    }
    , Bme = {
        class: "slap-countdown__value"
    }
    , Fme = {
        class: "slap-countdown__label"
    }
    , $me = {
        class: "slap-countdown__item"
    }
    , Ume = {
        class: "slap-countdown__value"
    }
    , Vme = {
        class: "slap-countdown__label"
    }
    , Gme = {
        class: "slap-countdown__item"
    }
    , Hme = {
        class: "slap-countdown__value"
    }
    , Wme = {
        class: "slap-countdown__label"
    };
function Yme(t, e, n, s, r, i) {
    return A(),
        N("div", {
            class: Te(["slap-countdown", {
                "slap-countdown--no-month": n.noMonth
            }])
        }, [n.noMonth ? te("", !0) : (A(),
            N("div", Rme, [T("span", Mme, $(r.months < 10 ? `0${r.months}` : r.months), 1), Pme])), T("div", Lme, [T("span", Ome, $(r.days < 10 ? `0${r.days}` : r.days), 1), T("span", Nme, [n.noMonth ? (A(),
                N(Ie, {
                    key: 0
                }, [Fe("D")], 64)) : (A(),
                    N(Ie, {
                        key: 1
                    }, [Fe("Day")], 64))])]), T("div", Dme, [T("span", Bme, $(r.hours < 10 ? `0${r.hours}` : r.hours), 1), T("span", Fme, [n.noMonth ? (A(),
                        N(Ie, {
                            key: 0
                        }, [Fe("H")], 64)) : (A(),
                            N(Ie, {
                                key: 1
                            }, [Fe("Hr")], 64))])]), T("div", $me, [T("span", Ume, $(r.minutes < 10 ? `0${r.minutes}` : r.minutes), 1), T("span", Vme, [n.noMonth ? (A(),
                                N(Ie, {
                                    key: 0
                                }, [Fe("M")], 64)) : (A(),
                                    N(Ie, {
                                        key: 1
                                    }, [Fe("Min")], 64))])]), T("div", Gme, [T("span", Hme, $(r.seconds < 10 ? `0${r.seconds}` : r.seconds), 1), T("span", Wme, [n.noMonth ? (A(),
                                        N(Ie, {
                                            key: 0
                                        }, [Fe("S")], 64)) : (A(),
                                            N(Ie, {
                                                key: 1
                                            }, [Fe("Sec")], 64))])])], 2)
}
const BL = _e(Ame, [["render", Yme], ["__scopeId", "data-v-e6162323"]])
    , Xme = {
        name: "Tabs",
        components: {
            NotificationDot: Vm
        },
        props: {
            tabs: {
                type: Array,
                required: !0
            },
            selectedTabId: {
                type: String,
                required: !0
            }
        },
        emits: ["changeTab"],
        methods: {
            onChangeTab(t) {
                this.$emit("changeTab", t)
            }
        }
    }
    , jme = {
        class: "shrink-0 bg-white/5 rounded-lg inline-flex justify-center items-center p-0.5 gap-0.5 overflow-hidden"
    }
    , zme = ["onClick"];
function qme(t, e, n, s, r, i) {
    const o = q("NotificationDot");
    return A(),
        N("div", jme, [(A(!0),
            N(Ie, null, mt(n.tabs, l => (A(),
                N("div", {
                    key: l.id,
                    class: Te(["px-2 py-2 grow shrink basis-0 inline-flex justify-center rounded-lg items-center text-white/80 text-base cursor-pointer whitespace-nowrap text-overflow-ellipsis relative", {
                        "bg-white/10 font-semibold text-white": l.id === n.selectedTabId
                    }]),
                    onClick: a => i.onChangeTab(l.id)
                }, [l.hasNotification ? (A(),
                    fe(o, {
                        key: 0,
                        class: "right-0.5 top-1 bg-red-600"
                    })) : te("", !0), Fe(" " + $(l.title), 1)], 10, zme))), 128))])
}
const wS = _e(Xme, [["render", qme]])
    , Kme = "/icons/icon-new.webp"
    , Jme = {
        name: "Card",
        components: {
            IconInfo: DL,
            Glow: gr,
            Blik: Ki,
            IconCoin: dn
        },
        props: {
            id: {
                type: String
            },
            image: {
                type: String,
                required: !0
            },
            name: {
                type: String
            },
            price: {
                type: Number,
                default: 0
            },
            tier: {
                type: String,
                default: "common",
                validator: t => ["common", "rare", "epic", "legendary"].includes(t)
            },
            isNew: {
                type: Boolean,
                default: !1
            },
            disabled: {
                type: Boolean,
                default: !1
            },
            dimmed: {
                type: Boolean,
                default: !1
            },
            icon: {
                type: Object,
                default: dn
            },
            glow: {
                type: Boolean,
                default: !0
            },
            showHelpIcon: {
                type: Boolean,
                default: !1,
                required: !1
            }
        },
        emits: ["click", "onHelpIconClick"],
        setup(t, { emit: e }) {
            const { isPressed: n, handlePressStart: s, handlePressEnd: r, handlePressCancel: i } = uh({
                onPressEnd: () => {
                    t.disabled ? ur("error") : (a(),
                        e("click"),
                        ur("medium"))
                }
            })
                , o = ke(!1)
                , l = ke(Xt(t.price))
                , a = () => {
                    o.value = !0,
                        setTimeout(() => {
                            o.value = !1
                        }
                            , 180)
                }
                ;
            return {
                isBlikActive: o,
                isPressed: n,
                handlePressStart: s,
                handlePressEnd: r,
                handlePressCancel: i,
                formattedPrice: l,
                onHelpIconClick: u => {
                    u.stopPropagation(),
                        e("onHelpIconClick", t.id)
                }
            }
        }
    }
    , Zme = T("div", {
        class: "pt-[100%]"
    }, null, -1)
    , Qme = {
        key: 2,
        class: "absolute top-8 right-1 z-10"
    }
    , ege = T("img", {
        class: "w-11 h-11",
        src: Kme
    }, null, -1)
    , tge = [ege]
    , nge = ["src"]
    , sge = T("div", {
        class: "absolute inset-x-0 bottom-0 h-12 bg-gradient-to-b from-transparent to-black/90 z-10"
    }, null, -1)
    , rge = {
        class: "text-center text-white text-xxs font-semibold leading-3 h-3 relative z-20"
    }
    , ige = {
        class: "absolute bottom-0 inset-x-0"
    }
    , oge = {
        class: "px-2 py-[3px] bg-white/5 rounded-3xl border border-white/5 text-white font-semibold leading-tight relative z-20 backdrop-blur-sm"
    };
function age(t, e, n, s, r, i) {
    const o = q("Glow")
        , l = q("IconInfo")
        , a = q("Blik")
        , c = mr("bounce");
    return vn((A(),
        N("div", {
            class: Te(["card overflow-hidden flex flex-col gap-1 relative bg-black/60 rounded-lg border border-white/5 px-2 py-3 transform transition-transform duration-200", {
                "scale-95 bg-white/10": s.isPressed && !n.disabled,
                "border-white/1": n.disabled || n.dimmed
            }]),
            onPointerdown: e[4] || (e[4] = (...u) => s.handlePressStart && s.handlePressStart(...u)),
            onPointerup: e[5] || (e[5] = (...u) => s.handlePressEnd && s.handlePressEnd(...u)),
            onPointermove: e[6] || (e[6] = (...u) => s.handlePressCancel && s.handlePressCancel(...u)),
            onPointerleave: e[7] || (e[7] = (...u) => s.handlePressCancel && s.handlePressCancel(...u))
        }, [n.glow ? (A(),
            fe(o, {
                key: 0,
                class: "self-center",
                blur: s.isPressed && !n.disabled ? "20" : "23",
                tier: n.tier
            }, null, 8, ["blur", "tier"])) : te("", !0), Zme, n.showHelpIcon ? (A(),
                N("div", {
                    key: 1,
                    class: "absolute right-[5px] top-[5px] text-white/[.48] z-10",
                    onClick: e[0] || (e[0] = (...u) => s.onHelpIconClick && s.onHelpIconClick(...u)),
                    onPointerdown: e[1] || (e[1] = ni(() => { }
                        , ["stop"])),
                    onPointerup: e[2] || (e[2] = ni(() => { }
                        , ["stop"])),
                    onPointerleave: e[3] || (e[3] = ni(() => { }
                        , ["stop"]))
                }, [G(l)], 32)) : te("", !0), n.isNew ? (A(),
                    N("div", Qme, tge)) : te("", !0), T("img", {
                        src: n.image,
                        loading: "lazy",
                        alt: "Card image",
                        class: "absolute top-0 inset-x-0 rounded w-full object-contain object-top"
                    }, null, 8, nge), sge, G(a, {
                        isBlikActive: s.isBlikActive
                    }, null, 8, ["isBlikActive"]), T("div", rge, [rs(t.$slots, "name", {}, () => [T("span", ige, $(n.name), 1)])]), T("div", oge, [T("span", {
                        class: Te(["flex justify-center items-center gap-1", {
                            "opacity-30": n.disabled || n.dimmed
                        }])
                    }, [rs(t.$slots, "button", {}, () => [(A(),
                        fe(Kl(n.icon), {
                            class: "w-4 h-4"
                        })), T("span", null, $(s.formattedPrice), 1)])], 2)])], 34)), [[c, {
                            enabled: !1,
                            startAnimation: s.isPressed && n.disabled
                        }]])
}
const SS = _e(Jme, [["render", age]])
    , Wh = {
        ANIMATION_OPEN_START_TIME: .01,
        ANIMATION_OPEN_END_TIME: .6,
        ANIMATION_TRANSITION_TO_CARDS_TIME: 1.5,
        ANIMATION_HINT_END_TIME: .15
    }
    , lge = "/shop/animation/open_lootbox/spine.json"
    , cge = 150
    , uge = 956
    , hge = 1700
    , dge = 2e3
    , DA = {
        [Dt.STANDARD]: "lootbox-common",
        [Dt.ADVANCED]: "lootbox-rare",
        [Dt.PREMIUM]: "lootbox-epic",
        [Dt.ULTRA_PREMIUM]: "lootbox-legendary",
        [Dt.BASIC_STAR]: "lootbox-basic-star",
        [Dt.DELUXE_STAR]: "lootbox-deluxe-star",
        [Dt.ELITE_STAR]: "lootbox-epic-star",
        [Dt.PREMIUM_STAR]: "lootbox-premium-star",
        [Dt.REFERRAL_BOX_STANDARD]: "lootbox-basic-star",
        [Dt.REFERRAL_BOX_PREMIUM]: "lootbox-basic-star",
        [Dt.STARTER_RARE]: "lootbox-rare",
        [Dt.STARTER_EPIC]: "lootbox-epic",
        [Dt.STARTER_LEGENDARY]: "lootbox-legendary"
    }
    , fge = (t, e) => Math.min(t / uge, e / hge)
    , pge = t => {
        const { ANIMATION_OPEN_START_TIME: e, ANIMATION_OPEN_END_TIME: n } = Wh;
        return e + t * (n - e)
    }
    , mge = ({ onComplete: t, type: e }) => {
        let n, s, r = 0, i = !1, o = 1, l = null;
        setTimeout(() => {
            l === null && (l = !0)
        }
            , dge);
        const a = async f => {
            n = new gS({
                backgroundAlpha: 0,
                resizeTo: window,
                resolution: window.devicePixelRatio
            }),
                f.appendChild(n.view);
            const p = await ru.load(lge);
            s = new _L(p.spineData),
                e && s.skeleton.data.findSkin(DA[e]) ? (s.skeleton.setSkinByName(DA[e]),
                    s.skeleton.setSlotsToSetupPose()) : console.warn(`Skin for '${e}' not found. Using default skin.`);
            const m = s.getLocalBounds();
            s.pivot.set(m.x + m.width / 2, m.y + m.height / 2 + 50),
                u(),
                n.stage.addChild(s);
            const g = s.state.setAnimation(0, "animation", !1);
            s.state.timeScale = 0,
                n.ticker.add(() => {
                    l && c(g),
                        s.state.timeScale < 0 && g.trackTime <= Wh.ANIMATION_OPEN_START_TIME && (g.trackTime = 0,
                            s.state.timeScale = 0),
                        g.trackTime >= Wh.ANIMATION_TRANSITION_TO_CARDS_TIME && !i && (i = !0,
                            t == null || t())
                }
                ),
                s.state.addListener({
                    complete: () => {
                        n.stop()
                    }
                })
        }
            , c = f => {
                f.trackTime += o * .002,
                    f.trackTime >= Wh.ANIMATION_HINT_END_TIME ? o = -1 : f.trackTime <= Wh.ANIMATION_OPEN_START_TIME && (o = 1)
            }
            , u = () => {
                if (!(s != null && s.state))
                    return;
                const f = 30;
                n.renderer.resize(window.innerWidth, window.innerHeight),
                    s.position.set(n.screen.width / 2, n.screen.height / 2 - f);
                const p = fge(window.innerWidth, window.innerHeight);
                s.scale.set(p, p)
            }
            , h = f => {
                if (!(s != null && s.state))
                    return;
                l && (l = !1);
                const p = Math.max(0, Math.min(f / cge, 1));
                if (r = Math.min(p, 1),
                    s.state.timeScale === 1)
                    return;
                const m = s.state.getCurrent(0);
                if (!m)
                    throw new Error("Animation not found");
                r === 1 ? s.state.timeScale = 1 : (s.state.timeScale = 0,
                    m.trackTime = pge(r))
            }
            , d = () => {
                s != null && s.state && r < 1 && (s.state.timeScale = -1,
                    r = 0)
            }
            ;
        return Or(() => {
            window.addEventListener("resize", u)
        }
        ),
            Gg(() => {
                n == null || n.stop(),
                    n == null || n.destroy(),
                    window.removeEventListener("resize", u)
            }
            ),
        {
            initialize: a,
            handleSwipe: h,
            handleSwipeEnd: d
        }
    }
    , xh = t => t ? {
        ...$x(t),
        backgroundClip: "text",
        WebkitBackgroundClip: "text",
        WebkitTextFillColor: "transparent"
    } : {}
    , gge = {
        name: "LootboxCardTitle",
        methods: {
            formattingPrice: Xt
        },
        props: {
            type: {
                type: String,
                required: !0,
                validator: t => ["gift", "coins", "girl", "profit_boost", "energy_boost"].includes(t)
            },
            tier: {
                type: String,
                validator: t => ["common", "rare", "epic", "legendary"].includes(t)
            },
            amount: Number,
            girl_id: String
        },
        setup(t) {
            const { t: e } = gt()
                , n = ve(() => ls().getGirlById(t.girl_id))
                , s = Ye().gifts
                , r = ve(() => t.tier || (n == null ? void 0 : n.tier))
                , i = ve(() => xh(r.value));
            return {
                t: e,
                gradientStyle: i,
                girl: n,
                tier: r,
                gifts: s
            }
        }
    }
    , _ge = {
        class: "text-center text-xl font-semibold"
    }
    , yge = {
        class: "text-white"
    }
    , bge = {
        key: 0,
        class: "text-white/80 text-xs font-normal capitalize"
    };
function vge(t, e, n, s, r, i) {
    return A(),
        N("div", _ge, [T("p", yge, $(s.t("lootbox_popup.prize")), 1), T("p", {
            style: Wt(s.gradientStyle),
            class: Te(["text-4xl italic font-black leading-10 capitalize pr-1.5", {
                "text-coin": n.type === "coins"
            }])
        }, [n.type === "gift" ? (A(),
            N(Ie, {
                key: 0
            }, [Fe($(s.t("lootbox_popup.prize_exp", {
                exp: s.gifts[s.tier]
            })), 1)], 64)) : n.type === "coins" ? (A(),
                N(Ie, {
                    key: 1
                }, [Fe(" +" + $(i.formattingPrice(n.amount)), 1)], 64)) : n.type === "girl" ? (A(),
                    N(Ie, {
                        key: 2
                    }, [Fe($(t.$t(`girls.names.${s.girl.name}`)), 1)], 64)) : n.type === "energy_boost" ? (A(),
                        N(Ie, {
                            key: 3
                        }, [Fe($(s.t("lootbox_popup.prize_energy_boost")), 1)], 64)) : n.type === "profit_boost" ? (A(),
                            N(Ie, {
                                key: 4
                            }, [Fe($(s.t("lootbox_popup.prize_profit_boost")), 1)], 64)) : te("", !0)], 6), n.type === "girl" ? (A(),
                                N("span", bge, $(t.$t(`girls.collections.${s.girl.collection}`)), 1)) : te("", !0)])
}
const xge = _e(gge, [["render", vge]])
    , wge = {
        name: "ButtonSecondary",
        props: {
            label: {
                type: String,
                required: !0
            },
            icon: {
                type: Object,
                default: null
            }
        }
    }
    , Sge = {
        class: "flex flex-row justify-center items-center px-4 py-3 gap-1 w-[168.5px] h-[44px] bg-white/[.06] border border-white[/.04] backdrop-blur-md rounded-3xl"
    }
    , Ege = {
        key: 0
    }
    , Tge = {
        class: "font-semibold text-base leading-5 text-white"
    };
function Cge(t, e, n, s, r, i) {
    return A(),
        N("button", Sge, [n.icon ? (A(),
            N("span", Ege, [(A(),
                fe(Kl(n.icon), {
                    class: "fill-white"
                }))])) : te("", !0), T("span", Tge, $(n.label), 1)])
}
const FL = _e(wge, [["render", Cge]])
    , Ige = {}
    , Age = {
        width: "21",
        height: "20",
        viewBox: "0 0 21 20",
        xmlns: "http://www.w3.org/2000/svg"
    }
    , kge = T("path", {
        d: "M2.75 16.6667V3.33337L18.5833 10L2.75 16.6667ZM4.41667 14.1667L14.2917 10L4.41667 5.83337V8.75004L9.41667 10L4.41667 11.25V14.1667Z"
    }, null, -1)
    , Rge = [kge];
function Mge(t, e) {
    return A(),
        N("svg", Age, Rge)
}
const Pge = _e(Ige, [["render", Mge]])
    , Lge = async (t, e) => {
        var r;
        const n = Ye();
        return {
            user: ((r = (await Ls({
                action: async () => Bn(n.telegramAppFunctions, "add_bonus_call")({
                    action_type: t,
                    item_type: e
                }),
                onSuccess: i => {
                    n.setUserData(i.data.user);
                    const { showSuccessToast: o } = mi();
                    o("toast_messages.share_reward")
                }
                ,
                onError: i => {
                    console.error("Error in addBonus:", i.message)
                }
            })).data) == null ? void 0 : r.user) || {}
        }
    }
    , $L = (t, e) => window.Telegram.WebApp.openTelegramLink("https://t.me/share/url?" + new URLSearchParams({
        url: t,
        text: e || ""
    }).toString().replace(/\+/g, "%20"))
    , Oge = {
        name: "ShareButton",
        computed: {
            IconChevronRight() {
                return Pge
            }
        },
        components: {
            ButtonSecondary: FL
        },
        props: {
            text: {
                type: String,
                required: !0
            },
            url: {
                type: String
            },
            rewardType: String
        },
        methods: {
            onShareClick() {
                const t = window.Telegram.WebApp;
                t && t.openTelegramLink ? (this.rewardType && this.globalStore.isShareRewardActive && Lge("share", this.rewardType),
                    $L(this.url, this.text),
                    this.analyticsStore.share(this.rewardType)) : console.warn(`Your telegram version doesn't support share link functionality. Link to share: ${this.url}, text: ${this.text}`)
            }
        },
        setup() {
            return {
                globalStore: Ye(),
                analyticsStore: Fn()
            }
        }
    };
function Nge(t, e, n, s, r, i) {
    const o = q("ButtonSecondary");
    return A(),
        fe(o, {
            label: t.$t("common.share"),
            icon: i.IconChevronRight,
            onClick: i.onShareClick
        }, null, 8, ["label", "icon", "onClick"])
}
const UL = _e(Oge, [["render", Nge]])
    , ES = t => `https://t.me/SlapStarBot/app?startapp=${t}`
    , Dge = {
        key: 0,
        class: "flex flex-col items-center gap-4"
    }
    , Bge = {
        key: 0,
        class: "text-white/80 text-xl flex items-center"
    }
    , Fge = {
        class: "ml-0.5 text-coin font-semibold"
    }
    , $ge = {
        __name: "LootboxShare",
        props: {
            tier: {
                type: String,
                default: "common",
                validator: t => ["common", "rare", "epic", "legendary"].includes(t)
            },
            type: {
                type: String,
                required: !0,
                validator: t => ["gift", "girl", "coins", "energy_boost", "profit_boost"].includes(t)
            },
            girlId: String
        },
        setup(t) {
            const e = {
                common: 100,
                rare: 1e3,
                epic: 5e3,
                legendary: 1e4
            }
                , { t: n } = gt()
                , s = t
                , r = Ye()
                , i = r.isShareRewardActive
                , o = ES(r.userId)
                , l = ls()
                , a = ve(() => {
                    const c = s.type === "girl" && l.getGirlById(s.girlId);
                    return s.type !== "girl" || !c ? n("share.common", {
                        link: o
                    }) : n(s.tier === "legendary" ? "share.girl_premium" : "share.girl_regular", {
                        name: n(`girls.names.${c.name}`),
                        link: o,
                        rarity: n(`girls.rarity.${s.tier}`)
                    })
                }
                );
            return (c, u) => {
                const h = q("IconCoin");
                return t.type === "girl" ? (A(),
                    N("div", Dge, [de(i) ? (A(),
                        N("p", Bge, [Fe($(de(n)("lootbox_popup.share_and_get")) + " ", 1), G(h, {
                            class: "ml-2 w-6 h-6"
                        }), T("span", Fge, "+" + $(de(Xt)(e[s.tier])), 1)])) : te("", !0), G(UL, {
                            text: a.value,
                            rewardType: `card_${t.tier}`,
                            url: de(o)
                        }, null, 8, ["text", "rewardType", "url"])])) : te("", !0)
            }
        }
    }
    , Uge = {
        name: "LootboxBody",
        components: {
            LootboxCards: R4,
            LootboxShare: $ge,
            LootboxCardTitle: xge
        },
        props: {
            items: {
                type: Array,
                required: !0
            },
            startAnimation: {
                type: Boolean,
                default: !1
            },
            playToEndAnimation: {
                type: Boolean,
                default: !1
            }
        },
        emits: ["openedCardsCount"],
        setup(t) {
            const e = ke(!1)
                , n = ke(-1)
                , s = ve(() => t.items[n.value])
                , r = i => {
                    n.value = i.value
                }
                ;
            return Ln(n, () => {
                e.value = !1,
                    setTimeout(() => {
                        e.value = !0
                    }
                        , 500)
            }
            ),
            {
                currentIndex: n,
                setCurrentIndex: r,
                activeItem: s,
                showText: e
            }
        }
    }
    , Vge = {
        class: "flex flex-col justify-between gap-4 px-4 overflow-y-auto"
    }
    , Gge = {
        class: "h-24 shrink-0"
    }
    , Hge = {
        class: "flex flex-col w-full justify-center grow gap-4"
    }
    , Wge = {
        class: "h-24 shrink-0"
    };
function Yge(t, e, n, s, r, i) {
    const o = q("LootboxCardTitle")
        , l = q("LootboxCards")
        , a = q("LootboxShare");
    return A(),
        N("div", Vge, [T("div", Gge, [G(is, {
            name: "fade"
        }, {
            default: Ce(() => [vn(G(o, Ms({
                class: "top-3 z-10"
            }, s.activeItem), null, 16), [[Ru, s.showText]])]),
            _: 1
        })]), T("div", Hge, [G(l, {
            items: n.items,
            startAnimation: n.startAnimation,
            playToEndAnimation: n.playToEndAnimation,
            onCurrentIndexChanged: s.setCurrentIndex,
            onOpenedCardsCount: e[0] || (e[0] = c => t.$emit("openedCardsCount", c))
        }, null, 8, ["items", "startAnimation", "playToEndAnimation", "onCurrentIndexChanged"]), T("div", Wge, [G(is, {
            name: "fade"
        }, {
            default: Ce(() => [s.showText ? (A(),
                fe(a, {
                    key: 0,
                    tier: s.activeItem.tier || "common",
                    type: s.activeItem.type,
                    girlId: s.activeItem.girl_id
                }, null, 8, ["tier", "type", "girlId"])) : te("", !0)]),
            _: 1
        })])])])
}
const Xge = _e(Uge, [["render", Yge], ["__scopeId", "data-v-96d67e34"]])
    , jge = {
        name: "OpenLootboxOverlay",
        computed: {
            ONBOARDING_STEPS() {
                return Be
            }
        },
        props: {
            isVisible: {
                type: Boolean,
                default: !1
            },
            lootboxType: {
                type: String,
                required: !0
            }
        },
        emits: ["close"],
        components: {
            IconHand: al,
            LootboxBody: Xge,
            Overlay: ch,
            Loader: ol
        },
        setup(t, { emit: e }) {
            const { t: n } = gt()
                , s = Ld()
                , r = ke()
                , i = ke(!1)
                , o = ke(!1)
                , l = ke(!1)
                , a = ke(!1)
                , c = ji()
                , u = ke([])
                , h = ke(!1)
                , d = _s()
                , f = d.isOnboardingInProgress;
            let p = mge({
                type: t.lootboxType,
                onComplete: () => l.value = !0
            });
            const { handlePressStart: m, handleMove: g, handlePressEnd: b } = uh({
                onSwipe: ({ deltaX: _ }) => p.handleSwipe(_),
                onSwipeEnd: () => p.handleSwipeEnd()
            })
                , v = async () => h.value === u.value.length ? Promise.resolve() : (o.value = !0,
                    new Promise(_ => {
                        const y = Ln(h, x => {
                            x === u.value.length && (y(),
                                setTimeout(() => {
                                    _()
                                }
                                    , 1e3))
                        }
                        )
                    }
                    ));
            return Or(async () => {
                await p.initialize(r.value),
                    setTimeout(() => {
                        a.value = !0
                    }
                        , 4e3),
                    u.value = await c.openLootbox(t.lootboxType),
                    u.value.length && (i.value = !0)
            }
            ),
            {
                t: n,
                area: r,
                isLoaded: i,
                playCardSwipeAnimation: l,
                openedLootboxes: u,
                showAllCards: o,
                openedCardsCount: h,
                showSwipeHint: a,
                setOpenedCardsCount(_) {
                    h.value = _
                },
                handlePressStart: m,
                handleMove: g,
                handlePressEnd: b,
                handleConfirm: v,
                handleCloseOverlay() {
                    e("close"),
                        f && s.push(ft.MAIN)
                },
                onboardingStore: d
            }
        }
    }
    , zge = {
        class: "text-white text-xl font-bold"
    }
    , qge = {
        class: "relative flex flex-col overflow-hidden"
    }
    , Kge = {
        class: "absolute top-[11%] inset-x-0 flex justify-center"
    }
    , Jge = {
        class: "text-white font-bold whitespace-nowrap"
    };
function Zge(t, e, n, s, r, i) {
    const o = q("LootboxBody")
        , l = q("IconHand")
        , a = q("Loader")
        , c = q("Overlay");
    return A(),
        fe(Hg, {
            to: "body"
        }, [G(c, {
            class: "bg-gradient-to-b from-black to-[#1a1135]",
            isVisible: n.isVisible,
            onClose: s.handleCloseOverlay,
            confirm: s.handleConfirm,
            hideCloseIcon: !0,
            showConfirmButton: s.openedCardsCount > 0,
            confirmButtonText: s.t("lootbox_popup.claim_all")
        }, {
            header: Ce(() => [T("h5", zge, $(s.t("lootbox_popup.title")), 1)]),
            default: Ce(() => {
                var u, h;
                return [T("div", qge, [G(is, {
                    name: "slide-fade-up"
                }, {
                    default: Ce(() => [vn(T("div", Kge, [T("span", Jge, $(s.t("lootbox_popup.hint")), 1)], 512), [[Ru, !s.playCardSwipeAnimation && s.showSwipeHint]])]),
                    _: 1
                }), T("div", {
                    class: Te(["animation-container z-20 grow opacity-100 transition duration-1000 ease-in-out", {
                        "!opacity-0": s.playCardSwipeAnimation
                    }]),
                    ref: "area",
                    onPointerdown: e[0] || (e[0] = (...d) => s.handlePressStart && s.handlePressStart(...d)),
                    onPointerup: e[1] || (e[1] = (...d) => s.handlePressEnd && s.handlePressEnd(...d)),
                    onPointermove: e[2] || (e[2] = (...d) => s.handleMove && s.handleMove(...d))
                }, null, 34), (u = s.openedLootboxes) != null && u.length ? (A(),
                    fe(o, {
                        key: 0,
                        class: Te(["absolute inset-0 flex flex-col items-center z-10", {
                            "z-30": s.playCardSwipeAnimation
                        }]),
                        items: s.openedLootboxes,
                        startAnimation: s.playCardSwipeAnimation,
                        playToEndAnimation: s.showAllCards,
                        onOpenedCardsCount: s.setOpenedCardsCount
                    }, null, 8, ["class", "items", "startAnimation", "playToEndAnimation", "onOpenedCardsCount"])) : te("", !0)]), n.isVisible && ((h = s.onboardingStore.currentStep) == null ? void 0 : h.stepId) === i.ONBOARDING_STEPS.LOOTBOX_OPENED && s.openedCardsCount > 0 ? (A(),
                        fe(l, {
                            key: 0,
                            class: "absolute z-[999] block onboarding-hand w-10 h-10"
                        })) : te("", !0), s.isLoaded ? te("", !0) : (A(),
                            fe(a, {
                                key: 1,
                                class: "fixed left-1/2 top-1/2 transform -translate-x-1/2 -translate-y-1/2"
                            }))]
            }
            ),
            _: 1
        }, 8, ["isVisible", "onClose", "confirm", "showConfirmButton", "confirmButtonText"])])
}
const VL = _e(jge, [["render", Zge], ["__scopeId", "data-v-3d31ddb7"]])
    , Qge = {
        name: "MyLootboxesTab",
        computed: {
            ONBOARDING_STEPS() {
                return Be
            }
        },
        components: {
            OpenLootboxOverlay: VL,
            Card: SS
        },
        data() {
            return {
                onboardingStore: _s(),
                lootboxesStore: ji(),
                showOverlay: !1,
                selectedLootboxType: null
            }
        },
        methods: {
            openLootbox({ isNew: t, type: e }) {
                this.showOverlay = !0,
                    this.selectedLootboxType = e,
                    t && this.lootboxesStore.decrementNewLootboxes(e),
                    this.onboardingStore.goToNextStep()
            },
            closeOverlay() {
                this.showOverlay = !1,
                    this.selectedLootboxType = null
            }
        },
        beforeUnmount() {
            this.lootboxesStore.resetNewLootboxes()
        }
    }
    , e_e = {
        class: "flex flex-col gap-3"
    }
    , t_e = {
        class: "text-white text-xl font-semibold"
    }
    , n_e = {
        key: 0,
        class: "grid grid-cols-3 gap-3"
    }
    , s_e = {
        key: 1,
        class: "text-white/60 text-center"
    };
function r_e(t, e, n, s, r, i) {
    var c;
    const o = q("Card")
        , l = q("OpenLootboxOverlay")
        , a = mr("fade-in-up");
    return A(),
        N("div", e_e, [T("h2", t_e, $(t.$t("shop.lootboxes")), 1), (c = r.lootboxesStore.ownedLootboxes) != null && c.length ? (A(),
            N("div", n_e, [(A(!0),
                N(Ie, null, mt(r.lootboxesStore.ownedLootboxes, (u, h) => {
                    var d;
                    return vn((A(),
                        N("div", {
                            key: u.id
                        }, [G(o, Ms({
                            ref_for: !0
                        }, u, {
                            onClick: f => i.openLootbox(u),
                            glow: !1,
                            class: {
                                "opacity-30 pointer-events-none": h !== 0 && ((d = r.onboardingStore.currentStep) == null ? void 0 : d.stepId) === i.ONBOARDING_STEPS.OPEN_LOOTBOX
                            }
                        }), {
                            button: Ce(() => [Fe($(t.$t("shop.open")), 1)]),
                            _: 2
                        }, 1040, ["onClick", "class"])])), [[a, h * 50]])
                }
                ), 128))])) : (A(),
                    N("p", s_e, $(t.$t("shop.noLootboxes")), 1)), r.showOverlay ? (A(),
                        fe(l, {
                            key: 2,
                            isVisible: r.showOverlay,
                            lootboxType: r.selectedLootboxType,
                            onClose: i.closeOverlay
                        }, null, 8, ["isVisible", "lootboxType", "onClose"])) : te("", !0)])
}
const i_e = _e(Qge, [["render", r_e]])
    , Q_ = Ds("chips", {
        state: () => ({
            chips: []
        }),
        actions: {
            isAvailableForWheel(t) {
                return this.chips.some(e => {
                    var n;
                    return (n = e.wheels) == null ? void 0 : n.includes(t)
                }
                )
            },
            setChips(t) {
                this.chips = t
            },
            async purchaseChip(t) {
                const e = await g_("chips", t.id);
                try {
                    window.Telegram.WebApp.openInvoice(e, n => {
                        n === "paid" && (zo().increaseSpinBalance(t.spinCount),
                            Fn().logEvent("buy_spins"))
                    }
                    )
                } catch (n) {
                    console.error("Error opening Chips invoice link:", e, n)
                }
            }
        }
    })
    , o_e = {
        class: "grid grid-cols-3 gap-3"
    }
    , a_e = {
        class: "text-xl font-semibold text-accent absolute inset-x-0 bottom-0"
    }
    , GL = {
        __name: "ShopChips",
        emits: ["onPurchaseSuccess"],
        setup(t, { emit: e }) {
            const n = e
                , s = Q_()
                , r = ve(() => s.chips)
                , i = async o => {
                    await s.purchaseChip(o),
                        n("onPurchaseSuccess")
                }
                ;
            return (o, l) => {
                const a = mr("fade-in-up");
                return A(),
                    N("div", o_e, [(A(!0),
                        N(Ie, null, mt(r.value, (c, u) => vn((A(),
                            fe(SS, {
                                key: c.id,
                                tier: c.tier,
                                price: c.price,
                                image: "/shop/chip.webp",
                                icon: vc,
                                onClick: h => i(c)
                            }, {
                                name: Ce(() => [T("span", a_e, $(c.spinCount), 1)]),
                                _: 2
                            }, 1032, ["tier", "price", "onClick"])), [[a, u * 50]])), 128))])
            }
        }
    }
    , l_e = "/badges/guaranteed-girl.webp"
    , c_e = "/shop/girl-placeholder.webp"
    , u_e = {
        class: "flex flex-col gap-3 items-center justify-end w-full relative aspect-square overflow-hidden rounded-lg bg-gradient-to-b from-transparent to-black border border-white/5"
    }
    , h_e = ["src"]
    , d_e = T("img", {
        src: c_e,
        alt: "",
        class: "z-[-1] w-full h-full object-cover object-top absolute top-2"
    }, null, -1)
    , f_e = {
        class: "flex p-2 flex-col items-start w-full"
    }
    , p_e = {
        class: "z-10 text-white text-xs font-semibold"
    }
    , m_e = {
        class: "z-10 text-xxs font-semibold text-white px-1 py-0.5 bg-black/60 rounded-3xl leading-3"
    }
    , g_e = {
        __name: "GirlInfoCard",
        props: {
            chance: {
                type: Number,
                required: !0
            },
            tier: {
                type: String,
                required: !0,
                validator: t => ["common", "rare", "epic", "legendary"].includes(t)
            }
        },
        setup(t) {
            const { t: e } = gt()
                , n = t
                , s = ve(() => xh(n.tier))
                , r = ve(() => {
                    const i = Math.round(n.chance * 100);
                    return i < 20 ? e("shop.lootbox_info_popup.chance.low") : i >= 20 && i <= 49 ? e("shop.lootbox_info_popup.chance.medium") : i >= 50 && i <= 75 ? e("shop.lootbox_info_popup.chance.high") : i >= 76 && i <= 99 ? e("shop.lootbox_info_popup.chance.very_high") : i === 100 ? e("shop.lootbox_info_popup.chance.guaranteed") : ""
                }
                );
            return (i, o) => (A(),
                N("div", u_e, [G(gr, {
                    class: "z-[-1]",
                    position: "top",
                    tier: t.tier,
                    height: "70%",
                    width: "80%",
                    blur: "25"
                }, null, 8, ["tier"]), T("img", {
                    src: `/icons/icon-type-${t.tier}.svg`,
                    alt: "",
                    class: "absolute top-2 left-2 w-4 h-4 z-20"
                }, null, 8, h_e), d_e, T("div", f_e, [T("p", p_e, $(de(e)(`rare.${t.tier}`)), 1), T("p", m_e, [T("span", {
                    style: Wt(s.value)
                }, $(r.value), 5)])])]))
        }
    }
    , __e = {
        class: "flex flex-col items-center justify-end w-full relative aspect-square overflow-hidden rounded-lg border border-white/5 pt-2"
    }
    , y_e = {
        class: "z-10 flex flex-col p-2 items-center w-full"
    }
    , b_e = {
        class: "text-white text-xs font-semibold"
    }
    , v_e = {
        class: "text-xxs text-coin font-semibold inline-flex whitespace-nowrap items-center"
    }
    , e0 = {
        __name: "InfoCard",
        props: {
            tier: {
                type: String,
                validator: t => ["common", "rare", "epic", "legendary"].includes(t)
            },
            label: {
                type: String,
                required: !0
            },
            chance: {
                type: Number,
                required: !0
            },
            type: {
                type: String,
                required: !0,
                validator: t => ["gift", "energy_boost", "profit_boost", "coins"].includes(t)
            },
            info: {
                type: String,
                required: !0
            },
            image: {
                type: [Object, Function],
                required: !1
            },
            icon: {
                type: [Object, Function],
                required: !0
            }
        },
        setup(t) {
            return gt(),
                (e, n) => (A(),
                    N("div", __e, [G(gr, {
                        position: "top",
                        tier: t.tier || "common",
                        height: "70%",
                        width: "80%",
                        blur: "25"
                    }, null, 8, ["tier"]), (A(),
                        fe(Kl(t.image || t.icon), {
                            class: "grow z-10"
                        })), T("div", y_e, [T("p", b_e, $(t.label), 1), T("p", v_e, [(A(),
                            fe(Kl(t.icon), {
                                class: "!w-3 !h-3 mr-0.5"
                            })), Fe(" " + $(t.info), 1)])])]))
        }
    }
    , x_e = {
        __name: "EnergyBoostInfoCard",
        props: {
            chance: {
                type: Number,
                required: !0
            },
            minTier: {
                type: String,
                required: !0
            },
            maxTier: {
                type: String,
                required: !0
            }
        },
        setup(t) {
            const { t: e } = gt()
                , n = t
                , s = Xs()
                , r = ve(() => {
                    var a, c;
                    const i = (a = s.getBoost(ns.ENERGY, n.minTier)) == null ? void 0 : a.bonus
                        , o = (c = s.getBoost(ns.ENERGY, n.maxTier)) == null ? void 0 : c.bonus
                        , l = u => `${Math.round((u - 1) * 100)}%`;
                    return i !== o ? `+${l(i)}-${l(o)}` : `+${l(i)}`
                }
                );
            return (i, o) => (A(),
                fe(e0, {
                    chance: t.chance,
                    tier: de(Pt).COMMON,
                    type: "energy_boost",
                    icon: () => Wi(E4, {
                        class: "w-1/3"
                    }),
                    info: r.value,
                    label: de(e)("shop.lootbox_info_popup.labels.energy_boost")
                }, null, 8, ["chance", "tier", "icon", "info", "label"]))
        }
    }
    , w_e = {
        __name: "GiftInfoCard",
        props: {
            chance: {
                type: Number,
                required: !0
            },
            minTier: {
                type: String,
                required: !0
            },
            maxTier: {
                type: String,
                required: !0
            }
        },
        setup(t) {
            const { t: e } = gt()
                , n = t
                , s = Ye()
                , r = ve(() => {
                    const i = s.gifts[n.maxTier]
                        , o = s.gifts[n.minTier];
                    return o !== i ? `+${Xt(o)}-${Xt(i, !0)}` : `+${Xt(o)}`
                }
                );
            return (i, o) => (A(),
                fe(e0, {
                    chance: t.chance,
                    tier: de(Pt).COMMON,
                    type: "gift",
                    icon: () => Wi(Yx, {
                        class: "!w-1/3"
                    }),
                    info: r.value,
                    label: de(e)("shop.lootbox_info_popup.labels.gift")
                }, null, 8, ["chance", "tier", "icon", "info", "label"]))
        }
    }
    , S_e = {
        __name: "ProfitBoostInfoCard",
        props: {
            chance: {
                type: Number,
                required: !0
            },
            minTier: {
                type: String,
                required: !0
            },
            maxTier: {
                type: String,
                required: !0
            }
        },
        setup(t) {
            const { t: e } = gt()
                , n = t
                , s = Xs()
                , r = ve(() => {
                    var a, c;
                    const i = (a = s.getBoost(ns.PROFIT, n.minTier)) == null ? void 0 : a.bonus
                        , o = (c = s.getBoost(ns.PROFIT, n.maxTier)) == null ? void 0 : c.bonus
                        , l = u => `${Math.round((u - 1) * 100)}%`;
                    return i !== o ? `+${l(i)}-${l(o)}` : `+${l(i)}`
                }
                );
            return (i, o) => (A(),
                fe(e0, {
                    chance: t.chance,
                    tier: de(Pt).LEGENDARY,
                    type: "profit_boost",
                    icon: () => Wi(Hx, {
                        tier: de(Pt).LEGENDARY,
                        class: "w-1/3"
                    }),
                    info: r.value,
                    label: de(e)("shop.lootbox_info_popup.labels.profit_boost")
                }, null, 8, ["chance", "tier", "icon", "info", "label"]))
        }
    }
    , E_e = {
        __name: "CoinInfoCard",
        props: {
            chance: {
                type: Number,
                required: !0
            },
            tier: void 0,
            minCoins: Number,
            maxCoins: Number
        },
        setup(t) {
            const { t: e } = gt();
            return (n, s) => (A(),
                fe(e0, {
                    chance: t.chance,
                    tier: de(Pt).LEGENDARY,
                    type: "coins",
                    image: Wi(dn, {
                        class: "object-contain object-[0_3px] h-1/2"
                    }),
                    icon: Wi(dn, {
                        class: "object-contain h-1/2"
                    }),
                    info: `${de(Xt)(t.minCoins)}-${de(Xt)(t.maxCoins)}`,
                    label: de(e)("shop.lootbox_info_popup.labels.coins")
                }, null, 8, ["chance", "tier", "image", "icon", "info", "label"]))
        }
    }
    , T_e = t => (Wo("data-v-80680c36"),
        t = t(),
        Yo(),
        t)
    , C_e = {
        class: "flex flex-col w-full text-white items-center"
    }
    , I_e = {
        key: 0,
        class: "absolute left-2 top-2 rounded-full"
    }
    , A_e = T_e(() => T("img", {
        class: "w-[98px] max-[375px]:w-[76px]",
        src: l_e,
        alt: "guaranteed girl"
    }, null, -1))
    , k_e = {
        class: "text-white font-semibold"
    }
    , R_e = {
        class: "grid grid-cols-3 gap-1 w-full"
    }
    , M_e = {
        key: 1,
        class: "mt-3"
    }
    , P_e = {
        class: "flex flex-col items-center"
    }
    , L_e = {
        class: "text-white/[.80] font-normal text-base leading-tight"
    }
    , O_e = {
        key: 0,
        class: "text-xl font-semibold text-white flex flex-row items-center gap-0.5"
    }
    , N_e = {
        __name: "LootboxInfoPopup",
        props: {
            isVisible: {
                type: Boolean,
                required: !0
            },
            isLoading: {
                type: Boolean,
                default: !1
            },
            lootboxInfo: {
                type: [Object, null],
                required: !0
            },
            buttonText: {
                type: String,
                default: null
            },
            onClick: {
                type: Function,
                required: !0
            }
        },
        emits: ["close"],
        setup(t, { emit: e }) {
            const n = {
                girl: g_e,
                energy_boost: x_e,
                gift: w_e,
                profit_boost: S_e,
                coins: E_e
            }
                , s = t
                , { t: r } = gt()
                , i = e
                , o = ve(() => xh(NM[s.lootboxInfo.type]))
                , l = ve(() => {
                    const h = s.lootboxInfo.drops.reduce((f, p) => (f[p.type] || (f[p.type] = []),
                        f[p.type].push(p),
                        f), {});
                    return Object.keys(h).forEach(f => {
                        f === "girl" && h[f].sort((p, m) => (yC[m.tier] || 0) - (yC[p.tier] || 0))
                    }
                    ),
                        ["girl", "gift", "energy_boost", "profit_boost", "coins"].reduce((f, p) => (h[p] && f.push(...h[p]),
                            f), [])
                }
                )
                , a = ve(() => s.lootboxInfo.drops.filter(h => h.type === "girl").reduce((h, d) => h + d.chance, 0) === 1)
                , c = async () => {
                    if (s.lootboxInfo.disabled) {
                        ur("error");
                        return
                    }
                    await s.onClick()
                }
                , u = () => {
                    i("close")
                }
                ;
            return (h, d) => (A(),
                fe(il, {
                    "is-visible": t.isVisible,
                    onClose: u
                }, {
                    default: Ce(() => [T("div", C_e, [a.value ? (A(),
                        N("div", I_e, [G(Ki, {
                            hasInterval: !0
                        }), A_e])) : te("", !0), T("p", k_e, $(t.lootboxInfo.name), 1), T("p", {
                            class: "text-2xl font-black mb-3",
                            style: Wt(o.value)
                        }, $(h.$t("shop.lootbox_info_popup.you_can_get")), 5), T("div", R_e, [(A(!0),
                            N(Ie, null, mt(l.value, (f, p) => (A(),
                                fe(Kl(n[f.type]), Ms({
                                    key: p,
                                    ref_for: !0
                                }, f), null, 16))), 128))]), a.value ? (A(),
                                    N("p", M_e, [Fe($(de(r)("shop.lootbox_info_popup.guaranteed_girl_text_part1")) + " ", 1), T("strong", null, $(de(r)("shop.lootbox_info_popup.guaranteed_girl_text_part2")), 1), Fe("! ")])) : te("", !0), rs(h.$slots, "button", {
                                        disabled: t.lootboxInfo.disabled,
                                        isLoading: t.isLoading,
                                        onClick: c
                                    }, () => [G(Lr, {
                                        disabled: t.lootboxInfo.disabled,
                                        class: "mt-3",
                                        isLoading: t.isLoading,
                                        size: "l",
                                        type: t.lootboxInfo.group === de(Uu).STAR ? "accent" : "primary",
                                        onClick: c
                                    }, {
                                        default: Ce(() => [T("div", P_e, [T("span", L_e, $(s.buttonText || h.$t("shop.lootbox_info_popup.buy")), 1), +t.lootboxInfo.price ? (A(),
                                            N("span", O_e, [(A(),
                                                fe(Kl(t.lootboxInfo.group === de(Uu).COIN ? dn : vc), {
                                                    class: "w-5 h-5"
                                                })), Fe(" " + $(de(Xt)(+t.lootboxInfo.price)), 1)])) : te("", !0)])]),
                                        _: 1
                                    }, 8, ["disabled", "isLoading", "type"])], !0)])]),
                    _: 3
                }, 8, ["is-visible"]))
        }
    }
    , HL = _e(N_e, [["__scopeId", "data-v-80680c36"]])
    , TS = {
        __name: "UserSlots",
        props: {
            isCollapsed: {
                type: Boolean,
                required: !1,
                default: !1
            },
            alwaysShowLocked: {
                type: Boolean,
                required: !1,
                default: !1
            },
            alwaysShowEmpty: {
                type: Boolean,
                required: !1,
                default: !1
            },
            shrinkOnCollapse: {
                type: Boolean,
                required: !1,
                default: !1
            },
            onGirlAvatarClick: {
                type: Function,
                required: !1
            }
        },
        setup(t) {
            const e = t
                , n = ls()
                , s = ve(() => n.girlsInSlots)
                , r = ve(() => n.lockedSlots)
                , i = ve(() => n.slots)
                , o = () => {
                    e.isCollapsed || Fo().showBuySlotModal()
                }
                ;
            return (l, a) => (A(),
                N("div", {
                    class: Te(["flex flex-row items-center gap-1", {
                        "-space-x-2": t.shrinkOnCollapse && t.isCollapsed,
                        "-space-x-3": !t.shrinkOnCollapse && t.isCollapsed
                    }])
                }, [(A(!0),
                    N(Ie, null, mt(i.value, (c, u) => (A(),
                        fe(vS, {
                            key: u,
                            girl: s.value[u],
                            isCollapsed: t.isCollapsed,
                            shrinkOnCollapse: t.shrinkOnCollapse,
                            alwaysShowEmpty: t.alwaysShowEmpty,
                            onGirlAvatarClick: t.onGirlAvatarClick
                        }, null, 8, ["girl", "isCollapsed", "shrinkOnCollapse", "alwaysShowEmpty", "onGirlAvatarClick"]))), 128)), !t.isCollapsed || t.alwaysShowLocked ? (A(!0),
                            N(Ie, {
                                key: 0
                            }, mt(r.value, c => (A(),
                                fe(bS, {
                                    onClick: a[0] || (a[0] = u => o()),
                                    key: c,
                                    class: Te([t.alwaysShowLocked && "z-[2]"])
                                }, null, 8, ["class"]))), 128)) : te("", !0)], 2))
        }
    }
    , D_e = {
        key: 0,
        class: "unlock-slot-banner w-full flex flex-row justify-between text-white py-1.5 px-3 rounded-lg bg-cover"
    }
    , B_e = {
        class: "flex flex-col gap-1"
    }
    , F_e = {
        class: "font-bold"
    }
    , $_e = {
        class: "text-white/60 text-xs"
    }
    , U_e = {
        class: "flex items-center"
    }
    , V_e = {
        __name: "UnlockSlotBanner",
        setup(t) {
            const { t: e } = gt()
                , n = Fo()
                , s = ve(() => n.unlockPrice)
                , r = ve(() => n.hasMaxSlots)
                , i = n.showBuySlotModal;
            return (o, l) => r.value ? te("", !0) : (A(),
                N("div", D_e, [T("div", B_e, [T("p", F_e, $(de(e)("unlock_slot_banner.unlock_new_slot")), 1), G(TS, {
                    isCollapsed: !0,
                    alwaysShowLocked: !0,
                    alwaysShowEmpty: !0
                }), T("p", $_e, $(de(e)("unlock_slot_banner.help_text")), 1)]), T("div", U_e, [G(ic, {
                    label: de(Xt)(s.value),
                    icon: "star",
                    onClick: de(i)
                }, null, 8, ["label", "onClick"])])]))
        }
    }
    , WL = _e(V_e, [["__scopeId", "data-v-4a15127b"]])
    , G_e = {
        name: "LootboxesTab",
        components: {
            UnlockSlotBanner: WL,
            LootboxInfoPopup: HL,
            ShopChips: GL,
            OpenLootboxOverlay: VL,
            Card: SS
        },
        computed: {
            currency() {
                return Uu
            },
            showOnboarding() {
                return this.onboardingStore.isOnboardingInProgress
            },
            lootboxInfo() {
                return this.lootboxInfoType == null ? null : this.lootboxesStore.getLootboxByType(this.lootboxInfoType)
            }
        },
        data() {
            return {
                globalStore: Ye(),
                onboardingStore: _s(),
                lootboxesStore: ji(),
                analyticsStore: Fn(),
                slotsStore: Fo(),
                showOpenLootboxOverlay: !1,
                isPurchasedCallLoading: !1,
                purchasedType: null,
                showLootboxInfoPopup: !1,
                lootboxInfoType: null
            }
        },
        setup() {
            return {
                IconCoin: dn,
                IconStars: vc
            }
        },
        methods: {
            async purchaseBaseLootbox(t) {
                this.globalStore.setChangedBalance(t.price),
                    await this.lootboxesStore.purchaseLootbox(t.type),
                    this.analyticsStore.logEvent("buy_base_lootbox", {
                        type: t.type
                    }),
                    this.handleOpenLootboxOverlay(t)
            },
            async purchaseStarLootbox(t) {
                const e = await g_(t.type);
                try {
                    window.Telegram.WebApp.openInvoice(e, n => {
                        n === "paid" && (this.lootboxesStore.incrementLootbox(t.type),
                            this.analyticsStore.logEvent("buy_star_lootbox", {
                                type: t.type
                            }),
                            this.handleOpenLootboxOverlay(t))
                    }
                    )
                } catch (n) {
                    console.error("Error opening Lootbox invoice link:", e, n)
                }
            },
            handleOpenLootboxOverlay(t) {
                this.showOpenLootboxOverlay = !0,
                    this.purchasedType = t.type
            },
            handleCloseOpenLootboxOverlay() {
                this.showOpenLootboxOverlay = !1,
                    this.purchasedType = null
            },
            onHelpIconClick(t) {
                this.lootboxInfoType = t,
                    setTimeout(() => {
                        this.showLootboxInfoPopup = !0
                    }
                        , 10)
            },
            onLootboxInfoPopupClose() {
                this.showLootboxInfoPopup = !1,
                    this.lootboxInfoType = null
            },
            async onLootboxInfoBuyClick() {
                this.isPurchasedCallLoading = !0,
                    this.lootboxInfo.group === Uu.COIN ? await this.purchaseBaseLootbox(this.lootboxInfo) : await this.purchaseStarLootbox(this.lootboxInfo),
                    this.isPurchasedCallLoading = !1,
                    this.onLootboxInfoPopupClose()
            }
        }
    }
    , H_e = {
        class: "slap-shop-page__items flex flex-col gap-6"
    }
    , W_e = {
        class: "flex flex-col gap-3"
    }
    , Y_e = {
        class: "grid grid-cols-3 gap-3"
    }
    , X_e = {
        class: "text-white text-xl font-semibold"
    }
    , j_e = {
        class: "grid grid-cols-3 gap-3"
    }
    , z_e = {
        class: "text-white text-xl font-semibold"
    }
    , q_e = {
        key: 0,
        class: "flex flex-col gap-3"
    }
    , K_e = {
        class: "text-white text-xl font-semibold"
    };
function J_e(t, e, n, s, r, i) {
    const o = q("Card")
        , l = q("ShopChips")
        , a = q("UnlockSlotBanner")
        , c = q("OpenLootboxOverlay")
        , u = q("LootboxInfoPopup")
        , h = mr("fade-in-up");
    return A(),
        N("div", H_e, [T("div", W_e, [T("h3", {
            class: Te(["text-white text-xl font-semibold", {
                "onboarding-opacity": i.showOnboarding
            }])
        }, $(t.$t("shop.lootboxes")), 3), T("div", Y_e, [(A(!0),
            N(Ie, null, mt(r.lootboxesStore.baseLootboxes, (d, f) => vn((A(),
                fe(o, Ms({
                    key: d.type,
                    ref_for: !0
                }, d, {
                    disabled: !1,
                    dimmed: d.disabled,
                    id: d.type,
                    icon: s.IconCoin,
                    onClick: p => i.onHelpIconClick(d.type),
                    class: {
                        "onboarding-opacity": i.showOnboarding && f !== 0
                    },
                    glow: !1,
                    showHelpIcon: !0,
                    onOnHelpIconClick: i.onHelpIconClick
                }), null, 16, ["dimmed", "id", "icon", "onClick", "class", "onOnHelpIconClick"])), [[h, f * 50]])), 128))])]), T("div", {
                    class: Te(["flex flex-col gap-3", {
                        "onboarding-opacity": i.showOnboarding
                    }])
                }, [T("h3", X_e, $(t.$t("shop.vipboxes")), 1), T("div", j_e, [(A(!0),
                    N(Ie, null, mt(r.lootboxesStore.vipLootboxes, (d, f) => vn((A(),
                        fe(o, Ms({
                            key: d.type,
                            ref_for: !0
                        }, d, {
                            disabled: !1,
                            dimmed: d.disabled,
                            id: d.type,
                            icon: s.IconStars,
                            onClick: p => i.onHelpIconClick(d.type),
                            glow: !1,
                            showHelpIcon: !0,
                            onOnHelpIconClick: i.onHelpIconClick
                        }), null, 16, ["dimmed", "id", "icon", "onClick", "onOnHelpIconClick"])), [[h, f * 50]])), 128))])], 2), T("div", {
                            class: Te(["flex flex-col gap-3", {
                                "onboarding-opacity": i.showOnboarding
                            }])
                        }, [T("h3", z_e, $(t.$t("shop.chips")), 1), G(l)], 2), r.slotsStore.hasMaxSlots ? te("", !0) : (A(),
                            N("div", q_e, [T("h3", K_e, $(t.$t("shop.slots")), 1), G(a)])), r.showOpenLootboxOverlay && r.purchasedType ? (A(),
                                fe(c, {
                                    key: 1,
                                    isVisible: r.showOpenLootboxOverlay,
                                    lootboxType: r.purchasedType,
                                    onClose: i.handleCloseOpenLootboxOverlay
                                }, null, 8, ["isVisible", "lootboxType", "onClose"])) : te("", !0), G(u, {
                                    isVisible: r.showLootboxInfoPopup,
                                    lootboxInfo: i.lootboxInfo,
                                    isLoading: r.isPurchasedCallLoading,
                                    onClose: i.onLootboxInfoPopupClose,
                                    onClick: i.onLootboxInfoBuyClick
                                }, null, 8, ["isVisible", "lootboxInfo", "isLoading", "onClose", "onClick"])])
}
const Z_e = _e(G_e, [["render", J_e], ["__scopeId", "data-v-7f6d4941"]])
    , Q_e = "/collections/label-new.webp"
    , Oc = {
        LOOTBOXES: "lootboxes",
        COLLECTIONS: "collections",
        MY_LOOTBOXES: "my-lootboxes"
    }
    , e0e = {
        name: "SlapShopPage",
        components: {
            IconHand: al,
            IconArrowLeft: Fx,
            IconStars: vc,
            LootboxesTab: Z_e,
            MyLootboxesTab: i_e,
            Tabs: wS,
            Header: oc,
            MainHeader: oc,
            MainFooter: jo,
            Countdown: BL
        },
        mixins: [Ef],
        computed: {
            locales() {
                return js
            },
            tabs() {
                return [{
                    id: Oc.LOOTBOXES,
                    title: this.$t("shop.tabs.lootboxes")
                }, {
                    id: Oc.COLLECTIONS,
                    title: this.$t("shop.tabs.collections")
                }, {
                    id: Oc.MY_LOOTBOXES,
                    title: this.$t("shop.tabs.my_lootboxes"),
                    hasNotification: this.lootboxesStore.hasNewLootboxes
                }]
            }
        },
        data() {
            return {
                globalStore: Ye(),
                lootboxesStore: ji(),
                onboardingStore: _s(),
                analyticsStore: Fn(),
                TabsID: Oc,
                selectedTabId: Oc.LOOTBOXES,
                isInDev: !0,
                collections: [{
                    name: "PornHub Collection",
                    desc: "Inside this collection you will find <span>Sweetie Fox, Eva Elfie, Diana Rider</span> and many more",
                    img: "/collections/collection-new1.webp",
                    priceStarsOld: 1e3,
                    priceStars: 200,
                    date: new Date("2025-01-01")
                }, {
                    name: "Onlyfans Collection",
                    desc: "Onlyfans revenue exceeded <span>$6 billion</span> in 2023 - the platform <span>is already twice as large</span> as Pornhub",
                    link: "OnlyFans",
                    img: "/collections/collection-new2.webp",
                    priceStars: 500,
                    isNew: !0
                }, {
                    name: "xHamster Collection",
                    desc: "<span>Yes, were also shocked</span> that the hamster turned out to be a scam!",
                    img: "/collections/collection-new3.webp",
                    logo: "/collections/collection-logo1.webp",
                    priceStars: 1500,
                    isNew: !0
                }],
                activeCollection: null,
                showOverlay: !1
            }
        },
        methods: {
            onCollectionBack() {
                this.activeCollection = null
            },
            showCollection(t) {
                this.activeCollection = t
            },
            onChangeTab(t) {
                this.selectedTabId = t,
                    this.onboardingStore.goToNextStep()
            }
        },
        mounted() {
            var e, n;
            this.$emit("ready"),
                this.analyticsStore.logEvent("open_shop");
            const t = (e = this.$route.query) == null ? void 0 : e.collection;
            t && (this.selectedTabId = Oc.COLLECTIONS,
                this.activeCollection = this.collections.find(s => s.name === t)),
                ((n = this.onboardingStore.currentStep) == null ? void 0 : n.stepId) === Be.GO_SHOP && this.onboardingStore.goToNextStep()
        }
    }
    , t0e = {
        class: "relative z-[5] flex flex-col gap-3 grow overflow-hidden"
    }
    , n0e = {
        key: 3,
        class: "slap-shop-page__items overflow-auto px-4"
    }
    , s0e = ["src"]
    , r0e = ["onClick"]
    , i0e = {
        class: "slap-shop-page__collection-name"
    }
    , o0e = ["innerHTML"]
    , a0e = ["src"]
    , l0e = {
        key: 2,
        class: "slap-shop-page__collection-new",
        src: Q_e
    }
    , c0e = {
        class: "slap-shop-page__collection-stars"
    }
    , u0e = {
        key: 0
    };
function h0e(t, e, n, s, r, i) {
    var p;
    const o = q("Header")
        , l = q("IconHand")
        , a = q("Tabs")
        , c = q("MyLootboxesTab")
        , u = q("LootboxesTab")
        , h = q("Countdown")
        , d = q("IconStars")
        , f = q("MainFooter");
    return A(),
        N("div", {
            class: Te(["slap-shop-page overflow-hidden flex flex-col h-[calc(100%-90px)]", [`slap-shop-page--${(p = r.onboardingStore.currentStep) == null ? void 0 : p.stepId}`]])
        }, [G(o, {
            class: "slap-shop-page__header"
        }), T("main", t0e, [r.onboardingStore.isOnboardingInProgress ? (A(),
            fe(l, {
                key: 0,
                class: "slap-shop-page__hand"
            })) : te("", !0), G(a, {
                class: "slap-shop-page__tabs mx-4",
                tabs: i.tabs,
                selectedTabId: r.selectedTabId,
                onChangeTab: i.onChangeTab
            }, null, 8, ["tabs", "selectedTabId", "onChangeTab"]), r.selectedTabId === r.TabsID.MY_LOOTBOXES ? (A(),
                fe(c, {
                    key: 1,
                    class: "slap-shop-page__my-lootboxes grow overflow-y-auto px-4"
                })) : te("", !0), r.selectedTabId === r.TabsID.LOOTBOXES ? (A(),
                    fe(u, {
                        key: 2,
                        class: "grow overflow-y-auto px-4"
                    })) : te("", !0), r.selectedTabId === r.TabsID.COLLECTIONS ? (A(),
                        N("div", n0e, [r.isInDev ? (A(),
                            N("img", {
                                key: 0,
                                class: "w-full rounded-lg border border-white/5 object-cover",
                                alt: "In development banner",
                                src: `/shop/soon-collection-banner-${t.$i18n.locale === i.locales.RU ? i.locales.RU : i.locales.EN}.webp`
                            }, null, 8, s0e)) : (A(!0),
                                N(Ie, {
                                    key: 1
                                }, mt(r.collections, m => (A(),
                                    N("div", {
                                        class: "slap-shop-page__collection",
                                        key: m.name,
                                        onClick: g => i.showCollection(m),
                                        style: Wt({
                                            backgroundImage: `url(${m.img})`
                                        })
                                    }, [T("div", i0e, $(m.name), 1), T("div", {
                                        class: "slap-shop-page__collection-desc",
                                        innerHTML: m.desc
                                    }, null, 8, o0e), m.date ? (A(),
                                        fe(h, {
                                            key: 0,
                                            class: "mb-3",
                                            targetDate: m.date,
                                            "no-month": ""
                                        }, null, 8, ["targetDate"])) : te("", !0), m.logo ? (A(),
                                            N("img", {
                                                key: 1,
                                                class: "mb-3",
                                                src: m.logo
                                            }, null, 8, a0e)) : te("", !0), m.isNew ? (A(),
                                                N("img", l0e)) : te("", !0), T("div", c0e, [G(d, {
                                                    class: "w-[20px] mr-1"
                                                }), m.priceStarsOld ? (A(),
                                                    N("span", u0e, $(m.priceStarsOld), 1)) : te("", !0), Fe(" " + $(m.priceStars), 1)])], 12, r0e))), 128))])) : te("", !0), G(f)])], 2)
}
const d0e = _e(e0e, [["render", h0e], ["__scopeId", "data-v-1c5bf78e"]])
    , f0e = {}
    , p0e = {
        viewBox: "0 0 40 40",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }
    , m0e = Nr('<rect x="5" y="13" width="30" height="24" rx="2" fill="url(#paint0_linear_1910_18856)" fill-opacity="0.6"></rect><path fill-rule="evenodd" clip-rule="evenodd" d="M18 9V11V13H14C11.7909 13 10 11.2091 10 9C10 6.79086 11.7909 5 14 5C16.2091 5 18 6.79086 18 9ZM9.52779 13C8.57771 11.9385 8 10.5367 8 9C8 5.68629 10.6863 3 14 3C17.3137 3 20 5.68629 20 9C20 5.68629 22.6863 3 26 3C29.3137 3 32 5.68629 32 9C32 10.5367 31.4223 11.9385 30.4722 13H35C36.1046 13 37 13.8954 37 15V17C37 18.1046 36.1046 19 35 19H22V32C22 33.1046 21.1046 34 20 34C18.8954 34 18 33.1046 18 32V19H5C3.89543 19 3 18.1046 3 17V15C3 13.8954 3.89543 13 5 13H9.52779ZM26 13C28.2091 13 30 11.2091 30 9C30 6.79086 28.2091 5 26 5C23.7909 5 22 6.79086 22 9V11V13H26Z" fill="url(#paint1_linear_1910_18856)"></path><defs><linearGradient id="paint0_linear_1910_18856" x1="20" y1="13.0007" x2="20" y2="37.0008" gradientUnits="userSpaceOnUse"><stop stop-color="#FF5B70"></stop><stop offset="1" stop-color="#DD0A6F"></stop></linearGradient><linearGradient id="paint1_linear_1910_18856" x1="20" y1="3.00095" x2="20" y2="34.001" gradientUnits="userSpaceOnUse"><stop stop-color="#FF5B70"></stop><stop offset="1" stop-color="#DD0A6F"></stop></linearGradient></defs>', 3)
    , g0e = [m0e];
function _0e(t, e) {
    return A(),
        N("svg", p0e, g0e)
}
const y0e = _e(f0e, [["render", _0e]])
    , b0e = "/boxes/present.webp"
    , v0e = {}
    , x0e = {
        class: "w-[80px] h-[80px]",
        src: b0e,
        alt: "Present Image"
    };
function w0e(t, e) {
    return A(),
        N("img", x0e)
}
const S0e = _e(v0e, [["render", w0e]])
    , E0e = {
        name: "SlapAirdropPage",
        components: {
            TasksList: Y4,
            IconClose: S_,
            IconPresent: S0e,
            MainFooter: jo,
            Countdown: BL,
            IconGift: y0e
        },
        data() {
            return {
                webApp: window.Telegram.WebApp,
                analyticsStore: Fn(),
                targetDate: new Date("2025-01-01")
            }
        },
        methods: {
            goToPreviousPage() {
                this.$route.path !== ft.MAIN && this.$router.go(-1)
            }
        },
        mounted() {
            this.$emit("ready"),
                this.analyticsStore.logEvent("open_airdrop");
            const t = window.Telegram.WebApp.BackButton;
            t && (t.show(),
                t.onClick(this.goToPreviousPage))
        },
        unmounted() {
            const t = window.Telegram.WebApp.BackButton;
            t && (t.hide(),
                t.offClick(this.goToPreviousPage))
        }
    }
    , T0e = {
        class: "sl-airdrop-page relative px-4 pb-0 overflow-x-hidden overflow-y-auto"
    }
    , C0e = T("div", {
        class: "sl-airdrop-page__rotating-background absolute inset-0 bg-center bg-no-repeat bg-cover rotate-animation"
    }, null, -1)
    , I0e = T("div", {
        class: "sl-airdrop-page__bg-gradient rounded-full"
    }, null, -1)
    , A0e = {
        class: "text-center"
    }
    , k0e = {
        class: "mt-14 flex justify-center"
    }
    , R0e = {
        class: "sl-airdrop-page__header-title-container text-center relative flex flex-col items-start gap-2 isolate mt-6"
    }
    , M0e = {
        class: "sl-airdrop-page__header-title-container__title italic font-extrabold text-4xl text-center relative z-0 w-full"
    }
    , P0e = T("div", {
        class: "sl-airdrop-page__header-title-container__blur absolute h-3 rounded-full"
    }, null, -1)
    , L0e = {
        class: "text-xl leading-6 px-4 text-white mt-2"
    };
function O0e(t, e, n, s, r, i) {
    const o = q("IconClose")
        , l = q("IconPresent")
        , a = q("TasksList");
    return A(),
        N("div", T0e, [T("button", {
            class: "absolute right-4 top-2 p-2 w-10 bg-white/[.06] rounded-full border border-white/[.06] z-[102]",
            onClick: e[0] || (e[0] = (...c) => i.goToPreviousPage && i.goToPreviousPage(...c))
        }, [G(o)]), C0e, I0e, T("div", A0e, [T("div", k0e, [G(l, {
            class: "pulse-animation"
        })]), T("div", R0e, [T("p", M0e, $(t.$t("airdrop.title")), 1), P0e]), T("div", L0e, $(t.$t("airdrop.subtitle")), 1)]), G(a, {
            class: "mt-4"
        })])
}
const N0e = _e(E0e, [["render", O0e]])
    , D0e = {
        class: "flex gap-0.5 justify-between h-20 px-3 py-2 rounded-lg border border-white/5 items-center bg-[url('/games/card-bg.webp')] overflow-hidden bg-cover"
    }
    , B0e = ["src"]
    , F0e = {
        class: "grow flex flex-col gap-1 justify-center"
    }
    , $0e = {
        class: "text-white leading-tight font-bold"
    }
    , U0e = {
        class: "text-white/60 leading-tight text-xs"
    }
    , V0e = {
        __name: "GameCard",
        props: {
            image: String,
            title: String,
            description: String,
            onClick: Function
        },
        setup(t) {
            const { t: e } = gt();
            return (n, s) => (A(),
                N("div", D0e, [T("img", {
                    class: "h-full object-cover",
                    alt: "Game Image",
                    src: t.image
                }, null, 8, B0e), T("div", F0e, [T("p", $0e, $(t.title), 1), T("p", U0e, $(t.description), 1)]), G(ic, {
                    class: "!w-auto active:scale-90 hover:scale-90",
                    icon: "play",
                    label: de(e)("games.play"),
                    onClick: ni(t.onClick, ["stop", "prevent"])
                }, null, 8, ["label", "onClick"])]))
        }
    }
    , G0e = {
        name: "FortuneWheelHeader"
    }
    , H0e = {
        class: "text-white font-bold text-xl"
    };
function W0e(t, e, n, s, r, i) {
    return A(),
        N("div", H0e, $(t.$t("fortune_wheel.title")), 1)
}
const Y0e = _e(G0e, [["render", W0e]])
    , X0e = {}
    , j0e = {
        width: "25",
        height: "24",
        viewBox: "0 0 25 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }
    , z0e = T("path", {
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        d: "M12.6016 21.1667C7.53895 21.1667 3.4349 17.0626 3.4349 12C3.4349 6.93739 7.53895 2.83333 12.6016 2.83333C17.6642 2.83333 21.7682 6.93739 21.7682 12C21.7682 17.0626 17.6642 21.1667 12.6016 21.1667ZM1.60156 12C1.60156 5.92487 6.52643 1 12.6016 1C18.6767 1 23.6016 5.92487 23.6016 12C23.6016 18.0751 18.6767 23 12.6016 23C6.52643 23 1.60156 18.0751 1.60156 12ZM14.4766 7.96875C14.5547 7.80729 14.5938 7.625 14.5938 7.42188C14.5938 7.25 14.5573 7.09115 14.4844 6.94531C14.4167 6.79948 14.3203 6.67448 14.1953 6.57031C14.0755 6.46094 13.9323 6.3776 13.7656 6.32031C13.599 6.25781 13.4167 6.22656 13.2188 6.22656C13.0052 6.22656 12.8073 6.25781 12.625 6.32031C12.4427 6.38281 12.2839 6.47396 12.1484 6.59375C12.0182 6.70833 11.9141 6.84635 11.8359 7.00781C11.763 7.16927 11.7266 7.35156 11.7266 7.55469C11.7266 7.72656 11.7604 7.88542 11.8281 8.03125C11.901 8.17708 11.9974 8.30469 12.1172 8.41406C12.2422 8.51823 12.388 8.60156 12.5547 8.66406C12.7266 8.72135 12.9115 8.75 13.1094 8.75C13.3177 8.75 13.5104 8.71875 13.6875 8.65625C13.8698 8.59375 14.026 8.50521 14.1562 8.39062C14.2917 8.27083 14.3984 8.13021 14.4766 7.96875ZM13.4531 18.0078C13.5781 17.9818 13.6875 17.9557 13.7812 17.9297C13.849 17.6172 13.9141 17.3099 13.9766 17.0078C14.0391 16.7005 14.1042 16.3906 14.1719 16.0781C14.0573 16.125 13.9297 16.1641 13.7891 16.1953C13.6536 16.2214 13.5182 16.2344 13.3828 16.2344C13.2214 16.2344 13.0781 16.1953 12.9531 16.1172C12.8281 16.0391 12.7656 15.901 12.7656 15.7031C12.7656 15.5365 12.7891 15.3411 12.8359 15.1172C12.8828 14.888 12.9271 14.6823 12.9688 14.5L13.9219 10H11.4219C11.401 10.0885 11.3646 10.2526 11.3125 10.4922C11.2656 10.7266 11.2083 10.9974 11.1406 11.3047C11.0781 11.612 11.0104 11.9375 10.9375 12.2812C10.8646 12.6198 10.7943 12.9427 10.7266 13.25C10.6641 13.5573 10.6068 13.8307 10.5547 14.0703C10.5078 14.3047 10.474 14.4661 10.4531 14.5547C10.4219 14.7005 10.3906 14.8542 10.3594 15.0156C10.3333 15.1719 10.3099 15.3281 10.2891 15.4844C10.2682 15.6354 10.25 15.7812 10.2344 15.9219C10.224 16.0625 10.2188 16.1901 10.2188 16.3047C10.2188 16.5755 10.2552 16.8255 10.3281 17.0547C10.4062 17.2786 10.526 17.474 10.6875 17.6406C10.849 17.8021 11.0521 17.9271 11.2969 18.0156C11.5469 18.1094 11.8464 18.1562 12.1953 18.1562C12.3411 18.1562 12.487 18.1484 12.6328 18.1328C12.7839 18.1224 12.9271 18.1042 13.0625 18.0781C13.2031 18.0573 13.3333 18.0339 13.4531 18.0078Z",
        fill: "white"
    }, null, -1)
    , q0e = [z0e];
function K0e(t, e) {
    return A(),
        N("svg", j0e, q0e)
}
const CS = _e(X0e, [["render", K0e]])
    , J0e = "/fortuneWheel/help-image.webp"
    , Z0e = {
        name: "FortuneWheelRulesPopup",
        components: {
            ButtonPrimary: Lr,
            Popup: il
        },
        props: {
            isVisible: {
                type: Boolean,
                required: !0
            },
            onClose: Function
        }
    }
    , Q0e = {
        class: "text-xl font-semibold text-white"
    }
    , e1e = {
        class: "flex flex-col gap-3 justify-center items-center mt-3"
    }
    , t1e = T("div", null, [T("img", {
        class: "max-w-[228px]",
        src: J0e
    })], -1)
    , n1e = {
        class: "text-center text-white/60"
    }
    , s1e = {
        class: "text-white font-semibold"
    }
    , r1e = {
        class: "text-white font-semibold"
    };
function i1e(t, e, n, s, r, i) {
    const o = q("ButtonPrimary")
        , l = q("Popup");
    return A(),
        fe(l, {
            "is-visible": n.isVisible,
            onClose: n.onClose
        }, {
            default: Ce(() => [T("h2", Q0e, $(t.$t("fortune_wheel.rules.title")) + ": ", 1), T("div", e1e, [t1e, T("p", n1e, [Fe($(t.$t("fortune_wheel.rules.body1_part1")) + " ", 1), T("span", s1e, $(t.$t("fortune_wheel.rules.body1_part2")), 1), Fe(" " + $(t.$t("fortune_wheel.rules.body1_part3")) + " ", 1), T("span", r1e, $(t.$t("fortune_wheel.rules.body1_part4")), 1)])]), G(o, {
                size: "l",
                type: "success",
                onClick: n.onClose,
                class: "w-full"
            }, {
                default: Ce(() => [Fe($(t.$t("fortune_wheel.rules.got_it")), 1)]),
                _: 1
            }, 8, ["onClick"])]),
            _: 1
        }, 8, ["is-visible", "onClose"])
}
const o1e = _e(Z0e, [["render", i1e]])
    , a1e = {
        name: "FortuneWheelLuck",
        components: {
            FortuneWheelRulesPopup: o1e,
            IconHelp: CS
        },
        data() {
            return {
                isHelpPopupVisible: !1,
                fortuneWheelStore: zo()
            }
        },
        methods: {
            onHelpIconClick() {
                this.isHelpPopupVisible = !0
            },
            onHelpPopupClose() {
                this.isHelpPopupVisible = !1
            }
        }
    }
    , l1e = {
        class: "flex flex-col items-center w-full px-10"
    }
    , c1e = {
        class: "text-sm text-white/[.4] flex items-center space-x-1 mt-3"
    };
function u1e(t, e, n, s, r, i) {
    const o = q("IconHelp")
        , l = q("FortuneWheelRulesPopup");
    return A(),
        N("div", l1e, [T("div", c1e, [T("span", null, $(t.$t("fortune_wheel.how_does_this_work")), 1), T("span", {
            class: "cursor-pointer text-white/[.4]",
            onClick: e[0] || (e[0] = (...a) => i.onHelpIconClick && i.onHelpIconClick(...a))
        }, [G(o)])]), G(l, {
            isVisible: r.isHelpPopupVisible,
            onClose: i.onHelpPopupClose
        }, null, 8, ["isVisible", "onClose"])])
}
const h1e = _e(a1e, [["render", u1e], ["__scopeId", "data-v-51115965"]])
    , d1e = {
        class: "absolute right-4 top-4 rounded-full bg-white/[.06] active:bg-white/[.12] hover:active:bg-white/[.12] cursor-pointer will-change-transform"
    }
    , f1e = {
        class: "relative w-full h-full rounded-full overflow-hidden flex flex-row justify-between gap-1 items-center p-1.5 border-s border-white/[.04]"
    }
    , p1e = T("span", null, [T("img", {
        class: "w-5 h-5",
        src: xS
    })], -1)
    , m1e = {
        class: "text-accent font-semibold"
    }
    , g1e = {
        key: 0
    }
    , _1e = T("div", {
        class: "absolute w-5 h-3 bottom-[-6px] left-2 bg-gradient-to-r from-[#DD0A6F] to-[#FF5B70] blur-[11.35px] rounded-full"
    }, null, -1)
    , y1e = {
        __name: "SpinBalance",
        setup(t) {
            const e = zo()
                , n = ve(() => e.spinBalance)
                , s = Q_()
                , r = ve(() => s.isAvailableForWheel(e.wheel.name));
            return (i, o) => (A(),
                N("div", d1e, [T("div", f1e, [p1e, T("span", m1e, $(n.value), 1), r.value ? (A(),
                    N("span", g1e, [G(qx, {
                        class: "w-5 h-5 fill-white/[.6]"
                    })])) : te("", !0), _1e, G(Ki, {
                        hasInterval: !0
                    })])]))
        }
    }
    , YL = t => WY.indexOf(t) !== -1
    , Hd = t => zY.indexOf(t) !== -1
    , XL = t => KY.indexOf(t) !== -1
    , IS = t => qY.indexOf(t) !== -1
    , jL = t => XY.indexOf(t) !== -1
    , zL = t => YY.indexOf(t) !== -1
    , dg = t => jY.indexOf(t) !== -1
    , b1e = t => JY.indexOf(t) !== -1
    , v1e = {
        name: "FortuneWheelPresentHeader",
        computed: {
            gradientStyle() {
                return this.tier ? {
                    ...$x(this.tier),
                    backgroundClip: "text",
                    WebkitBackgroundClip: "text",
                    WebkitTextFillColor: "transparent"
                } : {}
            }
        },
        props: {
            rewardType: {
                type: String,
                required: !0
            },
            value: Number,
            girl: Object,
            tier: String
        },
        methods: {
            formattingPrice: Xt,
            isBoxReward: dg,
            isProfitBoostReward: jL,
            isEnergyBoostReward: zL,
            isGirlReward: IS,
            isJackpot: Hd,
            isSpinReward: XL,
            isSlapReward: YL
        }
    }
    , x1e = {
        class: "text-xl font-semibold"
    }
    , w1e = {
        class: "w-full"
    }
    , S1e = {
        key: 0
    }
    , E1e = {
        key: 1
    }
    , T1e = {
        key: 2
    }
    , C1e = {
        key: 3
    }
    , I1e = {
        key: 0,
        class: "text-xl text-center font-normal capitalize text-white/[.48]"
    }
    , A1e = {
        key: 1,
        class: "text-xl font-bold text-center"
    };
function k1e(t, e, n, s, r, i) {
    return A(),
        N(Ie, null, [T("div", x1e, $(t.$t("fortune_wheel.present.you_get")), 1), G(is, {
            name: "fade"
        }, {
            default: Ce(() => [T("div", w1e, [T("div", {
                class: "font-extrabold text-4xl italic text-transparent bg-clip-text flex flex-row gap-2 items-center justify-center w-full text-center",
                style: Wt(i.gradientStyle)
            }, [i.isSlapReward(n.rewardType) ? (A(),
                N("p", S1e, $(i.formattingPrice(+n.value)) + " SLAP ", 1)) : te("", !0), i.isSpinReward(n.rewardType) ? (A(),
                    N("p", E1e, $(n.value) + " SPIN", 1)) : te("", !0), i.isProfitBoostReward(n.rewardType) || i.isEnergyBoostReward(n.rewardType) || i.isBoxReward(n.rewardType) ? (A(),
                        N("p", T1e, $(t.$t(`fortune_wheel.reward_type.${n.rewardType}`)), 1)) : te("", !0), i.isGirlReward(n.rewardType) ? (A(),
                            N("p", C1e, $(t.$t(`girls.names.${n.girl.name}`)), 1)) : te("", !0)], 4), i.isGirlReward(n.rewardType) ? (A(),
                                N("div", I1e, $(t.$t(`girls.collections.${n.girl.collection}`)), 1)) : te("", !0), i.isJackpot(n.rewardType) ? (A(),
                                    N("div", A1e, $(t.$t("fortune_wheel.jackpot")) + "! ", 1)) : te("", !0)])]),
            _: 1
        })], 64)
}
const R1e = _e(v1e, [["render", k1e], ["__scopeId", "data-v-3886170a"]])
    , M1e = "/fortuneWheel/jackpot_coins.png"
    , P1e = "/boxes/box-common.webp"
    , L1e = {
        name: "FortuneWheelPresent",
        components: {
            FortuneWheelPresentHeader: R1e,
            ProfitBoostCard: jx,
            EnergyBoostCard: Wx,
            GiftCard: I4,
            GirlCard: k4,
            CoinCard: w4,
            ShareButton: UL,
            Blik: Ki,
            ButtonSecondary: FL
        },
        props: {
            reward: {
                type: Object,
                required: !0
            },
            isVisible: {
                type: Boolean,
                required: !0
            }
        },
        data() {
            return {
                fortuneWheelStore: zo(),
                showJackpotMessage: !1
            }
        },
        methods: {
            isSharableReward: b1e,
            isBoxReward: dg,
            isEnergyBoostReward: zL,
            isProfitBoostReward: jL,
            isGirlReward: IS,
            isJackpot: Hd,
            isSpinReward: XL,
            isSlapReward: YL,
            onClose() {
                var t;
                if (dg((t = this.reward) == null ? void 0 : t.type)) {
                    const { showSuccessToast: e } = mi();
                    e("toast_messages.added_to_my_lootboxes")
                }
                this.$emit("close")
            },
            triggerJackpotAnimation() {
                this.showJackpotMessage = !0,
                    setTimeout(() => {
                        this.showJackpotMessage = !1
                    }
                        , 2e3)
            }
        },
        computed: {
            shareData() {
                var n;
                const t = Ye()
                    , e = ES(t.userId);
                return {
                    text: this.$t(`fortune_wheel.share_text.${this.reward.type}`, {
                        amount: this.reward.value,
                        name: this.girl ? this.$t(`girls.names.${(n = this.girl) == null ? void 0 : n.name}`) : "",
                        reward_type: this.$t(`fortune_wheel.reward_type.${this.reward.type}`),
                        rarity: this.$t(`girls.rarity.${this.tier}`),
                        link: e
                    }),
                    url: e
                }
            },
            girl() {
                return this.reward.girl_id ? ls().getGirlById(this.reward.girl_id) : null
            },
            tier() {
                if (this.girl)
                    return this.girl.tier;
                switch (this.reward.type) {
                    case He.LOOTBOX_STANDARD:
                    case He.PROFIT_BOOST_COMMON:
                    case He.ENERGY_BOOST_COMMON:
                    case He.GIRL_REGULAR:
                        return Pt.COMMON;
                    case He.PROFIT_BOOST_RARE:
                    case He.ENERGY_BOOST_RARE:
                    case He.STARTER_RARE:
                        return Pt.RARE;
                    case He.PROFIT_BOOST_EPIC:
                    case He.ENERGY_BOOST_EPIC:
                    case He.STARTER_EPIC:
                        return Pt.EPIC;
                    case He.LOOTBOX_JACKPOT:
                    case He.PROFIT_BOOST_LEGENDARY:
                    case He.ENERGY_BOOST_LEGENDARY:
                    case He.SLAP_JACKPOT:
                    case He.SLAP_SMALL:
                    case He.SLAP_MEDIUM:
                    case He.SLAP_LARGE:
                    case He.SLAP_PITTY_JACKPOT:
                    case He.STARTER_LEGENDARY:
                        return Pt.LEGENDARY;
                    default:
                        return Pt.COMMON
                }
            }
        },
        mounted() {
            Hd(this.reward.type) && this.triggerJackpotAnimation()
        }
    }
    , qL = t => (Wo("data-v-30b78563"),
        t = t(),
        Yo(),
        t)
    , O1e = {
        class: "absolute h-screen w-full z-[12] bg-black/[.60]"
    }
    , N1e = {
        key: 0,
        class: "fixed inset-0 bg-black bg-opacity-70 z-50"
    }
    , D1e = {
        class: "relative h-full w-full flex items-center justify-center"
    }
    , B1e = qL(() => T("div", {
        class: "absolute"
    }, [T("img", {
        src: M1e
    })], -1))
    , F1e = {
        class: "text-white text-[84px] leading-[116px] text-center font-extrabold italic transform -rotate-[15deg]"
    }
    , $1e = {
        key: 0
    }
    , U1e = {
        class: "flex flex-col items-center justify-center p-3 h-[calc(100vh-134px-60px)]"
    }
    , V1e = {
        class: "py-4 h-full flex flex-col justify-center"
    }
    , G1e = {
        class: "w-[192px] h-[296px]"
    }
    , H1e = ["src"]
    , W1e = {
        key: 0,
        class: "mt-3"
    }
    , Y1e = ["src"]
    , X1e = {
        class: "fixed bottom-0 left-0 right-0 px-10 pb-[46px] flex flex-col justify-center items-center"
    }
    , j1e = {
        key: 0,
        class: "text-xl text-white/[.80] flex items-center gap-2"
    }
    , z1e = qL(() => T("img", {
        class: "w-6 h-6",
        src: P1e
    }, null, -1))
    , q1e = {
        class: "flex flex-row gap-3 mt-4"
    }
    , K1e = {
        key: 0,
        class: "relative"
    };
function J1e(t, e, n, s, r, i) {
    var f;
    const o = q("FortuneWheelPresentHeader")
        , l = q("GirlCard")
        , a = q("ProfitBoostCard")
        , c = q("EnergyBoostCard")
        , u = q("ShareButton")
        , h = q("Blik")
        , d = q("ButtonSecondary");
    return A(),
        N("div", O1e, [G(is, {
            name: "fade"
        }, {
            default: Ce(() => [r.showJackpotMessage ? (A(),
                N("div", N1e, [T("div", D1e, [B1e, T("span", F1e, $(t.$t("fortune_wheel.jackpot")) + "! ", 1)])])) : te("", !0)]),
            _: 1
        }), n.isVisible && !r.showJackpotMessage ? (A(),
            N("div", $1e, [T("div", U1e, [G(o, {
                rewardType: n.reward.type,
                value: n.reward.value,
                tier: i.tier,
                girl: i.girl
            }, null, 8, ["rewardType", "value", "tier", "girl"]), T("div", V1e, [T("div", G1e, [i.isSlapReward(n.reward.type) || i.isSpinReward(n.reward.type) || i.isBoxReward(n.reward.type) ? (A(),
                N("img", {
                    key: 0,
                    src: `/fortuneWheel/rewardTypes/${n.reward.type}.webp`
                }, null, 8, H1e)) : te("", !0), i.isGirlReward(n.reward.type) ? (A(),
                    fe(l, {
                        key: 1,
                        id: n.reward.girl_id
                    }, null, 8, ["id"])) : te("", !0), i.isProfitBoostReward(n.reward.type) ? (A(),
                        fe(a, {
                            key: 2,
                            tier: i.tier,
                            clickable: !1,
                            showName: !0,
                            showButton: !1,
                            hideAmount: !0
                        }, null, 8, ["tier"])) : te("", !0), i.isEnergyBoostReward(n.reward.type) ? (A(),
                            fe(c, {
                                key: 3,
                                tier: i.tier,
                                clickable: !1,
                                showName: !0,
                                showButton: !1,
                                hideAmount: !0
                            }, null, 8, ["tier"])) : te("", !0)])]), n.reward.sponsor_id ? (A(),
                                N("div", W1e, [T("img", {
                                    src: `/fortuneWheel/sponsors/${(f = r.fortuneWheelStore.getSponsorName(n.reward.sponsor_id)) == null ? void 0 : f.toLowerCase()}.png`
                                }, null, 8, Y1e)])) : te("", !0)]), T("div", X1e, [i.isSharableReward(n.reward.type) ? (A(),
                                    N("div", j1e, [Fe($(t.$t("fortune_wheel.present.share_and_get")) + " ", 1), z1e])) : te("", !0), T("div", q1e, [i.isSharableReward(n.reward.type) ? (A(),
                                        N("div", K1e, [G(u, {
                                            text: i.shareData.text,
                                            url: i.shareData.url,
                                            rewardType: n.reward.type
                                        }, null, 8, ["text", "url", "rewardType"]), G(h, {
                                            hasInterval: !0
                                        })])) : te("", !0), T("div", null, [G(d, {
                                            label: t.$t("fortune_wheel.present.claim"),
                                            onClick: i.onClose
                                        }, null, 8, ["label", "onClick"])])])])])) : te("", !0)])
}
const Z1e = _e(L1e, [["render", J1e], ["__scopeId", "data-v-30b78563"]])
    , Q1e = {
        name: "FortuneWheelShopPopup",
        components: {
            ShopChips: GL,
            Popup: il
        },
        props: {
            isVisible: {
                type: Boolean,
                required: !0
            },
            isOutOfSpins: {
                type: Boolean,
                required: !0
            },
            onClose: Function
        },
        methods: {
            onPurchaseSuccess() {
                this.onClose()
            }
        }
    }
    , eye = {
        class: "flex flex-col gap-3 w-full"
    }
    , tye = {
        class: "text-xl font-semibold text-white"
    }
    , nye = {
        class: "w-full"
    }
    , sye = {
        class: "text-center text-white/60"
    };
function rye(t, e, n, s, r, i) {
    const o = q("ShopChips")
        , l = q("Popup");
    return A(),
        fe(l, {
            "is-visible": n.isVisible,
            onClose: n.onClose
        }, {
            default: Ce(() => [T("div", eye, [T("h2", tye, $(t.$t(n.isOutOfSpins ? "fortune_wheel.shop.alternative_title" : "fortune_wheel.shop.title")), 1), T("div", nye, [G(o, {
                onOnPurchaseSuccess: i.onPurchaseSuccess
            }, null, 8, ["onOnPurchaseSuccess"])]), T("p", sye, $(t.$t("fortune_wheel.shop.helper_text")), 1)])]),
            _: 1
        }, 8, ["is-visible", "onClose"])
}
const iye = _e(Q1e, [["render", rye]])
    , oye = "/fortuneWheel/pointer.png"
    , aye = {
        name: "FortuneWheelBody",
        components: {
            FortuneWheelShopPopup: iye,
            FortuneWheelPresent: Z1e,
            SpinBalance: y1e,
            FortuneWheelLuck: h1e,
            ButtonPrimary: Lr
        },
        data() {
            return {
                currentWheel: this.wheelStore.wheel,
                isSpinning: !1,
                currentAngle: 0,
                targetSectorId: null,
                isPresentVisible: !1,
                isShopPopupVisible: !1,
                speed: 0,
                spinInterval: null,
                reward: null,
                wheelConfig: {
                    style: {
                        radius: 438,
                        containerBorder: 12
                    },
                    initialRotationOffset: 90,
                    maxSpeed: 20,
                    acceleration: .5,
                    constantDuration: 4e3
                }
            }
        },
        computed: {
            numSectors() {
                var t;
                return (t = this.currentWheel) == null ? void 0 : t.sectors.length
            },
            diameter() {
                return this.wheelConfig.style.radius * 2
            },
            containerDiameter() {
                return this.diameter + 2 * this.wheelConfig.style.containerBorder
            },
            rotationOffset() {
                return this.wheelConfig.initialRotationOffset - 360 / this.numSectors / 2
            },
            canBuyChips() {
                var t;
                return this.chipsStore.isAvailableForWheel((t = this.wheelStore.wheel) == null ? void 0 : t.name)
            }
        },
        methods: {
            isJackpot: Hd,
            drawSector(t) {
                const e = t * 360 / this.numSectors + this.rotationOffset
                    , n = e + 360 / this.numSectors
                    , s = this.wheelConfig.style.radius * Math.cos(Math.PI * e / 180)
                    , r = this.wheelConfig.style.radius * Math.sin(Math.PI * e / 180)
                    , i = this.wheelConfig.style.radius * Math.cos(Math.PI * n / 180)
                    , o = this.wheelConfig.style.radius * Math.sin(Math.PI * n / 180);
                return `M 0,0 L ${s},${r} A ${this.wheelConfig.style.radius},${this.wheelConfig.style.radius} 0 0 1 ${i},${o} Z`
            },
            getSectorGradient(t, e) {
                return `url(${HY[this.getSectorType(t, e)]})`
            },
            getSectorType(t, e) {
                return Hd(t.reward_type) ? pu.JACKPOT : e % 2 === 0 ? pu.EVEN : pu.ODD
            },
            getOuterPosition(t, e, n = -90) {
                const s = this.getSectorAngle(t)
                    , r = e * Math.cos(Math.PI * s / 180)
                    , i = e * Math.sin(Math.PI * s / 180);
                return `translate(${r}, ${i}) rotate(${s + n})`
            },
            getSectorAngle(t) {
                return (t + .5) * 360 / this.numSectors + this.rotationOffset
            },
            getSectorValue(t) {
                return dg(t.reward_type) ? this.$t("fortune_wheel.reward_types.gift") : IS(t.reward_type) ? this.$t("fortune_wheel.reward_types.girl") : Xt(+t.value)
            },
            getTargetAngle() {
                if (this.targetSectorId == null)
                    return null;
                const t = this.currentWheel.sectors.findIndex(s => s.id === this.targetSectorId)
                    , e = 360 / this.numSectors
                    , n = Math.floor(Math.random() * (e * .8 - e * .2)) + Math.ceil(e * .2) - Math.ceil(e / 2);
                return 360 - t * e + n
            },
            async spinWheel() {
                if (this.isSpinning)
                    return;
                if (this.wheelStore.spinBalance === 0) {
                    this.onSpinBalanceClick();
                    return
                }
                this.isSpinning = !0;
                const { sector_id: t, reward: e } = await this.wheelStore.spinFortuneWheel();
                this.analyticsStore.logEvent("spin_wheel", {
                    win_sector: t,
                    reward_type: e.type
                }),
                    this.targetSectorId = t,
                    this.reward = e;
                const n = 3 * 360
                    , s = this.getTargetAngle() - this.currentAngle % 360 + n;
                this.currentAngle += s,
                    setTimeout(() => {
                        this.isSpinning = !1,
                            this.isPresentVisible = !0,
                            this.onboardingStore.goToNextStep()
                    }
                        , 5e3)
            },
            onPresentClose() {
                this.isPresentVisible = !1,
                    this.targetSectorId = null,
                    this.reward = null,
                    this.onboardingStore.goToNextStep()
            },
            onSpinBalanceClick() {
                this.canBuyChips && (this.isShopPopupVisible = !0)
            },
            onShopPopupClose() {
                this.isShopPopupVisible = !1
            }
        },
        setup() {
            const t = zo()
                , e = Q_()
                , n = _s()
                , s = Fn();
            return {
                wheelStore: t,
                chipsStore: e,
                onboardingStore: n,
                analyticsStore: s
            }
        }
    }
    , AS = t => (Wo("data-v-7b528a71"),
        t = t(),
        Yo(),
        t)
    , lye = {
        class: "flex flex-col h-screen text-white bg-gradient-to-b from-black to-[#1B1235] rounded-t-3xl"
    }
    , cye = {
        class: "pb-3 max-h-[calc(100vh-140px)] overflow-auto"
    }
    , uye = {
        class: "relative w-full flex justify-center h-[504px] overflow-hidden rounded-t-3xl"
    }
    , hye = {
        class: "absolute -top-[calc(100%-108px)]"
    }
    , dye = AS(() => T("div", {
        class: "absolute rounded-full inset-0",
        style: {
            background: `linear-gradient(270deg, #0172CF 0%, #DD0A6F 100%),
                      conic-gradient(from 176.21deg at 50% 50%, #000000 -24.66deg, #FFFFFF 0.25deg, #000000 50.63deg, #000000 51.97deg, #FFFFFF 88.12deg, #000000 117deg, #000000 169.2deg, #FFFFFF 196.87deg, #000000 256.87deg, #FFFFFF 300deg, #000000 335.2deg, #000000 335.34deg, #FFFFFF 360.25deg),
                      linear-gradient(217.44deg, #DFDFDF 0%, #424141 100%),
                      linear-gradient(0deg, #D9D9D9, #D9D9D9), #D9D9D9`,
            backgroundBlendMode: "screen, soft-light, normal, normal, normal"
        }
    }, null, -1))
    , fye = AS(() => T("div", {
        class: "absolute z-[11] top-[calc(100%-20px)] left-[calc(50%-20px)] w-10 h-10"
    }, [T("img", {
        src: oye
    })], -1))
    , pye = ["width", "height", "viewBox"]
    , mye = Nr('<defs data-v-7b528a71><linearGradient id="jackpot-gradient" x1="0%" y1="0%" x2="0%" y2="100%" data-v-7b528a71><stop offset="0%" stop-color="rgba(255, 149, 0, 0)" data-v-7b528a71></stop><stop offset="50%" stop-color="#FF9500" data-v-7b528a71></stop><stop offset="100%" stop-color="#FFD237" data-v-7b528a71></stop></linearGradient><linearGradient id="even-gradient" x1="0%" y1="0%" x2="0%" y2="100%" data-v-7b528a71><stop offset="0%" stop-color="rgba(255, 255, 255, 0.12)" data-v-7b528a71></stop><stop offset="100%" stop-color="rgba(255, 255, 255, 0)" data-v-7b528a71></stop></linearGradient><linearGradient id="odd-gradient" x1="0%" y1="0%" x2="0%" y2="100%" data-v-7b528a71><stop offset="0%" stop-color="rgba(0, 0, 0, 0.12)" data-v-7b528a71></stop><stop offset="100%" stop-color="rgba(0, 0, 0, 0)" data-v-7b528a71></stop></linearGradient></defs>', 1)
    , gye = ["transform"]
    , _ye = ["d", "fill"]
    , yye = ["transform", "font-size"]
    , bye = ["href", "transform"]
    , vye = ["transform"]
    , xye = ["href", "transform"]
    , wye = ["href"]
    , Sye = AS(() => T("img", {
        src: xS,
        class: "w-6 h-6 mr-1"
    }, null, -1));
function Eye(t, e, n, s, r, i) {
    const o = q("SpinBalance")
        , l = q("FortuneWheelLuck")
        , a = q("FortuneWheelPresent")
        , c = q("FortuneWheelShopPopup")
        , u = q("ButtonPrimary");
    return A(),
        N("div", lye, [T("div", cye, [T("div", uye, [T("div", hye, [T("div", {
            class: "fortune-wheel relative rounded-full",
            style: Wt({
                width: `${i.containerDiameter}px`,
                height: `${i.containerDiameter}px`
            })
        }, [T("div", {
            class: "absolute z-[9] rounded-full",
            style: Wt({
                width: `${i.containerDiameter}px`,
                height: `${i.containerDiameter}px`
            })
        }, [dye, T("div", {
            class: "absolute rounded-full left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 bg-gradient-to-br from-[#2D176F] to-black",
            style: Wt({
                width: `${i.containerDiameter - r.wheelConfig.style.containerBorder}px`,
                height: `${i.containerDiameter - r.wheelConfig.style.containerBorder}px`
            })
        }, null, 4), T("div", {
            class: "absolute rounded-full left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 border-2 border-black box-border",
            style: Wt({
                width: `${i.containerDiameter - r.wheelConfig.style.containerBorder}px`,
                height: `${i.containerDiameter - r.wheelConfig.style.containerBorder}px`
            })
        }, null, 4)], 4), fye, (A(),
            N("svg", {
                width: i.diameter,
                height: i.diameter,
                viewBox: `0 0 ${i.diameter} ${i.diameter}`,
                xmlns: "http://www.w3.org/2000/svg",
                class: "rounded-full overflow-hidden absolute z-[10] will-change-transform wheel-animation",
                ref: "wheel",
                style: Wt({
                    top: `${r.wheelConfig.style.containerBorder}px`,
                    left: `${r.wheelConfig.style.containerBorder}px`,
                    transform: `rotate(${this.currentAngle}deg)`
                })
            }, [mye, T("g", {
                transform: `translate(${r.wheelConfig.style.radius}, ${r.wheelConfig.style.radius})`
            }, [(A(!0),
                N(Ie, null, mt(r.currentWheel.sectors, (h, d) => {
                    var f;
                    return A(),
                        N(Ie, {
                            key: h.id
                        }, [T("path", {
                            d: i.drawSector(d),
                            fill: i.getSectorGradient(h, d),
                            stroke: "black",
                            "stroke-width": "1"
                        }, null, 8, _ye), T("text", {
                            transform: i.getOuterPosition(d, 410),
                            "text-anchor": "middle",
                            "font-size": t.$i18n.locale === "ru" ? 14 : 16,
                            "font-weight": "700",
                            fill: "white"
                        }, $(i.getSectorValue(h)), 9, yye), T("image", {
                            href: `/fortuneWheel/rewardTypes/${h.reward_type}.webp`,
                            x: -16,
                            y: -16,
                            width: "32",
                            height: "32",
                            transform: i.getOuterPosition(d, 370)
                        }, null, 8, bye), i.isJackpot(h.reward_type) && !h.sponsor_id ? (A(),
                            N("text", {
                                key: 0,
                                y: 4,
                                transform: i.getOuterPosition(d, 310, 180),
                                "text-anchor": "middle",
                                "font-size": "16",
                                fill: "black",
                                "font-weight": "600"
                            }, $(t.$t("fortune_wheel.jackpot")), 9, vye)) : te("", !0), h.sponsor_id ? (A(),
                                N("image", {
                                    key: 1,
                                    href: `/fortuneWheel/sponsors/${(f = s.wheelStore.getSponsorName(h.sponsor_id)) == null ? void 0 : f.toLowerCase()}.png`,
                                    x: -16,
                                    y: -16,
                                    width: "87",
                                    height: "29",
                                    transform: i.getOuterPosition(d, 270, 0)
                                }, null, 8, xye)) : te("", !0)], 64)
                }
                ), 128)), T("image", {
                    href: `/fortuneWheel/cores/${r.currentWheel.core_type}.png`,
                    x: "-54",
                    y: "-54",
                    width: "108",
                    height: "108",
                    "clip-path": "circle(54px)"
                }, null, 8, wye)], 8, gye)], 12, pye))], 4)])]), G(o, {
                    class: "z-[11]",
                    onClick: i.onSpinBalanceClick
                }, null, 8, ["onClick"]), G(l, {
                    class: "mt-2.5"
                })]), r.isPresentVisible ? (A(),
                    fe(a, {
                        key: 0,
                        isVisible: r.isPresentVisible,
                        reward: r.reward,
                        onClose: i.onPresentClose
                    }, null, 8, ["isVisible", "reward", "onClose"])) : te("", !0), G(c, {
                        isVisible: r.isShopPopupVisible,
                        isOutOfSpins: s.wheelStore.spinBalance === 0,
                        onClose: i.onShopPopupClose
                    }, null, 8, ["isVisible", "isOutOfSpins", "onClose"]), G(u, {
                        class: "fixed !w-auto left-4 bottom-4 right-4",
                        isLoading: r.isSpinning,
                        onClick: i.spinWheel,
                        size: "l",
                        type: "secondary"
                    }, {
                        default: Ce(() => [Sye, s.wheelStore.spinBalance > 0 || r.isSpinning ? (A(),
                            N(Ie, {
                                key: 0
                            }, [Fe($(t.$t("fortune_wheel.spin")), 1)], 64)) : (A(),
                                N(Ie, {
                                    key: 1
                                }, [Fe($(t.$t("fortune_wheel.shop.title")), 1)], 64))]),
                        _: 1
                    }, 8, ["isLoading", "onClick"])])
}
const Tye = _e(aye, [["render", Eye], ["__scopeId", "data-v-7b528a71"]])
    , Cye = {
        name: "FortuneWheelOverlay",
        computed: {
            ONBOARDING_STEPS() {
                return Be
            }
        },
        components: {
            IconHand: al,
            Overlay: ch,
            FortuneWheelBody: Tye,
            FortuneWheelHeader: Y0e
        },
        props: {
            isVisible: {
                type: Boolean,
                required: !0
            },
            onClose: Function
        },
        data() {
            return {
                onboardingStore: _s()
            }
        }
    };
function Iye(t, e, n, s, r, i) {
    var u;
    const o = q("FortuneWheelHeader")
        , l = q("IconHand")
        , a = q("FortuneWheelBody")
        , c = q("Overlay");
    return A(),
        fe(c, {
            isVisible: n.isVisible,
            onClose: n.onClose,
            showButtons: !1,
            class: "",
            bodyClass: "",
            headerCustomClass: r.onboardingStore.isOnboardingInProgress && ((u = r.onboardingStore.currentStep) == null ? void 0 : u.stepId) !== i.ONBOARDING_STEPS.CLOSE_WHEEL ? "opacity-25 pointer-events-none" : "",
            closeButtonClass: "bg-white/5 rounded-full"
        }, {
            header: Ce(() => [G(o)]),
            default: Ce(() => {
                var h, d;
                return [r.onboardingStore.isOnboardingInProgress ? (A(),
                    fe(l, {
                        key: 0,
                        class: Te(["onboarding-hand", [(h = r.onboardingStore.currentStep) == null ? void 0 : h.stepId]])
                    }, null, 8, ["class"])) : te("", !0), T("div", {
                        class: Te(["relative", [r.onboardingStore.isOnboardingInProgress && ((d = r.onboardingStore.currentStep) == null ? void 0 : d.stepId) === i.ONBOARDING_STEPS.CLOSE_WHEEL && "opacity-25 pointer-events-none"]])
                    }, [G(a)], 2)]
            }
            ),
            _: 1
        }, 8, ["isVisible", "onClose", "headerCustomClass"])
}
const KL = _e(Cye, [["render", Iye], ["__scopeId", "data-v-00e2f0bd"]])
    , Aye = {
        name: "Games",
        components: {
            FortuneWheelOverlay: KL,
            GameCard: V0e,
            MainFooter: jo,
            Header: oc
        },
        mixins: [Ef],
        setup(t, { emit: e }) {
            const { t: n, locale: s } = gt()
                , r = zo()
                , i = ve(() => [{
                    id: "wheel_fortune",
                    title: n("games.wheel_fortune.title"),
                    description: n("games.wheel_fortune.description"),
                    image: "/shop/chip.webp",
                    onClick: () => {
                        r.show = !0
                    }
                }]);
            return Or(() => {
                e("ready")
            }
            ),
            {
                t: n,
                locale: s,
                locales: js,
                games: i
            }
        }
    }
    , kye = {
        class: "overflow-hidden flex flex-col h-[calc(100%-90px)]"
    }
    , Rye = {
        class: "flex grow flex-col gap-6 overflow-auto px-4"
    }
    , Mye = {
        class: "flex flex-col gap-3"
    }
    , Pye = {
        class: "text-white text-xl font-semibold leading-none"
    }
    , Lye = {
        class: "flex flex-col gap-3"
    }
    , Oye = {
        class: "flex flex-col gap-3"
    }
    , Nye = {
        class: "text-white text-xl font-semibold leading-none"
    }
    , Dye = ["src"];
function Bye(t, e, n, s, r, i) {
    const o = q("Header")
        , l = q("GameCard")
        , a = q("MainFooter");
    return A(),
        N("div", kye, [G(o), T("main", Rye, [T("div", Mye, [T("h4", Pye, $(s.t("games.title")), 1), T("div", Lye, [(A(!0),
            N(Ie, null, mt(s.games, c => (A(),
                fe(l, Ms({
                    key: c.id,
                    ref_for: !0
                }, c), null, 16))), 128))])]), T("div", Oye, [T("h4", Nye, $(s.t("games.label_in_dev")), 1), T("img", {
                    class: "w-full rounded-lg border border-white/5 object-cover",
                    alt: "In development banner",
                    src: `/games/soon-banner-${s.locale === s.locales.RU ? s.locales.RU : s.locales.EN}.webp`
                }, null, 8, Dye)])]), G(a)])
}
const Fye = _e(Aye, [["render", Bye]])
    , $ye = {
        name: "Capacity",
        props: {
            girl: {
                type: Object,
                required: !0
            },
            size: {
                type: String,
                default: "m",
                validator: t => ["s", "m"].includes(t)
            }
        }
    }
    , Uye = {
        class: "font-bold text-coin"
    };
function Vye(t, e, n, s, r, i) {
    const o = q("IconCoin");
    return A(),
        N("div", {
            class: Te(["flex justify-start items-center gap-2 px-3 py-1 text-white", {
                "bg-white/[.06] backdrop-blur-lg rounded-lg text-base text-white": n.size === "m",
                "text-xxs": n.size === "s"
            }])
        }, [G(o, {
            class: Te([{
                "w-6 h-6": n.size === "m",
                "w-4 h-4": n.size === "s"
            }])
        }, null, 8, ["class"]), T("span", Uye, $(n.girl.balance) + " / " + $(n.girl.capacity), 1), T("span", null, "(+" + $(n.girl.perHour) + "/" + $(t.$t("hour_short")) + ")", 1)], 2)
}
const Gye = _e($ye, [["render", Vye]])
    , Hye = {
        name: "GirlOverlay",
        computed: {
            girlCard() {
                var e;
                const t = this.girlsStore.getGirlById(this.girlCardId);
                return (e = _S(t).value) == null ? void 0 : e[0]
            }
        },
        components: {
            Glow: gr,
            Capacity: Gye,
            IconCoin: dn,
            Overlay: ch
        },
        props: {
            className: {
                type: String
            },
            isVisible: {
                type: Boolean,
                default: !1
            },
            girlCardId: {
                type: String
            }
        },
        data() {
            return {
                girlsStore: ls()
            }
        },
        methods: {
            onClose() {
                this.$emit("close")
            }
        }
    }
    , Wye = t => (Wo("data-v-8ce46fe3"),
        t = t(),
        Yo(),
        t)
    , Yye = {
        class: "text-white text-xl capitalize"
    }
    , Xye = {
        class: "text-white/80 text-xs font-normal capitalize"
    }
    , jye = {
        class: "flex flex-col items-center"
    }
    , zye = Wye(() => T("div", {
        class: "absolute z-[5] bottom-0 left-0 right-0 h-64 bg-gradient-to-t from-black to-transparent"
    }, null, -1))
    , qye = {
        class: "absolute z-[3] bottom-0 w-full max-h-[90%] overflow-hidden"
    }
    , Kye = ["src"]
    , Jye = {
        class: "self-start z-10 content-end flex flex-col items-start gap-2 w-full"
    };
function Zye(t, e, n, s, r, i) {
    const o = q("Glow")
        , l = q("Capacity")
        , a = q("Overlay");
    return A(),
        fe(a, {
            isVisible: n.isVisible,
            onClose: i.onClose,
            showCloseButton: "",
            class: "sl-girl-card__bg flex flex-col",
            bodyClass: "grow justify-end flex flex-col",
            headerCustomClass: "z-[3]"
        }, {
            header: Ce(() => [T("h3", Yye, $(t.$t(`girls.names.${i.girlCard.name}`)), 1), T("span", Xye, $(t.$t(`girls.collections.${i.girlCard.collection}`)), 1)]),
            default: Ce(() => [G(o, {
                class: "self-center bottom-0 z-[-1]",
                tier: i.girlCard.tier,
                blur: "140"
            }, null, 8, ["tier"]), T("div", jye, [zye, T("div", qye, [T("img", {
                class: "w-full h-full object-cover",
                src: i.girlCard.path,
                alt: "preview girl"
            }, null, 8, Kye)]), T("div", Jye, [G(l, {
                girl: i.girlCard,
                class: "ml-4"
            }, null, 8, ["girl"])])])]),
            _: 1
        }, 8, ["isVisible", "onClose"])
}
const Qye = _e(Hye, [["render", Zye], ["__scopeId", "data-v-8ce46fe3"]])
    , ebe = {}
    , tbe = {
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }
    , nbe = T("path", {
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        d: "M7.29289 3.79289C7.68342 3.40237 8.31658 3.40237 8.70711 3.79289L16.2071 11.2929C16.5976 11.6834 16.5976 12.3166 16.2071 12.7071L8.70711 20.2071C8.31658 20.5976 7.68342 20.5976 7.29289 20.2071C6.90237 19.8166 6.90237 19.1834 7.29289 18.7929L14.0858 12L7.29289 5.20711C6.90237 4.81658 6.90237 4.18342 7.29289 3.79289Z",
        fill: "white"
    }, null, -1)
    , sbe = [nbe];
function rbe(t, e) {
    return A(),
        N("svg", tbe, sbe)
}
const kS = _e(ebe, [["render", rbe]])
    , ibe = {
        name: "EquipUnequipPanel",
        components: {
            IconHelp: CS,
            ButtonPrimary: Lr
        },
        data() {
            return {
                globalStore: Ye()
            }
        },
        props: {
            selectedGirl: Object,
            onEquipUnequipClick: Function,
            onHelpIconClick: Function
        }
    }
    , obe = {
        key: 0,
        class: "equip-unequip-panel flex flex-row gap-2"
    };
function abe(t, e, n, s, r, i) {
    const o = q("ButtonPrimary")
        , l = q("IconHelp");
    return n.selectedGirl != null ? (A(),
        N("div", obe, [G(o, {
            size: "l",
            type: n.selectedGirl.slot == null ? "success" : "error",
            onClick: e[0] || (e[0] = a => n.onEquipUnequipClick())
        }, {
            default: Ce(() => [Fe($(n.selectedGirl.slot == null ? t.$t("girls.my_girls.equip_button_label") : t.$t("girls.my_girls.unequip_button_label")), 1)]),
            _: 1
        }, 8, ["type"]), G(o, {
            class: "aspect-square !w-auto",
            size: "l",
            type: "dark",
            onClick: ni(n.onHelpIconClick, ["stop"])
        }, {
            default: Ce(() => [G(l, {
                class: "h-6 w-6",
                onClick: ni(n.onHelpIconClick, ["stop"])
            }, null, 8, ["onClick"])]),
            _: 1
        }, 8, ["onClick"])])) : te("", !0)
}
const lbe = _e(ibe, [["render", abe], ["__scopeId", "data-v-c11a7523"]])
    , cbe = {
        name: "ActiveGirlsPanel",
        components: {
            UserSlots: TS,
            LockAvatar: bS,
            GirlAvatar: vS
        },
        props: {
            isCollapsed: Boolean,
            onGirlAvatarClick: Function
        },
        computed: {
            ...Pv(ls, ["girlsInSlots", "maxSlots", "lockedSlots", "slots"])
        }
    }
    , ube = {
        class: "active-girls-panel__label-container pl-1"
    }
    , hbe = {
        class: "active-girls-panel__label"
    }
    , dbe = {
        class: "active-girls-panel__counter ml-[6px]"
    };
function fbe(t, e, n, s, r, i) {
    const o = q("UserSlots");
    return A(),
        N("div", {
            class: Te(["active-girls-panel flex flex-row items-center gap-1", {
                "active-girls-panel--scrolled": n.isCollapsed
            }])
        }, [T("div", ube, [T("span", hbe, $(t.$t("girls.active_girls.label")) + ":", 1), T("span", dbe, $(t.girlsInSlots.length) + "/" + $(t.maxSlots), 1)]), G(o, {
            isCollapsed: n.isCollapsed,
            shrinkOnCollapse: !0,
            onGirlAvatarClick: n.onGirlAvatarClick
        }, null, 8, ["isCollapsed", "onGirlAvatarClick"])], 2)
}
const pbe = _e(cbe, [["render", fbe], ["__scopeId", "data-v-adc60c30"]])
    , mbe = {
        name: "CollectionsTab",
        components: {
            IconArrowRightWhite: kS
        },
        data() {
            return {
                selectedCollectionsIndex: 0
            }
        },
        methods: {
            onClickLink(t) {
                this.$router.push({
                    path: "/shop",
                    query: {
                        collection: t
                    }
                })
            },
            selectCollection(t) {
                this.selectedCollectionsIndex = t,
                    this.scrollToCollection(t)
            },
            scrollToCollection(t) {
                const e = this.$refs.collectionItems[t];
                e && e.scrollIntoView({
                    behavior: "smooth"
                })
            },
            onScroll(t) {
                const e = this.$refs.collectionItems;
                let n = 0;
                for (let s = 0; s < e.length; s++) {
                    const r = e[s].getBoundingClientRect();
                    if (r.top >= 0 && r.top <= window.innerHeight) {
                        n = s;
                        break
                    }
                }
                this.selectedCollectionsIndex = n
            }
        },
        setup() {
            return {
                globalStore: Ye()
            }
        },
        mounted() {
            window.addEventListener("scroll", this.onScroll)
        },
        beforeDestroy() {
            window.removeEventListener("scroll", this.onScroll)
        }
    }
    , gbe = {
        class: "fixed left-4 right-4 top-[68px]"
    }
    , _be = {
        class: "flex overflow-auto -mr-4 mb-4 pb-1.5"
    }
    , ybe = ["onClick"]
    , bbe = ["src"]
    , vbe = {
        key: 1,
        class: "text-white font-semibold text-xxl leading-7 mb-2"
    }
    , xbe = {
        key: 2,
        class: "text-xs leading-4 text-white/60 mb-2"
    }
    , wbe = ["onClick"]
    , Sbe = {
        class: "flex flex-wrap content-start -mb-3 mt-3 gap-3"
    }
    , Ebe = ["src"];
function Tbe(t, e, n, s, r, i) {
    const o = q("IconArrowRightWhite");
    return A(),
        N("div", gbe, [T("div", _be, [(A(!0),
            N(Ie, null, mt(s.globalStore.collections, (l, a) => (A(),
                N("div", {
                    class: Te(["text-[15px] leading-5 whitespace-nowrap mr-5", {
                        "font-semibold text-white": a === r.selectedCollectionsIndex,
                        "text-white/40": a !== r.selectedCollectionsIndex
                    }]),
                    key: "index",
                    onClick: c => i.selectCollection(a)
                }, $(l.title), 11, ybe))), 128))]), T("div", {
                    class: "pr-[5px] mr-[-5px] max-h-[calc(var(--vh,1vh)*100-210px)] overflow-auto",
                    ref: "itemsContainer",
                    onScroll: e[0] || (e[0] = (...l) => i.onScroll && i.onScroll(...l))
                }, [(A(!0),
                    N(Ie, null, mt(s.globalStore.collections, (l, a) => (A(),
                        N("div", {
                            class: "mb-10 last:mb-0",
                            key: "index",
                            ref_for: !0,
                            ref: "collectionItems"
                        }, [l.pic ? (A(),
                            N("img", {
                                key: 0,
                                class: "mb-2",
                                src: l.pic,
                                alt: ""
                            }, null, 8, bbe)) : te("", !0), l.subtitle ? (A(),
                                N("div", vbe, $(l.subtitle), 1)) : te("", !0), l.desc ? (A(),
                                    N("div", xbe, $(l.desc), 1)) : te("", !0), l.link ? (A(),
                                        N("div", {
                                            key: 3,
                                            class: "inline-flex align-top text-[11px] leading-3 text-white py-2 px-3 bg-white/[.08] rounded-2xl max-w-[calc(100%-190px)] active:bg-white/[.16] hover:bg-white/[.16] mb-2 cursor-pointer",
                                            onClick: c => i.onClickLink(l.title)
                                        }, [Fe(" Learn more "), G(o, {
                                            class: "w-[12px] ml-1"
                                        })], 8, wbe)) : te("", !0), T("div", Sbe, [(A(!0),
                                            N(Ie, null, mt(l.items, (c, u) => (A(),
                                                N("div", {
                                                    key: u,
                                                    class: "flex-[0_0_calc(33.33%-8px)] rounded-[8px] relative flex flex-col justify-end bg-[#06050a] overflow-hidden nth-child-3n:mr-0"
                                                }, [T("img", {
                                                    src: c,
                                                    alt: ""
                                                }, null, 8, Ebe)]))), 128))])], 512))), 128))], 544)])
}
const Cbe = _e(mbe, [["render", Tbe]])
    , Ibe = {
        name: "SlapGirlsPage",
        components: {
            UnlockSlotBanner: WL,
            Glow: gr,
            CollectionsTab: Cbe,
            IconHand: al,
            Blik: Ki,
            IconBlik: Vx,
            IconPrimary: yS,
            IconPlus: qx,
            ActiveGirlsPanel: pbe,
            EquipUnequipPanel: lbe,
            MainFooter: jo,
            IconArrowRightWhite: kS,
            GirlOverlay: Qye
        },
        mixins: [Ef],
        data() {
            return {
                globalStore: Ye(),
                onboardingStore: _s(),
                girlsStore: ls(),
                analyticsStore: Fn(),
                cards: _S(),
                tabs: [{
                    id: "girls"
                }, {
                    id: "collections"
                }],
                selectedTabId: "girls",
                showGirlModal: !1,
                selectedGirlId: null,
                isScrolled: !1,
                isBlikActive: !1,
                lastTapTime: 0,
                doubleTapDelay: GY.DOUBLE_TAP_DELAY_MS,
                scaledId: null
            }
        },
        computed: {
            ONBOARDING_STEPS() {
                return Be
            },
            selectedGirl() {
                return this.selectedGirlId != null ? this.cards.find(t => t.id === this.selectedGirlId) : null
            }
        },
        methods: {
            onGirlContainerScroll(t) {
                this.isScrolled = t.target.scrollTop > 25
            },
            onChangeTab(t) {
                this.selectedTabId = t
            },
            triggerBlik() {
                this.isBlikActive = !0,
                    setTimeout(() => {
                        this.isBlikActive = !1
                    }
                        , 180)
            },
            onCardPressStart(t) {
                this.scaledId = t,
                    ur("light")
            },
            onGirlPressEnd(t) {
                this.scaledId && (this.triggerBlik(),
                    ur("medium"),
                    this.scaledId = null,
                    this.onGirlClick(t))
            },
            onCardPressCancel() {
                this.scaledId = null
            },
            onGirlClick(t) {
                var s;
                const e = new Date().getTime()
                    , n = e - this.lastTapTime;
                this.lastTapTime = e,
                    n < this.doubleTapDelay && n > 0 ? (this.selectedGirlId = t.id,
                        this.onEquipUnequipClick()) : this.selectedGirlId === t.id && n > this.doubleTapDelay ? this.selectedGirlId = null : this.selectedGirlId = t.id,
                    this.selectedGirlId && ((s = this.onboardingStore.currentStep) == null ? void 0 : s.stepId) === Be.SECOND_GIRL && this.onboardingStore.goToNextStep()
            },
            onAddGirlNewPressEnd() {
                this.scaledId = null,
                    ur("medium"),
                    this.$router.push(ft.SHOP)
            },
            onGirlAvatarClick(t) {
                this.selectedGirlId = t.id;
                const e = this.$refs[`card${t.id}`][0];
                e && e.scrollIntoView({
                    behavior: "smooth",
                    block: "start"
                })
            },
            async onEquipUnequipClick() {
                var e;
                if (((e = this.onboardingStore.currentStep) == null ? void 0 : e.stepId) === Be.SECOND_GIRL_CHOSEN && this.onboardingStore.goToNextStep(),
                    this.selectedGirl.slot == null) {
                    if (this.girlsStore.emptySlots <= 0) {
                        this.globalStore.showModal(this.$t("validation.all_slots_busy"), async n => {
                            n && (this.girlsStore.equipGirl(this.selectedGirlId),
                                await this.updateSlotsOnBackend())
                        }
                            , !0, "", {
                            confirmLabel: this.$t("modal.replace"),
                            cancelLabel: this.$t("modal.cancel")
                        });
                        return
                    }
                    this.girlsStore.equipGirl(this.selectedGirlId),
                        this.triggerBlik()
                } else
                    this.girlsStore.unequipGirl(this.selectedGirlId),
                        this.selectedGirlId = null;
                await this.updateSlotsOnBackend()
            },
            onHelpIconClick() {
                this.showGirlModal = !0,
                    this.replaceBackButtonHandler(this.onGirlOverlayClosed)
            },
            onGirlOverlayClosed() {
                this.showGirlModal = !1,
                    this.resetBackButtonHandler(this.onGirlOverlayClosed)
            },
            async updateSlotsOnBackend() {
                try {
                    const e = await Bn(this.globalStore.telegramAppFunctions, "edit_slots_call")(this.girlsStore.slotsByGirlIndexMap);
                    this.globalStore.setUserData(e.data.user)
                } catch (t) {
                    console.error(t)
                }
            }
        },
        mounted() {
            this.$emit("ready"),
                this.analyticsStore.logEvent("open_girls_page"),
                this.$refs.girlsScrollContainer.addEventListener("scroll", this.onGirlContainerScroll)
        },
        beforeDestroy() {
            this.$refs.girlsScrollContainer.removeEventListener("scroll", this.onGirlContainerScroll)
        }
    }
    , Abe = {
        class: "flex flex-col items-center justify-center h-10 fixed left-4 right-4 top-4 text-white text-xl font-bold"
    }
    , kbe = {
        class: "slap-girls-page__cards-container__items px-4"
    }
    , Rbe = ["onPointerdown", "onPointerup"]
    , Mbe = ["src"]
    , Pbe = ["src"]
    , Lbe = {
        key: 0,
        class: "slap-girls-page__card__selected-girl-icon-container w-6 h-6 p-0.5 absolute flex flex-row gap-0.5 items-center"
    }
    , Obe = {
        class: "slap-girls-page__card-info"
    }
    , Nbe = {
        class: "text-xs font-bold text-white capitalize"
    }
    , Dbe = {
        class: "text-xxs text-white/60 capitalize"
    }
    , Bbe = {
        class: "slap-girls-page__card-energy"
    }
    , Fbe = {
        class: "slap-girls-page__card-level"
    }
    , $be = {
        class: "slap-girls-page__card-level-title"
    }
    , Ube = {
        class: "slap-girls-page__card-level-progress"
    }
    , Vbe = {
        class: "slap-girls-page__card-level-value"
    }
    , Gbe = {
        key: 3,
        class: "slap-girls-page__collections"
    };
function Hbe(t, e, n, s, r, i) {
    var _, y;
    const o = q("IconHand")
        , l = q("ActiveGirlsPanel")
        , a = q("Blik")
        , c = q("Glow")
        , u = q("IconPrimary")
        , h = q("IconCoin")
        , d = q("IconPlus")
        , f = q("UnlockSlotBanner")
        , p = q("EquipUnequipPanel")
        , m = q("CollectionsTab")
        , g = q("MainFooter")
        , b = q("GirlOverlay")
        , v = mr("fade-in-up");
    return A(),
        N("div", null, [T("div", {
            class: Te(["slap-girls-page", [`slap-girls-page--onboarding-step-${(_ = r.onboardingStore.currentStep) == null ? void 0 : _.stepId}`]])
        }, [r.onboardingStore.isOnboardingInProgress ? (A(),
            fe(o, {
                key: 0,
                class: "slap-girls-page__onboarding-hand"
            })) : te("", !0), T("div", Abe, $(t.$t("girls.title")), 1), te("", !0), r.selectedTabId === "girls" ? (A(),
                N("div", {
                    key: 2,
                    ref: "girlsScrollContainer",
                    class: Te(["slap-girls-page__cards-container overflow-auto", {
                        "slap-girls-page__cards-container--has-selected-girl": r.selectedGirlId != null
                    }])
                }, [G(l, {
                    isCollapsed: r.isScrolled,
                    onGirlAvatarClick: i.onGirlAvatarClick
                }, null, 8, ["isCollapsed", "onGirlAvatarClick"]), T("div", kbe, [(A(!0),
                    N(Ie, null, mt(r.cards, (x, w) => vn((A(),
                        N("div", {
                            key: x.id,
                            ref_for: !0,
                            ref: "card" + x.id,
                            class: Te(["slap-girls-page__card bg-[#06050a]", [`slap-girls-page__card--tier-${x.tier} transition transform ease-in-out duration-200`, r.selectedGirlId === x.id && "slap-girls-page__card--active", r.selectedGirlId !== x.id && x.slot != null && "outline outline-2 outline-white/[.12]", r.scaledId === x.id && "scale-95"]]),
                            onPointerdown: S => i.onCardPressStart(x.id),
                            onPointerup: S => i.onGirlPressEnd(x),
                            onPointercancel: e[0] || (e[0] = (...S) => i.onCardPressCancel && i.onCardPressCancel(...S)),
                            onPointerleave: e[1] || (e[1] = (...S) => i.onCardPressCancel && i.onCardPressCancel(...S))
                        }, [G(a, {
                            isBlikActive: r.isBlikActive && r.selectedGirlId === x.id
                        }, null, 8, ["isBlikActive"]), T("div", {
                            class: Te(["absolute z-[3] top-0 left-0 w-full h-full transition-colors duration-200 ease-out", [r.scaledId === x.id && "bg-white/[.12]"]])
                        }, null, 2), G(c, {
                            class: "self-center",
                            tier: x.tier,
                            blur: "24"
                        }, null, 8, ["tier"]), T("img", {
                            class: "slap-girls-page__card-icon",
                            src: `/icons/icon-type-${x.tier}.svg`,
                            alt: ""
                        }, null, 8, Mbe), T("img", {
                            class: "slap-girls-page__card-pic",
                            src: x.path,
                            alt: ""
                        }, null, 8, Pbe), x.slot != null ? (A(),
                            N("div", Lbe, [G(u, {
                                class: "fill-white w-5 h-5"
                            })])) : te("", !0), T("div", Obe, [T("div", Nbe, $(t.$t(`girls.names.${x.name}`)), 1), T("div", Dbe, $(t.$t(`girls.collections.${x.collection}`)), 1), T("div", Bbe, [G(h, {
                                class: "w-[16px] h-[16px] mr-1"
                            }), Fe(" " + $(x.balance) + " / " + $(x.capacity), 1)]), T("div", Fbe, [T("div", $be, $(t.$t("level")), 1), T("div", Ube, [T("div", {
                                class: "slap-girls-page__card-level-progress-inner",
                                style: Wt({
                                    width: `${x.level / 99 * 100}%`
                                })
                            }, null, 4)]), T("div", Vbe, $(x.level) + " / 99 ", 1)])])], 42, Rbe)), [[v, w * 50]])), 128)), vn((A(),
                                N("div", {
                                    class: Te(["slap-girls-page__card slap-girls-page__card--add-new-girl flex items-center justify-center transition transform ease-in-out duration-200", r.scaledId === "new-girl" && "scale-95"]),
                                    onPointerdown: e[2] || (e[2] = x => i.onCardPressStart("new-girl")),
                                    onPointerup: e[3] || (e[3] = (...x) => i.onAddGirlNewPressEnd && i.onAddGirlNewPressEnd(...x)),
                                    onPointercancel: e[4] || (e[4] = (...x) => i.onCardPressCancel && i.onCardPressCancel(...x)),
                                    onPointerleave: e[5] || (e[5] = (...x) => i.onCardPressCancel && i.onCardPressCancel(...x))
                                }, [G(d, {
                                    class: "w-8 h-8 fill-accent"
                                }), G(c, {
                                    tier: "rare",
                                    width: "100%",
                                    height: "10%",
                                    blur: r.scaledId === "new-girl" ? "15" : "20",
                                    position: "bottom"
                                }, null, 8, ["blur"])], 34)), [[v, ((y = r.globalStore.girlsCards) == null ? void 0 : y.length) * 50]]), G(f, {
                                    class: Te(["mt-4", {
                                        "opacity-25 pointer-events-none": r.onboardingStore.currentStep != null
                                    }])
                                }, null, 8, ["class"])]), G(p, {
                                    selectedGirl: i.selectedGirl,
                                    onEquipUnequipClick: i.onEquipUnequipClick,
                                    onHelpIconClick: i.onHelpIconClick
                                }, null, 8, ["selectedGirl", "onEquipUnequipClick", "onHelpIconClick"])], 2)) : te("", !0), r.selectedTabId === "collections" ? (A(),
                                    N("div", Gbe, [G(m)])) : te("", !0), G(g)], 2), r.showGirlModal ? (A(),
                                        fe(b, {
                                            key: 0,
                                            isVisible: r.showGirlModal,
                                            onClose: i.onGirlOverlayClosed,
                                            girlCardId: i.selectedGirl.id,
                                            onSelectNewGirl: i.onGirlClick
                                        }, null, 8, ["isVisible", "onClose", "girlCardId", "onSelectNewGirl"])) : te("", !0)])
}
const Wbe = _e(Ibe, [["render", Hbe], ["__scopeId", "data-v-1d19cc7c"]])
    , Ybe = t => {
        var n;
        return (n = [{
            name: "common",
            minLevel: 1
        }, {
            name: "rare",
            minLevel: 5
        }, {
            name: "epic",
            minLevel: 10
        }, {
            name: "legendary",
            minLevel: 20
        }].reverse().find(s => t >= s.minLevel)) == null ? void 0 : n.name
    }
    , Xbe = ["width", "height"]
    , jbe = ["href"]
    , zbe = Nr('<svg class="absolute w-0 h-0 opacity-0 pointer-events-none" aria-hidden="true" data-v-db4f799c><defs data-v-db4f799c><g id="shape-small" data-v-db4f799c><g filter="url(#filter0_d_6798_149353)" data-v-db4f799c><path d="M10.7477 7.8024L4.54747 8.67379L3.67609 2.47357L9.87631 1.60218L10.7477 7.8024Z" fill="url(#paint0_linear_6798_149353)" data-v-db4f799c></path></g></g><g id="shape-large" data-v-db4f799c><g filter="url(#filter0_df_6798_149352)" data-v-db4f799c><path d="M14.1266 7.03418L21.3451 14.2526L14.1266 21.471L6.9082 14.2526L14.1266 7.03418Z" fill="url(#paint0_linear_6798_149352)" data-v-db4f799c></path></g></g><filter id="filter0_d_6798_149353" data-v-db4f799c><feFlood flood-opacity="0" result="BackgroundImageFix" data-v-db4f799c></feFlood><feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha" data-v-db4f799c></feColorMatrix><feOffset dy="1.6041" data-v-db4f799c></feOffset><feGaussianBlur stdDeviation="1.6041" data-v-db4f799c></feGaussianBlur><feComposite in2="hardAlpha" operator="out" data-v-db4f799c></feComposite><feColorMatrix type="matrix" values="0 0 0 0 1 0 0 0 0 0.720588 0 0 0 0 0.329412 0 0 0 1 0" data-v-db4f799c></feColorMatrix><feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow_6798_149353" data-v-db4f799c></feBlend><feBlend mode="normal" in="SourceGraphic" in2="effect1_dropShadow_6798_149353" result="shape" data-v-db4f799c></feBlend></filter><filter id="filter0_df_6798_149352" data-v-db4f799c><feFlood flood-opacity="0" result="BackgroundImageFix" data-v-db4f799c></feFlood><feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha" data-v-db4f799c></feColorMatrix><feOffset dy="1.6041" data-v-db4f799c></feOffset><feGaussianBlur stdDeviation="1.6041" data-v-db4f799c></feGaussianBlur><feComposite in2="hardAlpha" operator="out" data-v-db4f799c></feComposite><feColorMatrix type="matrix" values="0 0 0 0 1 0 0 0 0 0.720588 0 0 0 0 0.329412 0 0 0 1 0" data-v-db4f799c></feColorMatrix><feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow_6798_149352" data-v-db4f799c></feBlend><feBlend mode="normal" in="SourceGraphic" in2="effect1_dropShadow_6798_149352" result="shape" data-v-db4f799c></feBlend><feGaussianBlur stdDeviation="3.20819" result="effect2_foregroundBlur_6798_149352" data-v-db4f799c></feGaussianBlur></filter><linearGradient id="paint0_linear_6798_149353" data-v-db4f799c><stop stop-color="#FFC370" data-v-db4f799c></stop><stop offset="1" stop-color="#FFD237" data-v-db4f799c></stop></linearGradient><linearGradient id="paint0_linear_6798_149352" data-v-db4f799c><stop stop-color="#FFC370" data-v-db4f799c></stop><stop offset="1" stop-color="#FFD237" data-v-db4f799c></stop></linearGradient></defs></svg>', 1)
    , qbe = 1e3
    , Kbe = {
        __name: "UpgradeAnimation",
        setup(t, { expose: e }) {
            let n = null;
            const s = ke(!1)
                , r = ke([])
                , i = ke({
                    x: 0,
                    y: 0
                })
                , o = [{
                    id: "shape-small",
                    size: 14
                }, {
                    id: "shape-large",
                    size: 28
                }]
                , l = (u, h) => Math.floor(Math.random() * (h - u + 1) + u)
                , a = () => {
                    const u = [];
                    for (let h = 0; h < 20; h++) {
                        const d = l(-130, 130)
                            , f = l(-100, 100)
                            , p = o[Math.floor(Math.random() * o.length)];
                        u.push({
                            svgId: p.id,
                            size: p.size,
                            style: Qu({
                                transform: `translate(${d}px, ${f}px)`
                            })
                        })
                    }
                    return u
                }
                ;
            return e({
                playAnimation: (u, h) => {
                    r.value = a(),
                        i.value = {
                            x: u,
                            y: h
                        },
                        s.value = !1,
                        clearTimeout(n),
                        Zd(() => {
                            s.value = !0
                        }
                        ),
                        n = setTimeout(() => {
                            s.value = !1
                        }
                            , qbe)
                }
            }),
                (u, h) => s.value ? (A(),
                    N(Ie, {
                        key: 0
                    }, [(A(!0),
                        N(Ie, null, mt(r.value, (d, f) => (A(),
                            N("div", {
                                key: f,
                                style: Wt({
                                    ...d.style,
                                    top: `${i.value.y}px`,
                                    left: `${i.value.x}px`
                                }),
                                class: "absolute z-[1000] animate-move pointer-events-none"
                            }, [(A(),
                                N("svg", {
                                    width: d.size,
                                    height: d.size,
                                    viewBox: "0 0 28 28",
                                    fill: "none",
                                    xmlns: "http://www.w3.org/2000/svg"
                                }, [T("use", {
                                    href: `#${d.svgId}`
                                }, null, 8, jbe)], 8, Xbe))], 4))), 128)), zbe], 64)) : te("", !0)
        }
    }
    , JL = _e(Kbe, [["__scopeId", "data-v-db4f799c"]])
    , Jbe = {
        name: "UpgradeCard",
        props: {
            innerClass: String,
            id: String,
            type: String,
            name: String,
            section: String,
            maxLevel: Number,
            level: Number,
            profit: Number,
            effectType: {
                type: String,
                validator(t) {
                    return ["percentage"].includes(t)
                }
            },
            nextLevelProfit: Number,
            price: Number,
            isLocked: Boolean,
            requiredCardId: String,
            requiredCardLevel: Number,
            lastUpgradeTime: Number,
            cooldownEndTime: {
                type: Number,
                default: 0
            },
            cooldownColor: {
                type: String,
                default: "green",
                validator(t) {
                    return ["green", "pink", "orange"].includes(t)
                }
            },
            viewType: {
                type: Number,
                required: !1,
                default: hs.VERTICAL
            },
            upgrade: Function
        },
        emits: ["scrollToRequiredCard"],
        components: {
            Glow: gr,
            LvlProgress: A4,
            CountdownTimer: C4,
            Blik: Ki,
            IconCoin: dn,
            IconHelp: CS,
            IconCheck: xc,
            IconLock: C_,
            IconBlik: Vx,
            BuyButton: ic,
            UpgradeAnimation: JL
        },
        computed: {
            ...Pv(Ye, ["balance", "userData"]),
            viewTypes() {
                return hs
            },
            handleImageError() {
                this.imageUrl = this.getCardImageUrl("Card_001")
            },
            isAffordable() {
                return this.balance >= this.price
            },
            isUpgradeAnimationActive() {
                return this.isUpgradePressed && this.isAffordable
            },
            isCooldownActive() {
                return this.cooldownEndTime > 0 && this.cooldownEndTime > this.timerStore.unixTime
            },
            requirement() {
                return this.isLocked && this.$t("upgrade.cards.locked_info", {
                    cardName: this.getCardName(this.requiredCardId),
                    lvl: this.requiredCardLevel
                })
            },
            bonusLabel() {
                return this.$t(`upgrade.bonus.${this.type}`)
            },
            tier() {
                return Ybe(this.isUpgradeAnimationActive ? this.level + 1 : this.level)
            },
            isMaxLevel() {
                return this.level === this.maxLevel
            },
            isAbbleToBuy() {
                return this.isAffordable && !this.isLocked && !this.isUpdating && !this.isCooldownActive && !this.isMaxLevel
            }
        },
        data() {
            const { isPressed: t, handlePressStart: e, handlePressEnd: n, handlePressCancel: s } = uh({
                onPressEnd: async r => {
                    this.isAffordable ? (this.triggerBlik(),
                        ur("medium"),
                        this.isUpdating = !0,
                        await this.upgrade(this.id),
                        this.showUpgradeAnimation(r),
                        this.isUpdating = !1) : ur("error")
                }
            });
            return {
                imageUrl: this.getCardImageUrl(this.id),
                isUpgradePressed: t,
                isBlikActive: !1,
                handlePressStart: e,
                handlePressEnd: n,
                handlePressCancel: s,
                isUpdating: !1,
                upgradeAnimation: null
            }
        },
        mounted() {
            this.upgradeAnimation = this.$refs.upgradeAnimation
        },
        methods: {
            formattingPrice: Xt,
            triggerBlik() {
                this.isBlikActive = !0,
                    setTimeout(() => {
                        this.isBlikActive = !1
                    }
                        , 180)
            },
            onCardPressStart(t) {
                this.isLocked || this.isUpdating || this.handlePressStart(t)
            },
            onCardPressEnd(t) {
                this.isAbbleToBuy && this.handlePressEnd(t)
            },
            showUpgradeAnimation(t) {
                var r, i, o, l;
                const e = ((r = t.currentTarget) == null ? void 0 : r.getBoundingClientRect()) || ((o = (i = t.target) == null ? void 0 : i.closest(".card")) == null ? void 0 : o.getBoundingClientRect())
                    , n = t.clientX - e.left
                    , s = t.clientY - e.top;
                (l = this.$refs.upgradeAnimation) == null || l.playAnimation(n, s)
            },
            getCardImageUrl(t) {
                return `/upgradeCards/${t}.webp`
            },
            getCardName(t) {
                return this.$t(`upgradeCards.name.${t}`)
            }
        },
        setup() {
            return {
                timerStore: si()
            }
        }
    }
    , Zbe = ["src"]
    , Qbe = {
        class: "text-coin font-semibold"
    }
    , eve = {
        key: 0,
        class: "flex items-center justify-center text-white font-semibold px-2 py-1"
    }
    , tve = {
        class: "text-white font-semibold leading-tight"
    }
    , nve = {
        key: 1,
        class: "absolute inset-0 flex flex-col items-center text-xxs text-center gap-1 text-white leading-3 font-semibold p-2 pt-5"
    }
    , sve = {
        class: "text-coin"
    }
    , rve = {
        class: "relative w-10 h-10 flex-shrink-0"
    }
    , ive = ["src"]
    , ove = {
        class: "flex flex-col flex-auto min-w-[190px]"
    }
    , ave = {
        class: "text-white text-xxs font-semibold leading-3 relative mt-0.5"
    }
    , lve = {
        class: "flex items-center text-gray-400 text-xxs mt-0.5 leading-3 relative"
    }
    , cve = {
        class: "text-coin font-semibold"
    }
    , uve = {
        class: "flex items-center justify-end min-w-24 w-full"
    }
    , hve = {
        key: 0,
        class: "flex items-center justify-center text-white font-semibold px-2 py-1"
    }
    , dve = {
        class: "text-white font-semibold leading-tight"
    };
function fve(t, e, n, s, r, i) {
    const o = q("Glow")
        , l = q("Blik")
        , a = q("UpgradeAnimation")
        , c = q("IconCoin")
        , u = q("LvlProgress")
        , h = q("IconCheck")
        , d = q("BuyButton")
        , f = q("IconLock")
        , p = q("CountdownTimer")
        , m = mr("bounce");
    return A(),
        N(Ie, null, [n.viewType === i.viewTypes.VERTICAL ? vn((A(),
            N("div", {
                key: 0,
                class: Te(["card p-2 h-full flex flex-col bg-white/5 rounded-lg border border-white/5 relative transform transition-transform duration-200", [n.innerClass, {
                    "scale-95 bg-white/[.13]": i.isUpgradeAnimationActive,
                    "border-white/1": n.isLocked || i.isCooldownActive
                }]]),
                onPointerdown: e[2] || (e[2] = (...g) => i.onCardPressStart && i.onCardPressStart(...g)),
                onPointerup: e[3] || (e[3] = (...g) => i.onCardPressEnd && i.onCardPressEnd(...g)),
                onPointermove: e[4] || (e[4] = (...g) => r.handlePressCancel && r.handlePressCancel(...g)),
                onPointerleave: e[5] || (e[5] = (...g) => r.handlePressCancel && r.handlePressCancel(...g))
            }, [i.tier ? (A(),
                fe(o, {
                    key: 0,
                    class: Te({
                        "opacity-20": n.isLocked || i.isCooldownActive
                    }),
                    position: "bottom",
                    blur: i.isUpgradeAnimationActive ? "20" : "24",
                    tier: i.tier
                }, null, 8, ["class", "blur", "tier"])) : te("", !0), G(l, {
                    isBlikActive: r.isBlikActive
                }, null, 8, ["isBlikActive"]), G(a, {
                    ref: "upgradeAnimation"
                }, null, 512), T("div", {
                    class: Te(["relative pt-[100%]", {
                        "opacity-40": n.isLocked || i.isCooldownActive
                    }])
                }, [T("img", {
                    src: r.imageUrl,
                    loading: "lazy",
                    onError: e[0] || (e[0] = (...g) => i.handleImageError && i.handleImageError(...g)),
                    alt: "Card image",
                    class: "absolute top-0 left-1/2 rounded transform -translate-x-1/2 w-auto h-full"
                }, null, 40, Zbe)], 2), T("div", {
                    class: Te(["text-white text-xxs font-semibold leading-3 relative mt-0.5", {
                        "opacity-20": n.isLocked || i.isCooldownActive
                    }])
                }, $(i.getCardName(n.name)), 3), T("div", {
                    class: Te(["flex items-center text-gray-400 text-xxs mt-0.5 leading-3 relative", {
                        "opacity-20": n.isLocked || i.isCooldownActive
                    }])
                }, [T("span", null, $(i.bonusLabel), 1), G(c, {
                    class: "w-3 h-3 mx-1"
                }), T("span", Qbe, "+" + $(`${n.nextLevelProfit}${n.effectType === "percentage" ? "%" : ""}`), 1)], 2), T("div", {
                    class: Te(["flex flex-col grow justify-between relative gap-2", {
                        "opacity-20": n.isLocked || i.isCooldownActive
                    }])
                }, [G(u, {
                    maxLevel: n.maxLevel,
                    currentLevel: n.level,
                    animateToLevel: i.isUpgradeAnimationActive ? n.level + 1 : void 0
                }, null, 8, ["maxLevel", "currentLevel", "animateToLevel"]), n.level === n.maxLevel ? (A(),
                    N("div", eve, [G(h, {
                        class: "w-5 h-5 mr-1"
                    }), T("span", tve, $(t.$t("common.maximum_short")), 1)])) : n.price ? (A(),
                        fe(d, {
                            key: 1,
                            class: "pointer-events-none !backdrop-blur-none",
                            disabled: !i.isAffordable,
                            label: i.formattingPrice(n.price),
                            icon: "coin",
                            isLoading: r.isUpdating
                        }, null, 8, ["disabled", "label", "isLoading"])) : te("", !0)], 2), n.isLocked ? (A(),
                            N("div", nve, [G(f, {
                                class: "w-6 h-6 mx-auto"
                            }), T("p", null, [T("span", sve, $(t.$t("common.required")) + ":", 1), Fe(" " + $(i.requirement), 1)]), T("button", {
                                class: "px-2 py-1 bg-white/15 rounded-full hover:bg-white/30 active:bg-white/30 backdrop-blur-sm",
                                onClick: e[1] || (e[1] = ni(g => t.$emit("scrollToRequiredCard"), ["stop"]))
                            }, $(t.$t("upgrade.cards.get_it_now")), 1)])) : i.isCooldownActive ? (A(),
                                fe(p, {
                                    key: 2,
                                    class: "inset-x-0 px-2 py-0",
                                    startUnixTime: n.lastUpgradeTime,
                                    endUnixTime: n.cooldownEndTime,
                                    cooldownColor: n.cooldownColor,
                                    viewType: n.viewType
                                }, null, 8, ["startUnixTime", "endUnixTime", "cooldownColor", "viewType"])) : te("", !0)], 34)), [[m, {
                                    enabled: !1,
                                    startAnimation: r.isUpgradePressed && !i.isAbbleToBuy
                                }]]) : te("", !0), n.viewType === i.viewTypes.HORIZONTAL ? vn((A(),
                                    N("div", {
                                        key: 1,
                                        class: Te(["card flex flex-row p-2 gap-2 bg-white/5 relative rounded-lg border border-white/5 transform transition-transform duration-200", {
                                            "scale-95 bg-white/[.13]": i.isUpgradeAnimationActive
                                        }]),
                                        onPointerdown: e[7] || (e[7] = (...g) => i.onCardPressStart && i.onCardPressStart(...g)),
                                        onPointerup: e[8] || (e[8] = (...g) => i.onCardPressEnd && i.onCardPressEnd(...g)),
                                        onPointermove: e[9] || (e[9] = (...g) => r.handlePressCancel && r.handlePressCancel(...g)),
                                        onPointerleave: e[10] || (e[10] = (...g) => r.handlePressCancel && r.handlePressCancel(...g))
                                    }, [i.tier ? (A(),
                                        fe(o, {
                                            key: 0,
                                            position: "left",
                                            blur: "12",
                                            width: "20%",
                                            tier: i.tier
                                        }, null, 8, ["tier"])) : te("", !0), G(l, {
                                            isBlikActive: r.isBlikActive
                                        }, null, 8, ["isBlikActive"]), G(a, {
                                            ref: "upgradeAnimation"
                                        }, null, 512), T("div", rve, [T("img", {
                                            src: r.imageUrl,
                                            loading: "lazy",
                                            onError: e[6] || (e[6] = (...g) => i.handleImageError && i.handleImageError(...g)),
                                            alt: "Card image",
                                            class: "absolute top-0 left-0 rounded w-full h-full"
                                        }, null, 40, ive)]), T("div", ove, [T("div", ave, $(i.getCardName(n.name)), 1), T("div", lve, [T("span", null, $(i.bonusLabel), 1), G(c, {
                                            class: "w-3 h-3 mx-1"
                                        }), T("span", cve, "+" + $(`${n.nextLevelProfit}${n.effectType === "percentage" ? "%" : ""}`), 1)]), G(u, {
                                            maxLevel: n.maxLevel,
                                            currentLevel: n.level,
                                            animateToLevel: i.isUpgradeAnimationActive ? n.level + 1 : void 0
                                        }, null, 8, ["maxLevel", "currentLevel", "animateToLevel"])]), T("div", uve, [n.level === n.maxLevel ? (A(),
                                            N("div", hve, [G(h, {
                                                class: "w-5 h-5 mr-1"
                                            }), T("span", dve, $(t.$t("common.maximum_short")), 1)])) : n.price ? (A(),
                                                fe(d, {
                                                    key: 1,
                                                    class: "!w-[118px] pointer-events-none !backdrop-blur-none",
                                                    disabled: !i.isAffordable,
                                                    label: i.formattingPrice(n.price),
                                                    icon: "coin",
                                                    isLoading: r.isUpdating
                                                }, null, 8, ["disabled", "label", "isLoading"])) : te("", !0)]), i.isCooldownActive ? (A(),
                                                    fe(p, {
                                                        key: 1,
                                                        class: "flex-row items-center gap-2 bg-black/60 absolute inset-0",
                                                        startUnixTime: n.lastUpgradeTime,
                                                        endUnixTime: n.cooldownEndTime,
                                                        cooldownColor: n.cooldownColor,
                                                        viewType: n.viewType
                                                    }, null, 8, ["startUnixTime", "endUnixTime", "cooldownColor", "viewType"])) : te("", !0)], 34)), [[m, {
                                                        enabled: !1,
                                                        startAnimation: r.isUpgradePressed && !i.isAbbleToBuy
                                                    }]]) : te("", !0)], 64)
}
const RS = _e(Jbe, [["render", fve]])
    , pve = {
        name: "ItemsTab",
        components: {
            UpgradeCard: RS,
            UpgradeAnimation: JL
        },
        computed: {
            ...Pv(Ye, ["balance", "userData", "upgradeCardsGroupedBySection"])
        },
        data() {
            return {
                activeTab: 0,
                lastScrollTop: 0,
                highlightCard: null,
                upgradeAnimation: null
            }
        },
        props: {
            handleUpgradeCard: Function
        },
        setup() {
            return {
                globalStore: Ye()
            }
        },
        methods: {
            scrollToSection(t) {
                var n, s;
                if (!((s = (n = this.$refs) == null ? void 0 : n.section) != null && s[t]))
                    return;
                this.$refs.section[t].scrollIntoView({
                    behavior: "smooth",
                    block: "start"
                }),
                    this.activeTab = t,
                    this.scrollTabIntoView(t)
            },
            handleScroll() {
                var r, i;
                if (!((r = this.$refs) != null && r.section) || !((i = this.$refs) != null && i.sections))
                    return;
                const t = this.$refs.section
                    , e = this.$refs.sections.scrollTop;
                let n = this.activeTab
                    , s = e > this.lastScrollTop;
                t.some((o, l) => {
                    const a = o.getBoundingClientRect()
                        , c = a.top
                        , u = a.bottom;
                    if (s && c <= window.innerHeight / 2 && u >= window.innerHeight / 2)
                        return n = l,
                            !0;
                    if (!s && u >= window.innerHeight / 2)
                        return n = l,
                            !0
                }
                ),
                    n !== null && n !== this.activeTab && (this.activeTab = n,
                        this.scrollTabIntoView(n)),
                    this.lastScrollTop = e
            },
            scrollTabIntoView(t) {
                var i;
                if (!((i = this.$refs) != null && i.tabs))
                    return;
                const e = this.$refs.tabs
                    , n = e.children[t]
                    , s = e.getBoundingClientRect()
                    , r = n.getBoundingClientRect();
                (r.left < s.left || r.right > s.right) && n.scrollIntoView({
                    behavior: "smooth",
                    block: "nearest",
                    inline: "center"
                })
            },
            handleScrollToRequiredCard(t) {
                const e = this.$refs[`card_${t}`][0];
                e && (this.highlightCard = t,
                    e.scrollIntoView({
                        behavior: "smooth",
                        block: "center"
                    }),
                    setTimeout(() => {
                        this.highlightCard = null
                    }
                        , 3e3))
            },
            getCooldownColor(t) {
                switch (t % 3) {
                    case 1:
                        return "green";
                    case 2:
                        return "pink";
                    default:
                        return "orange"
                }
            }
        },
        mounted() {
            this.$emit("ready"),
                this.$refs.sections.addEventListener("scroll", this.handleScroll)
        },
        beforeDestroy() {
            this.$refs.sections.removeEventListener("scroll", this.handleScroll)
        }
    }
    , mve = {
        class: "flex flex-col grow overflow-hidden"
    }
    , gve = {
        ref: "tabs",
        class: "inline-flex shrink-0 gap-5 items-center overflow-x-auto scrollbar-hide touch-pan-x px-4"
    }
    , _ve = ["onClick"]
    , yve = {
        key: 0,
        class: "absolute bottom-[2px] left-0 right-0 h-[2px] bg-accent rounded-full"
    }
    , bve = {
        ref: "sections",
        class: "grow flex flex-col gap-6 py-6 overflow-y-auto overflow-x-hidden px-4"
    }
    , vve = {
        class: "text-white text-xl font-semibold"
    }
    , xve = {
        class: "grid grid-cols-3 md:grid-cols-6 gap-3"
    };
function wve(t, e, n, s, r, i) {
    const o = q("UpgradeCard")
        , l = mr("fade-in-up");
    return A(),
        N("div", mve, [T("div", gve, [(A(!0),
            N(Ie, null, mt(t.upgradeCardsGroupedBySection, (a, c) => (A(),
                N("div", {
                    key: a.id,
                    class: "px-1 py-3 grow basis-0 inline-flex justify-center items-center text-white/80 text-base whitespace-nowrap relative",
                    onClick: u => i.scrollToSection(c)
                }, [T("span", null, $(t.$t(`upgradeSections.${a.id}`)), 1), r.activeTab === c ? (A(),
                    N("div", yve)) : te("", !0)], 8, _ve))), 128))], 512), T("div", bve, [(A(!0),
                        N(Ie, null, mt(t.upgradeCardsGroupedBySection, (a, c) => (A(),
                            N("div", {
                                key: a.id,
                                ref_for: !0,
                                ref: "section",
                                class: "flex flex-col gap-3"
                            }, [T("h2", vve, $(t.$t(`upgradeSections.${a.id}`)), 1), T("div", xve, [(A(!0),
                                N(Ie, null, mt(a.cards, (u, h) => vn((A(),
                                    N("div", {
                                        ref_for: !0,
                                        ref: `card_${u.id}`,
                                        key: u.id
                                    }, [G(o, Ms({
                                        innerClass: r.highlightCard === u.id ? "animate-glow-pulse" : null,
                                        ref_for: !0
                                    }, u, {
                                        cooldownColor: i.getCooldownColor(h),
                                        upgrade: n.handleUpgradeCard,
                                        onScrollToRequiredCard: d => i.handleScrollToRequiredCard(u.requiredCardId)
                                    }), null, 16, ["innerClass", "cooldownColor", "upgrade", "onScrollToRequiredCard"])])), [[l, c + h < 15 ? (c + h) * 50 : 0]])), 128))])]))), 128))], 512)])
}
const Sve = _e(pve, [["render", wve]])
    , Eve = {
        class: "flex flex-col gap-3"
    }
    , Tve = {
        class: "text-white text-xl font-semibold"
    }
    , Cve = {
        class: "px-4 py-2 bg-white/5 rounded-lg border border-white/5 gap-2 items-center flex"
    }
    , Ive = {
        class: "flex flex-col gap-1 shrink-0 grow"
    }
    , Ave = {
        class: "text-white/60"
    }
    , kve = {
        class: "flex items-center gap-2"
    }
    , Rve = {
        class: "flex items-center gap-1"
    }
    , Mve = T("span", {
        class: "text-white font-semibold"
    }, " 3h:12m ", -1)
    , Pve = {
        class: "flex items-center gap-1"
    }
    , Lve = T("span", {
        class: "text-coin font-semibold"
    }, "+15%", -1)
    , Ove = T("div", {
        class: "w-[1px] h-12 bg-white/5"
    }, null, -1)
    , Nve = {
        class: "flex flex-col gap-1 shrink-0 grow"
    }
    , Dve = {
        class: "text-white/60"
    }
    , Bve = {
        class: "flex items-center gap-1"
    }
    , Fve = T("span", {
        class: "text-coin font-semibold"
    }, "+15% h", -1)
    , $ve = {
        __name: "TravelBonus",
        setup(t) {
            return (e, n) => {
                const s = q("IconCoin");
                return A(),
                    N("div", Eve, [T("h3", Tve, $(e.$t("upgrade.travel_bonus.active_travel_bonus_label")), 1), T("div", Cve, [T("div", Ive, [T("h5", Ave, $(e.$t("upgrade.travel_bonus.temporary_bonus_label")), 1), T("div", kve, [T("div", Rve, [G(Xx, {
                        class: "h-6 w-6 p-0.5"
                    }), Mve]), T("div", Pve, [G(s, {
                        class: "h-6 w-6"
                    }), Lve])])]), Ove, T("div", Nve, [T("h5", Dve, $(e.$t("upgrade.travel_bonus.permanent_bonus_label")), 1), T("div", Bve, [G(s, {
                        class: "h-6 w-6"
                    }), Fve])])])])
            }
        }
    }
    , Uve = {
        class: "h-[296px] bg-black overflow-hidden flex flex-col items-stretch justify-end rounded-lg border border-white/5 text-white relative"
    }
    , Vve = ["src"]
    , Gve = ["src"]
    , Hve = {
        class: "px-3 z-10 flex flex-col gap-0.5 items-center bg-gradient-to-b from-transparent to-black"
    }
    , Wve = {
        class: "font-bold text-center leading-tight"
    }
    , Yve = {
        class: "flex items-center justify-center gap-1 text-xs font-semibold"
    }
    , Xve = {
        class: "flex items-center gap-0.5"
    }
    , jve = {
        class: "flex items-center gap-0.5"
    }
    , zve = {
        class: "text-xxs"
    }
    , qve = {
        class: "text-white/60"
    }
    , Kve = {
        class: "ml-0.5 text-white text-xs font-semibold"
    }
    , Jve = {
        class: "px-3 pt-2 pb-3 flex bg-black items-center justify-center z-10"
    }
    , Zve = {
        class: "font-semibold"
    }
    , Qve = {
        __name: "TravelCard",
        props: {
            id: Number,
            image: String,
            country: String,
            name: String,
            time: String,
            profit: String,
            cardsLeft: String,
            purchased: Boolean,
            disabled: {
                type: Boolean,
                default: !0
            }
        },
        setup(t) {
            const e = t
                , { isPressed: n, handlePressStart: s, handleMove: r, handlePressEnd: i } = uh({
                    onPressEnd: () => {
                        e.disabled && ur("error")
                    }
                });
            return (o, l) => {
                const a = mr("bounce");
                return vn((A(),
                    N("div", Uve, [T("img", {
                        src: t.image,
                        alt: "Card Image",
                        class: "absolute w-full h-full object-cover rounded-lg"
                    }, null, 8, Vve), T("img", {
                        src: `/countryFlags/Property 1=${t.country}.svg`,
                        alt: "Country Logo",
                        class: "absolute top-2 left-2 rounded-full overflow-hidden flex items-center justify-center h-6 w-6"
                    }, null, 8, Gve), T("div", Hve, [T("h3", Wve, $(t.name), 1), T("div", Yve, [T("div", Xve, [G(Xx, {
                        class: "w-4 h-4 p-0.5"
                    }), T("span", null, $(t.time), 1)]), T("div", jve, [G(dn, {
                        class: "w-4 h-4"
                    }), T("span", null, $(t.profit), 1)])]), T("p", zve, [T("span", qve, $(o.$t("upgrade.travel.cards_left")) + ":", 1), T("span", Kve, $(t.cardsLeft), 1)])]), T("div", Jve, [t.purchased ? (A(),
                        N(Ie, {
                            key: 0
                        }, [G(xc, {
                            class: "w-5 h-5 mr-[6px]"
                        }), T("span", Zve, $(o.$t("upgrade.travel.purchased")), 1)], 64)) : (A(),
                            fe(ic, {
                                key: 1,
                                icon: "star",
                                label: o.$t("upgrade.travel.soon"),
                                disabled: t.disabled,
                                onPointerdown: de(s),
                                onPointerup: de(i),
                                onPointerleave: de(r)
                            }, null, 8, ["label", "disabled", "onPointerdown", "onPointerup", "onPointerleave"]))])])), [[a, {
                                enabled: !1,
                                startAnimation: de(n) && t.disabled
                            }]])
            }
        }
    }
    , ZL = [{
        id: 1,
        name: "Big-Ben",
        country: "england",
        image: "big-ben.webp",
        profit: "+600/h",
        time: "3h",
        cardsLeft: "2500/2500",
        purchased: !1,
        price: null
    }, {
        id: 2,
        name: "Grand Canal in Venice",
        country: "italy",
        image: "grand-canal-venice.webp",
        profit: "+600/h",
        time: "3h",
        cardsLeft: "2500/2500",
        purchased: !1,
        price: null
    }, {
        id: 3,
        name: "Castle Hill in Nice",
        country: "france",
        image: "castle-hill-nice.webp",
        profit: "+600/h",
        time: "3h",
        cardsLeft: "2500/2500",
        purchased: !1,
        price: 1e3
    }, {
        id: 4,
        name: "Golden Gate Bridge in San Francisco",
        country: "united states",
        image: "golden-gate.webp",
        profit: "+600/h",
        time: "3h",
        cardsLeft: "2500/2500",
        purchased: !1,
        price: 1e3
    }, {
        id: 5,
        name: "Osaka Castle",
        country: "japan",
        image: "osaka-castle.webp",
        profit: "+600/h",
        time: "3h",
        cardsLeft: "2500/2500",
        purchased: !1,
        price: 1e3
    }, {
        id: 6,
        name: "Eiffel Tower",
        country: "france",
        image: "eiffel-tower.webp",
        profit: "+600/h",
        time: "3h",
        cardsLeft: "2500/2500",
        purchased: !1,
        price: 1e3
    }, {
        id: 7,
        name: "Roman Colosseum",
        country: "italy",
        image: "colosseum.webp",
        profit: "+600/h",
        time: "3h",
        cardsLeft: "2500/2500",
        purchased: !1,
        price: 1e3
    }, {
        id: 8,
        name: "Tower Bridge",
        country: "england",
        image: "tower-bridge.webp",
        profit: "+600/h",
        time: "3h",
        cardsLeft: "2500/2500",
        purchased: !1,
        price: 1e3
    }, {
        id: 9,
        name: "Buckingham Palace",
        country: "england",
        image: "buckingham-palace.webp",
        profit: "+600/h",
        time: "3h",
        cardsLeft: "2500/2500",
        purchased: !1,
        price: 1e3
    }, {
        id: 10,
        name: "Edinburgh Castle",
        country: "scotland",
        image: "edinburgh-castle.webp",
        profit: "+600/h",
        time: "3h",
        cardsLeft: "2500/2500",
        purchased: !1,
        price: 1e3
    }, {
        id: 11,
        name: "Acropolis of Athens",
        country: "greece",
        image: "acropolis-athens.webp",
        profit: "+600/h",
        time: "3h",
        cardsLeft: "2500/2500",
        purchased: !1,
        price: 1e3
    }, {
        id: 12,
        name: "Shinjuku Gyoen National Garden",
        country: "japan",
        image: "shinjuku-gyoen.webp",
        profit: "+600/h",
        time: "3h",
        cardsLeft: "2500/2500",
        purchased: !1,
        price: 1e3
    }]
    , exe = {
        class: "flex flex-col px-4 gap-6 overflow-y-auto"
    }
    , txe = {
        key: 0,
        class: "flex flex-col gap-3"
    }
    , nxe = {
        class: "text-white text-xl font-semibold leading-none"
    }
    , sxe = ["src"]
    , rxe = {
        class: "flex flex-col gap-3"
    }
    , ixe = {
        class: "text-white text-xl font-semibold leading-none"
    }
    , oxe = {
        class: "grid grid-cols-2 gap-4"
    }
    , axe = {
        __name: "TravelTab",
        setup(t) {
            const { t: e, locale: n } = gt();
            return Ye(),
                (s, r) => {
                    const i = mr("fade-in-up");
                    return A(),
                        N("div", exe, [(A(),
                            N("div", txe, [T("h4", nxe, $(de(e)("upgrade.travel.label_in_dev")), 1), T("img", {
                                class: "w-full rounded-lg border border-white/5 object-cover",
                                alt: "In development banner",
                                src: `/travelCards/soon-banner-${de(n) === de(js).RU ? de(js).RU : de(js).EN}.webp`
                            }, null, 8, sxe)])), T("div", rxe, [T("h4", ixe, $(de(e)("upgrade.travel.label_soon")), 1), T("div", oxe, [(A(!0),
                                N(Ie, null, mt(de(ZL), (o, l) => vn((A(),
                                    fe(Qve, Ms({
                                        key: o.id,
                                        ref_for: !0
                                    }, o, {
                                        image: `/travelCards/${o.image}`
                                    }), null, 16, ["image"])), [[i, l * 50]])), 128))])])])
                }
        }
    }
    , lxe = {
        name: "Characteristics",
        methods: {
            formattingPrice: Xt
        },
        computed: {
            characteristicTypes() {
                return Jf
            },
            characteristics() {
                return [{
                    id: "slap_power",
                    label: this.$t("my_cards.my_characteristics.slap_power"),
                    type: Jf.SLAP,
                    value: this.globalStore.slapPower
                }, {
                    id: "profit",
                    label: this.$t("my_cards.my_characteristics.profit"),
                    type: Jf.PROFIT,
                    value: Math.round(this.globalStore.profitBonus * 100)
                }, {
                    id: "capacity",
                    label: this.$t("my_cards.my_characteristics.capacity"),
                    type: Jf.CAPACITY,
                    value: Math.round(this.globalStore.capacityBonus * 100)
                }]
            }
        },
        components: {
            IconPrimary: yS,
            IconCoin: dn
        },
        setup() {
            return {
                globalStore: Ye()
            }
        }
    }
    , cxe = {
        class: "text-xl font-semibold"
    }
    , uxe = {
        class: "flex flex-col mt-3"
    }
    , hxe = {
        class: "col-span-3 text-white/60"
    }
    , dxe = {
        class: "col-span-1 font-semibold flex flex-row gap-1 items-center"
    };
function fxe(t, e, n, s, r, i) {
    const o = q("IconCoin")
        , l = q("IconPrimary");
    return A(),
        N("div", null, [T("h1", cxe, $(t.$t("my_cards.my_characteristics.header")), 1), T("div", uxe, [(A(!0),
            N(Ie, null, mt(i.characteristics, a => (A(),
                N("div", {
                    key: a.id,
                    class: "grid grid-cols-4"
                }, [T("div", hxe, $(a.label) + ":", 1), T("div", dxe, [[i.characteristicTypes.PROFIT, i.characteristicTypes.CAPACITY].includes(a.type) ? (A(),
                    N(Ie, {
                        key: 0
                    }, [G(o, {
                        class: "w-5 h-5"
                    }), Fe(" +" + $(a.value) + "% ", 1)], 64)) : te("", !0), a.type === i.characteristicTypes.SLAP ? (A(),
                        N(Ie, {
                            key: 1
                        }, [G(l, {
                            class: "w-5 h-5 fill-white"
                        }), Fe(" " + $(a.value), 1)], 64)) : te("", !0)])]))), 128))])])
}
const pxe = _e(lxe, [["render", fxe]])
    , mxe = {
        name: "CollapsibleSection",
        props: {
            title: {
                type: String,
                required: !0
            },
            titleIcon: {
                type: String,
                required: !1
            },
            defaultOpen: {
                type: Boolean,
                default: !1
            }
        },
        setup(t) {
            const e = ke(t.defaultOpen)
                , n = ke(null)
                , s = ke(0)
                , r = () => {
                    var i;
                    e.value = !e.value,
                        s.value = ((i = n.value) == null ? void 0 : i.scrollHeight) || 0
                }
                ;
            return t.defaultOpen && setTimeout(() => {
                var i;
                s.value = ((i = n.value) == null ? void 0 : i.scrollHeight) || 0
            }
            ),
            {
                isOpen: e,
                toggle: r,
                content: n,
                contentHeight: s
            }
        }
    }
    , gxe = t => (Wo("data-v-55a5c6d1"),
        t = t(),
        Yo(),
        t)
    , _xe = {
        class: "collapsible-section py-3 border-t border-white/5"
    }
    , yxe = {
        class: "flex flex-row gap-2 items-center"
    }
    , bxe = ["src", "alt"]
    , vxe = gxe(() => T("path", {
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": "2",
        d: "M19 9l-7 7-7-7"
    }, null, -1))
    , xxe = [vxe];
function wxe(t, e, n, s, r, i) {
    return A(),
        N("div", _xe, [T("div", {
            onClick: e[0] || (e[0] = (...o) => s.toggle && s.toggle(...o)),
            class: "w-full flex items-center justify-between text-left rounded-md outline-none focus:outline-none text-white text-xl"
        }, [T("span", yxe, [n.titleIcon ? (A(),
            N("img", {
                key: 0,
                src: n.titleIcon,
                alt: n.title,
                class: "rounded-full overflow-hidden flex items-center justify-center h-8 w-8"
            }, null, 8, bxe)) : te("", !0), Fe(" " + $(n.title), 1)]), (A(),
                N("svg", {
                    class: Te([{
                        "rotate-180": s.isOpen
                    }, "w-5 h-5 transition-transform duration-200"]),
                    fill: "none",
                    stroke: "currentColor",
                    viewBox: "0 0 24 24",
                    xmlns: "http://www.w3.org/2000/svg"
                }, xxe, 2))]), T("div", {
                    ref: "content",
                    class: Te(["transition-all duration-300", {
                        "overflow-hidden": !s.isOpen
                    }]),
                    style: Wt({
                        maxHeight: s.isOpen ? s.contentHeight + "px" : 0
                    })
                }, [rs(t.$slots, "default", {}, void 0, !0)], 6)])
}
const QL = _e(mxe, [["render", wxe], ["__scopeId", "data-v-55a5c6d1"]])
    , Sxe = {
        name: "MyItems",
        components: {
            CollapsibleSection: QL,
            UpgradeCard: RS
        },
        computed: {
            viewTypes() {
                return hs
            },
            sections() {
                var e;
                const t = (e = this.globalStore.myCards) == null ? void 0 : e.reduce((n, s) => (n[s.section] || (n[s.section] = []),
                    n[s.section].push(s),
                    n), {});
                return Object.keys(t).map((n, s) => ({
                    id: n,
                    isOpen: s === 0,
                    cards: t[n]
                }))
            }
        },
        methods: {
            getCooldownColor(t) {
                switch (t % 3) {
                    case 1:
                        return "green";
                    case 2:
                        return "pink";
                    default:
                        return "orange"
                }
            }
        },
        props: {
            handleUpgradeCard: Function
        },
        setup() {
            return {
                globalStore: Ye()
            }
        }
    }
    , Exe = {
        class: "text-xl font-semibold"
    }
    , Txe = {
        class: "mt-3"
    }
    , Cxe = {
        key: 0,
        class: "bg-white/5 text-center p-3 rounded-lg w-full mt-3 text-white/20"
    }
    , Ixe = {
        class: "mt-3 flex flex-col gap-1"
    };
function Axe(t, e, n, s, r, i) {
    const o = q("UpgradeCard")
        , l = q("CollapsibleSection");
    return A(),
        N("div", null, [T("div", null, [T("h1", Exe, $(t.$t("my_cards.my_items.header")), 1)]), T("div", Txe, [i.sections.length === 0 ? (A(),
            N("div", Cxe, $(t.$t("my_cards.my_items.no_cards")), 1)) : te("", !0), i.sections.length > 0 ? (A(!0),
                N(Ie, {
                    key: 1
                }, mt(i.sections, a => (A(),
                    fe(l, {
                        key: a.id,
                        title: t.$t(`upgradeSections.${a.id}`),
                        "default-open": a.isOpen
                    }, {
                        default: Ce(() => [T("div", Ixe, [(A(!0),
                            N(Ie, null, mt(a.cards, (c, u) => (A(),
                                N("div", {
                                    key: c.id
                                }, [G(o, Ms({
                                    ref_for: !0
                                }, c, {
                                    cooldownColor: i.getCooldownColor(u),
                                    upgrade: n.handleUpgradeCard,
                                    viewType: i.viewTypes.HORIZONTAL
                                }), null, 16, ["cooldownColor", "upgrade", "viewType"])]))), 128))])]),
                        _: 2
                    }, 1032, ["title", "default-open"]))), 128)) : te("", !0)])])
}
const kxe = _e(Sxe, [["render", Axe]])
    , Rxe = {
        name: "MyCountries",
        components: {
            IconCoin: dn,
            UpgradeCard: RS,
            CollapsibleSection: QL
        },
        computed: {
            locales() {
                return js
            },
            sections() {
                return Object.values(ZL.reduce((t, e, n) => {
                    const { country: s } = e;
                    return t[s] || (t[s] = {
                        country: s,
                        isOpen: n === 0,
                        cards: []
                    }),
                        t[s].cards.push(e),
                        t
                }
                    , {}))
            }
        }
    }
    , Mxe = {
        class: "text-xl font-semibold"
    }
    , Pxe = {
        class: "mt-3"
    }
    , Lxe = ["src"];
function Oxe(t, e, n, s, r, i) {
    const o = q("IconCoin")
        , l = q("CollapsibleSection");
    return A(),
        N("div", null, [T("div", null, [T("h1", Mxe, $(t.$t("my_cards.my_countries.header")), 1)]), T("div", Pxe, [T("img", {
            class: "w-full rounded-lg border border-white/5 object-cover",
            alt: "In development banner",
            src: `/travelCards/soon-banner-${t.$i18n.locale === i.locales.RU ? i.locales.RU : i.locales.EN}.webp`
        }, null, 8, Lxe), (i.sections.length,
            te("", !0)), (i.sections.length > 0,
                te("", !0))])])
}
const Nxe = _e(Rxe, [["render", Oxe]])
    , Dxe = {
        name: "MyCardsTab",
        components: {
            MyCountries: Nxe,
            MyItems: kxe,
            Characteristics: pxe,
            TravelBonus: $ve
        },
        props: {
            handleUpgradeCard: Function
        }
    }
    , Bxe = {
        class: "my-cards-tab text-white flex flex-col grow overflow-y-auto overflow-x-hidden"
    };
function Fxe(t, e, n, s, r, i) {
    const o = q("Characteristics");
    q("TravelBonus");
    const l = q("MyItems")
        , a = q("MyCountries");
    return A(),
        N("div", Bxe, [G(o, {
            class: "px-4"
        }), te("", !0), G(l, {
            class: "px-4 mt-6",
            handleUpgradeCard: n.handleUpgradeCard
        }, null, 8, ["handleUpgradeCard"]), G(a, {
            class: "px-4 mt-6"
        })])
}
const $xe = _e(Dxe, [["render", Fxe]])
    , Uxe = {
        name: "UpgradePage",
        components: {
            Tabs: wS,
            MyCardsTab: $xe,
            TravelTab: axe,
            ItemsTab: Sve,
            Header: oc,
            MainFooter: jo,
            IconArrowRightWhite: kS
        },
        mixins: [Ef],
        computed: {
            tabs() {
                return [{
                    id: "items",
                    title: this.$t("upgrade.tabs.items")
                }, {
                    id: "travel",
                    title: this.$t("upgrade.tabs.travel")
                }, {
                    id: "my-cards",
                    title: this.$t("upgrade.tabs.my-cards")
                }]
            }
        },
        data() {
            return {
                globalStore: Ye(),
                analyticsStore: Fn(),
                selectedTabId: "items"
            }
        },
        methods: {
            onChangeTab(t) {
                this.selectedTabId = t
            },
            async handleUpgradeCard(t) {
                await this.globalStore.upgradeCard(t)
            }
        },
        mounted() {
            this.$emit("ready"),
                this.analyticsStore.logEvent("open_upgrade_page")
        }
    }
    , Vxe = {
        class: "overflow-hidden flex flex-col h-[calc(100%-90px)]"
    }
    , Gxe = {
        class: "flex grow flex-col gap-3 overflow-hidden"
    };
function Hxe(t, e, n, s, r, i) {
    const o = q("Header")
        , l = q("Tabs")
        , a = q("ItemsTab")
        , c = q("TravelTab")
        , u = q("MyCardsTab")
        , h = q("MainFooter");
    return A(),
        N("div", Vxe, [G(o), T("main", Gxe, [G(l, {
            class: "mx-4",
            tabs: i.tabs,
            selectedTabId: r.selectedTabId,
            onChangeTab: i.onChangeTab
        }, null, 8, ["tabs", "selectedTabId", "onChangeTab"]), r.selectedTabId === "items" ? (A(),
            fe(a, {
                key: 0,
                handleUpgradeCard: i.handleUpgradeCard
            }, null, 8, ["handleUpgradeCard"])) : te("", !0), r.selectedTabId === "travel" ? (A(),
                fe(c, {
                    key: 1
                })) : te("", !0), r.selectedTabId === "my-cards" ? (A(),
                    fe(u, {
                        key: 2,
                        handleUpgradeCard: i.handleUpgradeCard
                    }, null, 8, ["handleUpgradeCard"])) : te("", !0)]), G(h)])
}
const Wxe = _e(Uxe, [["render", Hxe]])
    , Yxe = {}
    , Xxe = {
        width: "25",
        height: "24",
        viewBox: "0 0 25 24",
        xmlns: "http://www.w3.org/2000/svg"
    }
    , jxe = T("path", {
        d: "M2.76562 13.8008L3.25722 23.6034L11.5008 18.2764L2.76562 13.8008ZM14.2508 20.9989C11.764 21.4545 9.32955 20.8593 7.40091 19.5268L6.43461 20.9255C8.7192 22.5039 11.6088 23.2113 14.5571 22.6711L14.2508 20.9989ZM21.6849 13.1257C21.2069 16.9881 18.2795 20.2609 14.2508 20.9989L14.5571 22.6711C19.3371 21.7954 22.8055 17.9127 23.3721 13.3345L21.6849 13.1257Z",
        fill: "white"
    }, null, -1)
    , zxe = T("path", {
        d: "M22.4384 10.1975L21.9468 0.394878L13.7033 5.72193L22.4384 10.1975ZM10.9532 2.99935C13.44 2.54376 15.8745 3.13902 17.8031 4.47147L18.7694 3.07281C16.4848 1.49444 13.5952 0.787041 10.6469 1.32718L10.9532 2.99935ZM3.51906 10.8726C3.99706 7.01022 6.92451 3.73742 10.9532 2.99935L10.6469 1.32718C5.8669 2.20289 2.39852 6.08558 1.83193 10.6638L3.51906 10.8726Z",
        fill: "white"
    }, null, -1)
    , qxe = [jxe, zxe];
function Kxe(t, e) {
    return A(),
        N("svg", Xxe, qxe)
}
const Jxe = _e(Yxe, [["render", Kxe]])
    , Zxe = {
        class: "flex px-4 py-2 bg-white/5 text-white rounded-lg shadow-md"
    }
    , Qxe = ["src"]
    , ewe = {
        class: "flex-1 ml-4"
    }
    , twe = {
        class: "text-base font-semibold leading-tight"
    }
    , nwe = {
        class: "inline-flex items-center text-coin text-base mt-1 font-bold leading-tight"
    }
    , swe = {
        class: "flex items-center"
    }
    , rwe = {
        key: 0,
        class: "inline-flex items-center text-center text-white text-xs font-semibold"
    }
    , iwe = {
        __name: "FriendsListItem",
        props: {
            photoUrl: String,
            username: String,
            isPremium: Boolean,
            balance: Number
        },
        setup(t) {
            return (e, n) => (A(),
                N("div", Zxe, [T("img", {
                    src: t.photoUrl,
                    alt: "Profile Picture",
                    class: "w-[52px] h-[52px] rounded-full"
                }, null, 8, Qxe), T("div", ewe, [T("h2", twe, $(t.username || e.$t("referral.anonymous")), 1), T("div", nwe, [T("span", swe, [G(dn, {
                    class: "w-5 h-5 mr-1"
                }), Fe(" " + $(de(Xt)(t.balance, !0)), 1)])])]), t.isPremium ? (A(),
                    N("div", rwe, [G(vc, {
                        class: "w-3 h-3 mr-1",
                        "first-color": "#61ABFF",
                        "second-color": "#A95DE1"
                    }), Fe(" " + $(e.$t("referral.premium")), 1)])) : te("", !0)]))
        }
    }
    , owe = {
        name: "FriendsList",
        components: {
            Loader: ol,
            FriendsListItem: iwe,
            IconUpdate: Jxe
        },
        props: {
            friends: Array,
            refreshList: Function,
            isLoading: Boolean
        }
    }
    , awe = {
        class: "flex justify-between items-center"
    }
    , lwe = {
        class: "text-base text-white font-semibold"
    }
    , cwe = {
        key: 0,
        class: "bg-white/5 text-center p-3 rounded-lg w-full mt-3 text-white/20"
    }
    , uwe = {
        class: "mt-3 w-full"
    }
    , hwe = {
        key: 1,
        class: "w-full flex justify-center"
    };
function dwe(t, e, n, s, r, i) {
    const o = q("IconUpdate")
        , l = q("FriendsListItem")
        , a = q("Loader");
    return A(),
        N("div", null, [T("div", awe, [T("h2", lwe, $(t.$t("referral.list_title")), 1), T("button", {
            onClick: e[0] || (e[0] = (...c) => n.refreshList && n.refreshList(...c)),
            class: "text-white p-3 -m-3"
        }, [G(o, {
            class: "w-6 h-6"
        })])]), n.friends.length === 0 ? (A(),
            N("div", cwe, $(t.$t("referral.no_friends")), 1)) : te("", !0), T("div", uwe, [n.isLoading ? te("", !0) : (A(!0),
                N(Ie, {
                    key: 0
                }, mt(n.friends, c => (A(),
                    fe(l, Ms({
                        class: "mb-2",
                        key: c.user_id,
                        ref_for: !0
                    }, c), null, 16))), 128)), n.isLoading ? (A(),
                        N("div", hwe, [G(a)])) : te("", !0)])])
}
const fwe = _e(owe, [["render", dwe]])
    , pwe = {
        class: "text-white text-xs font-semibold text-center"
    }
    , mwe = {
        class: "inline-flex flex-col gap-2 items-center grow justify-center"
    }
    , gwe = ["src"]
    , _we = {
        class: "text-white text-xs font-semibold text-center"
    }
    , ywe = {
        class: "text-white/50 text-xs text-center"
    }
    , bwe = {
        class: "text-white"
    }
    , vwe = Qa({
        __name: "ReferralReward",
        props: {
            isPremium: {
                type: Boolean
            }
        },
        setup(t) {
            const e = t
                , { t: n } = gt()
                , s = ve(() => e.isPremium ? {
                    title: n("referral.rewards.invite_friend_premium"),
                    image: "/shop/lootbox-referral_box_premium.webp",
                    lootbox: n("referral.rewards.lootbox_premium")
                } : {
                    title: n("referral.rewards.invite_friend"),
                    image: "/shop/lootbox-referral_box_standard.webp",
                    lootbox: n("referral.rewards.lootbox")
                })
                , r = ve(() => xh(e.isPremium ? Pt.EPIC : Pt.COMMON));
            return (i, o) => (A(),
                N("div", {
                    class: Te(["py-4 px-3 bg-white/5 rounded-lg border border-white/5 flex-col inline-flex items-center gap-1", {
                        "bg-[url('/background.jpg')] bg-cover bg-center": i.isPremium
                    }])
                }, [T("h5", pwe, $(s.value.title), 1), T("div", mwe, [T("p", {
                    class: "text-sm font-black",
                    style: Wt(r.value)
                }, $(i.$t("referral.rewards.subtitle")), 5), T("img", {
                    class: "w-1/3",
                    src: s.value.image,
                    alt: "referral-reward"
                }, null, 8, gwe), T("p", _we, $(s.value.lootbox), 1)]), T("p", ywe, [T("span", bwe, [G(dn, {
                    class: "inline-block w-4 h-4"
                }), Fe("" + $(i.isPremium ? 10 : 5) + "%", 1)]), Fe(" " + $(i.$t("referral.rewards.earn")), 1)])], 2))
        }
    })
    , xwe = {
        class: "inline-flex items-center px-1 py-1 bg-white/5 rounded-lg border border-white/5 gap-2"
    }
    , wwe = {
        class: "grow basis-0 flex flex-col gap-0.5"
    }
    , Swe = {
        class: "text-white/50 text-xs ml-2"
    }
    , Ewe = {
        class: "text-coin text-xl font-semibold ml-2"
    }
    , Twe = T("div", {
        class: "border-l shrink-0 border-white/5 h-full"
    }, null, -1)
    , Cwe = {
        class: "grow basis-0 flex items-center"
    }
    , Iwe = {
        class: "flex flex-col gap-0.5"
    }
    , Awe = {
        class: "text-white/50 text-xs"
    }
    , kwe = {
        class: "text-white text-xl font-semibold"
    }
    , Rwe = {
        __name: "RewardClaim",
        setup(t) {
            const e = kx()
                , { showSuccessToast: n } = mi()
                , s = Fn()
                , r = ve(() => e.bonus.coins)
                , i = ve(() => e.bonus.standardLootboxes + e.bonus.bonusStandardLootboxes)
                , o = ke(!1)
                , l = ve(() => i.value > 0 || r.value > 0)
                , a = async () => {
                    try {
                        o.value = !0,
                            await e.claimRewards(),
                            i.value > 0 ? n("toast_messages.added_to_my_lootboxes") : n("toast_messages.referral_rewards_claimed"),
                            s.logEvent("claim_referral_rewards"),
                            o.value = !1
                    } catch (c) {
                        console.error(c)
                    } finally {
                        o.value = !1
                    }
                }
                ;
            return (c, u) => (A(),
                N("div", xwe, [T("div", wwe, [T("p", Swe, $(c.$t("referral.rewards.bonuses")), 1), T("p", Ewe, [G(dn, {
                    class: "w-6 h-6 inline-block"
                }), Fe(" " + $(de(Xt)(r.value, !0)), 1)])]), Twe, T("div", Cwe, [T("div", Iwe, [T("p", Awe, $(c.$t("referral.rewards.lootboxes")), 1), T("p", kwe, $(i.value), 1)]), G(Lr, {
                    class: "!w-auto ml-auto",
                    type: "success",
                    isLoading: o.value,
                    disabled: !l.value,
                    onClick: a
                }, {
                    default: Ce(() => [Fe($(c.$t("referral.rewards.claim")), 1)]),
                    _: 1
                }, 8, ["isLoading", "disabled"])])]))
        }
    }
    , Mwe = {}
    , Pwe = {
        width: "25",
        height: "24",
        viewBox: "0 0 25 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }
    , Lwe = T("rect", {
        x: "0.601562",
        y: "4",
        width: "20",
        height: "20",
        rx: "2"
    }, null, -1)
    , Owe = T("path", {
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        d: "M6.60156 0C5.49699 0 4.60156 0.895431 4.60156 2L20.6016 2C21.7061 2 22.6016 2.89543 22.6016 4V20C23.7061 20 24.6016 19.1046 24.6016 18V2C24.6016 0.895431 23.7061 0 22.6016 0H6.60156Z",
        fill: "currentColor"
    }, null, -1)
    , Nwe = [Lwe, Owe];
function Dwe(t, e) {
    return A(),
        N("svg", Pwe, Nwe)
}
const Bwe = _e(Mwe, [["render", Dwe]])
    , Fwe = {
        name: "Referral",
        components: {
            IconCopy: Bwe,
            FriendsList: fwe,
            MainFooter: jo,
            ReferralReward: vwe,
            RewardClaim: Rwe,
            LootboxInfoPopup: HL,
            ButtonPrimary: Lr
        },
        computed: {
            referralUrl() {
                const t = Ye();
                return ES(t.userId)
            }
        },
        data() {
            return {
                showLootboxInfoPopup: !1,
                lootboxInfo: null
            }
        },
        methods: {
            refreshList() {
                this.referralStore.fetchReferralData()
            },
            onInviteFriendClick() {
                const t = this.$t("referral.invite_friend_message", {
                    link: this.referralUrl
                });
                $L(this.referralUrl, t),
                    this.analyticsStore.logEvent("invite_friend_click")
            },
            openLootboxInfoPopup(t = !1) {
                this.showLootboxInfoPopup = !0,
                    this.lootboxInfo = this.lootboxesStore.getLootboxByType(t ? Dt.REFERRAL_BOX_PREMIUM : Dt.REFERRAL_BOX_STANDARD)
            },
            onLootboxInfoPopupClose() {
                this.showLootboxInfoPopup = !1,
                    this.lootboxInfo = null
            },
            async onCopyClick() {
                await navigator.clipboard.writeText(this.referralUrl);
                const { showSuccessToast: t } = mi();
                t("toast_messages.copy_link_to_clipboard"),
                    this.analyticsStore.logEvent("copy_referral_link_to_clipboard")
            }
        },
        mixins: [Ef],
        mounted() {
            this.referralStore.fetchReferralData().then(() => {
                this.$emit("ready")
            }
            ),
                this.analyticsStore.logEvent("open_referral_page")
        },
        setup() {
            return {
                lootboxesStore: ji(),
                referralStore: kx(),
                analyticsStore: Fn()
            }
        }
    }
    , $we = {
        class: "overflow-hidden flex flex-col h-[calc(100%-90px)]"
    }
    , Uwe = {
        class: "overflow-y-auto flex flex-col content-center px-4 py-4 grow"
    }
    , Vwe = {
        class: "text-white text-xl font-bold mb-2 text-center"
    }
    , Gwe = {
        class: "text-white/80 text-base font-normal leading-tight text-center"
    }
    , Hwe = {
        class: "grid grid-cols-2 gap-4 mt-3"
    }
    , Wwe = {
        key: 0,
        class: "py-2 text-center bg-white/5 rounded-lg border border-white/5 mt-3"
    }
    , Ywe = {
        class: "text-white leading-tight"
    }
    , Xwe = {
        class: "text-accent font-semibold leading-tight"
    }
    , jwe = {
        class: "flex flex-row gap-2 px-4 mt-4"
    };
function zwe(t, e, n, s, r, i) {
    const o = q("RewardClaim")
        , l = q("ReferralReward")
        , a = q("FriendsList")
        , c = q("ButtonPrimary")
        , u = q("IconCopy")
        , h = q("MainFooter")
        , d = q("LootboxInfoPopup");
    return A(),
        N("div", $we, [T("div", Uwe, [T("h2", Vwe, $(t.$t("referral.header")), 1), T("p", Gwe, $(t.$t("referral.subheader")), 1), G(o, {
            class: "mt-4"
        }), T("div", Hwe, [G(l, {
            class: "w-full active:bg-white/10 active:scale-95 transition-all duration-100",
            isPremium: !1,
            onClick: e[0] || (e[0] = f => i.openLootboxInfoPopup())
        }), G(l, {
            class: "w-full active:bg-white/10 active:scale-95 transition-all duration-100",
            isPremium: !0,
            onClick: e[1] || (e[1] = f => i.openLootboxInfoPopup(!0))
        })]), s.referralStore.invitedByUsername != null ? (A(),
            N("div", Wwe, [T("p", Ywe, $(t.$t("referral.you_are_referral")), 1), T("p", Xwe, $(s.referralStore.invitedByUsername), 1)])) : te("", !0), G(a, {
                class: "mt-6",
                friends: s.referralStore.invitedUsers,
                refreshList: i.refreshList,
                isLoading: s.referralStore.isLoading
            }, null, 8, ["friends", "refreshList", "isLoading"])]), T("div", jwe, [G(c, {
                type: "success",
                size: "l",
                onClick: i.onInviteFriendClick
            }, {
                default: Ce(() => [Fe($(t.$t("referral.buttons.invite_friend")), 1)]),
                _: 1
            }, 8, ["onClick"]), G(c, {
                class: "aspect-square !w-auto text-white active:text-white/50",
                size: "l",
                type: "dark",
                onClick: ni(i.onCopyClick, ["stop"])
            }, {
                default: Ce(() => [G(u, {
                    class: "h-6 w-6 fill-current"
                })]),
                _: 1
            }, 8, ["onClick"])]), G(h), G(d, {
                isVisible: r.showLootboxInfoPopup,
                lootboxInfo: r.lootboxInfo,
                onClose: i.onLootboxInfoPopupClose,
                onClick: i.onInviteFriendClick
            }, {
                button: Ce(() => [G(c, {
                    class: "mt-3",
                    type: "success",
                    size: "l",
                    onClick: i.onInviteFriendClick
                }, {
                    default: Ce(() => [Fe($(t.$t("referral.buttons.invite_friend")), 1)]),
                    _: 1
                }, 8, ["onClick"])]),
                _: 1
            }, 8, ["isVisible", "lootboxInfo", "onClose", "onClick"])])
}
const qwe = _e(Fwe, [["render", zwe]])
    , Kwe = "/qr-code.svg"
    , eO = () => {
        var t, e, n, s;
        return ((e = (t = window.Telegram) == null ? void 0 : t.WebApp) == null ? void 0 : e.platform) === "ios" || ((s = (n = window.Telegram) == null ? void 0 : n.WebApp) == null ? void 0 : s.platform) === "android"
    }
    , Jwe = {
        class: "flex flex-col align-middle content-center justify-center items-center w-full h-full gap-4"
    }
    , Zwe = {
        class: "text-white text-2xl"
    }
    , Qwe = T("div", {
        class: "px-4"
    }, [T("img", {
        class: "max-w-[600px] max-h-[600px] w-full",
        src: Kwe,
        alt: "QR Code"
    })], -1)
    , eSe = {
        __name: "RestrictedAccess",
        emits: ["ready"],
        setup(t, { emit: e }) {
            const n = e;
            return Ld(),
                Or(() => {
                    n("ready"),
                        eO() && Ld().push(ft.MAIN)
                }
                ),
                (s, r) => (A(),
                    N("div", Jwe, [T("div", null, [T("h2", Zwe, $(s.$t("telegram_not_mobile.modal_message")), 1)]), Qwe]))
        }
    }
    , tSe = {
        class: "flex items-center"
    }
    , nSe = {
        class: "text-accent w-[52px]"
    }
    , sSe = {
        class: "font-bold"
    }
    , rSe = {
        class: "flex items-center gap-1"
    }
    , iSe = {
        __name: "LeaderboardLine",
        props: {
            orderNumber: {
                type: Number,
                required: !0
            },
            username: {
                type: String,
                required: !1
            },
            value: {
                type: Number,
                required: !0
            },
            userId: {
                type: String,
                required: !0
            }
        },
        setup(t) {
            const { t: e } = gt()
                , n = Ye()
                , s = ve(() => n.userId);
            return (r, i) => (A(),
                N("div", {
                    class: Te(["text-xs rounded-lg font-semibold text-white/[.8] p-3 flex flex-row gap-1 items-center justify-between self-stretch border border-solid border-white/[.14] bg-[rgba(40,46,77,0.24)]", s.value === t.userId && "sticky inset-y-0 highlighted-row border-0"])
                }, [T("div", tSe, [T("div", nSe, $(t.orderNumber), 1), T("div", sSe, $(t.username || de(e)("leaderboard.anonymous")), 1)]), T("div", rSe, [T("span", null, [G(dn, {
                    class: "w-5 h-5"
                })]), T("span", null, $(de(Xt)(t.value, !0)), 1)])], 2))
        }
    }
    , oSe = _e(iSe, [["__scopeId", "data-v-eea869e2"]])
    , tO = Ds("leaderboard", {
        state: () => ({
            leaderboards: null
        }),
        actions: {
            setLeaderboards(t) {
                this.leaderboards = t
            },
            fetchLeaderboards() {
                const t = Ye();
                return Ls({
                    action: () => Bn(t.telegramAppFunctions, "get_leaderboard_call")(),
                    onSuccess: e => {
                        this.setLeaderboards(_o(e.data))
                    }
                })
            },
            getLeaderboard(t) {
                return this.leaderboards == null ? {
                    users: [],
                    league: ""
                } : {
                    league: this.leaderboards[t].league,
                    users: this.leaderboards[t].users
                }
            }
        }
    })
    , aSe = {
        class: "flex flex-col grow overflow-hidden"
    }
    , lSe = {
        class: "text-white font-semibold text-xl px-4"
    }
    , cSe = {
        class: "mt-2 flex flex-col gap-2 px-4 grow overflow-y-auto"
    }
    , N1 = {
        __name: "LeaderboardTab",
        props: {
            leaderboardType: {
                type: String,
                required: !0,
                validator: t => ["daily", "global", "referral"].includes(t)
            }
        },
        setup(t) {
            const { t: e } = gt()
                , n = t
                , s = tO()
                , r = ve(() => s.getLeaderboard(n.leaderboardType));
            return (i, o) => (A(),
                N("div", aSe, [T("div", lSe, $(de(e)(`leagues.${r.value.league}`)), 1), T("div", cSe, [(A(!0),
                    N(Ie, null, mt(r.value.users, l => (A(),
                        fe(oSe, Ms({
                            key: l.orderNumber,
                            ref_for: !0
                        }, l), null, 16))), 128))])]))
        }
    }
    , uSe = {
        key: 1,
        class: "h-full w-full flex justify-center"
    }
    , hSe = {
        __name: "LoaderWrapper",
        props: {
            isLoading: Boolean
        },
        setup(t) {
            return (e, n) => (A(),
                N("div", {
                    class: Te([t.isLoading && "h-full"])
                }, [t.isLoading ? (A(),
                    N("div", uSe, [G(ol)])) : rs(e.$slots, "default", {
                        key: 0
                    })], 2))
        }
    };
function dSe(t) {
    const e = ke(!1);
    return {
        isLoading: e,
        execute: async (...s) => {
            e.value = !0;
            try {
                return await t(...s)
            } finally {
                e.value = !1
            }
        }
    }
}
function fSe() {
    var l, a;
    const t = Ld()
        , e = _s()
        , n = (a = (l = window.Telegram) == null ? void 0 : l.WebApp) == null ? void 0 : a.BackButton
        , s = () => {
            t.push(ft.MAIN)
        }
        , r = () => {
            s()
        }
        , i = c => {
            n && (n.offClick(r),
                n.onClick(c))
        }
        , o = c => {
            n && (n.offClick(c),
                n.onClick(r))
        }
        ;
    return Or(() => {
        n && !e.isOnboardingInProgress && (n.show(),
            n.onClick(r))
    }
    ),
        Qd(() => {
            n && (n.hide(),
                n.offClick(r))
        }
        ),
    {
        redirectToMainPage: s,
        replaceBackButtonHandler: i,
        resetBackButtonHandler: o
    }
}
const pSe = {
    class: "overflow-hidden flex flex-col h-[calc(100%-90px)]"
}
    , mSe = {
        class: "flex grow flex-col gap-3 overflow-hidden"
    }
    , gSe = {
        __name: "Leaderboard",
        emits: ["ready"],
        setup(t, { emit: e }) {
            const n = ke("today")
                , s = e
                , { t: r } = gt();
            fSe();
            const i = tO()
                , { isLoading: o, execute: l } = dSe(i.fetchLeaderboards)
                , a = ve(() => [{
                    id: "today",
                    title: r("leaderboard.tabs.today")
                }, {
                    id: "referral",
                    title: r("leaderboard.tabs.referral")
                }, {
                    id: "total",
                    title: r("leaderboard.tabs.total")
                }])
                , c = u => {
                    n.value = u
                }
                ;
            return Or(() => {
                l().then(() => {
                    s("ready")
                }
                )
            }
            ),
                (u, h) => (A(),
                    N("div", pSe, [G(oc), G(hSe, {
                        isLoading: de(o),
                        class: "flex overflow-hidden"
                    }, {
                        default: Ce(() => [T("main", mSe, [G(wS, {
                            class: "mx-4",
                            tabs: a.value,
                            selectedTabId: n.value,
                            onChangeTab: c
                        }, null, 8, ["tabs", "selectedTabId"]), n.value === "today" ? (A(),
                            fe(N1, {
                                key: 0,
                                leaderboardType: "daily"
                            })) : te("", !0), n.value === "referral" ? (A(),
                                fe(N1, {
                                    key: 1,
                                    leaderboardType: "referral"
                                })) : te("", !0), n.value === "total" ? (A(),
                                    fe(N1, {
                                        key: 2,
                                        leaderboardType: "global"
                                    })) : te("", !0)])]),
                        _: 1
                    }, 8, ["isLoading"]), G(jo)]))
        }
    }
    , ft = {
        MAIN: "/",
        SHOP: "/shop",
        EARN: "/earn",
        AIRDROP: "/airdrop",
        GAMES: "/games",
        GIRLS: "/girls",
        UPGRADE: "/upgrade",
        REFERRAL: "/referral",
        LEADERBOARD: "/leaderboard",
        RESTRICTED_ACCESS: "/restricted-access"
    }
    , _Se = [ft.GIRLS, ft.REFERRAL, ft.SHOP, ft.UPGRADE, ft.GAMES, ft.AIRDROP, ft.RESTRICTED_ACCESS]
    , ySe = [{
        path: ft.MAIN,
        component: pme
    }, {
        path: ft.SHOP,
        component: d0e
    }, {
        path: ft.EARN,
        component: Ime
    }, {
        path: ft.AIRDROP,
        component: N0e
    }, {
        path: ft.GAMES,
        component: Fye
    }, {
        path: ft.GIRLS,
        component: Wbe
    }, {
        path: ft.UPGRADE,
        component: Wxe
    }, {
        path: ft.REFERRAL,
        component: qwe
    }, {
        path: ft.LEADERBOARD,
        component: gSe
    }, {
        path: ft.RESTRICTED_ACCESS,
        component: eSe
    }]
    , MS = Cte({
        history: ete(),
        routes: ySe
    })
    , bSe = [{
        stepId: Be.HI,
        showGirlText: !0
    }, {
        stepId: Be.STASH_SLAP,
        showGirlText: !0,
        needClickToNextButton: !0
    }, {
        stepId: Be.MAIN_RESOURCE,
        showGirlText: !0,
        needClickToNextButton: !0
    }, {
        stepId: Be.PER_HOUR,
        showGirlText: !0,
        needClickToNextButton: !0
    }, {
        stepId: Be.CANT_HOLD,
        showGirlText: !0,
        needClickToNextButton: !0
    }, {
        stepId: Be.DONT_LEAVE,
        showGirlText: !0
    }, {
        stepId: Be.NICE,
        showGirlText: !0
    }, {
        stepId: Be.GO_TO_WHEEL,
        showGirlText: !0
    }, {
        stepId: Be.SPIN_WHEEL,
        preconditionCallback: () => {
            const t = zo();
            t.setWheel(rd.STARTER),
                t.show = !0
        }
    }, {
        stepId: Be.CLAIM_REWARD,
        redirectToStepOnInit: Be.GO_SHOP
    }, {
        stepId: Be.CLOSE_WHEEL,
        redirectToStepOnInit: Be.GO_SHOP
    }, {
        stepId: Be.GO_SHOP,
        showGirlText: !0
    }, {
        stepId: Be.GO_TO_MY_LOOTBOXES,
        preconditionCallback: t => {
            t.push(ft.SHOP)
        }
    }, {
        stepId: Be.OPEN_LOOTBOX,
        redirectToStepOnInit: Be.GO_TO_MY_LOOTBOXES,
        preconditionCallback: t => {
            t.push(ft.SHOP)
        }
    }, {
        stepId: Be.LOOTBOX_OPENED,
        redirectToStepOnInit: Be.USE_GIFT,
        preconditionCallback: t => {
            t.push(ft.SHOP)
        }
    }, {
        stepId: Be.USE_GIFT,
        showGirlText: !0
    }, {
        stepId: Be.USE_GIFT_1,
        showGirlText: !0,
        preconditionCallback: t => {
            Ye().setIsGiftActivated(!0)
        }
    }, {
        stepId: Be.USE_GIFT_2,
        showGirlText: !0,
        preconditionCallback: t => {
            Ye().setIsGiftActivated(!0)
        }
    }, {
        stepId: Be.USE_BOOST,
        showGirlText: !0
    }, {
        stepId: Be.USE_BOOST_1,
        showGirlText: !0,
        preconditionCallback: t => {
            Xs().setShowBoostsOverlay(!0)
        }
    }, {
        stepId: Be.SECOND_GIRL,
        showGirlText: !0
    }, {
        stepId: Be.SECOND_GIRL_CHOSEN,
        redirectToStepOnInit: Be.SECOND_GIRL,
        preconditionCallback: t => {
            t.push(ft.GIRLS)
        }
    }, {
        stepId: Be.SECOND_GIRL_EQUIPPED,
        preconditionCallback: t => {
            t.push(ft.GIRLS)
        }
    }, {
        stepId: Be.GO_EARN,
        showGirlText: !0
    }, {
        stepId: Be.CHOOSE_DAILY_REWARD,
        redirectToStepOnInit: Be.GO_EARN
    }, {
        stepId: Be.CHOOSE_DAILY_REWARD_DAY,
        redirectToStepOnInit: Be.GO_EARN
    }, {
        stepId: Be.DONE,
        showGirlText: !0
    }]
    , _s = Ds("onboarding", {
        state: () => ({
            stepId: null,
            steps: bSe
        }),
        getters: {
            currentStep(t) {
                return t.stepId == null ? null : t.steps.find(e => e.stepId == t.stepId)
            },
            nextStep(t) {
                if (t.currentStep == null)
                    return null;
                const e = t.steps.indexOf(t.currentStep);
                return t.steps[e + 1]
            },
            isOnboardingInProgress(t) {
                return t.stepId != null
            },
            visibilityMatrix(t) {
                return {
                    fortuneWheelButton: [].includes(t.stepId),
                    boostsButton: [].includes(t.stepId),
                    tasksButton: [].includes(t.stepId),
                    giftsButton: [].includes(t.stepId),
                    secondGirlSlot: [].includes(t.stepId)
                }
            }
        },
        actions: {
            _setStepId(t) {
                this.stepId != null && this.stepId !== t && Ls({
                    action: async () => {
                        const { telegramAppFunctions: e } = Ye();
                        return Bn(e, "set_onboarding_step_call")({
                            onboarding_step: t
                        })
                    }
                }),
                    this.stepId = t
            },
            beginOnboarding(t) {
                var n, s;
                if (t == null)
                    return;
                this._setStepId(t),
                    this.currentStep.redirectToStepOnInit ? this._setStepId(this.currentStep.redirectToStepOnInit) : (s = (n = this.currentStep).preconditionCallback) == null || s.call(n, this.$router),
                    Fn().beginOnboarding()
            },
            setStep(t) {
                if (this.isOnboardingInProgress) {
                    if (this.steps.findIndex(e => e.stepId === t) < this.steps.findIndex(e => e.stepId === this.stepId)) {
                        console.warn("The step you're trying to set is earlier than the current");
                        return
                    }
                    this._setStepId(t)
                }
            },
            goToNextStep() {
                this.isOnboardingInProgress && (this.nextStep == null && this.finishOnboarding(),
                    this._setStepId(this.nextStep.stepId))
            },
            finishOnboarding() {
                this._setStepId(null),
                    Fn().finishOnboarding()
            },
            isElementVisible(t) {
                return !this.isOnboardingInProgress || this.visibilityMatrix[t]
            }
        }
    })
    , vSe = "/shop/chip.webp"
    , xSe = {
        name: "ChipCard",
        props: {
            amount: Number
        },
        setup() {
            const { t } = gt();
            return {
                t,
                formattingPrice: Xt
            }
        }
    }
    , wSe = {
        class: "relative w-full h-full items-center justify-center flex flex-col rounded-lg border border-[#3d2216] bg-gradient-to-t from-black to-violet-950 overflow-hidden"
    }
    , SSe = T("img", {
        src: vSe,
        alt: "Coin Image",
        class: "w-full"
    }, null, -1)
    , ESe = {
        key: 0,
        class: "flex flex-col items-center gap-2 p-2"
    }
    , TSe = {
        class: "font-semibold text-coin text-lg"
    }
    , CSe = {
        class: "text-white/60 text-xxs"
    };
function ISe(t, e, n, s, r, i) {
    return A(),
        N("div", wSe, [SSe, n.amount ? (A(),
            N("div", ESe, [T("div", TSe, " + " + $(s.formattingPrice(n.amount)), 1), T("p", CSe, $(s.t("shop.chips")), 1)])) : te("", !0)])
}
const ASe = _e(xSe, [["render", ISe]])
    , kSe = {
        class: "flex flex-col items-center w-full"
    }
    , RSe = {
        class: "w-full text-center text-white text-xl font-bold"
    }
    , MSe = {
        class: "flex flex-col gap-3 items-center w-full"
    }
    , PSe = {
        class: "h-8"
    }
    , LSe = {
        key: 0
    }
    , OSe = {
        key: 1,
        class: "capitalize"
    }
    , NSe = {
        key: 0,
        class: "relative"
    }
    , DSe = ["src"]
    , BSe = {
        class: "w-full mt-4"
    }
    , FSe = {
        class: "flex overflow-x-auto gap-1.5 px-2 scrollbar-hide"
    }
    , $Se = ["onClick"]
    , USe = {
        __name: "DailyClaimsPopup",
        props: {
            isVisible: Boolean
        },
        emits: ["click", "close"],
        setup(t, { emit: e }) {
            const n = {
                coins: "coins",
                spin: "spin",
                lootbox: "lootbox",
                profit_boost: "profit_boost",
                energy_boost: "energy_boost"
            }
                , { t: s } = gt()
                , r = t
                , i = e
                , o = _s()
                , l = gf()
                , a = ji()
                , c = Fn()
                , u = mi()
                , h = ve(() => l.currentDailyClaim || {})
                , d = ke(0)
                , f = ke(!0)
                , p = ke([])
                , m = ke(!1)
                , g = ke(h.value || {})
                , b = ve(() => l.dailyClaims)
                , v = ve(() => g.value.claims[d.value] || {})
                , _ = ve(() => {
                    var S;
                    return xh(v.value.type === n.lootbox ? NM[v.value.lootbox_type] : (S = v.value) == null ? void 0 : S.tier)
                }
                )
                , y = async () => {
                    m.value || (m.value = !0,
                        c.logEvent("claim_daily_reward"),
                        await l.claimDailyReward(),
                        m.value = !1,
                        u.showSuccessToast(s("daily.reward_popup.success")),
                        i("click"))
                }
                , x = S => {
                    d.value = S.value
                }
                ;
            let w = null;
            return Ln(d, () => {
                clearTimeout(w),
                    f.value = !1,
                    w = setTimeout(() => {
                        f.value = !0
                    }
                        , 500)
            }
            ),
                Ln(() => r.isVisible, async S => {
                    var E, C;
                    S && (d.value = 0,
                        f.value = !0,
                        p.value = [],
                        m.value = !1,
                        g.value = h.value,
                        await Zd(),
                        (C = (E = p.value) == null ? void 0 : E[g.value.day]) == null || C.scrollIntoView({
                            behavior: "smooth",
                            block: "center"
                        }))
                }
                ),
                (S, E) => (A(),
                    fe(Hg, {
                        to: "body"
                    }, [G(il, {
                        isVisible: t.isVisible,
                        onClose: E[0] || (E[0] = C => i("close")),
                        class: "z-[100]"
                    }, {
                        default: Ce(() => {
                            var C, I, L;
                            return [T("div", kSe, [T("h4", RSe, $(de(s)("daily.body.daily_reward")), 1), T("div", MSe, [T("div", PSe, [G(is, {
                                name: "fade"
                            }, {
                                default: Ce(() => {
                                    var k, R;
                                    return [f.value ? (A(),
                                        N("p", {
                                            key: 0,
                                            class: Te(["text-2xl pr-1.5 italic font-black capitalize text-center", {
                                                "text-coin": [n.coins, n.spin].includes(v.value.type)
                                            }]),
                                            style: Wt(_.value)
                                        }, [v.value.type === n.lootbox && de(a).lootboxes ? (A(),
                                            N("span", LSe, $((R = (k = de(a).lootboxes) == null ? void 0 : k[v.value.lootbox_type]) == null ? void 0 : R.name), 1)) : (A(),
                                                N("span", OSe, $(S.$t(`daily.reward_type.${v.value.type}`)), 1))], 6)) : te("", !0)]
                                }
                                ),
                                _: 1
                            })]), (I = (C = g.value) == null ? void 0 : C.claims) != null && I.length ? (A(),
                                fe(R4, {
                                    key: 0,
                                    items: g.value.claims,
                                    startAnimation: !0,
                                    playToEndAnimation: !1,
                                    showAllCardsOnStart: !0,
                                    startIndex: d.value,
                                    skipInitialAnimation: !0,
                                    onCurrentIndexChanged: x
                                }, {
                                    cards: Ce(({ item: k }) => [k.type === n.lootbox ? (A(),
                                        N("div", NSe, [T("img", {
                                            src: `/shop/lootbox-${k.lootbox_type}.webp`,
                                            alt: "Card image",
                                            class: "top-0 inset-x-0 rounded-lg w-full object-contain object-top"
                                        }, null, 8, DSe)])) : k.type === n.spin ? (A(),
                                            fe(ASe, {
                                                key: 1,
                                                amount: k.amount
                                            }, null, 8, ["amount"])) : te("", !0)]),
                                    _: 1
                                }, 8, ["items", "startIndex"])) : te("", !0)]), T("div", BSe, [T("div", FSe, [(A(!0),
                                    N(Ie, null, mt(b.value, (k, R) => (A(),
                                        N("div", {
                                            key: R,
                                            ref_for: !0,
                                            ref_key: "dailyClaimRefs",
                                            ref: p,
                                            class: Te(["p-2 bg-white/5 border aspect-square rounded-lg shrink-0 relative border-white/5 flex flex-col gap-1 items-center justify-center", {
                                                "!border-[#22b3f2]": k.day === g.value.day
                                            }]),
                                            onClick: U => g.value = k
                                        }, [k.day === g.value.day ? (A(),
                                            fe(gr, {
                                                key: 0,
                                                tier: de(Pt).RARE,
                                                class: "z-[-1]",
                                                height: "80%",
                                                blur: "24"
                                            }, null, 8, ["tier"])) : te("", !0), G(dn, {
                                                class: Te(["w-12 h-12", {
                                                    "opacity-60": k.done
                                                }])
                                            }, null, 8, ["class"]), k.done ? (A(),
                                                fe(xc, {
                                                    key: 1,
                                                    class: "w-4 h-4 right-0.5 top-0.5 absolute"
                                                })) : te("", !0), T("p", {
                                                    class: Te(["text-white text-xxs font-semibold leading-3", {
                                                        "text-white/50": k.done
                                                    }])
                                                }, $(de(s)("day")) + " " + $(k.day), 3)], 10, $Se))), 128))])]), G(Lr, {
                                                    class: "mt-4",
                                                    type: "success",
                                                    size: "l",
                                                    disabled: g.value.day === h.value.day ? h.value.done : !0,
                                                    isLoading: m.value,
                                                    onClick: y
                                                }, {
                                                    default: Ce(() => [Fe($(de(s)("daily.reward_popup.button")), 1)]),
                                                    _: 1
                                                }, 8, ["disabled", "isLoading"]), de(o).isOnboardingInProgress ? (A(),
                                                    fe(al, {
                                                        key: 0,
                                                        class: Te(["onboarding-hand", [(L = de(o).currentStep) == null ? void 0 : L.stepId]])
                                                    }, null, 8, ["class"])) : te("", !0)])]
                        }
                        ),
                        _: 1
                    }, 8, ["isVisible"])]))
        }
    }
    , VSe = _e(USe, [["__scopeId", "data-v-ea519e40"]])
    , GSe = (t, e) => t === "unknown" || e(t === "mobile" ? UY : VY)
    , HSe = t => {
        const n = t.split(".")[1].replace(/-/g, "+").replace(/_/g, "/")
            , s = decodeURIComponent(window.atob(n).split("").map(function (r) {
                return "%" + ("00" + r.charCodeAt(0).toString(16)).slice(-2)
            }).join(""));
        return JSON.parse(s)
    }
    , WSe = {
        class: "flex flex-col gap-3 w-full items-center text-white"
    }
    , YSe = {
        class: "flex flex-col items-center"
    }
    , XSe = {
        class: "font-semibold leading-tight"
    }
    , jSe = {
        class: "text-center text-white/60 leading-tight"
    }
    , zSe = {
        class: "text-white"
    }
    , qSe = {
        class: "text-white/[.80] leading-tight font-normal text-base"
    }
    , KSe = {
        class: "flex flex-row items-center gap-1"
    }
    , JSe = {
        __name: "UnlockSlotPopup",
        setup(t) {
            const { t: e } = gt()
                , n = Fo()
                , s = ve(() => n.isBuySlotModalVisible)
                , r = ve(() => n.currentSlots)
                , i = ve(() => n.unlockPrice)
                , o = ve(() => {
                    var h;
                    return (h = n.slotsConfig) == null ? void 0 : h.maxSlotsNumber
                }
                )
                , l = ve(() => n.hasMaxSlots)
                , a = ve(() => l ? {} : xh(ZY[n.currentSlots + 1]))
                , c = n.hideBuySlotModal
                , u = n.unlockSlot;
            return (h, d) => l.value ? te("", !0) : (A(),
                fe(il, {
                    key: 0,
                    "is-visible": s.value,
                    onClose: de(c)
                }, {
                    default: Ce(() => [T("div", WSe, [T("div", YSe, [T("p", XSe, $(de(e)("unlock_slot_popup.slot")) + " " + $(r.value + 1) + "/" + $(o.value), 1), T("p", {
                        class: "text-2xl font-black italic",
                        style: Wt(a.value)
                    }, $(de(e)("unlock_slot_popup.unlock_new_slot")), 5)]), G(TS, {
                        isCollapsed: !0,
                        alwaysShowLocked: !0,
                        alwaysShowEmpty: !0
                    }), T("div", jSe, [T("p", null, [Fe($(de(e)("unlock_slot_popup.help_text_line1_part1")) + " ", 1), T("span", zSe, $(de(e)("unlock_slot_popup.help_text_line1_part2")), 1)]), T("p", null, $(de(e)("unlock_slot_popup.help_text_line2")), 1)]), G(Lr, {
                        class: "flex flex-col mt-1",
                        type: "accent",
                        onClick: de(u),
                        size: "l"
                    }, {
                        default: Ce(() => [T("span", qSe, $(de(e)("unlock_slot_popup.button")), 1), T("span", KSe, [G(vc, {
                            class: "w-5 h-5"
                        }), Fe(" " + $(de(Xt)(i.value)), 1)])]),
                        _: 1
                    }, 8, ["onClick"])])]),
                    _: 1
                }, 8, ["is-visible", "onClose"]))
        }
    }
    , ZSe = {
        class: "toast"
    }
    , QSe = {
        key: 0,
        class: "absolute inline-flex flex-row items-center gap-2 text-white px-2 py-1 bg-white/[.12] backdrop-blur-sm z-[9999] left-1/2 top-16 rounded-lg transform -translate-x-1/2 w-max max-w-[90%]"
    }
    , eEe = {
        key: 0
    }
    , tEe = {
        class: "text-overflow-ellipsis overflow-hidden"
    }
    , nEe = {
        key: 1
    }
    , sEe = {
        __name: "Toast",
        setup(t) {
            const { t: e } = gt()
                , n = mi()
                , s = n.hideToast
                , r = ve(() => n.hasToast)
                , i = ve(() => n.toast);
            return (o, l) => (A(),
                fe(Hg, {
                    to: "body"
                }, [T("div", ZSe, [G(is, {
                    name: "fade"
                }, {
                    default: Ce(() => {
                        var a, c;
                        return [r.value ? (A(),
                            N("div", QSe, [((a = i.value) == null ? void 0 : a.type) === "success" ? (A(),
                                N("div", eEe, [G(xc, {
                                    class: "w-8 h-8"
                                })])) : te("", !0), T("div", tEe, $(de(e)(i.value.message)), 1), ((c = i.value) == null ? void 0 : c.type) === "success" ? (A(),
                                    N("div", nEe, [G(S_, {
                                        onClick: de(s),
                                        class: "w-4 h-4"
                                    }, null, 8, ["onClick"])])) : te("", !0)])) : te("", !0)]
                    }
                    ),
                    _: 1
                })])]))
        }
    }
    , rEe = _e(sEe, [["__scopeId", "data-v-b6bcea06"]])
    , { disableVerticalSwipes: iEe } = Pq()
    , oEe = {
        apiKey: "AIzaSyAYPGepKwdVahPoEhGxcKcETpt056OiE5U",
        authDomain: "slapapp-prod-fe50c.firebaseapp.com",
        projectId: "slapapp-prod-fe50c",
        storageBucket: "slapapp-prod-fe50c.firebasestorage.app",
        messagingSenderId: "973731802401",
        appId: "1:973731802401:web:deb3651cfb04cb4bc4a260",
        measurementId: "G-Y7J414DNBQ"
    }
    , aEe = {
        name: "SlapApp",
        components: {
            UnlockSlotPopup: JSe,
            FortuneWheelOverlay: KL,
            Overlay: ch,
            Loader: ol,
            Modal: HJ,
            Popup: il,
            IconWarning: b4,
            Toast: rEe,
            DailyClaimsPopup: VSe
        },
        data() {
            return {
                timeout: null,
                isReady: !1,
                globalStore: Ye(),
                onboardingStore: _s(),
                analyticsStore: Fn(),
                fortuneWheelStore: zo(),
                tasksStore: _f(),
                lootboxesStore: ji(),
                slotsStore: Fo(),
                chipsStore: Q_(),
                boostsStore: Xs(),
                dailyClaimsStore: gf(),
                isDev: !1,
                isPageReady: !1,
                almostReady: !1,
                routeBackground: null,
                isTelegramVersionNotSupported: !1,
                defaultBackground: gC
            }
        },
        computed: {
            isTelegramBot() {
                var t, e;
                return (e = (t = window.Telegram) == null ? void 0 : t.WebApp) == null ? void 0 : e.initData
            },
            energyLeftAmount() {
                return this.globalStore.energyLeftAmount
            },
            balance() {
                return this.globalStore.balance
            },
            webApp() {
                var t, e;
                return console.log(window.Telegram.webApp),
                    console.log((e = (t = window.Telegram.webApp) == null ? void 0 : t.initDataUnsafe) == null ? void 0 : e.start_param),
                    window.Telegram.WebApp
            },
            mode() {
                return this.$appMode || "test"
            },
            backgroundStyle() {
                return this.globalStore.routeBackground ? this.globalStore.routeBackground : {
                    backgroundImage: `url('${this.globalStore.globalBackground ? this.globalStore.globalBackground : gC}')`
                }
            },
            isDailyPopupVisible() {
                return this.dailyClaimsStore.ui.showPopup
            }
        },
        methods: {
            restart() {
                window.location.href = "/"
            },
            defineVh() {
                const t = window.innerHeight * .01;
                document.documentElement.style.setProperty("--vh", `${t}px`)
            },
            makePageReady() {
                if (this.isPageReady = !0,
                    this.globalStore.isTelegramInited) {
                    const t = document.querySelector(".app-loader");
                    t && t.classList.add("app-loader--hidden")
                }
            },
            makePageNotReady() {
                this.isPageReady = !1;
                const t = document.querySelector(".app-loader");
                t && t.classList.remove("app-loader--hidden")
            },
            setViewportHeight() {
                const e = this.webApp.initData ? "var(--tg-viewport-height, 100vh)" : "100dvh";
                document.documentElement.style.setProperty("--dynamic-viewport-height", e)
            },
            getUserLocale() {
                var e, n;
                const t = (n = (e = this.webApp.initDataUnsafe) == null ? void 0 : e.user) == null ? void 0 : n.language_code;
                return !t || this.$i18n.availableLocales.indexOf(t) === -1 ? js.EN : t
            },
            updateTelegram() {
                this.webApp.openLink(this.$t("telegram_update.link")),
                    this.webApp.close()
            },
            async initTelegram() {
                var o, l, a, c, u;
                const t = "prod"
                    , e = this.webApp.initData;
                console.log(this.webApp);
                const n = pk(oEe);
                this.analyticsStore.initializeAnalytics(n);
                const s = LJ(n)
                    , r = W9(n, "europe-west1")
                    , i = Bn(r, "telegram_init_call");
                if (this.globalStore.setApp(n),
                    this.globalStore.setAppFunctions(r),
                    this.globalStore.setCurrentLocale(this.getUserLocale()),
                    !eO() && Dy)
                    this.globalStore.setTelegramInit(!0),
                        this.$router.push(ft.RESTRICTED_ACCESS);
                else if (e) {
                    if (console.log(`Telegram SDK platform: ${this.webApp.platform}; version ${this.webApp.version}`),
                        (o = this.webApp.initDataUnsafe) != null && o.start_param && this.analyticsStore.logEvent("register_by_referral_link", {
                            invited_by: this.webApp.initDataUnsafe.start_param
                        }),
                        this.webApp.isVersionAtLeast && !GSe(this.webApp.platform, this.webApp.isVersionAtLeast)) {
                        this.isTelegramVersionNotSupported = !0,
                            this.globalStore.setTelegramInit(!0);
                        return
                    }
                    if (this.webApp.isOrientationLocked || this.webApp.lockOrientation(),
                        this.webApp.enableClosingConfirmation && this.webApp.enableClosingConfirmation(),
                        this.webApp.CloudStorage)
                        try {
                            this.webApp.CloudStorage.getItem(OM.CURRENT_LOCALE, (h, d) => {
                                !h && d && this.globalStore.setCurrentLocale(d)
                            }
                            )
                        } catch (h) {
                            console.error(h)
                        }
                    try {
                        const h = await i({
                            env: t,
                            init_data: e,
                            locale: this.getUserLocale()
                        })
                            , d = (l = HSe(h.data.token)) == null ? void 0 : l.uid;
                        this.globalStore.setUserId(d),
                            this.analyticsStore.setUserId(d);
                        try {
                            const f = await bK(s, h.data.token);
                            this.globalStore.setUserData(h.data.user),
                                this.boostsStore.setConfig(h.data.boosts);
                            const p = h.data.user.created && h.data.user.created === h.data.user.last_login;
                            p && this.globalStore.setIsNewUser(p),
                                this.globalStore.setUpgradeCards(h.data.upgrade_cards),
                                this.globalStore.setGifts(h.data.gifts),
                                this.globalStore.setTelegramInit(!0),
                                this.fortuneWheelStore.setSponsors((a = h.data.fortune_wheels_settings) == null ? void 0 : a.sponsors),
                                this.fortuneWheelStore.setRewardTypes((c = h.data.fortune_wheels_settings) == null ? void 0 : c.reward_types),
                                this.fortuneWheelStore.setWheels(h.data.fortune_wheels),
                                this.tasksStore.setMediaTasks(h.data.media_quests, h.data.user.media_quests),
                                this.lootboxesStore.setLootboxes(h.data.lootboxes),
                                this.dailyClaimsStore.setDailyClaims(h.data.daily_claims, h.data.user.daily_claims.day, h.data.user.daily_claims.timestamp),
                                this.slotsStore.setSlotsConfig(_o(h.data.slots_config)),
                                this.chipsStore.setChips(_o(h.data.spin_packages)),
                                (u = h.data.user) != null && u.onboarding_step && this.onboardingStore.beginOnboarding(h.data.user.onboarding_step),
                                this.fortuneWheelStore.wheel == null && this.fortuneWheelStore.setWheel(rd.DEFAULT)
                        } catch (f) {
                            console.log(f.code),
                                console.log(f.message)
                        }
                    } catch (h) {
                        this.globalStore.setTelegramInit(!0),
                            console.error(h),
                            this.globalStore.showErrorModal(),
                            No(new Error("Failed to initialize user: " + (typeof h == "object" ? h.message : h)))
                    }
                    this.globalStore.setCollections((await er(async () => {
                        const { default: h } = await import("./collections-EzMVFcNU.js");
                        return {
                            default: h
                        }
                    }
                        , [])).default)
                } else if (Dy)
                    this.globalStore.setTelegramInit(!0),
                        this.globalStore.showErrorModal(),
                        No(new Error("Failed to initialize user"));
                else {
                    const h = (await er(async () => {
                        const { default: p } = await import("./mockedUserData-DIEO0qw0.js");
                        return {
                            default: p
                        }
                    }
                        , [])).default;
                    this.globalStore.setUserData(h),
                        this.globalStore.setUpgradeCards((await er(async () => {
                            const { default: p } = await import("./mockedUpgradeCards-Dq5mHHgw.js");
                            return {
                                default: p
                            }
                        }
                            , [])).default),
                        this.globalStore.setCollections((await er(async () => {
                            const { default: p } = await import("./collections-EzMVFcNU.js");
                            return {
                                default: p
                            }
                        }
                            , [])).default),
                        this.tasksStore.setMediaTasks((await er(async () => {
                            const { default: p } = await import("./mediaTasks-Bu36HQvc.js");
                            return {
                                default: p
                            }
                        }
                            , [])).default, this.globalStore.userData.media_quests),
                        this.globalStore.setGifts((await er(async () => {
                            const { default: p } = await import("./gifts-Bh0vEn7o.js");
                            return {
                                default: p
                            }
                        }
                            , [])).default);
                    const d = (await er(async () => {
                        const { default: p } = await import("./mockedFortuneWheelsSettings-CcMIoydA.js");
                        return {
                            default: p
                        }
                    }
                        , [])).default;
                    this.fortuneWheelStore.setSponsors(d.sponsors),
                        this.fortuneWheelStore.setRewardTypes(d.reward_types),
                        this.fortuneWheelStore.setWheels((await er(async () => {
                            const { default: p } = await import("./mockedFortuneWheels-BTZxJN7Q.js");
                            return {
                                default: p
                            }
                        }
                            , [])).default),
                        this.fortuneWheelStore.setWheel(rd.DEFAULT),
                        ji().setLootboxes((await er(async () => {
                            const { default: p } = await import("./lootboxes-B07-kw8b.js");
                            return {
                                default: p
                            }
                        }
                            , [])).default),
                        this.dailyClaimsStore.setDailyClaims((await er(async () => {
                            const { default: p } = await import("./dailyClaims-DSinAJdH.js");
                            return {
                                default: p
                            }
                        }
                            , [])).default, h.daily_claims.day, h.daily_claims.timestamp),
                        this.slotsStore.setSlotsConfig(_o((await er(async () => {
                            const { default: p } = await import("./slotsConfig-Q_ASQbBq.js");
                            return {
                                default: p
                            }
                        }
                            , [])).default)),
                        this.chipsStore.setChips(_o((await er(async () => {
                            const { default: p } = await import("./spinPackages-cyQrX-8P.js");
                            return {
                                default: p
                            }
                        }
                            , [])).default)),
                        this.boostsStore.setConfig((await er(async () => {
                            const { default: p } = await import("./boosts-B6H7HRyL.js");
                            return {
                                default: p
                            }
                        }
                            , [])).default),
                        this.globalStore.setTelegramInit(!0)
                }
            },
            getActualEnergy(t) {
                const [e, n] = t.split(";")
                    , s = parseInt(e)
                    , r = parseInt(n) / 1e3
                    , o = Date.now() / 1e3 - r
                    , l = s + Math.floor(o * 3);
                return typeof l == "number" && !isNaN(l) ? l : this.globalStore.energyMaxAmount
            },
            fetchEnergy() {
                if (!this.webApp.initData) {
                    this.globalStore.setEnergyLeftAmount(this.globalStore.energyMaxAmount);
                    return
                }
                try {
                    this.webApp.CloudStorage.getItem("energy_left", (t, e) => {
                        t ? console.error(t) : this.globalStore.setEnergyLeftAmount(this.getActualEnergy(e))
                    }
                    )
                } catch (t) {
                    console.error(t),
                        this.globalStore.setEnergyLeftAmount(this.globalStore.energyMaxAmount)
                } finally {
                    this.isReady = !0
                }
            },
            onFortuneWheelClose() {
                this.fortuneWheelStore.show = !1,
                    this.onboardingStore.isOnboardingInProgress && (this.onboardingStore.goToNextStep(),
                        this.fortuneWheelStore.setWheel(rd.DEFAULT))
            },
            onDailyRewardClose() {
                this.dailyClaimsStore.closeDailyRewardPopup()
            },
            showBackButton(t) {
                const e = window.Telegram.WebApp.BackButton;
                e && (e.show(),
                    e.onClick(t))
            },
            hideBackButton(t) {
                const e = window.Telegram.WebApp.BackButton;
                e && (e.hide(),
                    e.offClick(t))
            },
            showDailyRewardIfNeeded() {
                this.dailyClaimsStore.isCurrentDailyClaimAvailable && !this.onboardingStore.isOnboardingInProgress && (this.showBackButton(this.onDailyRewardClose),
                    this.dailyClaimsStore.showDailyRewardPopup())
            },
            showFortuneWheelIfNeeded() {
                var t, e;
                !this.onboardingStore.isOnboardingInProgress && ((e = this.globalStore.getWheelUserData((t = this.fortuneWheelStore.wheel) == null ? void 0 : t.name)) == null ? void 0 : e.spin_balance) > 0 && (this.fortuneWheelStore.show = !0)
            }
        },
        watch: {
            "globalStore.currentLocale": {
                handler: function (t) {
                    this.$i18n.locale = t
                }
            },
            "globalStore.isTelegramInited": {
                handler: async function (t) {
                    if (t && this.isPageReady) {
                        const e = document.querySelector(".app-loader");
                        e && e.classList.add("app-loader--hidden")
                    }
                }
            },
            "fortuneWheelStore.show": {
                handler: function (t) {
                    const e = window.Telegram.WebApp.BackButton;
                    e && !this.onboardingStore.isOnboardingInProgress && (t ? (e.show(),
                        e.onClick(this.onFortuneWheelClose)) : (e.hide(),
                            e.offClick(this.onFortuneWheelClose)))
                }
            },
            $route(t, e) {
                t != null && t.path && _Se.indexOf(t.path) !== -1 ? this.globalStore.setRouteBackground({
                    background: "linear-gradient(180deg, #000000 0%, #1B1235 100%)"
                }) : this.globalStore.setRouteBackground(null)
            }
        },
        created() {
            this.defineVh(),
                this.webApp.setHeaderColor("#000000"),
                this.webApp.setBackgroundColor("#000000"),
                this.webApp.setBottomBarColor("#000000"),
                this.webApp.ready(),
                this.webApp.expand(),
                iEe(),
                window.addEventListener("resize", this.defineVh)
        },
        async mounted() {
            await this.initTelegram(),
                this.setViewportHeight(),
                this.globalStore.setIsDevMode(this.isDev),
                this.showDailyRewardIfNeeded(),
                this.isDailyPopupVisible || this.showFortuneWheelIfNeeded(),
                document.addEventListener("touchstart", function (t) {
                    t.touches.length > 1 && t.preventDefault()
                }, !1),
                this.webApp.initData
        }
    }
    , lEe = t => (Wo("data-v-8a990abd"),
        t = t(),
        Yo(),
        t)
    , cEe = lEe(() => T("div", {
        class: "sl-layout__background"
    }, null, -1))
    , uEe = {
        class: "sl-layout__popup-title"
    }
    , hEe = {
        class: "sl-layout__popup-text"
    }
    , dEe = {
        class: "sl-layout__popup-text"
    };
function fEe(t, e, n, s, r, i) {
    const o = q("router-view")
        , l = q("Modal")
        , a = q("IconWarning")
        , c = q("Popup")
        , u = q("Loader")
        , h = q("Overlay")
        , d = q("DailyClaimsPopup")
        , f = q("FortuneWheelOverlay")
        , p = q("UnlockSlotPopup")
        , m = q("Toast");
    return A(),
        N("div", {
            class: "sl-layout flex flex-col",
            style: Wt(i.backgroundStyle)
        }, [cEe, vn(G(o, {
            onReady: i.makePageReady,
            onNotReady: i.makePageNotReady
        }, null, 8, ["onReady", "onNotReady"]), [[Ru, r.isPageReady]]), G(l), G(c, {
            "is-visible": r.globalStore.errorModal.isVisible,
            class: "sl-layout__popup fixed z-[999]",
            onClose: r.globalStore.closeErrorModal
        }, {
            default: Ce(() => [G(a, {
                class: "mb-1 w-[80px]"
            }), T("div", uEe, $(t.$t("error_modal.title")), 1), T("div", hEe, $(t.$t("error_modal.text")), 1), T("button", {
                class: "sl-layout__popup-button",
                onClick: e[0] || (e[0] = (...g) => i.restart && i.restart(...g))
            }, $(t.$t("error_modal.button")), 1)]),
            _: 1
        }, 8, ["is-visible", "onClose"]), G(c, {
            class: "sl-layout__popup",
            "is-visible": r.isTelegramVersionNotSupported
        }, {
            default: Ce(() => [G(a, {
                class: "mb-1 w-[80px]"
            }), T("div", dEe, $(t.$t("telegram_update.modal_message")), 1), T("button", {
                class: "sl-layout__popup-button",
                onClick: e[1] || (e[1] = (...g) => i.updateTelegram && i.updateTelegram(...g))
            }, $(t.$t("telegram_update.modal_button")), 1)]),
            _: 1
        }, 8, ["is-visible"]), G(h, {
            "is-visible": r.globalStore.ui.showLoadingOverlay,
            class: "z-100 bg-black/60",
            "hide-close-icon": !0
        }, {
            default: Ce(() => [G(u, {
                class: "fixed left-1/2 top-1/2 transform -translate-x-1/2 -translate-y-1/2 !w-16 !h-16"
            })]),
            _: 1
        }, 8, ["is-visible"]), vn(G(d, {
            isVisible: i.isDailyPopupVisible,
            onClose: i.onDailyRewardClose
        }, null, 8, ["isVisible", "onClose"]), [[Ru, i.isDailyPopupVisible]]), r.fortuneWheelStore.show ? (A(),
            fe(f, {
                key: 0,
                onClose: i.onFortuneWheelClose,
                isVisible: r.fortuneWheelStore.show
            }, null, 8, ["onClose", "isVisible"])) : te("", !0), G(p), G(m)], 4)
}
const pEe = _e(aEe, [["render", fEe], ["__scopeId", "data-v-8a990abd"]])
    , nO = jN();
nO.use(({ store: t }) => {
    t.$router = Bg(MS)
}
);
const sO = function () {
    return document.ontouchstart !== null ? "click" : "touchstart"
}
    , fg = "__vue_click_away__"
    , rO = function (t, e, n) {
        iO(t);
        let s = n.context
            , r = e.value
            , i = !1;
        setTimeout(function () {
            i = !0
        }, 0),
            t[fg] = function (o) {
                if ((!t || !t.contains(o.target)) && r && i && typeof r == "function")
                    return r.call(s, o)
            }
            ,
            document.addEventListener(sO(), t[fg], !1)
    }
    , iO = function (t) {
        document.removeEventListener(sO(), t[fg], !1),
            delete t[fg]
    }
    , mEe = function (t, e, n) {
        e.value !== e.oldValue && rO(t, e, n)
    }
    , gEe = {
        install: function (t) {
            t.directive("click-away", _Ee)
        }
    }
    , _Ee = {
        mounted: rO,
        updated: mEe,
        unmounted: iO
    }
    , yEe = {
        beauty_contest: "Beauty contest",
        collections: "Collections"
    }
    , bEe = {
        home: "Home",
        my_girls: "Girls",
        shop: "Shop",
        games: "Games",
        airdrop: "Airdrop",
        upgrade: "Upgrade",
        referral: "Referral"
    }
    , vEe = {
        recruit: "Recruit",
        apprentice: "Apprentice",
        initiate: "Initiate",
        advanced: "Advanced",
        "elite-novice": "Elite Novice",
        "bronze-five": "Bronze V",
        "bronze-four": "Bronze IV",
        "bronze-three": "Bronze III",
        "bronze-two": "Bronze II",
        "bronze-one": "Bronze I",
        "silver-five": "Silver V",
        "silver-four": "Silver IV",
        "silver-three": "Silver III",
        "silver-two": "Silver II",
        "silver-one": "Silver I",
        "gold-five": "Gold V",
        "gold-four": "Gold IV",
        "gold-three": "Gold III",
        "gold-two": "Gold II",
        "gold-one": "Gold I",
        "diamond-five": "Diamond V",
        "diamond-four": "Diamond IV",
        "diamond-three": "Diamond III",
        "diamond-two": "Diamond II",
        "diamond-one": "Diamond I"
    }
    , xEe = {
        common: "Common",
        rare: "Rare",
        epic: "Epic",
        legendary: "Legendary"
    }
    , wEe = {
        confirm: "Confirm",
        cancel: "Cancel",
        close: "Close",
        replace: "Replace"
    }
    , SEe = "h"
    , EEe = "m"
    , TEe = "s"
    , CEe = "Daily goal"
    , IEe = "Avail. thru:"
    , AEe = "Energy"
    , kEe = "by"
    , REe = "Back"
    , MEe = "Confirm"
    , PEe = "Your balance"
    , LEe = "Daily tasks"
    , OEe = "Tasks list"
    , NEe = "Tasks list"
    , DEe = "Daily Reward"
    , BEe = "your streak"
    , FEe = "Day"
    , $Ee = "{n} day | {n} days"
    , UEe = "Lvl"
    , VEe = "Capacity"
    , GEe = "Recovery"
    , HEe = "h"
    , WEe = "Unlock"
    , YEe = {
        level_short: "lvl",
        level: "Level",
        confirm: "Confirm",
        back: "Back",
        energy_limit: "Energy Limit",
        slap_power: "Slap Power",
        maximum_short: "Max",
        required: "Required",
        new: "New",
        slap: "Slap",
        share: "Share",
        soon: "Soon"
    }
    , XEe = {
        airdrop_button: "Airdrop"
    }
    , jEe = {
        rarity: {
            common: "common",
            rare: "rare",
            epic: "epic",
            legendary: "legendary"
        },
        active_girls: {
            label: "Active girls"
        },
        my_girls: {
            equip_button_label: "Equip",
            unequip_button_label: "Unequip"
        },
        hint: {
            change_girl_position: "Hehe, I know what you want... Just turn me around, sugar ",
            no_balance: "Everything's yours now... just let me catch my breath "
        },
        names: {
            new_girl: "New girl",
            alisa: "Alisa",
            alt: "Alt",
            jess: "Jess",
            kara: "Kara",
            kate: "Kate",
            karin: "Karin",
            zendaya: "Zendaya",
            marusia: "Marusia",
            ember: "Ember",
            seo: "Seo",
            pom: "Pom",
            rihanna: "Rihanna",
            makima: "Makima",
            chan: "Chan",
            megan: "Megan",
            miray: "Miray",
            anna: "Anna",
            olivia: "Olivia",
            belle: "Belle",
            marishka: "Marishka",
            demi: "Demi",
            mia: "Mia",
            diana: "Diana",
            avril: "Avril",
            naomi: "Naomi"
        },
        collections: {
            any: "Any",
            default: "Default"
        },
        tabs: {
            girls: "My girls",
            collections: "Collections"
        },
        title: "Girls"
    }
    , zEe = {
        apply: "Apply",
        level: "Level",
        leveling: "Leveling",
        confirmation: "Are you sure you want to use the gift?"
    }
    , qEe = {
        all_slots_busy: "All slots are occupied. Replace the girl?"
    }
    , KEe = {
        header: "Invite friends",
        subheader: "You and your friend will receive bonuses",
        list_title: "List of your friends",
        you_are_referral: "You are already a referral, invited by",
        invite_friend_message: `Hi, I have some news for you!

I found my horny love girl in Slap Universe.
I start collecting SLAP tokens and valuable NFTs.

Get your limited girl NFT too by opening the link below and take part in future AirDrop.

{link}`,
        invite_friend_message_1: `Psst! Want to meet some hot beauties in Slap Stars?
Get your first lootbox as a gift and, if you're lucky, one of them might be yours!
Slap & earn $SLAP with me: {link}
#SlapStars #P2E #GameFi #NFT`,
        invite_friend_message_2: `Hey! Want to meet girls who like to play naughty?
Slap Stars has a gift for you - a lootbox with a chance to get your first beauty!
Join me and let's earn together: {link}
#SlapStars #P2E #GameFi`,
        invite_bonus: "for you and your friend",
        no_friends: "You haven't invited anyone yet",
        buttons: {
            invite_friend: "Invite a friend"
        },
        rewards: {
            invite_friend: "Invite a friend",
            invite_friend_premium: "Invite a friend with Telegram Premium",
            subtitle: "You get",
            lootbox: "Referral Lootbox",
            lootbox_premium: "Referral Premium Lootbox",
            earn: "of invitee's earnings",
            bonuses: "Bonuses",
            lootboxes: "Lootboxes",
            claim: "Claim"
        },
        anonymous: "Anonymous",
        premium: "Premium",
        link_copied_to_clipboard: "Link copied to clipboard!"
    }
    , JEe = {
        name: {
            Card_001: "School of Etiquette",
            Card_002: "Public speaking courses",
            Card_003: "Psychology courses",
            Card_004: "Meditation lessons",
            Card_005: "Language center",
            Card_006: "Business education",
            Card_007: "Martial arts training",
            Card_008: "Private Academy",
            Card_009: "Research Center",
            Card_010: "Human Resources Program",
            Card_011: "Penthouse with upgrades",
            Card_012: "Designer furniture",
            Card_013: "Smart home system",
            Card_014: "Home cinema",
            Card_015: "Wine cellar",
            Card_016: "Private Island",
            Card_017: "Mountain Residence",
            Card_018: "underwater house",
            Card_019: "Ecological residence",
            Card_020: "Art gallery",
            Card_021: "Personal assistant",
            Card_022: "Chef",
            Card_023: "Security service",
            Card_024: "Personal driver",
            Card_025: "Maids",
            Card_026: "Concierge service",
            Card_027: "Event organization",
            Card_028: "Personal doctor",
            Card_029: "PR consultant",
            Card_030: "Legal support",
            Card_031: "Vehicle fleet",
            Card_032: "Yachts",
            Card_033: "Private jets",
            Card_034: "Helicopters",
            Card_035: "Retro cars",
            Card_036: "Golf club",
            Card_037: "Billiard room",
            Card_038: "Private gaming room",
            Card_039: "Private night club",
            Card_040: "Exclusive casino",
            Card_041: "Indoor concert hall",
            Card_042: "Sports park for extreme sports",
            Card_043: "Collection of rare wines",
            Card_044: "Shooting field",
            Card_045: "Private art studio",
            Card_046: "Negotiation office",
            Card_047: "Expanded network of contacts",
            Card_048: "Media influence",
            Card_049: "Investment portfolio",
            Card_050: "Political influence",
            Card_051: "Corporate communication system",
            Card_052: "Laboratory for research",
            Card_053: "High level medical equipment",
            Card_054: "Comprehensive data protection",
            Card_055: "Business consulting service",
            Card_056: "Personal SPA complex",
            Card_057: "Elite gym",
            Card_058: "Medical staff",
            Card_059: "Wellness nutrition program",
            Card_060: "Anti-age procedures",
            Card_061: "Rejuvenation Center",
            Card_062: "Cryochamber",
            Card_063: "Sea water pool",
            Card_064: "Aromatherapy program",
            Card_065: "Home laboratory for health diagnostics",
            Card_066: "Personal stylist",
            Card_067: "Exclusive shoe wardrobe",
            Card_068: "Designer accessories",
            Card_069: "Perfume collection",
            Card_070: "Premium Jewelry",
            Card_071: "Luxury watch collection",
            Card_072: "Costumes from leading designers",
            Card_073: "Collection of ties and cufflinks",
            Card_074: "Branded sunglasses",
            Card_075: "Collection of expensive briefcases and bags",
            Card_076: "Collection of paintings",
            Card_077: "Watch collection",
            Card_078: "Rare Book Library",
            Card_079: "Numismatic collection",
            Card_080: "Antique furniture",
            Card_081: "Rare musical instruments",
            Card_082: "Renaissance sculptures",
            Card_083: "Antique carpets",
            Card_084: "Collection of porcelain and ceramics",
            Card_085: "Archaeological artifacts",
            Card_086: "Modern security system",
            Card_087: "Personal security squad",
            Card_088: "High-tech cyber security",
            Card_089: "Armored Shelter",
            Card_090: "Personal counterintelligence",
            Card_091: "CCTV system",
            Card_092: "Bulletproof windows",
            Card_093: "Personal alarm",
            Card_094: "Personal bodyguard",
            Card_095: "Safe Evacuation Program"
        }
    }
    , ZEe = {
        Section_01: "Status",
        Section_02: "Luxury",
        Section_03: "Staff",
        Section_04: "Transport",
        Section_05: "Entertainment",
        Section_06: "Business",
        Section_07: "Wellness",
        Section_08: "Style",
        Section_09: "Art",
        Section_10: "Security"
    }
    , QEe = {
        travel_bonus: {
            active_travel_bonus_label: "Active Travel bonus",
            temporary_bonus_label: "Temporary bonus",
            permanent_bonus_label: "Permanent bonus"
        },
        travel: {
            cards_left: "Cards Left",
            purchased: "Purchased",
            travels: "Travels",
            label_in_dev: "In development",
            label_soon: "Future tours",
            last_minute_tour: "Last minute tours",
            soon: "Soon"
        },
        cards: {
            locked_info: 'Cooperation with "{cardName}" lvl {lvl}',
            get_it_now: "Get it now"
        },
        bonus: {
            Slap_hr_up: "Slap/Hour",
            Slap_cap_up: "Capacity",
            Slap_tap_up: "Slap"
        },
        tabs: {
            items: "Items",
            travel: "Travel",
            "my-cards": "My cards"
        }
    }
    , eTe = {
        title: "Games",
        label_in_dev: "In development",
        play: "Play",
        wheel_fortune: {
            title: "Wheel of Fortune",
            description: "Try your luck right now!"
        }
    }
    , tTe = {
        my_characteristics: {
            header: "My characteristics",
            slap_power: "Slap power",
            profit: "Slap/Hour",
            capacity: "Capacity"
        },
        active_travel_bonus: {
            header: "Active travel bonus",
            temporary_bonus: "Temporary bonus",
            permanent_bonus: "Permanent bonus"
        },
        my_items: {
            header: "My items",
            no_cards: "You haven't bought any card yet"
        },
        my_countries: {
            header: "My countries",
            permanent_bonus: "Permanent bonus"
        }
    }
    , nTe = {
        england: "England",
        italy: "Italy",
        france: "France",
        "united states": "United States",
        japan: "Japan",
        scotland: "Scotland",
        greece: "Greece"
    }
    , sTe = {
        title: "AirDrop is Coming",
        subtitle: "To participate, complete the following tasks",
        prize_pool: "Prize Pool",
        body: {
            tasks_list: "Tasks list",
            popup_button_text: "Check"
        },
        open: "Open"
    }
    , rTe = {
        join_tg_community: {
            label: "Join TG SlapStar Community",
            button: "Join"
        },
        join_tg_channel: {
            label: "Join TG SlapStar Channel",
            button: "Join"
        },
        ton_wallet: {
            label: "Connect Wallet",
            button: "Connect"
        },
        join_x: {
            label: "Join X",
            button: "Join"
        },
        join_secret_x: {
            label: "Join Secret X",
            button: "Join"
        },
        join_instagram: {
            label: "Join Instagram",
            button: "Join"
        },
        join_youtube: {
            label: "Join YouTube",
            button: "Join"
        },
        join_tiktok: {
            label: "Join TikTok",
            button: "Join"
        },
        share_in_stories: {
            label: "Share in TG Stories",
            button: "Share"
        }
    }
    , iTe = {
        validation: {
            no_girl_in_slots: "You need to assign a girl to a slot!",
            no_gifts: "Looks like you dont have any gifts right now.",
            no_boosts_like_active: "You dont have any boosts similar to the one thats currently active.",
            no_boosts: "Oops, no boosts in your stash.",
            all_girls_in_slots: "All your girls are already assigned to slots!"
        }
    }
    , oTe = {
        header: {
            title: "Your balance:"
        },
        body: {
            title: "Free daily boosters",
            tasks_header: "Tasks list"
        }
    }
    , aTe = {
        press_to_continue: "Press to continue",
        slides: {
            1: {
                title: "Slap and earn coins",
                subtitle: "Upgrade your girl, use boosters and buy gifts to increase SLAP earnings"
            },
            2: {
                title: "Collect NFTs",
                subtitle: "Buy Loot Boxes, get rare Girls, and set them in available slots"
            },
            3: {
                title: "Discover your Girl",
                subtitle: "Dive into an exciting journey with your girl and discover Slap Universe together."
            },
            4: {
                title: "Collect SLAP and NFTs to get an airdrop at token listing",
                subtitle: ""
            }
        },
        steps_bubbles: {
            "cant-hold": "I can't hold too much essence inside, no matter how much I wanna. Ugh, the struggle!",
            done: "Looks like your training is donebut I wouldnt mind a little extra practice.",
            "dont-leave": "Hey, dont leave me stuffed to the max for too long, okay? It takes me about 10 hours to fill up. ",
            "go-earn": "Time to grab your daily bonus, go for it!",
            "go-shop": "Looks like weve racked up some Slap Essence! Lets hit the shop and snag a Supply Box to power up!",
            hi: "Hey there! Lets get this show on the road! ",
            "main-resource": "This stuffs the big deal around here  currency, power source, you name it!",
            nice: "Oooh, that feels so good! ",
            "per-hour": "I build up some Slap Essence every hour, and you can grab it with a good ol slap!",
            "second-girl": "Quick, bring my bestie in! She can help us rake in even more goodies! ",
            "second-girl-chosen": "",
            "second-girl-equipped": "",
            "start-lesson": "",
            "stash-slap": "Oh, and I can totally stash up some Slap Essence for ya.",
            "use-boost": "Youve got cocktails too! Those bad boys can give me a temporary supercharge. ",
            "use-boost1": "Dont forget about the cocktails! Theyre my secret sauce for a quick boost. ",
            "use-gift": "Guess what? Youve got some gifts! Use them to level me up! ",
            "use-gift1": "Regular gifts are cute and give a little XP, but rare ones? Oh, theyre the real deal!",
            "use-gift2": "Boom! Now you know how to use gifts. Hit that Back button and lets keep going!",
            "go-to-wheel": "Oh! This is our special Fortune Wheel! You can win unique prizes here!"
        }
    }
    , lTe = {
        body: {
            referral_title: "Referral",
            daily_tasks_title: "Daily tasks",
            tasks_list_title: "Tasks list",
            daily_reward: "Daily reward"
        },
        reward_popup: {
            title: "Daily tasks",
            subtitle: "your streak",
            button: "Claim",
            join: "join",
            check: "Check",
            success: "Daily reward claimed"
        },
        reward_type: {
            coins: "Coins",
            profit_boost: "Recovery Boost",
            energy_boost: "Instant Recovery",
            spin: "Spin"
        }
    }
    , cTe = {
        title: "Level Up",
        subtitle: "Congratulations, you have reached"
    }
    , uTe = {
        title: "Lootbox",
        prize: "You get",
        prize_profit_boost: "Recovery Boost",
        prize_energy_boost: "Instant Recovery",
        prize_exp: "+{exp} XP",
        claim_all: "Claim all",
        share: "Share",
        share_and_get: "Share and get",
        exp: "XP",
        slapcoins: "Slapcoins",
        hint: "Swipe to open"
    }
    , hTe = {
        common: ` Just got an awesome reward in SLAP Stars!
 Join the game: {link}
#SLAPStars #GameFi #P2E`,
        girl_regular: ` Look who I just met in SLAP Stars!
 {name} has joined my collection! This {rarity} beauty is helping me earn $SLAP tokens.
 Join the adventure: {link}
#SLAPGStars #P2E #GameFi`,
        girl_premium: ` LEGENDARY DROP in SLAP Stars!
 {name} - this month's rarest beauty is now mine!
 Join the game while you can: {link}
#SLAPStars #NFT #Cryptocurrency`
    }
    , dTe = {
        modal_message: "Your Telegram version is outdated",
        modal_button: "Update now!",
        link: "https://telegram.org/dl"
    }
    , fTe = {
        modal_message: "Please, use mobile Telegram"
    }
    , pTe = {
        slap_power: "Slap power",
        slap_per_hour: "Slap/Hour",
        capacity: "Capacity"
    }
    , mTe = {
        tabs: {
            lootboxes: "Lootboxes",
            my_lootboxes: "My Lootboxes",
            collections: "Collections"
        },
        open: "Open",
        lootboxes: "Lootboxes",
        noLootboxes: "You don't have any lootboxes",
        vipboxes: "VIP Boxes",
        chips: "Chips",
        slots: "Slots",
        lootbox_info_popup: {
            you_can_get: "You can get",
            drop_chance: "Drop chance",
            item_details: "Inside this box you can find {itemContent} and more",
            buy: "Buy now",
            chance: {
                low: "Low",
                medium: "Medium",
                high: "High",
                very_high: "Very high",
                guaranteed: "Guaranteed"
            },
            labels: {
                coins: "Slaps",
                gift: "XP",
                profit_boost: "Slap/h",
                energy_boost: "Energy"
            },
            guaranteed_girl_text_part1: "This loot box ",
            guaranteed_girl_text_part2: "guarantees you a girl"
        },
        type: {
            coins: "Coins",
            girl: "Girl",
            boost: "Boost",
            gift: "Gift",
            profit_boost: "Recovery Boost",
            energy_boost: "Instant Recovery"
        }
    }
    , gTe = {
        header: "Choose boosts",
        apply_button: "Apply",
        profit_boost: "Recovery Boost",
        energy_boost: "Instant Recovery",
        profit_boost_description: "Increases energy recovery per hour.",
        energy_boost_description: "Instantly restores a portion of energy.",
        energy_boost_replica: {
            common: ["Mmmm... a little better...", "I feel a surge of energy..."],
            rare: ["Oh... this... is very nice...", "Yes... exactly what I need..."],
            epic: ["Ah!.. So much energy!..", "I... I feel such a surge..."],
            legendary: ["I... I feel it... it fills me... mhaaaa", "Ah!.. I... I'm... I'm overflowing... with energy..."]
        },
        disabled_reason: {
            no_boost_amount: "No boost in stock",
            another_boost_active: "Another boost is active",
            max_duration_reached: "Maximum boost duration reached"
        }
    }
    , _Te = {
        title: "Wheel of Fortune",
        jackpot: "Jackpot",
        guaranteed_jackpot: "Guaranteed Jackpot!",
        your_luck: "Your Luck",
        spin: "Spin",
        how_does_this_work: "How does this work?",
        reward_types: {
            girl: "Girl",
            gift: "Gift"
        },
        shop: {
            title: "Buy chips",
            alternative_title: "Out of chips",
            helper_text: "Get new chips and try your luck again"
        },
        present: {
            you_get: "You get",
            share_and_get: "Share and get",
            claim: "Claim",
            share: "Share"
        },
        rules: {
            title: "Rules of the game",
            body1_part1: "You receive",
            body1_part2: "one free chip every day.",
            body1_part3: "Additional chips can be purchased",
            body1_part4: "in the store.",
            body2_part1: "Fill the",
            body2_part2: "luck bar",
            body2_part3: `to receive a guaranteed jackpot.
The minimum withdrawal amount is 10 USDT.`,
            got_it: "Got it"
        },
        share_text: {
            crypto_jackpot: ` JACKPOT IN SLAP STARS!
Just won {amount} USDT in the Fortune Wheel!
Try your luck: {link}
#SLAPStars #Crypto #GameFi`,
            lootbox_jackpot: ` Just got an awesome reward in SLAP Stars!
Scored {amount} {reward_type}!
Join the game: {link}
#SLAPStars #GameFi #P2E`,
            slap_jackpot: ` Just got an awesome reward in SLAP Stars!
Scored {amount} {reward_type}!
Join the game: {link}
#SLAPStars #GameFi #P2E`,
            slap_large: ` Just got an awesome reward in SLAP Stars!
Scored {amount} {reward_type}!
Join the game: {link}
#SLAPStars #GameFi #P2E`,
            slap_medium: ` Just got an awesome reward in SLAP Stars!
Scored {amount} {reward_type}!
Join the game: {link}
#SLAPStars #GameFi #P2E`,
            slap_small: ` Just got an awesome reward in SLAP Stars!
Scored {amount} {reward_type}!
Join the game: {link}
#SLAPStars #GameFi #P2E`,
            lootbox_premium: ` Just got an awesome reward in SLAP Stars!
Scored {amount} {reward_type}!
Join the game: {link}
#SLAPStars #GameFi #P2E`,
            lootbox_standard: ` Just got an awesome reward in SLAP Stars!
Scored {amount} {reward_type}!
Join the game: {link}
#SLAPStars #GameFi #P2E`,
            profit_boost_legendary: ` Just got an awesome reward in SLAP Stars!
Scored {amount} {reward_type}!
Join the game: {link}
#SLAPStars #GameFi #P2E`,
            profit_boost_epic: ` Just got an awesome reward in SLAP Stars!
Scored {amount} {reward_type}!
Join the game: {link}
#SLAPStars #GameFi #P2E`,
            profit_boost_rare: ` Just got an awesome reward in SLAP Stars!
Scored {amount} {reward_type}!
Join the game: {link}
#SLAPStars #GameFi #P2E`,
            profit_boost_common: ` Just got an awesome reward in SLAP Stars!
Scored {amount} {reward_type}!
Join the game: {link}
#SLAPStars #GameFi #P2E`,
            energy_boost_legendary: ` Just got an awesome reward in SLAP Stars!
Scored {amount} {reward_type}!
Join the game: {link}
#SLAPStars #GameFi #P2E`,
            energy_boost_epic: ` Just got an awesome reward in SLAP Stars!
Scored {amount} {reward_type}!
Join the game: {link}
#SLAPStars #GameFi #P2E`,
            energy_boost_rare: ` Just got an awesome reward in SLAP Stars!
Scored {amount} {reward_type}!
Join the game: {link}
#SLAPStars #GameFi #P2E`,
            energy_boost_common: ` Just got an awesome reward in SLAP Stars!
Scored {amount} {reward_type}!
Join the game: {link}
#SLAPStars #GameFi #P2E`,
            spin_regular: ` Just got an awesome reward in SLAP Stars!
Scored {amount} {reward_type}!
Join the game: {link}
#SLAPStars #GameFi #P2E`,
            spin_premium: ` Just got an awesome reward in SLAP Stars!
Scored {amount} {reward_type}!
Join the game: {link}
#SLAPStars #GameFi #P2E`,
            girl_regular: ` Look who I just met in SLAP Stars!
 {name} has joined my collection! This {rarity} beauty is helping me earn $SLAP tokens.
 Join the adventure: {link}
#SLAPGStars #P2E #GameFi`,
            girl_premium: ` LEGENDARY DROP in SLAP Stars!
 {name} - this month's rarest beauty is now mine!
 Join the game while you can: {link}
#SLAPStars #NFT #Cryptocurrency`,
            girl_jackpot: ` Just got an awesome reward in SLAP Stars!
 Join the game while you can: {link}
#SLAPStars #NFT #Cryptocurrency`
        },
        reward_type: {
            crypto_jackpot: "Crypto",
            lootbox_jackpot: "Lootbox",
            slap_jackpot: "Slap",
            slap_large: "Slap",
            slap_medium: "Slap",
            slap_small: "Slap",
            lootbox_premium: "Premium Lootbox",
            lootbox_standard: "Standard Lootbox",
            profit_boost_legendary: "Legendary Recovery Boost",
            profit_boost_epic: "Epic Recovery Boost",
            profit_boost_rare: "Rare Recovery Boost",
            profit_boost_common: "Common Recovery Boost",
            energy_boost_legendary: "Legendary Instant Recovery",
            energy_boost_epic: "Epic Instant Recovery",
            energy_boost_rare: "Rare Instant Recovery",
            energy_boost_common: "Common Instant Recovery",
            slap_pitty_jackpot: "slap_pitty_jackpot",
            spin_regular: "Spin",
            spin_premium: "Spin",
            girl_regular: "Girl",
            girl_premium: "Girl",
            starter_rare: "Base Starter Pack",
            starter_epic: "Advanced Starter Pack",
            starter_legendary: "Premium Starter Pack"
        }
    }
    , yTe = {
        title: "Something went wrong",
        text: "Please restart the app.",
        button: "Restart"
    }
    , bTe = {
        slot: "Slot",
        unlock_new_slot: "Unlock a New Slot!",
        help_text_line1_part1: "Heres your chance to",
        help_text_line1_part2: "boost your income!",
        help_text_line2: "Unlock an additional slot",
        button: "Buy now"
    }
    , vTe = {
        unlock_new_slot: "Unlock a New Slot!",
        help_text: "Boost your income now!"
    }
    , xTe = {
        upgrade_card: "You've got a new upgrade",
        unlock_slot: "You've got a new slot",
        consume_boost: "Boost is consumed",
        added_to_my_lootboxes: "Added to My Lootboxes",
        copy_link_to_clipboard: "Link copied to clipboard successfully",
        complete_media_quest: "Task completed! Youve received your reward!",
        share_reward: "You've received your reward!",
        referral_rewards_claimed: "Referral rewards claimed!"
    }
    , wTe = {
        tabs: {
            today: "Today",
            referral: "Referral",
            total: "Total"
        },
        total: {
            league: "league"
        },
        anonymous: "Anonymous"
    }
    , STe = {
        header_links: yEe,
        footer_links: bEe,
        leagues: vEe,
        rare: xEe,
        modal: wEe,
        hours_short: SEe,
        minutes_short: EEe,
        seconds_short: TEe,
        daily_goal: CEe,
        cooldown_available: IEe,
        energy: AEe,
        by: kEe,
        back: REe,
        confirm: MEe,
        your_balance: PEe,
        daily_tasks: LEe,
        tasks_list: OEe,
        daily_reward: NEe,
        daily_claim: DEe,
        your_streak: BEe,
        day: FEe,
        days: $Ee,
        level: UEe,
        capacity: VEe,
        recovery: GEe,
        hour_short: HEe,
        unlock: WEe,
        common: YEe,
        header: XEe,
        girls: jEe,
        gifts: zEe,
        validation: qEe,
        referral: KEe,
        upgradeCards: JEe,
        upgradeSections: ZEe,
        upgrade: QEe,
        games: eTe,
        my_cards: tTe,
        countries: nTe,
        airdrop: sTe,
        tasks: rTe,
        main: iTe,
        boost: oTe,
        onboarding: aTe,
        daily: lTe,
        level_up_popup: cTe,
        lootbox_popup: uTe,
        share: hTe,
        telegram_update: dTe,
        telegram_not_mobile: fTe,
        characteristics: pTe,
        shop: mTe,
        boosts: gTe,
        fortune_wheel: _Te,
        error_modal: yTe,
        unlock_slot_popup: bTe,
        unlock_slot_banner: vTe,
        toast_messages: xTe,
        leaderboard: wTe
    }
    , ETe = {
        daily_quests: " ",
        collections: "",
        special_offers: " "
    }
    , TTe = {
        room: "",
        shop: "",
        rating: "",
        earn: "",
        airdrop: ""
    }
    , CTe = {
        diamond: " "
    }
    , ITe = {
        uncommon: "",
        rare: "",
        epic: "",
        legendary: ""
    }
    , ATe = " "
    , kTe = " "
    , RTe = " "
    , MTe = ""
    , PTe = ""
    , LTe = " "
    , OTe = ""
    , NTe = ""
    , DTe = {
        header_links: ETe,
        footer_links: TTe,
        league: CTe,
        rare: ITe,
        daily_goal: ATe,
        slap_day: kTe,
        slap_hour: RTe,
        energy: MTe,
        boost: PTe,
        by: LTe,
        back: OTe,
        confirm: NTe
    }
    , BTe = {
        beauty_contest: " ",
        collections: ""
    }
    , FTe = {
        home: "",
        my_girls: "",
        shop: "",
        games: "",
        airdrop: "",
        upgrade: "",
        referral: ""
    }
    , $Te = {
        recruit: "",
        apprentice: "",
        initiate: "",
        advanced: "",
        "elite-novice": " ",
        "bronze-five": " V",
        "bronze-four": " IV",
        "bronze-three": " III",
        "bronze-two": " II",
        "bronze-one": " I",
        "silver-five": " V",
        "silver-four": " IV",
        "silver-three": " III",
        "silver-two": " II",
        "silver-one": " I",
        "gold-five": " V",
        "gold-four": " IV",
        "gold-three": " III",
        "gold-two": " II",
        "gold-one": " I",
        "diamond-five": " V",
        "diamond-four": " IV",
        "diamond-three": " III",
        "diamond-two": " II",
        "diamond-one": " I"
    }
    , UTe = {
        common: "",
        rare: "",
        epic: "",
        legendary: ""
    }
    , VTe = {
        confirm: "",
        cancel: "",
        close: "",
        replace: ""
    }
    , GTe = ""
    , HTe = ""
    , WTe = ""
    , YTe = " "
    , XTe = " :"
    , jTe = ""
    , zTe = ""
    , qTe = ""
    , KTe = ""
    , JTe = " "
    , ZTe = " "
    , QTe = " "
    , eCe = " "
    , tCe = " "
    , nCe = ""
    , sCe = "{n}  | {n}  | {n} "
    , rCe = ""
    , iCe = ""
    , oCe = ""
    , aCe = ""
    , lCe = "."
    , cCe = {
        level_short: "",
        level: "",
        confirm: "",
        back: "",
        energy_limit: " ",
        slap_power: " ",
        maximum_short: "",
        required: "",
        new: "New",
        slap: "Slap",
        share: "",
        soon: ""
    }
    , uCe = {
        airdrop_button: ""
    }
    , hCe = {
        rarity: {
            common: "",
            rare: "",
            epic: "",
            legendary: ""
        },
        active_girls: {
            label: " "
        },
        my_girls: {
            equip_button_label: "",
            unequip_button_label: ""
        },
        hint: {
            change_girl_position: "-,  ,   ...   ,  ",
            no_balance: "  ...      "
        },
        names: {
            new_girl: " ",
            alisa: "",
            alt: "",
            jess: "",
            kara: "",
            kate: "",
            karin: "",
            zendaya: "",
            marusia: "",
            ember: "",
            seo: "",
            pom: "",
            rihanna: "",
            makima: "",
            chan: "",
            megan: "",
            miray: "",
            anna: "",
            olivia: "",
            belle: "",
            marishka: "",
            demi: "",
            mia: "",
            diana: "",
            avril: "",
            naomi: ""
        },
        collections: {
            any: "",
            default: ""
        },
        tabs: {
            girls: " ",
            collections: ""
        },
        title: ""
    }
    , dCe = {
        apply: "",
        level: "",
        leveling: "",
        confirmation: " ,    ?"
    }
    , fCe = {
        all_slots_busy: "  .  ?"
    }
    , pCe = {
        header: " ",
        subheader: "     ",
        list_title: "  ",
        you_are_referral: "  , ",
        invite_friend: " ",
        invite_friend_premium: "   Telegram Premium",
        invite_friend_message: `,      !

      Slap Universe.
   SLAP    NFT.

   NFT-,    ,     AirDrop.

{link}`,
        invite_friend_message_1: `!       Slap Stars?
      ,  ,     ! 
   $SLAP  : {link}
#SlapStars #P2E #GameFi #NFT`,
        invite_friend_message_2: `!    ,   ?
 Slap Stars    -       !
    : {link}
#SlapStars #P2E #GameFi
`,
        invite_bonus: "    ",
        no_friends: "    ",
        buttons: {
            invite_friend: " "
        },
        rewards: {
            invite_friend: " ",
            invite_friend_premium: "   Telegram Premium",
            subtitle: " ",
            lootbox: " ",
            lootbox_premium: "   Telegram Premium",
            earn: "  ",
            bonuses: "",
            lootboxes: "",
            claim: ""
        },
        anonymous: "",
        premium: "",
        link_copied_to_clipboard: "    !"
    }
    , mCe = {
        name: {
            Card_001: " ",
            Card_002: "  ",
            Card_003: " ",
            Card_004: " ",
            Card_005: " ",
            Card_006: "-",
            Card_007: "   ",
            Card_008: " ",
            Card_009: " ",
            Card_010: "   ",
            Card_011: "  ",
            Card_012: " ",
            Card_013: "  ",
            Card_014: " ",
            Card_015: " ",
            Card_016: " ",
            Card_017: " ",
            Card_018: " ",
            Card_019: " ",
            Card_020: "  ",
            Card_021: " ",
            Card_022: "-",
            Card_023: " ",
            Card_024: " ",
            Card_025: "",
            Card_026: "-",
            Card_027: " ",
            Card_028: " ",
            Card_029: "PR-",
            Card_030: " ",
            Card_031: "",
            Card_032: "",
            Card_033: " ",
            Card_034: "",
            Card_035: "-",
            Card_036: "-",
            Card_037: " ",
            Card_038: "  ",
            Card_039: "  ",
            Card_040: " ",
            Card_041: "  ",
            Card_042: "   ",
            Card_043: "  ",
            Card_044: "  ",
            Card_045: "  ",
            Card_046: "  ",
            Card_047: "  ",
            Card_048: "-",
            Card_049: " ",
            Card_050: " ",
            Card_051: "  ",
            Card_052: "  ",
            Card_053: " ",
            Card_054: "  ",
            Card_055: "   ",
            Card_056: " -",
            Card_057: "  ",
            Card_058: " ",
            Card_059: " wellness-",
            Card_060: "Anti-age ",
            Card_061: " ",
            Card_062: "",
            Card_063: "   ",
            Card_064: " ",
            Card_065: " ",
            Card_066: " ",
            Card_067: "  ",
            Card_068: " ",
            Card_069: " ",
            Card_070: "  -",
            Card_071: "  ",
            Card_072: "   ",
            Card_073: "   ",
            Card_074: "  ",
            Card_075: "    ",
            Card_076: " ",
            Card_077: " ",
            Card_078: "  ",
            Card_079: " ",
            Card_080: " ",
            Card_081: "  ",
            Card_082: "  ",
            Card_083: " ",
            Card_084: " ",
            Card_085: " ",
            Card_086: "  ",
            Card_087: "  ",
            Card_088: " ",
            Card_089: " ",
            Card_090: " ",
            Card_091: " ",
            Card_092: " ",
            Card_093: "  ",
            Card_094: " ",
            Card_095: "   "
        }
    }
    , gCe = {
        Section_01: "",
        Section_02: "",
        Section_03: "",
        Section_04: "",
        Section_05: "",
        Section_06: "",
        Section_07: "",
        Section_08: "",
        Section_09: "",
        Section_10: ""
    }
    , _Ce = {
        travel_bonus: {
            active_travel_bonus_label: "  ",
            temporary_bonus_label: " ",
            permanent_bonus_label: " "
        },
        travel: {
            cards_left: " ",
            purchased: "",
            travels: "",
            label_in_dev: " ",
            label_soon: " ",
            last_minute_tour: " ",
            soon: ""
        },
        cards: {
            locked_info: ' "{cardName}"  . {lvl}',
            get_it_now: " "
        },
        bonus: {
            Slap_hr_up: "Slap/",
            Slap_cap_up: "",
            Slap_tap_up: ""
        },
        tabs: {
            items: "",
            travel: "",
            "my-cards": ""
        }
    }
    , yCe = {
        title: "",
        label_in_dev: " ",
        play: "",
        wheel_fortune: {
            title: " ",
            description: "  !"
        }
    }
    , bCe = {
        my_characteristics: {
            header: " ",
            slap_power: " ",
            profit: "Slap/",
            capacity: ""
        },
        active_travel_bonus: {
            header: "  ",
            temporary_bonus: " ",
            permanent_bonus: " "
        },
        my_items: {
            header: " ",
            no_cards: "      "
        },
        my_countries: {
            header: " ",
            permanent_bonus: " "
        }
    }
    , vCe = {
        england: "",
        italy: "",
        france: "",
        "united states": "",
        japan: "",
        scotland: "",
        greece: ""
    }
    , xCe = {
        title: " ",
        subtitle: " ,   ",
        prize_pool: " ",
        body: {
            tasks_list: " ",
            popup_button_text: ""
        },
        open: ""
    }
    , wCe = {
        join_tg_community: {
            label: "   SlapStar",
            button: ""
        },
        join_tg_channel: {
            label: "   SlapStar",
            button: ""
        },
        ton_wallet: {
            label: " ",
            button: ""
        },
        join_x: {
            label: "  X",
            button: ""
        },
        join_secret_x: {
            label: "   X",
            button: ""
        },
        join_instagram: {
            label: "  Instagram",
            button: ""
        },
        join_youtube: {
            label: "  YouTube",
            button: ""
        },
        join_tiktok: {
            label: "  TikTok",
            button: ""
        },
        share_in_stories: {
            label: "  TG Stories",
            button: ""
        }
    }
    , SCe = {
        validation: {
            no_girl_in_slots: "    !",
            no_gifts: ",     .",
            no_boosts_like_active: "   ,   .",
            no_boosts: ",     .",
            all_girls_in_slots: "      !"
        }
    }
    , ECe = {
        header: {
            title: " :"
        },
        body: {
            title: "  ",
            tasks_header: " "
        }
    }
    , TCe = {
        press_to_continue: ",  ",
        slides: {
            1: {
                title: "   ",
                subtitle: "  ,     ,    SLAP"
            },
            2: {
                title: " NFT",
                subtitle: " ,         "
            },
            3: {
                title: "  ",
                subtitle: "           Slap"
            },
            4: {
                title: " SLAP  NFT,      ",
                subtitle: ""
            }
        },
        steps_bubbles: {
            "cant-hold": "       ,     . ,   !",
            done: ",            .",
            "dont-leave": ",       , ?    10 ,  . ",
            "go-earn": "    , !",
            "go-shop": ",     !          !",
            hi: "!    ! ",
            "main-resource": "      ,  ,   !",
            nice: ",   ! ",
            "per-hour": "     ,       !",
            "second-girl": ",   !       ! ",
            "second-girl-chosen": "",
            "second-girl-equipped": "",
            "start-lesson": "",
            "stash-slap": ",         .",
            "use-boost": "   !       . ",
            "use-boost1": "   !       . ",
            "use-gift": " ?    !  ,   ! ",
            "use-gift1": "      ,  ? ,    !",
            "use-gift2": "!   ,   .   ,   !",
            "go-to-wheel": "!     !     !"
        }
    }
    , CCe = {
        body: {
            referral_title: "",
            daily_tasks_title: " ",
            tasks_list_title: " ",
            daily_reward: " "
        },
        reward_popup: {
            title: " ",
            subtitle: " ",
            button: "",
            check: "",
            success: "   "
        },
        reward_type: {
            coins: "",
            profit_boost: " ",
            energy_boost: " ",
            spin: ""
        }
    }
    , ICe = {
        title: " ",
        subtitle: ",  "
    }
    , ACe = {
        title: "",
        prize: " ",
        prize_profit_boost: " ",
        prize_energy_boost: " ",
        prize_exp: "+{exp} XP",
        claim_all: " ",
        share: "",
        share_and_get: "  ",
        exp: "XP",
        slapcoins: "Slapcoins",
        hint: " ,  "
    }
    , kCe = {
        common: `       SLAP Stars!
  : {link}
#SLAPStars #GameFi #P2E`,
        girl_regular: ` ,     SLAP Stars! 
{name}    !  {rarity}      $SLAP.
  : {link}
#SLAPStars #P2E #GameFi`,
        girl_premium: `    SLAP Stars!
{name} -       !
   : {link}
#SLAPStars #NFT #Cryptocurrency`
    }
    , RCe = {
        modal_message: "  Telegram ",
        modal_button: " !",
        link: "https://telegram.org/dl"
    }
    , MCe = {
        modal_message: "   Telegram"
    }
    , PCe = {
        slap_power: " ",
        slap_per_hour: "Slap/",
        capacity: ""
    }
    , LCe = {
        tabs: {
            lootboxes: "",
            my_lootboxes: " ",
            collections: ""
        },
        open: "",
        lootboxes: "",
        noLootboxes: "    ",
        vipboxes: "VIP ",
        chips: "",
        slots: "",
        lootbox_info_popup: {
            you_can_get: "  ",
            drop_chance: " ",
            item_details: "      {itemContent}   ",
            buy: " ",
            chance: {
                low: "",
                medium: "",
                high: "",
                very_high: " ",
                guaranteed: ""
            },
            labels: {
                coins: "",
                gift: "XP",
                profit_boost: "Slap/",
                energy_boost: ""
            },
            guaranteed_girl_text_part1: "  ",
            guaranteed_girl_text_part2: "  "
        },
        type: {
            coins: "",
            girl: "",
            boost: "",
            gift: "",
            profit_boost: " ",
            energy_boost: " "
        }
    }
    , OCe = {
        header: " ",
        apply_button: "",
        profit_boost: " ",
        energy_boost: " ",
        profit_boost_description: "    .",
        energy_boost_description: "   .",
        energy_boost_replica: {
            common: ["...  ...", "  ..."],
            rare: ["... ...  ...", "...  ,  ..."],
            epic: ["!..  !..", "...    ..."],
            legendary: ["..... , ...  ... ", "!.. ...  ... ..."]
        },
        disabled_reason: {
            no_boost_amount: "   ",
            another_boost_active: "  ",
            max_duration_reached: "   "
        }
    }
    , NCe = {
        title: " ",
        jackpot: "",
        guaranteed_jackpot: " !",
        your_luck: " ",
        spin: "",
        how_does_this_work: "  ?",
        reward_types: {
            girl: "",
            gift: ""
        },
        shop: {
            title: " ",
            alternative_title: " ",
            helper_text: "      "
        },
        present: {
            you_get: " ",
            share_and_get: "  ",
            claim: "",
            share: ""
        },
        rules: {
            title: " ",
            body1_part1: " ",
            body1_part2: "    .",
            body1_part3: "   ",
            body1_part4: " .",
            body2_part1: "",
            body2_part2: " ",
            body2_part3: `   .
    10 USDT.`,
            got_it: ""
        },
        share_text: {
            crypto_jackpot: `   SLAP STARS!
   {amount} USDT   !
  : {link}
#SLAPStars #Crypto #GameFi`,
            lootbox_jackpot: `       SLAP Stars!
 {amount} {reward_type}!
  : {link}
#SLAPStars #GameFi #P2E`,
            slap_jackpot: `       SLAP Stars!
 {amount} {reward_type}!
  : {link}
#SLAPStars #GameFi #P2E`,
            slap_large: `       SLAP Stars!
 {amount} {reward_type}!
  : {link}
#SLAPStars #GameFi #P2E`,
            slap_medium: `       SLAP Stars!
 {amount} {reward_type}!
  : {link}
#SLAPStars #GameFi #P2E`,
            slap_small: `       SLAP Stars!
 {amount} {reward_type}!
  : {link}
#SLAPStars #GameFi #P2E`,
            lootbox_premium: `       SLAP Stars!
 {amount} {reward_type}!
  : {link}
#SLAPStars #GameFi #P2E`,
            lootbox_standard: `       SLAP Stars!
 {amount} {reward_type}!
  : {link}
#SLAPStars #GameFi #P2E`,
            profit_boost_legendary: `       SLAP Stars!
 {amount} {reward_type}!
  : {link}
#SLAPStars #GameFi #P2E`,
            profit_boost_epic: `       SLAP Stars!
 {amount} {reward_type}!
  : {link}
#SLAPStars #GameFi #P2E`,
            profit_boost_rare: `       SLAP Stars!
 {amount} {reward_type}!
  : {link}
#SLAPStars #GameFi #P2E`,
            profit_boost_common: `       SLAP Stars!
 {amount} {reward_type}!
  : {link}
#SLAPStars #GameFi #P2E`,
            energy_boost_legendary: `       SLAP Stars!
 {amount} {reward_type}!
  : {link}
#SLAPStars #GameFi #P2E`,
            energy_boost_epic: `       SLAP Stars!
 {amount} {reward_type}!
  : {link}
#SLAPStars #GameFi #P2E`,
            energy_boost_rare: `       SLAP Stars!
 {amount} {reward_type}!
  : {link}
#SLAPStars #GameFi #P2E`,
            energy_boost_common: `       SLAP Stars!
 {amount} {reward_type}!
  : {link}
#SLAPStars #GameFi #P2E`,
            slap_pitty_jackpot: `       SLAP Stars!
 {amount} {reward_type}!
  : {link}
#SLAPStars #GameFi #P2E`,
            spin_regular: `       SLAP Stars!
 {amount} {reward_type}!
  : {link}
#SLAPStars #GameFi #P2E`,
            spin_premium: `       SLAP Stars!
 {amount} {reward_type}!
  : {link}
#SLAPStars #GameFi #P2E`,
            girl_regular: ` ,     SLAP Stars! 
{name}    !  {rarity}      $SLAP.
  : {link}
#SLAPStars #P2E #GameFi`,
            girl_premium: `    SLAP Stars!
{name} -       !
   : {link}
#SLAPStars #NFT #Cryptocurrency`,
            girl_jackpot: `       SLAP Stars!
  : {link}
#SLAPStars #NFT #Cryptocurrency`
        },
        reward_type: {
            crypto_jackpot: "",
            lootbox_jackpot: "",
            slap_jackpot: "",
            slap_large: "",
            slap_medium: "",
            slap_small: "",
            lootbox_premium: " ",
            lootbox_standard: " ",
            energy_boost_legendary: "",
            energy_boost_epic: "",
            energy_boost_rare: "",
            energy_boost_common: "",
            profit_boost_legendary: "",
            profit_boost_epic: "",
            profit_boost_rare: "",
            profit_boost_common: "",
            slap_pitty_jackpot: "  ",
            spin_regular: "",
            spin_premium: " ",
            girl_regular: "",
            girl_premium: "",
            starter_rare: "  ",
            starter_epic: "  ",
            starter_legendary: "  "
        }
    }
    , DCe = {
        title: "-   ",
        text: ",  .",
        button: ""
    }
    , BCe = {
        slot: "",
        unlock_new_slot: "  !",
        help_text_line1_part1: "  ",
        help_text_line1_part2: " !",
        help_text_line2: "  ",
        button: " "
    }
    , FCe = {
        unlock_new_slot: "  !",
        help_text: "    !"
    }
    , $Ce = {
        upgrade_card: "   ",
        unlock_slot: "   ",
        consume_boost: " ",
        added_to_my_lootboxes: "   ",
        copy_link_to_clipboard: "     ",
        complete_media_quest: " !    !",
        share_reward: "   !",
        referral_rewards_claimed: "   !"
    }
    , UCe = {
        tabs: {
            today: "",
            referral: "",
            total: ""
        },
        total: {
            league: ""
        },
        anonymous: ""
    }
    , VCe = {
        header_links: BTe,
        footer_links: FTe,
        leagues: $Te,
        rare: UTe,
        modal: VTe,
        hours_short: GTe,
        minutes_short: HTe,
        seconds_short: WTe,
        daily_goal: YTe,
        cooldown_available: XTe,
        energy: jTe,
        by: zTe,
        back: qTe,
        confirm: KTe,
        your_balance: JTe,
        daily_tasks: ZTe,
        tasks_list: QTe,
        daily_reward: eCe,
        your_streak: tCe,
        day: nCe,
        days: sCe,
        level: rCe,
        capacity: iCe,
        recovery: oCe,
        hour_short: aCe,
        unlock: lCe,
        common: cCe,
        header: uCe,
        girls: hCe,
        gifts: dCe,
        validation: fCe,
        referral: pCe,
        upgradeCards: mCe,
        upgradeSections: gCe,
        upgrade: _Ce,
        games: yCe,
        my_cards: bCe,
        countries: vCe,
        airdrop: xCe,
        tasks: wCe,
        main: SCe,
        boost: ECe,
        onboarding: TCe,
        daily: CCe,
        level_up_popup: ICe,
        lootbox_popup: ACe,
        share: kCe,
        telegram_update: RCe,
        telegram_not_mobile: MCe,
        characteristics: PCe,
        shop: LCe,
        boosts: OCe,
        fortune_wheel: NCe,
        error_modal: DCe,
        unlock_slot_popup: BCe,
        unlock_slot_banner: FCe,
        toast_messages: $Ce,
        leaderboard: UCe
    }
    , GCe = {
        beforeMount(t, e) {
            const n = e.value || 0;
            n !== 0 && (t.style.opacity = "0",
                t.style.transform = "translateY(8px)",
                t.style.transition = `opacity 180ms ease-out ${n}ms, transform 180ms ease-out ${n}ms`)
        },
        mounted(t, e) {
            const n = e.value || 0;
            n !== 0 && requestAnimationFrame(() => {
                t.style.opacity = "1",
                    t.style.transform = "translateY(0)",
                    setTimeout(() => {
                        t.style.transform = "",
                            t.style.transition = ""
                    }
                        , n + 100)
            }
            )
        }
    }
    , oO = t => {
        t.classList.add("animate-bounceLeft"),
            t.classList.remove("animate-bounceRight")
    }
    , aO = t => {
        t.classList.add("animate-bounceRight"),
            t.classList.remove("animate-bounceLeft")
    }
    , BA = t => {
        const e = () => oO(t)
            , n = () => aO(t);
        return t.addEventListener("mousedown", e),
            t.addEventListener("touchstart", e),
            t.addEventListener("mouseup", n),
            t.addEventListener("mouseleave", n),
            t.addEventListener("touchend", n),
            () => {
                t.removeEventListener("mousedown", e),
                    t.removeEventListener("touchstart", e),
                    t.removeEventListener("mouseup", n),
                    t.removeEventListener("mouseleave", n),
                    t.removeEventListener("touchend", n)
            }
    }
    , D1 = t => typeof t == "boolean" ? {
        enabled: t
    } : t
    , HCe = {
        mounted(t, e) {
            var r;
            const { enabled: n } = D1(e.value)
                , s = document.createElement("div");
            s.classList.add("w-full", "h-full"),
                (r = t.parentNode) == null || r.insertBefore(s, t),
                s.appendChild(t),
                n && (t._cleanup = BA(t))
        },
        updated(t, e) {
            var o;
            const { enabled: n, startAnimation: s } = D1(e.value)
                , { enabled: r, startAnimation: i } = D1(e.oldValue);
            r !== n && (n === !1 ? (o = t._cleanup) == null || o.call(t) : t._cleanup = BA(t)),
                s && !i ? oO(t) : !s && i && aO(t)
        },
        beforeUnmount(t) {
            var e;
            (e = t._cleanup) == null || e.call(t)
        }
    }
    , WCe = "/icons/icon-calendar.webp"
    , YCe = {}
    , XCe = {
        src: WCe,
        alt: "Calendar Image"
    };
function jCe(t, e) {
    return A(),
        N("img", XCe)
}
const zCe = _e(YCe, [["render", jCe]])
    , qCe = {}
    , KCe = {
        viewBox: "0 0 80 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }
    , JCe = Nr('<g clip-path="url(#clip0_1380_17765)"><g clip-path="url(#clip1_1380_17765)"><path d="M73.5365 22.8081C72.73 19.7331 70.3614 17.3166 67.3478 16.4934C61.8911 15 40 15 40 15C40 15 18.1092 15 12.6523 16.4934C9.63865 17.3166 7.27034 19.7331 6.46362 22.8081C5 28.376 5 40 5 40C5 40 5 51.624 6.46362 57.192C7.27034 60.267 9.63865 62.6835 12.6523 63.5065C18.1092 65 40 65 40 65C40 65 61.8911 65 67.3478 63.5065C70.3614 62.6835 72.73 60.267 73.5365 57.192C75.0002 51.624 75.0002 40 75.0002 40C75.0002 40 74.9944 28.376 73.5365 22.8081Z" fill="#FF0000"></path><path d="M32.9922 50.7133L51.178 40.0008L32.9922 29.2881V50.7133Z" fill="white"></path></g></g><defs><clipPath id="clip0_1380_17765"><rect width="70" height="50" fill="white" transform="translate(5 15)"></rect></clipPath><clipPath id="clip1_1380_17765"><rect width="70" height="50" fill="white" transform="translate(5 15)"></rect></clipPath></defs>', 2)
    , ZCe = [JCe];
function QCe(t, e) {
    return A(),
        N("svg", KCe, ZCe)
}
const e2e = _e(qCe, [["render", QCe]])
    , t2e = {}
    , n2e = {
        viewBox: "0 0 80 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }
    , s2e = T("circle", {
        cx: "40",
        cy: "40",
        r: "35",
        fill: "black"
    }, null, -1)
    , r2e = T("path", {
        d: "M36.7352 26.9335C39.7209 30.9002 42.2418 34.1669 42.3352 34.1669C42.4285 34.1669 45.5328 30.9002 49.1952 26.9335L55.8918 19.7002H59.6952L58.8785 20.5645C58.4118 21.0526 55.3785 24.3431 52.1352 27.8669C48.8918 31.3902 45.7185 34.8193 45.0876 35.4502L43.9685 36.6402L52.7185 48.2835C57.5252 54.7002 61.4685 60.0193 61.4685 60.1145C61.4685 60.2311 58.5994 60.3002 55.1209 60.3002L48.7518 60.2769L42.8252 52.3435C38.7418 46.8602 36.8285 44.5021 36.6418 44.6435C36.5018 44.7602 33.1876 48.3311 29.2685 52.5769L22.1518 60.3002H20.3542C19.3518 60.3002 18.5352 60.2526 18.5352 60.1835C18.5352 60.1145 22.2452 56.0526 26.7709 51.1769C31.2756 46.3002 35.009 42.2169 35.0542 42.1478C35.0785 42.0526 31.3685 36.9902 26.8185 30.9002C22.2685 24.8335 18.5352 19.8169 18.5352 19.7693C18.5352 19.724 21.4042 19.7002 24.9285 19.7002H31.3209L36.7352 26.9335Z",
        fill: "white"
    }, null, -1)
    , i2e = T("path", {
        d: "M24.2979 22.8267C24.3907 22.99 30.2693 30.8767 37.3169 40.3024L50.1503 57.4762L53.0193 57.5C54.7931 57.5 55.8669 57.4067 55.8193 57.2667C55.7979 57.15 49.9407 49.2643 42.8479 39.7667L29.9193 22.5H27.0269C24.6245 22.5 24.1336 22.5476 24.2979 22.8267Z",
        fill: "black"
    }, null, -1)
    , o2e = [s2e, r2e, i2e];
function a2e(t, e) {
    return A(),
        N("svg", n2e, o2e)
}
const l2e = _e(t2e, [["render", a2e]])
    , c2e = {}
    , u2e = {
        viewBox: "0 0 80 80",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }
    , h2e = Nr('<g clip-path="url(#clip0_423_6286)"><path d="M40.0167 80.0333C62.1172 80.0333 80.0333 62.1172 80.0333 40.0167C80.0333 17.9161 62.1172 0 40.0167 0C17.9161 0 0 17.9161 0 40.0167C0 62.1172 17.9161 80.0333 40.0167 80.0333Z" fill="url(#paint0_linear_423_6286)"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M18.0923 39.5835C29.7541 34.5189 37.5176 31.1537 41.4159 29.521C52.5113 24.8896 54.8437 24.09 56.3431 24.0566C56.6763 24.0566 57.4093 24.1233 57.9091 24.5231C58.3089 24.8563 58.4089 25.2895 58.4755 25.6227C58.5421 25.9559 58.6088 26.6556 58.5421 27.1887C57.9424 33.5194 55.3435 48.8796 54.0107 55.9434C53.4443 58.9421 52.3447 59.9417 51.2785 60.0416C48.9461 60.2416 47.1802 58.509 44.9478 57.0429C41.4159 54.7439 39.4501 53.3111 36.0182 51.0454C32.0532 48.4465 34.6188 47.0137 36.8845 44.6814C37.4842 44.0816 47.7133 34.7522 47.9132 33.9192C47.9466 33.8192 47.9466 33.4194 47.7133 33.2195C47.4801 33.0196 47.1469 33.0862 46.8803 33.1529C46.5138 33.2195 40.9161 36.9513 30.0207 44.3149C28.4214 45.4144 26.9886 45.9475 25.6892 45.9142C24.2564 45.8809 21.5242 45.1145 19.4584 44.4481C16.9595 43.6485 14.9603 43.2153 15.1269 41.8159C15.2269 41.0829 16.2264 40.3499 18.0923 39.5835Z" fill="white"></path></g><defs><linearGradient id="paint0_linear_423_6286" x1="39.9833" y1="0" x2="39.9833" y2="79.4002" gradientUnits="userSpaceOnUse"><stop stop-color="#2AABEE"></stop><stop offset="1" stop-color="#229ED9"></stop></linearGradient><clipPath id="clip0_423_6286"><rect width="80" height="80" fill="white"></rect></clipPath></defs>', 2)
    , d2e = [h2e];
function f2e(t, e) {
    return A(),
        N("svg", u2e, d2e)
}
const p2e = _e(c2e, [["render", f2e]])
    , m2e = "/icons/icon-invite.webp"
    , g2e = {}
    , _2e = {
        src: m2e,
        alt: "Invite Icon"
    };
function y2e(t, e) {
    return A(),
        N("img", _2e)
}
const b2e = _e(g2e, [["render", y2e]]);
function pg() {
    const t = ["42psliIY", "aXCyh", "LUYqG", "connection-restoring-error", "5758684KZMwpZ", "FuNbr", "disconnection", "CUSTOM_EVENT", "CONNECTION_RESTORING_STARTED", "app-hide", "70tyzfZb", "435069aKWsrH", "wBEeJ", "YXCqq", "hhqcy", "TRANSACTION_SENT_FOR_SIGNATURE", "Uqfkg", "90qYcmKK", "273584hIlLxz", "349215DgUfTH", "QJRrM", "CONNECTION_RESTORING_ERROR", "connection-completed", "connection-started", "hoZuK", "DbbVv", "697317lpHNac", "MmPgT", "transaction-signing-failed", "387425DEbooj", "connection-restoring-started", "https://staging.tganalytics.xyz/", "https://tganalytics.xyz/", "custom-event", "TGA-Batch-Requests", "SNhIZ", "app-init", "31492ySNEKg", "WALLET_CONNECT_ERROR", "WALLET_DISCONNECT", "ADDITIONAL_TASK_EVENT", "TRANSACTION_SIGNED", "IYXgB", "xffRC", "transaction-sent-for-signature", "WALLET_CONNECT_SUCCESS", "transaction-signed", "PNbCn", "HIDE"];
    return pg = function () {
        return t
    }
        ,
        pg()
}
const t0 = mg;
(function (t, e) {
    const n = mg
        , s = t();
    for (; ;)
        try {
            if (-parseInt(n(352)) / 1 + parseInt(n(370)) / 2 + parseInt(n(359)) / 3 + parseInt(n(337)) / 4 + -parseInt(n(362)) / 5 * (parseInt(n(350)) / 6) + parseInt(n(333)) / 7 * (parseInt(n(351)) / 8) + -parseInt(n(344)) / 9 * (-parseInt(n(343)) / 10) === e)
                break;
            s.push(s.shift())
        } catch {
            s.push(s.shift())
        }
}
)(pg, 719941);
function mg(t, e) {
    const n = pg();
    return mg = function (s, r) {
        return s = s - 332,
            n[s]
    }
        ,
        mg(t, e)
}
const uv = t0(365)
    , v2e = t0(364)
    , x2e = t0(367);
var ds = (t => {
    const e = t0
        , n = {
            FuNbr: e(340),
            bSRxD: e(366),
            MkhrF: "WALLET_CONNECT_STARTED",
            wBEeJ: e(356),
            aXCyh: e(348),
            Uqfkg: e(377),
            IYXgB: "CONNECTION_RESTORING_SUCCESS",
            WaCIS: "connection-restoring-completed",
            YXCqq: e(371),
            xffRC: "connection-error",
            QJRrM: e(341),
            KTesL: e(363),
            eIUkH: e(361),
            PNbCn: e(374),
            LUYqG: e(379),
            hoZuK: e(378),
            SNhIZ: "INIT",
            MmPgT: e(354),
            DbbVv: e(373),
            bxfdK: e(332),
            nIbnV: e(342),
            hhqcy: e(339)
        }
        , s = "10|13|1|2|9|5|6|4|11|3|8|7|14|12|0".split("|");
    let r = 0;
    for (; ;) {
        switch (s[r++]) {
            case "0":
                return t;
            case "1":
                t[n[e(338)]] = n.bSRxD;
                continue;
            case "2":
                t[n.MkhrF] = n[e(345)];
                continue;
            case "3":
                t[n[e(334)]] = n[e(349)];
                continue;
            case "4":
                t[n[e(375)]] = n.WaCIS;
                continue;
            case "5":
                t[n[e(346)]] = n[e(376)];
                continue;
            case "6":
                t[n[e(353)]] = n.KTesL;
                continue;
            case "7":
                t.TRANSACTION_SIGNING_FAILED = n.eIUkH;
                continue;
            case "8":
                t[n[e(380)]] = n[e(335)];
                continue;
            case "9":
                t[n[e(357)]] = e(355);
                continue;
            case "10":
                t[n[e(368)]] = e(369);
                continue;
            case "11":
                t[n[e(360)]] = e(336);
                continue;
            case "12":
                t[n[e(358)]] = e(373);
                continue;
            case "13":
                t[n.bxfdK] = n.nIbnV;
                continue;
            case "14":
                t[e(372)] = n[e(347)];
                continue
        }
        break
    }
}
)(ds || {});
const Cp = Wd;
(function (t, e) {
    const n = Wd
        , s = t();
    for (; ;)
        try {
            if (-parseInt(n(323)) / 1 * (parseInt(n(355)) / 2) + -parseInt(n(333)) / 3 + parseInt(n(349)) / 4 + parseInt(n(340)) / 5 * (-parseInt(n(327)) / 6) + parseInt(n(330)) / 7 + parseInt(n(343)) / 8 + -parseInt(n(345)) / 9 * (-parseInt(n(316)) / 10) === e)
                break;
            s.push(s.shift())
        } catch {
            s.push(s.shift())
        }
}
)(gg, 239523);
function Wd(t, e) {
    const n = gg();
    return Wd = function (s, r) {
        return s = s - 311,
            n[s]
    }
        ,
        Wd(t, e)
}
function gg() {
    const t = ["TRANSACTION_SIGNING_FAILED", "type", "3550vYdCAu", "tonConnectUiEvents", "WALLET_CONNECT_STARTED", "493704KNZbYz", " listener", "21474eoegDe", "addEventListener", "taCfT", "TRANSACTION_SIGNED", "266764MngNpB", "WALLET_DISCONNECT", "Dssyt", "log", "TRANSACTION_SENT_FOR_SIGNATURE", "Attach ", "14TzHTvC", "analyticsController", "WCASo", "2|4|1|3|0", "lxYnH", " received", "2460sfXLEL", "sdkScope", "uiScope", "ton-connect-ui-", "WALLET_CONNECT_ERROR", "CONNECTION_RESTORING_ERROR", "XhLsO", "24334vYTwdk", "hmFKx", "map", "tonConnectSdkEvents", "732cpNDFb", "events", "event ", "1715616skupxF", "MpEUz", "WALLET_CONNECT_SUCCESS", "1391901BAnAfo", "collectEvent", "init", "ton-connect-", "detail"];
    return gg = function () {
        return t
    }
        ,
        gg()
}
class w2e {
    constructor(e) {
        const n = Wd
            , s = {
                MpEUz: n(313),
                taCfT: n(336)
            }
            , r = s[n(331)].split("|");
        let i = 0;
        for (; ;) {
            switch (r[i++]) {
                case "0":
                    this[n(311)] = e;
                    continue;
                case "1":
                    this[n(318)] = n(319);
                    continue;
                case "2":
                    this[n(326)] = [ds.CUSTOM_EVENT, ds[n(332)], ds[n(320)], ds.CONNECTION_RESTORING_SUCCESS, ds[n(321)], ds[n(353)], ds[n(348)], ds[n(338)], ds[n(350)]];
                    continue;
                case "3":
                    this[n(317)] = s[n(347)];
                    continue;
                case "4":
                    this[n(341)] = [ds[n(342)], ds.WALLET_CONNECT_ERROR, ds.TRANSACTION_SIGNING_FAILED];
                    continue
            }
            break
        }
    }
    [Cp(335)]() {
        const e = Cp
            , n = {
                WCASo: function (s, r) {
                    return s === r
                },
                Dssyt: e(314),
                hmFKx: e(322)
            };
        for (let s of this[e(328)])
            if (n[e(312)](n[e(351)], n[e(324)]))
                for (let r of this[e(328)])
                    _0x3bb0fc[e(352)](e(354) + r + e(344)),
                        _0x4b9b51[e(346)](r, i => {
                            const o = e;
                            _0x59b408.log("event " + r + o(315), i[o(337)]);
                            const { type: l, ...a } = i[o(337)];
                            this[o(311)][o(334)](i[o(337)].type, {
                                ...a
                            })
                        }
                        );
            else
                console[e(352)](e(354) + s + e(344)),
                    window.addEventListener(s, r => {
                        const i = e;
                        console[i(352)](i(329) + s + i(315), r[i(337)]);
                        const { type: o, ...l } = r[i(337)];
                        this[i(311)][i(334)](r.detail[i(339)], {
                            ...l
                        })
                    }
                    )
    }
    get [Cp(328)]() {
        const e = Cp
            , n = this[e(341)].map(r => "" + this[e(318)] + r)
            , s = this[e(326)][e(325)](r => "" + this[e(317)] + r);
        return [...n, ...s]
    }
}
const FA = Yd;
function _g() {
    const t = ["hlCIF", "395UuoGxE", "entries", "visibilityState", "collectEvent", "4iUJVkJ", "hidden", "analyticsController", "358815RzcIZL", "iKodA", "LCUII", "addEventListener", "123736jaEPRn", "7026aaQJsP", "init", "HIDE", "documentEvents", "451KVoEKZ", "411640JmQOan", "9tJJXQs", "134448oXxSEE", "1389770ewOVww", "61463XBiawf", "7WMWHKI"];
    return _g = function () {
        return t
    }
        ,
        _g()
}
function Yd(t, e) {
    const n = _g();
    return Yd = function (s, r) {
        return s = s - 182,
            n[s]
    }
        ,
        Yd(t, e)
}
(function (t, e) {
    const n = Yd
        , s = t();
    for (; ;)
        try {
            if (-parseInt(n(182)) / 1 + -parseInt(n(202)) / 2 + -parseInt(n(192)) / 3 * (parseInt(n(189)) / 4) + parseInt(n(185)) / 5 * (-parseInt(n(197)) / 6) + parseInt(n(183)) / 7 * (-parseInt(n(196)) / 8) + parseInt(n(203)) / 9 * (parseInt(n(205)) / 10) + parseInt(n(201)) / 11 * (parseInt(n(204)) / 12) === e)
                break;
            s.push(s.shift())
        } catch {
            s.push(s.shift())
        }
}
)(_g, 103477);
class S2e {
    constructor(e) {
        const n = Yd
            , s = {
                UQNfA: n(190)
            };
        this[n(200)] = {
            visibilitychange: () => {
                const r = n;
                document[r(187)] === s.UQNfA && this.analyticsController[r(188)](ds[r(199)], void 0)
            }
        },
            this[n(191)] = e
    }
    [FA(198)]() {
        const e = FA
            , n = {
                iKodA: e(190),
                LCUII: function (s, r) {
                    return s !== r
                },
                ZWuDj: "hlCIF"
            };
        for (let [s, r] of Object[e(186)](this.documentEvents))
            n[e(194)](e(184), n.ZWuDj) ? _0x600a22.visibilityState === n[e(193)] && this[e(191)].collectEvent(_0x1a88a1[e(199)], void 0) : document[e(195)](s, r)
    }
}
(function (t, e) {
    const n = Xd
        , s = t();
    for (; ;)
        try {
            if (-parseInt(n(177)) / 1 * (-parseInt(n(174)) / 2) + parseInt(n(180)) / 3 + -parseInt(n(178)) / 4 + -parseInt(n(181)) / 5 + parseInt(n(185)) / 6 * (-parseInt(n(171)) / 7) + parseInt(n(172)) / 8 + parseInt(n(168)) / 9 === e)
                break;
            s.push(s.shift())
        } catch {
            s.push(s.shift())
        }
}
)(yg, 183988);
function Xd(t, e) {
    const n = yg();
    return Xd = function (s, r) {
        return s = s - 167,
            n[s]
    }
        ,
        Xd(t, e)
}
class E2e {
    constructor(e) {
        const n = Xd;
        this[n(170)] = [ds.ADDITIONAL_TASK_EVENT],
            this[n(183)] = e
    }
    init() {
        const e = Xd;
        for (let n of this[e(170)])
            console.log(e(175) + n + e(173)),
                window[e(176)](n, s => {
                    const r = e;
                    console.log(r(179) + n + r(167), s[r(169)]);
                    const { type: i, ...o } = s.detail;
                    this[r(183)][r(182)](s[r(169)][r(184)], {
                        ...o
                    })
                }
                )
    }
}
function yg() {
    const t = ["1605560tqxaVp", "collectTappsEvent", "analyticsController", "type", "308790HThpdc", " received", "1026027oTyihq", "detail", "telegramAppsCenterEvents", "42Argnee", "2818808kArkye", " listener", "9326UzLBOz", "Attach ", "addEventListener", "64qNbXmH", "318996aHXSPt", "event ", "386559HCEVip"];
    return yg = function () {
        return t
    }
        ,
        yg()
}
var Nc = jd;
function jd(t, e) {
    var n = bg();
    return jd = function (s, r) {
        s = s - 442;
        var i = n[s];
        return i
    }
        ,
        jd(t, e)
}
(function (t, e) {
    for (var n = jd, s = t(); ;)
        try {
            var r = -parseInt(n(447)) / 1 * (-parseInt(n(457)) / 2) + parseInt(n(449)) / 3 + parseInt(n(458)) / 4 + parseInt(n(453)) / 5 + parseInt(n(459)) / 6 * (parseInt(n(448)) / 7) + parseInt(n(456)) / 8 + -parseInt(n(444)) / 9 * (parseInt(n(452)) / 10);
            if (r === e)
                break;
            s.push(s.shift())
        } catch {
            s.push(s.shift())
        }
}
)(bg, 538129);
function bg() {
    var t = ["6740AnHIYf", "94955RLesaX", "appModule", "collectEvent", "4566032XOZARb", "44SjXPCk", "310428cARVAn", "310098weSiyP", "tonConnectObserver", "tappsObserver", "init", "25605kDiadV", "catch", "documentObserver", "13894dcBIny", "119ChiAqv", "1812084kaOWcI", "error", "recordEvent"];
    return bg = function () {
        return t
    }
        ,
        bg()
}
class T2e {
    constructor(e) {
        var n = jd;
        this[n(454)] = e,
            this.documentObserver = new S2e(this),
            this[n(460)] = new w2e(this),
            this[n(442)] = new E2e(this)
    }
    [Nc(443)]() {
        var e = Nc;
        this[e(446)].init(),
            this[e(460)][e(443)](),
            this[e(442)][e(443)]()
    }
    [Nc(451)](e, n) {
        var s = Nc;
        this[s(454)][s(451)](e, n)[s(445)](r => console[s(450)](r))
    }
    [Nc(455)](e, n) {
        var s = Nc;
        this.appModule[s(455)](e, n)
    }
    collectTappsEvent(e, n) {
        this.appModule.collectTappsEvent(e, n)
    }
}
function vg() {
    const t = ["22916TARMFg", "TOKEN_IS_NOT_PROVIDED", "Token is not provided.", "677opDVdJ", "2522zgbtWZ", "4025088efZUnq", "Telegram User data is not provided.", "9571856dmMJaI", "904169ZlIwJr", "foumP", "17415590fYKHrO", "USER_DATA_IS_NOT_PROVIDED", "18cxSGiV", "1370BFUwGR", "IQAJA", "10226457VxXAHC"];
    return vg = function () {
        return t
    }
        ,
        vg()
}
function xg(t, e) {
    const n = vg();
    return xg = function (s, r) {
        return s = s - 489,
            n[s]
    }
        ,
        xg(t, e)
}
(function (t, e) {
    const n = xg
        , s = t();
    for (; ;)
        try {
            if (-parseInt(n(490)) / 1 * (parseInt(n(491)) / 2) + -parseInt(n(492)) / 3 + -parseInt(n(503)) / 4 * (-parseInt(n(500)) / 5) + -parseInt(n(499)) / 6 * (parseInt(n(495)) / 7) + parseInt(n(494)) / 8 + -parseInt(n(502)) / 9 + parseInt(n(497)) / 10 === e)
                break;
            s.push(s.shift())
        } catch {
            s.push(s.shift())
        }
}
)(vg, 788620);
const lO = t => {
    throw new Error(t)
}
    ;
var PS = (t => {
    const e = xg
        , n = {
            foumP: e(504),
            IQAJA: e(489)
        };
    return t[n[e(496)]] = n[e(501)],
        t[e(498)] = e(493),
        t
}
)(PS || {});
const Ip = zd;
(function (t, e) {
    const n = zd
        , s = t();
    for (; ;)
        try {
            if (-parseInt(n(407)) / 1 + parseInt(n(435)) / 2 * (-parseInt(n(385)) / 3) + -parseInt(n(395)) / 4 * (parseInt(n(431)) / 5) + -parseInt(n(428)) / 6 + parseInt(n(409)) / 7 * (-parseInt(n(392)) / 8) + -parseInt(n(432)) / 9 * (parseInt(n(390)) / 10) + -parseInt(n(408)) / 11 * (-parseInt(n(403)) / 12) === e)
                break;
            s.push(s.shift())
        } catch {
            s.push(s.shift())
        }
}
)(wg, 270209);
function zd(t, e) {
    const n = wg();
    return zd = function (s, r) {
        return s = s - 383,
            n[s]
    }
        ,
        zd(t, e)
}
function wg() {
    const t = ["McwZv", "getApiToken", "json", "2724650UDpbXL", "DCGFC", "317976LxtTiH", "STG", "XrWMh", "12fxhNzW", "appModule", "BACKEND_URL", "custom_data", "AoIlW", "xAwOq", "responseToParams", "solveTask", "18942324IyDTSr", "setNewArgs", "events", "assign", "91165rihevl", "11LMsGAd", "21QxPuSK", "ddVWm", "UtxCU", "TOKEN_IS_NOT_PROVIDED", "AktCy", "RfnoI", "application/json", "YVSiO", "uULAP", "recordEvent", "moIEJ", "jGrjg", "generateHeaders", "bocJk", "then", "clone", "POST", "taskSolution", "Owkdd", "2275032YVARsy", "mJPMY", "Content", "36715YJxRDg", "9ajEHQw", "init", "vJgws", "2mHXjXM", "status", "assembleEventSession", "1272738jpFnLv", "otGpc"];
    return wg = function () {
        return t
    }
        ,
        wg()
}
class C2e {
    constructor(e) {
        const n = zd
            , s = {
                ddVWm: n(415),
                jGrjg: function (r, i) {
                    return r === i
                },
                YVSiO: function (r, i) {
                    return r === i
                },
                uULAP: function (r, i) {
                    return r(i)
                },
                wnaDG: n(430),
                ImOoF: function (r, i) {
                    return r === i
                },
                AktCy: n(391),
                qnPfd: function (r, i) {
                    return r === i
                },
                vJgws: n(393)
            };
        this.BACKEND_URL = uv,
            this[n(401)] = async r => {
                const i = n;
                if (s[i(420)]("FAWhI", i(399)))
                    return {
                        "TGA-Auth-Token": this.appModule[i(388)](),
                        "Content-Type": s[i(410)],
                        Content: this.appModule[i(426)]
                    };
                {
                    const o = r[i(424)]();
                    if (s[i(416)](s[i(417)](String, o[i(383)])[0], "2") || s.jGrjg(o[i(383)], 429)) {
                        const l = await o[i(389)]();
                        this[i(396)][i(404)](l[s.wnaDG])
                    }
                    return r
                }
            }
            ,
            this[n(421)] = () => {
                const r = n;
                if (this.appModule[r(402)](),
                    this.appModule[r(426)]) {
                    if (s.ImOoF(s[r(413)], s[r(413)]))
                        return {
                            "TGA-Auth-Token": this[r(396)][r(388)](),
                            "Content-Type": s[r(410)],
                            Content: this[r(396)][r(426)]
                        };
                    _0x5d7c72 ? _0xca0818 = _0x34c228[r(406)](_0x55d838[r(398)], _0x38e5bc) : _0x225ef2 = _0x43f7a5.custom_data
                }
                return {
                    "TGA-Auth-Token": this[r(396)][r(388)](),
                    "Content-Type": s.ddVWm
                }
            }
            ,
            this[n(396)] = e,
            s.qnPfd(this[n(396)].env, s[n(434)]) && (this[n(397)] = v2e),
            !this.appModule.getApiToken() && s[n(417)](lO, PS[n(412)])
    }
    [Ip(433)]() { }
    async recordEvents(e) {
        const n = Ip
            , s = {
                moIEJ: function (r, i) {
                    return r + i
                },
                XrWMh: n(405)
            };
        return await fetch(s[n(419)](this[n(397)], s[n(394)]), {
            method: n(425),
            headers: this[n(421)](),
            body: JSON.stringify(e)
        })[n(423)](this[n(401)], this[n(401)])
    }
    async[Ip(418)](e, n, s) {
        const r = Ip
            , i = {
                bocJk: function (o, l) {
                    return o === l
                },
                xAwOq: r(387),
                mJPMY: r(411),
                Owkdd: function (o, l, a) {
                    return o(l, a)
                },
                RfnoI: function (o, l) {
                    return o + l
                },
                otGpc: r(405),
                QHtLn: r(425)
            };
        n != null && n.custom_data && (i[r(422)](i[r(400)], i[r(429)]) ? this.BACKEND_URL = _0x586141 : s ? s = Object[r(406)](n[r(398)], s) : s = n.custom_data),
            await i[r(427)](fetch, i[r(414)](this[r(397)], i[r(386)]), {
                method: i.QHtLn,
                headers: this[r(421)](),
                body: JSON.stringify({
                    ...n,
                    event_name: e,
                    custom_data: s,
                    ...this[r(396)][r(384)]()
                })
            })[r(423)](this[r(401)], this.responseToParams)
    }
}
class LS extends Error {
    constructor(e, n, s) {
        super(n, {
            cause: s
        }),
            this.type = e,
            Object.setPrototypeOf(this, LS.prototype)
    }
}
function OS(t, e, n) {
    return new LS(t, e, n)
}
const I2e = "ERR_UNEXPECTED_TYPE"
    , cO = "ERR_PARSE";
function Tf() {
    return OS(I2e, "Value has unexpected type")
}
class NS {
    constructor(e, n, s) {
        this.parser = e,
            this.isOptional = n,
            this.type = s
    }
    parse(e) {
        if (!(this.isOptional && e === void 0))
            try {
                return this.parser(e)
            } catch (n) {
                throw OS(cO, `Unable to parse value${this.type ? ` as ${this.type}` : ""}`, n)
            }
    }
    optional() {
        return this.isOptional = !0,
            this
    }
}
function wh(t, e) {
    return () => new NS(t, !1, e)
}
const Pa = wh(t => {
    if (typeof t == "boolean")
        return t;
    const e = String(t);
    if (e === "1" || e === "true")
        return !0;
    if (e === "0" || e === "false")
        return !1;
    throw Tf()
}
    , "boolean");
function uO(t, e) {
    const n = {};
    for (const s in t) {
        const r = t[s];
        if (!r)
            continue;
        let i, o;
        if (typeof r == "function" || "parse" in r)
            i = s,
                o = typeof r == "function" ? r : r.parse.bind(r);
        else {
            const { type: l } = r;
            i = r.from || s,
                o = typeof l == "function" ? l : l.parse.bind(l)
        }
        try {
            const l = o(e(i));
            l !== void 0 && (n[s] = l)
        } catch (l) {
            throw OS(cO, `Unable to parse field "${s}"`, l)
        }
    }
    return n
}
function hO(t) {
    let e = t;
    if (typeof e == "string" && (e = JSON.parse(e)),
        typeof e != "object" || e === null || Array.isArray(e))
        throw Tf();
    return e
}
function iu(t, e) {
    return new NS(n => {
        const s = hO(n);
        return uO(t, r => s[r])
    }
        , !1, e)
}
const Ju = wh(t => {
    if (typeof t == "number")
        return t;
    if (typeof t == "string") {
        const e = Number(t);
        if (!Number.isNaN(e))
            return e
    }
    throw Tf()
}
    , "number")
    , Jt = wh(t => {
        if (typeof t == "string" || typeof t == "number")
            return t.toString();
        throw Tf()
    }
        , "string");
iu({
    req_id: Jt(),
    data: t => t === null ? t : Jt().optional().parse(t)
}),
    iu({
        req_id: Jt(),
        result: t => t,
        error: Jt().optional()
    }),
    iu({
        height: Ju(),
        width: t => t == null ? window.innerWidth : Ju().parse(t),
        is_state_stable: Pa(),
        is_expanded: Pa()
    });
function A2e(t) {
    return /^#[\da-f]{6}$/i.test(t)
}
function k2e(t) {
    return /^#[\da-f]{3}$/i.test(t)
}
function R2e(t) {
    const e = t.replace(/\s/g, "").toLowerCase();
    if (A2e(e))
        return e;
    if (k2e(e)) {
        let s = "#";
        for (let r = 0; r < 3; r += 1)
            s += e[1 + r].repeat(2);
        return s
    }
    const n = e.match(/^rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)$/) || e.match(/^rgba\((\d{1,3}),(\d{1,3}),(\d{1,3}),\d{1,3}\)$/);
    if (!n)
        throw new Error(`Value "${t}" does not satisfy any of known RGB formats.`);
    return n.slice(1).reduce((s, r) => {
        const i = parseInt(r, 10).toString(16);
        return s + (i.length === 1 ? "0" : "") + i
    }
        , "#")
}
const M2e = wh(t => t instanceof Date ? t : new Date(Ju().parse(t) * 1e3), "Date");
function dO(t, e) {
    return new NS(n => {
        if (typeof n != "string" && !(n instanceof URLSearchParams))
            throw Tf();
        const s = typeof n == "string" ? new URLSearchParams(n) : n;
        return uO(t, r => {
            const i = s.get(r);
            return i === null ? void 0 : i
        }
        )
    }
        , !1, e)
}
const P2e = iu({
    id: Ju(),
    type: Jt(),
    title: Jt(),
    photoUrl: {
        type: Jt().optional(),
        from: "photo_url"
    },
    username: Jt().optional()
}, "Chat").optional()
    , $A = iu({
        addedToAttachmentMenu: {
            type: Pa().optional(),
            from: "added_to_attachment_menu"
        },
        allowsWriteToPm: {
            type: Pa().optional(),
            from: "allows_write_to_pm"
        },
        firstName: {
            type: Jt(),
            from: "first_name"
        },
        id: Ju(),
        isBot: {
            type: Pa().optional(),
            from: "is_bot"
        },
        isPremium: {
            type: Pa().optional(),
            from: "is_premium"
        },
        languageCode: {
            type: Jt().optional(),
            from: "language_code"
        },
        lastName: {
            type: Jt().optional(),
            from: "last_name"
        },
        photoUrl: {
            type: Jt().optional(),
            from: "photo_url"
        },
        username: Jt().optional()
    }, "User").optional();
function L2e() {
    return dO({
        authDate: {
            type: M2e(),
            from: "auth_date"
        },
        canSendAfter: {
            type: Ju().optional(),
            from: "can_send_after"
        },
        chat: P2e,
        chatInstance: {
            type: Jt().optional(),
            from: "chat_instance"
        },
        chatType: {
            type: Jt().optional(),
            from: "chat_type"
        },
        hash: Jt(),
        queryId: {
            type: Jt().optional(),
            from: "query_id"
        },
        receiver: $A,
        startParam: {
            type: Jt().optional(),
            from: "start_param"
        },
        user: $A
    }, "InitData")
}
const O2e = wh(t => R2e(Jt().parse(t)), "rgb");
function N2e(t) {
    return t.replace(/_[a-z]/g, e => e[1].toUpperCase())
}
function D2e(t) {
    return t.replace(/[A-Z]/g, e => `_${e.toLowerCase()}`)
}
const B2e = wh(t => {
    const e = O2e().optional();
    return Object.entries(hO(t)).reduce((n, [s, r]) => (n[N2e(s)] = e.parse(r),
        n), {})
}
    , "ThemeParams");
function fO(t) {
    return dO({
        botInline: {
            type: Pa().optional(),
            from: "tgWebAppBotInline"
        },
        initData: {
            type: L2e().optional(),
            from: "tgWebAppData"
        },
        initDataRaw: {
            type: Jt().optional(),
            from: "tgWebAppData"
        },
        platform: {
            type: Jt(),
            from: "tgWebAppPlatform"
        },
        showSettings: {
            type: Pa().optional(),
            from: "tgWebAppShowSettings"
        },
        startParam: {
            type: Jt().optional(),
            from: "tgWebAppStartParam"
        },
        themeParams: {
            type: B2e(),
            from: "tgWebAppThemeParams"
        },
        version: {
            type: Jt(),
            from: "tgWebAppVersion"
        }
    }).parse(t)
}
function pO(t) {
    return fO(t.replace(/^[^?#]*[?#]/, "").replace(/[?#]/g, "&"))
}
function F2e() {
    return pO(window.location.href)
}
function $2e() {
    return performance.getEntriesByType("navigation")[0]
}
function U2e() {
    const t = $2e();
    if (!t)
        throw new Error("Unable to get first navigation entry.");
    return pO(t.name)
}
function mO(t) {
    return `telegram-apps/${t.replace(/[A-Z]/g, e => `-${e.toLowerCase()}`)}`
}
function V2e(t, e) {
    sessionStorage.setItem(mO(t), JSON.stringify(e))
}
function G2e(t) {
    const e = sessionStorage.getItem(mO(t));
    try {
        return e ? JSON.parse(e) : void 0
    } catch { }
}
function H2e() {
    return fO(G2e("launchParams") || "")
}
function W2e(t) {
    return JSON.stringify(Object.fromEntries(Object.entries(t).map(([e, n]) => [D2e(e), n])))
}
function Y2e(t) {
    const { initDataRaw: e, themeParams: n, platform: s, version: r, showSettings: i, startParam: o, botInline: l } = t
        , a = new URLSearchParams;
    return a.set("tgWebAppPlatform", s),
        a.set("tgWebAppThemeParams", W2e(n)),
        a.set("tgWebAppVersion", r),
        e && a.set("tgWebAppData", e),
        o && a.set("tgWebAppStartParam", o),
        typeof i == "boolean" && a.set("tgWebAppShowSettings", i ? "1" : "0"),
        typeof l == "boolean" && a.set("tgWebAppBotInline", l ? "1" : "0"),
        a.toString()
}
function X2e(t) {
    V2e("launchParams", Y2e(t))
}
function j2e() {
    const t = [];
    for (const e of [F2e, U2e, H2e])
        try {
            const n = e();
            return X2e(n),
                n
        } catch (n) {
            t.push(n instanceof Error ? n.message : JSON.stringify(n))
        }
    throw new Error([`Unable to retrieve launch parameters from any known source. Perhaps, you have opened your app outside Telegram?
`, " Refer to docs for more information:", `https://docs.telegram-mini-apps.com/packages/telegram-apps-sdk/environment
`, "Collected errors:", t.map(e => ` ${e}`)].join(`
`))
}
function Sg(t, e) {
    const n = Eg();
    return Sg = function (s, r) {
        return s = s - 369,
            n[s]
    }
        ,
        Sg(t, e)
}
(function (t, e) {
    const n = Sg
        , s = t();
    for (; ;)
        try {
            if (-parseInt(n(379)) / 1 * (-parseInt(n(369)) / 2) + parseInt(n(391)) / 3 * (-parseInt(n(392)) / 4) + -parseInt(n(375)) / 5 + parseInt(n(389)) / 6 + -parseInt(n(383)) / 7 * (parseInt(n(373)) / 8) + parseInt(n(385)) / 9 + parseInt(n(380)) / 10 === e)
                break;
            s.push(s.shift())
        } catch {
            s.push(s.shift())
        }
}
)(Eg, 691841);
function Eg() {
    const t = ["length", "fTVaK", "7979304DRgiAP", "toString", "13698NmSalb", "1112cyGete", "114YaKtRr", "slice", "charCodeAt", "txdMd", "64EGUBUI", "iVnLS", "1239795FCMZgd", "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx", "floor", "Fswco", "12158MbFrRY", "5658760BYdXJr", "MuyoX", "getTime", "579467UBrBGR", "pQlEo", "2543670JVRiit", "YGRbI"];
    return Eg = function () {
        return t
    }
        ,
        Eg()
}
function z2e(t) {
    const e = Sg
        , n = {
            pQlEo: function (c, u) {
                return c < u
            },
            NwXSY: function (c, u) {
                return c + u
            },
            fTVaK: function (c, u) {
                return c - u
            },
            txdMd: function (c, u) {
                return c << u
            },
            Fswco: function (c, u) {
                return c | u
            },
            AXzye: function (c, u) {
                return c % u
            },
            YGRbI: function (c, u) {
                return c + u
            },
            iVnLS: function (c, u) {
                return c / u
            },
            MuyoX: e(376),
            qFStl: function (c, u) {
                return c(u)
            },
            GpGpw: function (c, u) {
                return c < u
            }
        };
    let s = n[e(381)]
        , r = new Date()[e(382)]();
    const i = t + r;
    function o(c) {
        const u = e;
        let h = 0;
        for (let d = 0; n[u(384)](d, c[u(387)]); d++) {
            const f = c[u(371)](d);
            h = n.NwXSY(n[u(388)](n[u(372)](h, 5), h), f),
                h |= 0
        }
        return h
    }
    let l = n.qFStl(o, i).toString(16);
    for (; n.GpGpw(l.length, 32);)
        l += l;
    l = l[e(370)](0, 32);
    let a = 0;
    return s.replace(/[xy]/g, function (c) {
        const u = e
            , h = n[u(378)](n.AXzye(n[u(386)](r, parseInt(l[a], 16)), 16), 0);
        return r = Math[u(377)](n[u(374)](r, 16)),
            a++,
            (c == "x" ? h : h & 3 | 8)[u(390)](16)
    })
}
const tr = Zu;
(function (t, e) {
    const n = Zu
        , s = t();
    for (; ;)
        try {
            if (parseInt(n(328)) / 1 + parseInt(n(351)) / 2 + -parseInt(n(340)) / 3 + -parseInt(n(339)) / 4 + parseInt(n(337)) / 5 * (parseInt(n(323)) / 6) + parseInt(n(356)) / 7 * (-parseInt(n(341)) / 8) + -parseInt(n(350)) / 9 * (-parseInt(n(359)) / 10) === e)
                break;
            s.push(s.shift())
        } catch {
            s.push(s.shift())
        }
}
)(Tg, 737671);
function Zu(t, e) {
    const n = Tg();
    return Zu = function (s, r) {
        return s = s - 320,
            n[s]
    }
        ,
        Zu(t, e)
}
function Tg() {
    const t = ["userId", "userLocale", "320459dptwJq", "initData", "getUserIsPremium", "getWebAppStartParam", "getSessionId", "URRYV", "now", "getUserLocale", "getAppName", "563840QDvOUD", "startParam", "2787376ITAODe", "3973458RpCkDG", "47416ISTGMl", "getPlatform", "webAppStartParam", "DvztI", "is_premium", "jHOoG", "MWYRs", "MJQfh", "userData", "4734dJuaye", "995176afqEfd", "juyYn", "GJPXn", "isPremium", "appModule", "868LUzVeM", "getUserId", "sessionId", "27290yhGISo", "getUserData", "dwhAD", "photoUrl", "languageCode", "66PhCcTo", "platform", "lastName"];
    return Tg = function () {
        return t
    }
        ,
        Tg()
}
class q2e {
    constructor(e) {
        const n = Zu;
        this[n(355)] = e
    }
    init() {
        var e;
        const n = Zu
            , s = {
                FdJGX: function (l) {
                    return l()
                },
                rBRQy: function (l, a) {
                    return l === a
                },
                GJPXn: n(352),
                DvztI: n(346),
                MWYRs: function (l, a) {
                    return l(a)
                },
                MJQfh: function (l, a) {
                    return l(a)
                },
                dwhAD: function (l, a) {
                    return l(a)
                }
            }
            , r = s.FdJGX(j2e)
            , i = r[n(329)]
            , o = (e = r[n(329)]) == null ? void 0 : e.user;
        if (!o) {
            if (s.rBRQy(s[n(353)], s[n(344)]))
                return this.sessionId;
            s[n(347)](lO, PS.USER_DATA_IS_NOT_PROVIDED)
        }
        this[n(349)] = {
            id: o.id,
            is_premium: o[n(354)],
            first_name: o.firstName,
            is_bot: o.isBot,
            last_name: o[n(325)],
            language_code: o.languageCode,
            photo_url: o[n(321)],
            username: o.username
        },
            this.userId = o.id,
            this[n(327)] = o[n(322)],
            this.webAppStartParam = i[n(338)],
            this[n(324)] = r[n(324)],
            this[n(358)] = s[n(348)](z2e, s[n(320)](String, this[n(357)]()))
    }
    [tr(332)]() {
        return this[tr(358)]
    }
    [tr(357)]() {
        return this[tr(326)]
    }
    getWebAppStartParam() {
        return this[tr(343)]
    }
    [tr(342)]() {
        return this[tr(324)]
    }
    [tr(335)]() {
        return this[tr(327)]
    }
    [tr(360)]() {
        return this.userData
    }
    [tr(330)]() {
        const e = tr
            , n = {
                nChSx: function (r, i) {
                    return r(i)
                }
            }
            , s = this[e(360)]();
        return n.nChSx(Boolean, s == null ? void 0 : s[e(345)])
    }
    assembleEventSession() {
        const e = tr
            , n = {
                URRYV: function (s, r) {
                    return s(r)
                }
            };
        return {
            session_id: this[e(332)](),
            user_id: this[e(357)](),
            app_name: this[e(355)][e(336)](),
            is_premium: this[e(330)](),
            platform: this[e(342)](),
            locale: this.getUserLocale(),
            start_param: this[e(331)](),
            client_timestamp: n[e(333)](String, Date[e(334)]())
        }
    }
}
const Dc = qd;
(function (t, e) {
    const n = qd
        , s = t();
    for (; ;)
        try {
            if (parseInt(n(425)) / 1 + parseInt(n(423)) / 2 * (parseInt(n(418)) / 3) + -parseInt(n(430)) / 4 + parseInt(n(429)) / 5 + -parseInt(n(438)) / 6 * (-parseInt(n(419)) / 7) + parseInt(n(422)) / 8 * (-parseInt(n(428)) / 9) + parseInt(n(421)) / 10 * (-parseInt(n(441)) / 11) === e)
                break;
            s.push(s.shift())
        } catch {
            s.push(s.shift())
        }
}
)(Cg, 982804);
function qd(t, e) {
    const n = Cg();
    return qd = function (s, r) {
        return s = s - 417,
            n[s]
    }
        ,
        qd(t, e)
}
class K2e {
    constructor(e) {
        const n = qd;
        this[n(424)] = window.sessionStorage,
            this.localStorage = window[n(440)],
            this[n(426)] = e
    }
    [Dc(417)]() {
        const e = Dc;
        return [null, {
            tqgqE: "null"
        }.tqgqE][e(436)](this[e(424)][e(431)](this.key)) && [null, e(435)][e(436)](this[e(440)][e(431)](this[e(426)])) ? this.setItem([]) : this[e(432)](JSON[e(433)](this[e(440)][e(431)](this[e(426)]))),
            this[e(432)]([...JSON.parse(this.sessionStorage[e(431)](this[e(426)])), ...JSON[e(433)](this[e(440)][e(431)](this.key))][e(427)]((s, r, i) => i[e(420)](o => JSON[e(437)](o) === JSON.stringify(s)) === r)),
            JSON.parse(this[e(424)].getItem(this[e(426)]))
    }
    [Dc(439)](e, n) {
        const s = Dc
            , r = this[s(417)]();
        r[s(434)]({
            event_name: e,
            ...n
        }),
            this.setItem(r)
    }
    [Dc(432)](e) {
        const n = Dc;
        this[n(440)][n(432)](this.key, JSON[n(437)](e)),
            this[n(424)].setItem(this.key, JSON[n(437)](e))
    }
}
function Cg() {
    const t = ["542EXlIhQ", "sessionStorage", "916728BBIFnf", "key", "filter", "72uUwqjv", "8022905TOrZbn", "7483164mQdJkY", "getItem", "setItem", "parse", "push", "null", "includes", "stringify", "10476sYYKsK", "addToStorage", "localStorage", "6187599AfXrEO", "getBatch", "16083ndghft", "42yzjAdf", "findIndex", "10LEaBVO", "568512nNAltZ"];
    return Cg = function () {
        return t
    }
        ,
        Cg()
}
const Si = mo;
(function (t, e) {
    const n = mo
        , s = t();
    for (; ;)
        try {
            if (-parseInt(n(511)) / 1 + -parseInt(n(466)) / 2 + parseInt(n(550)) / 3 * (-parseInt(n(542)) / 4) + -parseInt(n(525)) / 5 * (-parseInt(n(474)) / 6) + -parseInt(n(507)) / 7 + -parseInt(n(546)) / 8 * (-parseInt(n(531)) / 9) + -parseInt(n(556)) / 10 * (-parseInt(n(516)) / 11) === e)
                break;
            s.push(s.shift())
        } catch {
            s.push(s.shift())
        }
}
)(Ig, 683471);
function Ig() {
    const t = ["6xbrSPU", "solveTask", "BFIZj", "taskSolution", "fpswf", "VRTjP", "aXUEV", "DGpGG", "iUsED", "FVQzB", "MJLuT", "kHQCL", "INIT", "zfwKW", "OEVHZ", "QDjcn", "split", "EkCgG", "appModule", "ZZCkz", "taskRetry", "HQkab", "eItjE", "length", "203", "batchInterval", "uvoGS", "NikpL", "addEventListener", "cSjzl", "429", "IdFMv", "storage", "9145885mIRYcE", "pmYJK", "onreadystatechange", "stopBatching", "1316892AXjqlL", "wvVpH", "lhgWw", "status", "sendBatch", "110aVOwzM", "pscRn", "IYfZT", "SYXgj", "HbvgI", "fhgvw", "readyState", "MAqAR", "complete", "4199230VEjIoX", "qswcs", "yDwVF", "XNoxg", "SPGjv", "QSMwl", "72kCTeaG", "3|2|6|1|5|0|4", "BATCH_KEY", "ZIInJ", "hORti", "jZwSG", "startBatchingWithInterval", "LsPgk", "Bkrmo", "zBxgy", "JRXcJ", "4FAUmZr", "nrKFp", "YOHgF", "collect", "709568rdfDIY", "zCaEY", "recordEvents", "getBatch", "3294891UkcpJO", "iCTtb", "XzTXf", "aETFp", "some", "GKiSa", "4192150CnElJw", "AajtK", "slice", "WVChs", "Hoznq", "hCjAD", "wdjhR", "PukyE", "navigator", "oMHkL", "then", "startBatching", "SlmeQ", "GsKSK", "pkWtb", "TUgLz", "stringify", "addToStorage", "load", "LmBhy", "intervalId", "ovIYG", "log", "collectEvent", "HYctL", "backoff", "FIRKE", "IpgEl", "IFgRO", "processQueue", "setInterval", "MgNNW", "wxGUy", "xiEse", "getApiToken", "GHhOS", "cqstK", "YUmYL", "2672698tgwOCv", "setItem", "GQNlR", "awzCo", "xxOOX", "qFfMM", "egFdx", "aJfoH"];
    return Ig = function () {
        return t
    }
        ,
        Ig()
}
function mo(t, e) {
    const n = Ig();
    return mo = function (s, r) {
        return s = s - 437,
            n[s]
    }
        ,
        mo(t, e)
}
class J2e {
    constructor(e) {
        const n = mo
            , s = {
                wxGUy: n(532),
                YOHgF: function (o, l) {
                    return o + l
                }
            }
            , r = s[n(460)][n(490)]("|");
        let i = 0;
        for (; ;) {
            switch (r[i++]) {
                case "0":
                    this[n(492)] = e;
                    continue;
                case "1":
                    this[n(494)] = 0;
                    continue;
                case "2":
                    this.intervalId = null;
                    continue;
                case "3":
                    this[n(453)] = 1;
                    continue;
                case "4":
                    this[n(506)] = new K2e(s[n(544)](s[n(544)](this[n(533)], "-"), this[n(492)][n(462)]()));
                    continue;
                case "5":
                    this[n(533)] = x2e;
                    continue;
                case "6":
                    this.batchInterval = 2e3;
                    continue
            }
            break
        }
    }
    init() {
        const e = mo
            , n = {
                aETFp: e(446),
                hCjAD: function (s, r) {
                    return s !== r
                },
                DGpGG: e(454),
                jZwSG: function (s, r) {
                    return s == r
                },
                zfwKW: "complete",
                TXGjz: function (s, r) {
                    return s === r
                },
                wvVpH: "IfuHs"
            };
        n.TXGjz(document.readyState, e(524)) ? this.startBatchingWithInterval() : n[e(512)] !== n[e(512)] ? _0x4029cb[e(502)](n[e(553)], _0x4b5fd4) : document[e(509)] = () => {
            const s = e;
            n[s(561)](n[s(481)], s(443)) ? n[s(536)](document[s(522)], n[s(487)]) && this.startBatchingWithInterval() : this[s(537)]()
        }
    }
    startBatchingWithInterval() {
        const e = mo
            , n = {
                IYfZT: function (r, i) {
                    return r * i
                },
                kHQCL: function (r, i) {
                    return r == i
                },
                AajtK: e(524),
                MJLuT: e(470),
                lhgWw: function (r, i) {
                    return r !== i
                },
                EkCgG: "YQDpM",
                qswcs: function (r, i) {
                    return r >= i
                },
                CaTiW: function (r, i) {
                    return r(i)
                },
                MgNNW: "QSMwl",
                zYZqO: function (r, i, o) {
                    return r(i, o)
                }
            };
        let s = 0;
        if (this[e(492)][e(475)](),
            this[e(492)][e(451)](ds[e(486)]),
            n[e(513)](this.appModule[e(477)], void 0))
            this[e(439)]();
        else if (e(530) !== n[e(459)]) {
            this.backoff < 5 && (this[e(453)]++,
                this[e(499)] = n[e(518)](this.batchInterval, 2.71),
                this[e(439)]());
            return
        } else {
            const r = n.zYZqO(setInterval, () => {
                const i = e
                    , o = {
                        igVyj: function (l, a) {
                            return n[mo(485)](l, a)
                        },
                        fhgvw: n[i(557)]
                    };
                if (n[i(484)] !== n.MJLuT) {
                    const l = {
                        YGVpP: function (a, c) {
                            return o.igVyj(a, c)
                        },
                        NikpL: o[i(521)]
                    };
                    _0x5bd05b[i(509)] = () => {
                        const a = i;
                        l.YGVpP(_0x3f438d.readyState, l[a(501)]) && this[a(537)]()
                    }
                } else if (n[i(513)](this[i(492)][i(477)], void 0))
                    n.lhgWw(n[i(491)], n[i(491)]) ? this[i(506)][i(445)](_0x23d2ee, _0x2b8d22) : (this[i(439)](),
                        clearInterval(r));
                else {
                    if (n[i(526)](s++, 3)) {
                        this.startBatching(),
                            n.CaTiW(clearInterval, r);
                        return
                    }
                    this[i(492)][i(475)]()
                }
            }
                , 1e3)
        }
    }
    [Si(510)]() {
        const e = Si
            , n = {
                Bkrmo: function (s, r) {
                    return s !== r
                },
                cSjzl: function (s, r) {
                    return s !== r
                },
                BFIZj: e(469)
            };
        if (n[e(539)](this[e(448)], null))
            if (n[e(503)](n[e(476)], n[e(476)])) {
                this[e(439)]();
                return
            } else
                clearInterval(this.intervalId),
                    this.intervalId = null
    }
    [Si(545)](e, n) {
        const s = Si
            , r = {
                OEVHZ: function (i) {
                    return i()
                },
                IFgRO: function (i, o) {
                    return i !== o
                },
                yDwVF: "tqFIJ",
                aXUEV: s(547),
                pscRn: function (i, o) {
                    return i + o
                },
                WVChs: function (i, o) {
                    return i * o
                },
                Hoznq: function (i, o) {
                    return i === o
                },
                SPGjv: s(437),
                ZIInJ: s(524),
                nrKFp: "vcUzW",
                pmYJK: "LRCIL",
                YUmYL: s(446),
                GHhOS: function (i, o, l) {
                    return i(o, l)
                }
            };
        if (document.readyState === r[s(534)])
            this[s(506)][s(445)](e, n);
        else {
            const i = () => {
                const o = s;
                r[o(456)](r[o(527)], r[o(480)]) ? this[o(506)][o(445)](e, n) : r[o(488)](_0x13c5a0)
            }
                ;
            r[s(463)](setTimeout, () => {
                const o = s
                    , l = {
                        SlmeQ: function (a, c) {
                            return r[mo(559)](a, c)
                        }
                    };
                r[o(560)](r[o(529)], r[o(529)]) ? r[o(560)](document[o(522)], r[o(534)]) ? r[o(488)](i) : r[o(543)] !== r[o(508)] ? window[o(502)](r[o(465)], i) : (this[o(453)] = 1,
                    this[o(448)] = null,
                    this.batchInterval = 2e3,
                    this[o(494)] = 0,
                    this[o(533)] = _0x5c549d,
                    this[o(492)] = _0x574058,
                    this[o(506)] = new _0x916eac(r[o(517)](this[o(533)], "-") + this[o(492)].getApiToken())) : (this.backoff++,
                        this[o(499)] = l[o(440)](this.batchInterval, 2.71),
                        this.startBatching())
            }
                , 0)
        }
    }
    [Si(439)]() {
        const e = Si
            , n = {
                vOfhh: function (s, r) {
                    return s(r)
                },
                GQNlR: function (s, r) {
                    return s === r
                },
                hORti: function (s, r) {
                    return s !== r
                },
                iCTtb: e(538)
            };
        this.appModule[e(475)](),
            n[e(468)](this[e(448)], null) && (n[e(535)](n[e(551)], n.iCTtb) ? (n.vOfhh(_0x387d44, this.intervalId),
                this.intervalId = null) : this.intervalId = window[e(458)](() => this[e(457)](), this[e(499)]))
    }
    [Si(457)]() {
        const e = Si
            , n = {
                SYXgj: function (r, i) {
                    return r !== i
                }
            }
            , s = this.storage[e(549)]();
        n[e(519)](s[e(497)], 0) && window[e(564)].onLine && this.sendBatch(s[e(558)](0, 20))
    }
    [Si(515)](e) {
        const n = Si
            , s = {
                ZZCkz: function (r, i) {
                    return r === i
                },
                HbvgI: n(540),
                eItjE: n(472),
                rECRG: function (r, i) {
                    return r === i
                },
                pkWtb: function (r, i) {
                    return r(i)
                },
                IdFMv: n(504),
                uvoGS: function (r, i) {
                    return r !== i
                },
                CNKIw: "gRGIN",
                GsKSK: function (r, i) {
                    return r === i
                },
                IpgEl: function (r, i) {
                    return r(i)
                },
                ECNMS: n(552),
                iUsED: n(449),
                QDjcn: function (r, i) {
                    return r < i
                },
                xiEse: n(562),
                GKiSa: n(452),
                JRXcJ: function (r, i) {
                    return r * i
                },
                PukyE: function (r, i) {
                    return r === i
                },
                cqstK: function (r, i) {
                    return r(i)
                },
                HIfte: n(495),
                FVQzB: n(478),
                XNoxg: n(479),
                QlVtE: function (r, i) {
                    return r === i
                }
            };
        this.stopBatching(),
            this[n(492)][n(548)](e)[n(438)](r => {
                const i = n;
                if (s[i(493)](s[i(520)], s[i(496)])) {
                    this[i(439)]();
                    return
                } else {
                    if (s.rECRG(s[i(442)](String, r[i(514)]), s[i(505)]))
                        if (s[i(500)](s.CNKIw, i(471))) {
                            this[i(439)]();
                            return
                        } else {
                            this.startBatching(),
                                _0x5cd5bd(_0x29b214);
                            return
                        }
                    if (s[i(441)](s[i(455)](String, r[i(514)])[0], "4"))
                        return s[i(441)](s.ECNMS, s[i(482)]),
                            void 0;
                    if (s[i(441)](s[i(455)](String, r[i(514)])[0], "5")) {
                        s[i(489)](this.backoff, 5) && (s[i(461)] === s[i(555)] ? this.startBatchingWithInterval() : (this[i(453)]++,
                            this[i(499)] = s[i(541)](this[i(499)], 2.71),
                            this[i(439)]()));
                        return
                    }
                    if (this[i(453)] = 1,
                        this.batchInterval = 2e3,
                        s[i(563)](s[i(464)](String, r[i(514)]), i(498)))
                        if (this[i(494)]++,
                            this[i(492)][i(477)] = void 0,
                            this[i(494)] > 3)
                            if (s.HIfte === i(447))
                                this[i(515)](_0x34eb59[i(558)](0, 20));
                            else {
                                this.startBatching();
                                return
                            }
                        else if (s[i(500)](s[i(483)], s[i(528)])) {
                            this[i(492)].solveTask(),
                                this[i(439)]();
                            return
                        } else
                            this[i(492)].solveTask(),
                                s.ZZCkz(this[i(448)], null) && (this[i(448)] = _0x4ef44e.setInterval(() => this[i(457)](), this.batchInterval));
                    this[i(494)] = 0,
                        this[i(506)][i(467)](this.storage[i(549)]().filter(o => !e[i(554)](l => JSON[i(444)](o) === JSON[i(444)](l)))),
                        this.startBatching()
                }
            }
                , r => {
                    const i = n;
                    s.QlVtE(i(473), i(523)) ? this[i(448)] = _0x5a8f9f[i(458)](() => this.processQueue(), this[i(499)]) : (console[i(450)](r),
                        this.startBatching())
                }
            )
    }
}
var Ap = Kd;
(function (t, e) {
    for (var n = Kd, s = t(); ;)
        try {
            var r = -parseInt(n(481)) / 1 * (parseInt(n(489)) / 2) + parseInt(n(490)) / 3 + parseInt(n(494)) / 4 * (-parseInt(n(493)) / 5) + parseInt(n(482)) / 6 * (-parseInt(n(496)) / 7) + -parseInt(n(469)) / 8 + -parseInt(n(498)) / 9 + parseInt(n(477)) / 10 * (parseInt(n(480)) / 11);
            if (r === e)
                break;
            s.push(s.shift())
        } catch {
            s.push(s.shift())
        }
}
)(Ag, 429392);
class Z2e {
    constructor(e) {
        this.appModule = e
    }
    async init() {
        var e = Kd
            , n = {
                HZJRh: e(485),
                KYsVy: function (s, r) {
                    return s === r
                },
                fvTHr: e(479),
                yayxW: function (s, r) {
                    return s(r)
                },
                fCltq: function (s, r) {
                    return s === r
                },
                FInFg: "QoCNW"
            };
        return new Promise(async (s, r) => {
            var i = e
                , o = {
                    SHHQF: function (l, a) {
                        return l(a)
                    }
                };
            if (n[i(500)](n[i(472)], i(479)))
                try {
                    await n[i(502)](fetch, uv + i(501))[i(492)](async l => {
                        var a = i;
                        this.worker = new Worker(URL[a(497)](await l[a(505)]())),
                            await fetch(uv + n[a(484)])[a(492)](async c => {
                                var u = a;
                                this[u(483)][u(491)] = o[u(478)](String, await c[u(503)]()),
                                    this.worker.onmessage = h => {
                                        var d = u;
                                        this[d(483)][d(471)] = h[d(486)]
                                    }
                                    ,
                                    s()
                            }
                            )
                    }
                    )
                } catch (l) {
                    n[i(475)](n[i(470)], i(487)) ? this[i(483)] = _0x3fe7f1 : r(l)
                }
            else
                this[i(483)][i(471)] = _0x3c6304[i(486)]
        }
        )
    }
    [Ap(473)](e) {
        var n = Ap;
        this[n(483)][n(491)] = e,
            this[n(476)]()
    }
    [Ap(476)]() {
        var e = Ap
            , n = {
                KtFBS: function (s, r) {
                    return s !== r
                },
                XLxQm: function (s, r) {
                    return s === r
                },
                Aenzt: e(488)
            };
        this[e(504)] !== void 0 && (n[e(495)](n.Aenzt, "VyaEE") ? n[e(499)](this[e(504)], void 0) && this.worker[e(474)](this.appModule[e(491)]) : this[e(504)][e(474)](this[e(483)][e(491)]))
    }
}
function Kd(t, e) {
    var n = Ag();
    return Kd = function (s, r) {
        s = s - 469;
        var i = n[s];
        return i
    }
        ,
        Kd(t, e)
}
function Ag() {
    var t = ["createObjectURL", "2468511iJwvsZ", "KtFBS", "KYsVy", "c3e068ebf11840ed3fc311a6f2df80b20fa05d25", "yayxW", "text", "worker", "blob", "6768360DKrqvD", "FInFg", "taskSolution", "fvTHr", "setNewArgs", "postMessage", "fCltq", "solveTask", "90xbVSng", "SHHQF", "zOyFO", "3142029vuamjm", "154933aRAgIC", "31746qzBtic", "appModule", "HZJRh", "aee7c93a9ae7930fb19732325d2c560c53849aa7", "data", "efFrt", "OKzPI", "6kaorGI", "760437XHOXSq", "taskParams", "then", "5pemoJo", "2244152JussJf", "XLxQm", "329avmmLy"];
    return Ag = function () {
        return t
    }
        ,
        Ag()
}
var us = Jd;
(function (t, e) {
    for (var n = Jd, s = t(); ;)
        try {
            var r = parseInt(n(156)) / 1 * (parseInt(n(160)) / 2) + -parseInt(n(168)) / 3 + -parseInt(n(180)) / 4 + parseInt(n(163)) / 5 + parseInt(n(177)) / 6 * (-parseInt(n(184)) / 7) + parseInt(n(182)) / 8 * (-parseInt(n(179)) / 9) + parseInt(n(154)) / 10 * (parseInt(n(176)) / 11);
            if (r === e)
                break;
            s.push(s.shift())
        } catch {
            s.push(s.shift())
        }
}
)(kg, 612843);
function Jd(t, e) {
    var n = kg();
    return Jd = function (s, r) {
        s = s - 154;
        var i = n[s];
        return i
    }
        ,
        Jd(t, e)
}
function kg() {
    var t = ["humanProofService", "assembleEventSession", "wHVQv", "1760112KAfOok", "appName", "setNewArgs", "catch", "then", "apiToken", "collectEvent", "env", "13303444KliNWT", "229446KrQbjz", "batchService", "9YHAHLd", "3214016mWNJrV", "recordEvent", "6802504zDZJLm", "networkController", "35yUOmiZ", "error", "analyticsController", "init", "10aUWyNX", "solveTask", "2vTEkqH", "recordEvents", "collect", "QvuNF", "893762DZRsla", "sessionController", "split", "4707015enyfrq", "collectTappsEvent"];
    return kg = function () {
        return t
    }
        ,
        kg()
}
class Q2e {
    constructor(e, n, s) {
        for (var r = Jd, i = "5|2|3|7|4|0|1|6"[r(162)]("|"), o = 0; ;) {
            switch (i[o++]) {
                case "0":
                    this.networkController = new C2e(this);
                    continue;
                case "1":
                    this[r(186)] = new T2e(this);
                    continue;
                case "2":
                    this[r(173)] = e;
                    continue;
                case "3":
                    this.appName = n;
                    continue;
                case "4":
                    this[r(161)] = new q2e(this);
                    continue;
                case "5":
                    this[r(175)] = s;
                    continue;
                case "6":
                    this[r(178)] = new J2e(this);
                    continue;
                case "7":
                    this[r(165)] = new Z2e(this);
                    continue
            }
            break
        }
    }
    async[us(187)]() {
        var e = us
            , n = {
                QvuNF: function (s, r) {
                    return s !== r
                },
                dccGR: e(167)
            };
        this.sessionController[e(187)](),
            this[e(186)][e(187)](),
            await this[e(165)][e(187)]()[e(172)](() => {
                var s = e;
                n[s(159)](n.dccGR, s(167)) ? this[s(155)]() : this.solveTask()
            }
            )[e(171)](s => console[e(185)](s)),
            this[e(183)][e(187)](),
            this[e(178)][e(187)]()
    }
    [us(166)]() {
        var e = us;
        return this[e(161)][e(166)]()
    }
    recordEvent(e, n, s) {
        var r = us;
        return this[r(183)][r(181)](e, n, s)
    }
    [us(157)](e) {
        var n = us;
        return this[n(183)][n(157)](e)
    }
    [us(174)](e, n) {
        var s = us;
        this.batchService[s(158)](e, {
            ...n,
            ...this[s(166)]()
        })
    }
    [us(164)](e, n) {
        var s = us;
        this.batchService[s(158)](e, {
            ...this[s(161)][s(166)](),
            custom_data: {
                userData: {
                    ...this[s(161)].getUserData()
                },
                ...n
            }
        })
    }
    getApiToken() {
        return this.apiToken
    }
    getAppName() {
        var e = us;
        return this[e(169)]
    }
    [us(155)]() {
        var e = us;
        this[e(165)][e(155)]()
    }
    [us(170)](e) {
        var n = us;
        this[n(165)][n(170)](e)
    }
}
const UA = Rg;
(function (t, e) {
    const n = Rg
        , s = t();
    for (; ;)
        try {
            if (parseInt(n(200)) / 1 + parseInt(n(203)) / 2 + -parseInt(n(196)) / 3 * (parseInt(n(201)) / 4) + -parseInt(n(202)) / 5 + parseInt(n(205)) / 6 * (-parseInt(n(197)) / 7) + -parseInt(n(198)) / 8 + parseInt(n(199)) / 9 === e)
                break;
            s.push(s.shift())
        } catch {
            s.push(s.shift())
        }
}
)(Mg, 564637);
function Rg(t, e) {
    const n = Mg();
    return Rg = function (s, r) {
        return s = s - 195,
            n[s]
    }
        ,
        Rg(t, e)
}
async function eIe({ token: t, appName: e, env: n = UA(204) }) {
    const s = UA;
    new Q2e(t, e, n)[s(195)]()
}
function Mg() {
    const t = ["2255718eRttfE", "PROD", "12WGTAKf", "init", "1083207qQGVmG", "3222597qEQLUB", "843232jdEYqR", "2972448jihvCp", "1071764CNGKiI", "4DrObrV", "2890215MrEOsk"];
    return Mg = function () {
        return t
    }
        ,
        Mg()
}
const tIe = {
    init: eIe
};
var DS = {
    VITE_FIREBASE_API_KEY: "AIzaSyAYPGepKwdVahPoEhGxcKcETpt056OiE5U",
    VITE_FIREBASE_AUTH_DOMAIN: "slapapp-prod-fe50c.firebaseapp.com",
    VITE_FIREBASE_PROJECT_ID: "slapapp-prod-fe50c",
    VITE_GCP_STORAGE_BUCKET: "slapapp-prod-fe50c.firebasestorage.app",
    VITE_FIREBASE_MESSAGING_SENDER_ID: "973731802401",
    VITE_FIREBASE_APP_ID: "1:973731802401:web:deb3651cfb04cb4bc4a260",
    VITE_FIREBASE_MEASUREMENT_ID: "G-Y7J414DNBQ",
    VITE_SENTRY_DSN: "https://01b47c8f6c2c3eb3f7bae75c8d9391ac@o123825.ingest.us.sentry.io/4508633190563840",
    VITE_BOTAPP_URL: "https://t.me/SlapStarBot/app",
    VITE_BOT_URL: "https://t.me/SlapStarBot",
    VITE_TELEGRAM_ANALYTICS_APP_NAME: "slapstar_prd",
    VITE_TELEGRAM_ANALYTICS_TOKEN: "eyJhcHBfbmFtZSI6InNsYXBzdGFyX3ByZCIsImFwcF91cmwiOiJodHRwczovL3QubWUvU2xhcFN0YXJCb3QiLCJhcHBfZG9tYWluIjoiaHR0cHM6Ly9zbGFwYXBwLXByb2QtZmU1MGMud2ViLmFwcC8ifQ==!hkzc0QqPxctUm+4T7mmAC62YS/gqBUKc5YNZ/U/NAwU=",
    VITE_APP_ENV: "prod",
    BASE_URL: "/",
    MODE: "production",
    DEV: !1,
    PROD: !0,
    SSR: !1
};
const Jn = VN(pEe);
Jn.directive("fade-in-up", GCe);
Jn.directive("bounce", HCe);
Jn.component("IconCalendar", zCe);
Jn.component("IconYoutube", e2e);
Jn.component("IconTwitter", l2e);
Jn.component("IconTelegram", p2e);
Jn.component("IconInvite", b2e);
Jn.component("IconCoin", dn);
Jn.component("IconArrowRight", H4);
Jn.component("IconCheck", xc);
Jn.config.globalProperties.$appMode = DS.VITE_APP_MODE;
Jn.config.globalProperties.$telegramInitData = DS.VITE_APP_TELEGRAM_INIT_DATA;
const nIe = Gj({
    locale: js.EN,
    fallbackLocale: js.EN,
    legacy: !1,
    messages: {
        en: STe,
        kp: DTe,
        ru: VCe
    }
})
    , sIe = {
        demo: "staging",
        prod: "production",
        dev: "development"
    };
DY({
    app: Jn,
    dsn: "https://01b47c8f6c2c3eb3f7bae75c8d9391ac@o123825.ingest.us.sentry.io/4508633190563840",
    environment: sIe.prod,
    integrations: [$Y({
        router: MS
    }), aY({
        maskAllText: !1,
        blockAllMedia: !1
    })],
    tracesSampleRate: 1,
    tracePropagationTargets: [DS.VITE_FIREBASE_DOMAIN],
    replaysSessionSampleRate: .1,
    replaysOnErrorSampleRate: 1
});
tIe.init({
    token: "eyJhcHBfbmFtZSI6InNsYXBzdGFyX3ByZCIsImFwcF91cmwiOiJodHRwczovL3QubWUvU2xhcFN0YXJCb3QiLCJhcHBfZG9tYWluIjoiaHR0cHM6Ly9zbGFwYXBwLXByb2QtZmU1MGMud2ViLmFwcC8ifQ==!hkzc0QqPxctUm+4T7mmAC62YS/gqBUKc5YNZ/U/NAwU=",
    appName: "slapstar_prd"
});
Jn.use(MS);
Jn.use(nO);
Jn.use(gEe);
Jn.use(nIe);
Jn.mount("#app");
const rIe = si();
rIe.startGlobalTimer();